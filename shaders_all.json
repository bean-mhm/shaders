{
 "userName": "beans_please",
 "date": "2025-01-24T19:17:49.764Z",
 "numShaders": 74,
 "shaders": [
  {
   "ver": "0.1",
   "info": {
    "id": "dsjcRR",
    "date": "1687371539",
    "viewed": 437,
    "name": "PBR with Ray Marching (WIP)",
    "description": "* Drag -> Look around\n* WASD -> Move\n* Shift -> Sprint\n* Alt -> Stealth?\n* R -> Reset\n",
    "likes": 7,
    "published": "Public API",
    "usePreview": 1,
    "tags": [
     "raymarching",
     "camera",
     "pathtracing"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Image\n// iChannel0 = Buffer A\n\n// Controls\n// * Drag -> Look around\n// * WASD -> Move\n// * Shift -> Sprint\n// * Alt -> Stealth?\n// * R -> Reset\n\nvec3 viewTransform(vec3 inp)\n{\n\t// Clip negatives\n    inp = max(inp, 0.0);\n\n    // Pre-Exposure\n    inp *= pow(2.0, 1.5);\n\n    // Offset\n    inp += vec3(0.0, 0.0, 0.006);\n\n    // Uniform Reinhard (good enough for now)\n    float lum = dot(inp, lumWeights);\n    inp /= lum + 1.0;\n    inp = mix(inp, vec3(1.0), smoothstep(0.0, 1.0, map_range_clamp(log2(lum), -1.0, 10.0, 0.0, 1.0)));\n\n    // OETF (Gamma)\n    inp = pow(inp, vec3(1.0 / 2.2));\n\n    return inp;\n}\n\nvec3 getAccumulated(in vec2 fragCoord)\n{\n    vec4 data = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    return data.rgb * SAMPLE_COUNT_MUL / data.w;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 col = getAccumulated(fragCoord);\n    col = viewTransform(col);\n\n    fragColor = vec4(col, 1.0);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "// Common\n\n#define PI 3.14159265359\n#define DEG_TO_RAD 0.01745329251994\n\n#define SAMPLE_COUNT_MUL 0.01\n\nconst vec3 lumWeights = vec3(0.2126, 0.7152, 0.0722);\nconst vec3 defPlayerPos = vec3(-1.5, -3.7, 0.4);\nconst vec3 defCamOrient = vec3(97.0, 0.0, -25.0);\n\nfloat map_range(float inp, float inp_start, float inp_end, float out_start, float out_end)\n{\n    return out_start + ((out_end - out_start) / (inp_end - inp_start)) * (inp - inp_start);\n}\n\nfloat map_range_clamp(float inp, float inp_start, float inp_end, float out_start, float out_end)\n{\n    float t = clamp((inp - inp_start) / (inp_end - inp_start), 0.0, 1.0);\n    float v = out_start + t * (out_end - out_start);\n    return v;\n}\n\nvec3 mixColPerceptual(vec3 a, vec3 b, float t)\n{\n    //return mix(a, b, t);\n    return pow(mix(sqrt(a), sqrt(b), t), vec3(2.0));\n}\n\nvec3 rotateEuler(vec3 v, vec3 angle)\n{\n    angle *= DEG_TO_RAD;\n\n    // X\n    v.x = v.x * cos(angle.x) - v.y * sin(angle.x);\n    v.y = v.x * sin(angle.x) + v.y * cos(angle.x);\n\n    // Y\n    v.x = v.x * cos(angle.y) + v.z * sin(angle.y);\n    v.z = -v.x * sin(angle.y) + v.z * cos(angle.y);\n\n    // Z\n    v.y = v.y * cos(angle.z) - v.z * sin(angle.z);\n    v.z = v.y * sin(angle.z) + v.z * cos(angle.z);\n\n    return v;\n}\n\n// Ignores Y (roll)\nvec3 orientationToDirection(vec3 orient)\n{\n    orient.x -= 90.0;\n    orient.x *= DEG_TO_RAD;\n    orient.z *= -DEG_TO_RAD;\n\n    return vec3(vec2(sin(orient.z), cos(orient.z)) * cos(orient.x), sin(orient.x));\n}\n\n// ***********************************************\n// Source: https://www.shadertoy.com/view/WdSSRt\n// ***********************************************\n\n/* Usage Example:\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Initialize PRNG\n    eprng_init(fragCoord.xy / max(iResolution.x, iResolution.y), iTime);\n\n    // Using the function:\n    float a = random();\n    vec3 b = vec3(random(), random(), random());\n    \n    ...\n}\n\n*/\n\nuint eprng_state[2];\n\nuint eprng_rot(uint x, int k)\n{\n    return (x << k) | (x >> (32 - k));\n}\n\nfloat random()\n{\n    uint s0 = eprng_state[0];\n    uint s1 = eprng_state[1];\n    uint result = eprng_rot(s0 * 0x9e3779bbu, 5) * 5u;\n    s1 ^= s0;\n    eprng_state[0] = eprng_rot(s0, 26) ^ s1 ^ (s1 << 9);\n    eprng_state[1] = eprng_rot(s1, 13);\n    // Not sure this is actually the best way to get evenly-distributed floats -\n    // precision will be lost converting from int to float, but how much depends on the order of magnitude\n    // I could use bit magic to build the bits of a float directly, then use uintBitsToFloat,\n    // but that also loses precision - just in a different way.\n    // I guess precision loss is inevitable, since if we want floats in the range 0.0 <= r <= 1.0 then\n    // there's only so many bits to work with. It's just a matter of how they're distributed.\n    return float(result) / float(0xffffffffu);\n}\n\nvoid eprng_init(vec2 uv, float iTime)\n{\n    uv *= (iTime + 10.258);\n\n    eprng_state[0] = floatBitsToUint(uv.x);\n    eprng_state[1] = floatBitsToUint(uv.y);\n\n    random();\n}\n\n// ***********************************************\n// End\n// ***********************************************\n\n// ***********************************************\n// Source: https://github.com/MaxBittker/glsl-voronoi-noise\n// ***********************************************\n\nconst mat2 myt = mat2(.12121212, .13131313, -.13131313, .12121212);\nconst vec2 mys = vec2(1e4, 1e6);\n\nvec2 rhash(vec2 uv)\n{\n    uv *= myt;\n    uv *= mys;\n    return fract(fract(uv / mys) * uv);\n}\n\nvec3 hash2(vec3 p)\n{\n    return fract(sin(vec3(dot(p, vec3(1.0, 57.0, 113.0)), dot(p, vec3(57.0, 113.0, 1.0)), dot(p, vec3(113.0, 1.0, 57.0)))) *\n        43758.5453);\n}\n\nvec3 voronoi3d(const in vec3 x)\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    float id = 0.0;\n    vec2 res = vec2(100.0);\n    for (int k = -1; k <= 1; k++)\n    {\n        for (int j = -1; j <= 1; j++)\n        {\n            for (int i = -1; i <= 1; i++)\n            {\n                vec3 b = vec3(float(i), float(j), float(k));\n                vec3 r = vec3(b) - f + hash2(p + b);\n                float d = dot(r, r);\n\n                float cond = max(sign(res.x - d), 0.0);\n                float nCond = 1.0 - cond;\n\n                float cond2 = nCond * max(sign(res.y - d), 0.0);\n                float nCond2 = 1.0 - cond2;\n\n                id = (dot(p + b, vec3(1.0, 57.0, 113.0)) * cond) + (id * nCond);\n                res = vec2(d, res.x) * cond + res * nCond;\n\n                res.y = cond2 * d + nCond2 * res.y;\n            }\n        }\n    }\n\n    return vec3(sqrt(res), abs(id));\n}\n\n// ***********************************************\n// End\n// ***********************************************\n\n// ***********************************************\n// Keyboard Utils\n// ***********************************************\n\n// Key code constants\n// https://asawicki.info/nosense/doc/devices/keyboard/key_codes.html\n\nconst int KEY_SHIFT = 16;\nconst int KEY_CTRL = 17;\nconst int KEY_ALT = 18;\nconst int KEY_LEFT = 37;\nconst int KEY_UP = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN = 40;\n\nconst int KEY_W = 87;\nconst int KEY_A = 65;\nconst int KEY_S = 83;\nconst int KEY_D = 68;\nconst int KEY_R = 82;\nconst int KEY_Q = 81;\nconst int KEY_Z = 90;\n\nbool keyIsDown(int key, sampler2D keyboardChannel)\n{\n    return texelFetch(keyboardChannel, ivec2(key, 0), 0).x != 0.0;\n}\n\nbool keyGotPressed(int key, sampler2D keyboardChannel)\n{\n    return texelFetch(keyboardChannel, ivec2(key, 1), 0).x != 0.0;\n}\n\nbool keyToggleState(int key, sampler2D keyboardChannel)\n{\n    return texelFetch(keyboardChannel, ivec2(key, 2), 0).x != 0.0;\n}\n\nfloat keyIsDownF(int key, sampler2D keyboardChannel)\n{\n    return keyIsDown(key, keyboardChannel) ? 1.0 : 0.0;\n}\n\nfloat keyGotPressedF(int key, sampler2D keyboardChannel)\n{\n    return keyGotPressed(key, keyboardChannel) ? 1.0 : 0.0;\n}\n\nfloat keyToggleStateF(int key, sampler2D keyboardChannel)\n{\n    return keyToggleState(key, keyboardChannel) ? 1.0 : 0.0;\n}\n\n// ***********************************************\n// End\n// ***********************************************\n\n// ***********************************************\n// Data Buffer Utils\n// ***********************************************\n\nvec4 fetchVec4(sampler2D channel, ivec2 coord)\n{\n    return texelFetch(channel, coord, 0);\n}\n\nvec3 fetchVec3(sampler2D channel, ivec2 coord)\n{\n    return texelFetch(channel, coord, 0).xyz;\n}\n\nvec2 fetchVec2(sampler2D channel, ivec2 coord)\n{\n    return texelFetch(channel, coord, 0).xy;\n}\n\nfloat fetchScalar(sampler2D channel, ivec2 coord)\n{\n    return texelFetch(channel, coord, 0).x;\n}\n\n// ***********************************************\n// End\n// ***********************************************\n\nvec3 randomUnitVector()\n{\n    const int numAttempts = 100;\n\n    float l = 0.0;\n    for (int i = 1; i <= numAttempts; i++)\n    {\n        // random() returns a float in the [0, 1] range\n        vec3 p = vec3(random(), random(), random());\n        p = p * 2.0 - 1.0;\n\n        // Normalize and return if length <= 1\n        if ((l = length(p)) <= 1.0)\n            return p / l;\n    }\n\n    // If all failed\n    return normalize(vec3(random(), random(), random()));\n}\n\nvec3 randomPointInUnitSphere()\n{\n    return random() * randomUnitVector();\n}\n\nfloat mengerSpongeDF(int n, vec3 pos)\n{\n    if (length(pos) > 2.2)\n        return length(pos) - 1.8;\n\n    //by recursively digging a box\n    float x = pos.x, y = pos.y, z = pos.z;\n    x = x * 0.5 + 0.5;\n    y = y * 0.5 + 0.5;\n    z = z * 0.5 + 0.5; //center it by changing position and scale\n\n    float xx = abs(x - 0.5) - 0.5, yy = abs(y - 0.5) - 0.5, zz = abs(z - 0.5) - 0.5;\n    float d1 = max(xx, max(yy, zz)); //distance to the box\n    float d = d1; //current computed distance\n    float p = 1.0;\n    for (int i = 1; i <= n; ++i)\n    {\n        float xa = mod(3.0 * x * p, 3.0);\n        float ya = mod(3.0 * y * p, 3.0);\n        float za = mod(3.0 * z * p, 3.0);\n        p *= 3.0;\n\n        //we can also translate/rotate (xa,ya,za) without affecting the DE estimate\n\n        float xx = 0.5 - abs(xa - 1.5), yy = 0.5 - abs(ya - 1.5), zz = 0.5 - abs(za - 1.5);\n        d1 = min(max(xx, zz), min(max(xx, yy), max(yy, zz))) / p; //distance inside the 3 axis-aligned square tubes\n\n        d = max(d, d1); //intersection\n    }\n    //return d*2.0; //the distance estimate. The *2 is because of the scaling we did at the beginning of the function\n    return d;\n}\n\n// https://iquilezles.org/articles/mandelbulb\nfloat mandelbulb(in vec3 p, out vec4 resColor)\n{\n    if (length(p) > 1.5)\n        return length(p) - 1.2;\n\n    vec3 w = p;\n    float m = dot(w, w);\n\n    vec4 trap = vec4(abs(w), m);\n    float dz = 1.0;\n\n    for (int i = 0; i < 4; i++)\n    {\n#if 0\n        // polynomial version (no trigonometrics, but MUCH slower)\n        float m2 = m * m;\n        float m4 = m2 * m2;\n        dz = 8.0 * sqrt(m4 * m2 * m) * dz + 1.0;\n\n        float x = w.x;\n        float x2 = x * x;\n        float x4 = x2 * x2;\n        float y = w.y;\n        float y2 = y * y;\n        float y4 = y2 * y2;\n        float z = w.z;\n        float z2 = z * z;\n        float z4 = z2 * z2;\n\n        float k3 = x2 + z2;\n        float k2 = inversesqrt(k3 * k3 * k3 * k3 * k3 * k3 * k3);\n        float k1 = x4 + y4 + z4 - 6.0 * y2 * z2 - 6.0 * x2 * y2 + 2.0 * z2 * x2;\n        float k4 = x2 - y2 + z2;\n\n        w.x = p.x + 64.0 * x * y * z * (x2 - z2) * k4 * (x4 - 6.0 * x2 * z2 + z4) * k1 * k2;\n        w.y = p.y + -16.0 * y2 * k3 * k4 * k4 + k1 * k1;\n        w.z = p.z + -8.0 * y * k4 * (x4 * x4 - 28.0 * x4 * x2 * z2 + 70.0 * x4 * z4 - 28.0 * x2 * z2 * z4 + z4 * z4) * k1 * k2;\n#else\n        // trigonometric version (MUCH faster than polynomial)\n\n        // dz = 8*z^7*dz\n        dz = 8.0 * pow(m, 3.5) * dz + 1.0;\n\n        // z = z^8+c\n        float r = length(w);\n        float b = 8.0 * acos(w.y / r);\n        float a = 8.0 * atan(w.x, w.z);\n        w = p + pow(r, 8.0) * vec3(sin(b) * sin(a), cos(b), sin(b) * cos(a));\n#endif        \n\n        trap = min(trap, vec4(abs(w), m));\n\n        m = dot(w, w);\n        if (m > 256.0)\n            break;\n    }\n\n    resColor = vec4(m, trap.yzw);\n\n    // distance estimation (through the Hubbard-Douady potential)\n    return 0.25 * log(m) * sqrt(m) / dz;\n}\n\nfloat boxSD(vec3 p, vec3 center, vec3 scale)\n{\n    float x = max(p.x - center.x - scale.x / 2., center.x - p.x - scale.x / 2.);\n    float y = max(p.y - center.y - scale.y / 2., center.y - p.y - scale.y / 2.);\n\n    float z = max(p.z - center.z - scale.z / 2., center.z - p.z - scale.z / 2.);\n    float d = x;\n    d = max(d, y);\n    d = max(d, z);\n    return d;\n}\n\n// http://blog.hvidtfeldts.net/index.php/2011/08/distance-estimated-3d-fractals-iii-folding-space/\nfloat anotherFractalSD(vec3 p, float scale, int iters)\n{\n\tvec3 a1 = vec3(1,1,1);\n\tvec3 a2 = vec3(-1,-1,1);\n\tvec3 a3 = vec3(1,-1,-1);\n\tvec3 a4 = vec3(-1,1,-1);\n\tvec3 c;\n\tint n = 0;\n\tfloat dist, d;\n\twhile (n < iters) {\n\t\t c = a1; dist = length(p-a1);\n\t        d = length(p-a2); if (d < dist) { c = a2; dist=d; }\n\t\t d = length(p-a3); if (d < dist) { c = a3; dist=d; }\n\t\t d = length(p-a4); if (d < dist) { c = a4; dist=d; }\n\t\tp = scale*p-c*(scale-1.0);\n\t\tn++;\n\t}\n\n\treturn length(p) * pow(scale, float(-n));\n}\n",
     "name": "Common",
     "description": "",
     "type": "common"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "// Buffer A\n// iChannel0 = Buffer A\n// iChannel1 = Buffer B\n\nprecision highp float;\n\n#define OBJID_BOX 0\n#define OBJID_FLOOR 1\n#define OBJID_WALL 2\n#define OBJID_FRACTAL 3\n#define OBJID_FRACTAL2 4\n\n// SD object info\nstruct SdInfo\n{\n    int objID;\n    vec4 data;\n};\n\nstruct HitInfo\n{\n    // Always present\n    vec3 rayDir;     // Ray direction (normalized)\n    bool hit;        // Have we hit something?\n    vec3 pos;        // Last position on the ray\n    float dist;      // Total distance traveled\n    SdInfo sdInfo;   // Last SD object info\n\n    // Only present if hit == true\n    vec3 normal;\n};\n\nconst float rayOffset = .02;\nconst float hitThreshold = .0006;\nconst float maxTotalDist = 100.;\nconst float eps = .0005;\n\nconst vec3 sunDir = normalize(vec3(0, 1, -.8));\n\nvec2 pixelToDeviceCoords(vec2 coords)\n{\n    vec2 uv = coords / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv = (uv * iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    return uv;\n}\n\nvec2 getMouseUV()\n{\n    if (ivec2(iMouse) == ivec2(0))\n        return vec2(0.0);\n\n    vec2 uv = iMouse.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    return uv;\n}\n\nfloat sceneSD(vec3 p, out SdInfo info)\n{\n    // Store individual distances\n    const int numObjs = 5;\n    float dists[5];\n\n    // Mouse UV\n    vec2 mouseUV = getMouseUV();\n\n    // Box\n    vec3 boxPos = vec3(-2.55, 6.0, -.2);\n    vec3 boxBounds = vec3(0.8, 2.5, 0.8);\n    dists[0] = boxSD(p, boxPos, boxBounds);\n\n    // Floor\n    vec3 planeNormal = normalize(vec3(0.0, 0.0, 1.0));\n    float planeHeight = -.601;// - voronoi3d(vec3(p.xy * 0.3, 1.0)).x;\n    dists[1] = dot(p, planeNormal) - planeHeight;\n\n    // Wall\n    vec3 planeNormal2 = normalize(vec3(1.0, 0.0, 0.0));\n    float planeHeight2 = 0.0;\n    dists[2] = dot(p - vec3(-3.0, 0.0, 0.0), planeNormal2) - planeHeight2;\n\n    // Fractal\n    vec4 mandelbulbData = vec4(1.0);\n    dists[3] = mandelbulb((p - vec3(1.9, -2.8, 0.5)) / 1.0, mandelbulbData); \n    \n    // Another fractal\n    dists[4] = mengerSpongeDF(5, 1.1 * p - vec3(1.0, 1.0, 0.6));\n\n    // Find minimum distance\n\n    float minDist = dists[0];\n    info.objID = 0;\n\n    if (numObjs < 2)\n        return minDist;\n\n    for (int i = 1; i < numObjs; i++)\n    {\n        if (dists[i] < minDist)\n        {\n            minDist = dists[i];\n            info.objID = i;\n\n            if (i == OBJID_FRACTAL)\n            {\n                info.data = mandelbulbData;\n            }\n        }\n    }\n\n    return minDist;\n}\n\nvoid rayMarch(vec3 orig, vec3 dir, out HitInfo hitInfo)\n{\n    dir = normalize(dir);\n    orig += rayOffset * dir;\n\n    float totalDist = 0.0;\n    SdInfo sdInfo;\n\n    float sd = sceneSD(orig, sdInfo);\n\n    while (sd > hitThreshold && totalDist < maxTotalDist)\n    {\n        orig += sd * dir;\n        totalDist += sd;\n\n        sd = sceneSD(orig, sdInfo);\n    }\n\n    hitInfo.hit = false;\n    hitInfo.rayDir = dir;\n    hitInfo.pos = orig;\n    hitInfo.dist = totalDist;\n    hitInfo.sdInfo = sdInfo;\n\n    if (sd > hitThreshold)\n        return;\n\n    hitInfo.hit = true;\n    hitInfo.normal = normalize(vec3(sceneSD(orig + vec3(eps, 0.0, 0.0), sdInfo) - sceneSD(orig - vec3(eps, 0.0, 0.0), sdInfo), sceneSD(orig + vec3(0.0, eps, 0.0), sdInfo) - sceneSD(orig - vec3(0.0, eps, 0.0), sdInfo), sceneSD(orig + vec3(0.0, 0.0, eps), sdInfo) - sceneSD(orig - vec3(0.0, 0.0, eps), sdInfo)));\n}\n\n// https://www.shadertoy.com/view/tlXBRl\nfloat calculateObstruction(vec3 pos, vec3 lightPos, float lightRadius)\n{\n    SdInfo sdInfo;\n\n    vec3 toLight = normalize(lightPos - pos);\n    float distToLight = length(lightPos - pos);\n    float d, t = lightRadius * 0.1;\n    float obstruction = 0.;\n    for (int j = 0; j < 32; j++)\n    {\n        d = sceneSD(pos + t * toLight, sdInfo);\n        obstruction = max(0.5 - d * distToLight / (2. * lightRadius * t), obstruction);\n        if (obstruction >= 1.)\n            break;\n        // If we're stuck, advance by the characteristic \n        // size of an obstructing object\n        t += max(d, lightRadius * t / distToLight);\n        if (t >= distToLight)\n            break;\n    }\n\n    return clamp(obstruction, 0., 1.);\n}\n\nvoid shadeRay(HitInfo hit, out vec3 incomingLight, out vec3 rayColor)\n{\n    // Sky\n    if (!hit.hit)\n    {\n        // Deep orange\n        const vec3 skyColor1 = vec3(0.60, 0.13, 0.07);\n        const float skyLine1 = -0.01;\n\n        // Orange\n        const vec3 skyColor2 = vec3(1.00, 0.40, 0.16);\n        const float skyLine2 = 0.03;\n\n        // Gray\n        const vec3 skyColor3 = vec3(0.64, 0.59, 0.55);\n        const float skyLine3 = 0.075;\n\n        // Cyan\n        const vec3 skyColor4 = vec3(0.04, 0.25, 0.63);\n        const float skyLine4 = 0.14;\n\n        // Blue\n        const vec3 skyColor5 = vec3(0.006, 0.027, 0.263);\n        const float skyLine5 = 0.25;\n\n        // Dark Blue\n        const vec3 skyColor6 = vec3(0.0002, 0.002, 0.055);\n        const float skyLine6 = 0.53;\n\n        float z = hit.rayDir.z;\n        z += map_range_clamp(voronoi3d(vec3(vec2(hit.rayDir.xy * 2.2), 0.0)).x, 0.0, 1.0, -0.02, 0.0);\n\n        // Color gradient\n\n        float fac = map_range_clamp(z, skyLine1, skyLine2, 0.0, 1.0);\n        vec3 col = mixColPerceptual(skyColor1, skyColor2, fac);\n\n        fac = map_range_clamp(z, skyLine2, skyLine3, 0.0, 1.0);\n        col = mixColPerceptual(col, skyColor3, fac);\n\n        fac = map_range_clamp(z, skyLine3, skyLine4, 0.0, 1.0);\n        col = mixColPerceptual(col, skyColor4, fac);\n\n        fac = map_range_clamp(z, skyLine4, skyLine5, 0.0, 1.0);\n        col = mixColPerceptual(col, skyColor5, fac);\n\n        fac = map_range_clamp(z, skyLine5, skyLine6, 0.0, 1.0);\n        col = mixColPerceptual(col, skyColor6, fac);\n\n        // Stars\n        fac = voronoi3d(hit.rayDir.xyz * 33.0).x;\n        if (fac < 0.035)\n        {\n            float intensity = random() * 4.0 + 0.5;\n            intensity *= max(0.0, (hit.rayDir.z - 0.1) * 1.9);\n            col += vec3(intensity);\n        }\n\n\n\n        incomingLight += rayColor * col;\n\n        return;\n    }\n\n    // Diffuse\n    if (hit.sdInfo.objID == OBJID_FLOOR)\n    {\n        rayColor *= vec3(0.08, 0.3, 0.005);\n    }\n    if (hit.sdInfo.objID == OBJID_BOX)\n    {\n        // Emission\n        //incomingLight += rayColor * vec3(1000.0, 50.0, 5.0);\n\n        rayColor *= vec3(0.5, 0.03, 0.01);\n    }\n    if (hit.sdInfo.objID == OBJID_WALL)\n    {\n        rayColor *= vec3(0.55, 0.55, 0.5);\n    }\n    if (hit.sdInfo.objID == OBJID_FRACTAL)\n    {\n        // Fractal color\n        vec3 c = pow(hit.sdInfo.data.ywz, vec3(0.5));\n\n        // Saturation\n        c = mix(vec3(dot(c, lumWeights)), c, 1.3);\n\n        // Clamp\n        c = clamp(c, 0.0, 1.0);\n\n        // Edge glow\n        // If ray dir and hit normal are 90 deg apart\n        // (dot is closer to 0) then we add light.\n        incomingLight += rayColor * pow(1.0 - abs(dot(hit.normal, hit.rayDir)), 1.5) * 0.05 * c;\n\n        // Diffuse color\n        rayColor *= c;\n    }\n    if (hit.sdInfo.objID == OBJID_FRACTAL2)\n    {\n        rayColor *= vec3(0.85, 0.05, 0.005);\n    }\n\n    // Conservation of energy? (IDK)\n    //rayColor /= PI;\n}\n\n// inspired by https://iquilezles.org/articles/fog/\nvec3 pretty_fog(\n    vec3 col,\n    float hit_dist,\n    vec3 ray_dir, // must be normalized\n    vec3 sun_dir, // must be normalized\n    float fog_start_dist, // normally 0\n    vec3 absorption_col, // RGB values below 1, or white to disable\n    float scatter_density, // usually near 0 like .04\n    vec3 scatter_col_sky, // normally a cold color\n    vec3 scatter_col_sun, // normally a warm color\n    float sun_sharpness // default=8\n)\n{\n    // subtract starting distance, return if depth is too low\n    hit_dist -= fog_start_dist;\n    if (hit_dist < .00001)\n    {\n        return col;\n    }\n    \n    // absorption\n    col *= pow(absorption_col, vec3(hit_dist));\n\n    // scatter color depends on view dir and sun dir\n    float sun_fac = pow(\n        max(dot(ray_dir, sun_dir), 0.),\n        sun_sharpness\n    );\n    vec3 scatter_col = mix(\n        scatter_col_sky,\n        scatter_col_sun,\n        sun_fac\n    );\n    \n    // scattering\n    col = mix(\n        col,\n        scatter_col,\n        1. - exp(-hit_dist * scatter_density)\n    );\n    \n    return col;\n}\n\nvoid shadeRayFog(HitInfo firstHit, inout vec3 col)\n{\n    if (!firstHit.hit)\n        return;\n\n    // Fog if we've hit an object\n    col = pretty_fog(\n        col,\n        firstHit.dist,\n        firstHit.rayDir,\n        sunDir,\n        1.,\n        vec3(.99, 1, .995),\n        .04,\n        vec3(.02, .03, .12),\n        vec3(.2, .15, .14),\n        8.\n    );\n}\n\nvec3 tracePath(vec3 rayOrig, vec3 rayDir, out HitInfo firstHit)\n{\n    HitInfo hit;\n    vec3 incomingLight = vec3(0.0);\n    vec3 rayColor = vec3(1.0);\n\n    for (int i = 0; i < 5; i++)\n    {\n        // Ray march\n        rayMarch(rayOrig, rayDir, hit);\n\n        if (i == 0)\n            firstHit = hit;\n\n        // Update the colors\n        shadeRay(hit, incomingLight, rayColor);\n\n        // Stop if we hit the sky\n        if (!hit.hit)\n            break;\n\n        // Should we stop bouncing?\n        if (random() > (1.0 / (2.0 * PI)))\n            break;\n\n        // Update the ray\n        rayOrig = hit.pos;\n        rayDir = hit.normal + randomUnitVector();\n        if (dot(rayDir, hit.normal) <= 0.0)\n        {\n            rayDir = -rayDir;\n        }\n\n        //vec3 reflectNormal = reflect(hit.rayDir, hit.normal);\n    }\n\n    // Cast ray towards point light\n    if (hit.hit)\n    {\n        vec3 pointLightPos = vec3(-2.6, 2.5, 3.6);\n        float pointLightStrength = 150.0;\n        vec3 pointLightCol = vec3(1.0, 0.9, 0.6);\n        float pointLightRadius = 0.3;\n\n        vec3 toLight = pointLightPos + (pointLightRadius * randomUnitVector()) - hit.pos;\n\n        float distToLight = length(toLight);\n\n        HitInfo hit2;\n        rayMarch(hit.pos, toLight, hit2);\n\n        if ((!hit2.hit) || (hit2.dist > distToLight))\n        {\n            incomingLight += rayColor * pointLightCol * pointLightStrength * max(dot(hit.normal, normalize(toLight)), 0.0) / (distToLight * distToLight);\n        }\n    }\n\n    return incomingLight;\n}\n\nvec3 render(vec2 uv)\n{\n    // Read data\n    vec3 camOrient = fetchVec3(iChannel1, ivec2(1, 0));\n    vec3 playerPos = fetchVec3(iChannel1, ivec2(2, 0));\n\n    // Setup camera\n\n    vec3 camPos = playerPos;\n    float camFOV = 80.0;\n    float camZoom = 90.0 / camFOV;\n\n    vec3 camForward = orientationToDirection(camOrient);\n    vec3 camRight = normalize(cross(camForward, vec3(0, 0, 1)));\n    vec3 camUp = cross(camRight, camForward);\n\n    // Ray\n    vec3 rayOrig = camPos;\n    vec3 rayDir = normalize(camForward + camRight * (uv.x / camZoom) + camUp * (uv.y / camZoom));\n\n    // Lighting\n    HitInfo firstHit;\n    vec3 col = tracePath(rayOrig, rayDir, firstHit);\n\n    // Fog\n    shadeRayFog(firstHit, col);\n\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // UV from -1 to +1\n    vec2 uv = pixelToDeviceCoords(fragCoord.xy);\n\n    // Initialize PRNG\n    eprng_init(fragCoord.xy / max(iResolution.x, iResolution.y), iTime);\n\n    // Previous frame data\n    vec4 prev = texelFetch(iChannel0, ivec2(fragCoord), 0);\n\n    // Jitter sample count (increases over time)\n    int numJitterSamples;\n    if (prev.w < (90.0 * SAMPLE_COUNT_MUL))\n        numJitterSamples = 1;\n    else\n        numJitterSamples = 5;\n\n    // Render\n    vec3 col = vec3(0.0);\n    vec2 msPixelOffset = pixelToDeviceCoords(vec2(1.0, 1.0)) - pixelToDeviceCoords(vec2(0.0, 0.0));\n    for (int i = 1; i <= numJitterSamples; i++)\n    {\n        float offsetX = random() - 0.5;\n        float offsetY = random() - 0.5;\n\n        col += render(uv + msPixelOffset * vec2(offsetX, offsetY));\n    }\n    col /= float(numJitterSamples);\n\n    // Should we reset accumulation?\n    vec4 mouseAndRes = fetchVec4(iChannel1, ivec2(0));\n    vec4 camOrient = fetchVec4(iChannel1, ivec2(1, 0));\n    vec4 playerPos = fetchVec4(iChannel1, ivec2(2, 0));\n    bool reset = (iFrame == 0) || (iTime == 0.0) || (iMouse.xy != mouseAndRes.xy) || (iResolution.xy != mouseAndRes.zw) || (playerPos.w == 1.0) || (camOrient.w == 1.0);\n\n    // Accumulate\n    if (reset)\n    {\n        fragColor = vec4(col, SAMPLE_COUNT_MUL);\n    }\n    else\n    {\n        fragColor.rgb = prev.rgb + col;\n        fragColor.w = prev.w + SAMPLE_COUNT_MUL;\n    }\n}\n",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [
      {
       "id": "4dXGRr",
       "filepath": "/presets/tex00.jpg",
       "type": "keyboard",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "XsXGR8",
       "channel": 0
      }
     ],
     "code": "// Buffer B\n// iChannel0 = Buffer B\n// iChannel1 = Keyboard\n\nvec2 getMouseUV()\n{\n    if (ivec2(iMouse) == ivec2(0))\n        return vec2(0.0);\n\n    vec2 uv = iMouse.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    return uv;\n}\n\nvec2 getMouseUV(vec2 pos, vec2 res)\n{\n    if (ivec2(pos) == ivec2(0))\n        return vec2(0.0);\n\n    vec2 uv = pos.xy / res.xy;\n    uv = uv * 2.0 - 1.0;\n    return uv;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Mouse position and resolution\n    if (ivec2(fragCoord) == ivec2(0))\n    {\n        fragColor = vec4(iMouse.xy, iResolution.xy);\n    }\n\n    bool reset = (iFrame < 4) || (iTime == 0.0) || keyGotPressed(KEY_R, iChannel1);\n\n    // Mouse drag info\n    if (ivec2(fragCoord) == ivec2(3, 0))\n    {\n        vec3 mouseDrag = fetchVec3(iChannel0, ivec2(3, 0));\n\n        // Update if needed\n        if (iMouse.z > 0.0)\n        {\n            mouseDrag = vec3(getMouseUV(), 1.0);\n        }\n        else\n        {\n            mouseDrag.z = 0.0;\n        }\n\n        // Write\n        fragColor = vec4(mouseDrag, 0);\n    }\n\n    // Camera orientation\n    if (ivec2(fragCoord) == ivec2(1, 0))\n    {\n        // Read\n        vec4 camOrient = fetchVec4(iChannel0, ivec2(1, 0));\n\n        // W == 1 means accumulation should be reset\n        if (camOrient.w == 1.0)\n            camOrient.w = 0.0;\n\n        // Reset if needed\n        if ((camOrient.xyz == vec3(0.0)) || (length(camOrient.xyz) < 0.1) || reset)\n        {\n            camOrient = vec4(defCamOrient, 1.0);\n        }\n\n        // Delta mouse UV\n        vec3 mouseDrag = fetchVec3(iChannel0, ivec2(3, 0));\n        vec2 deltaMouseUV = getMouseUV() - mouseDrag.xy;\n\n        // Update if needed\n        if (iMouse.z > 0.0 && mouseDrag.z > 0.0 && length(deltaMouseUV) > 0.00001)\n        {\n            camOrient.x += deltaMouseUV.y * 84.5;\n            camOrient.z += deltaMouseUV.x * -120.0;\n            camOrient.w = 1.0;\n        }\n\n        // Write\n        fragColor = camOrient;\n    }\n\n    // Player position\n    if (ivec2(fragCoord) == ivec2(2, 0))\n    {\n        // Read\n        vec4 playerPos = fetchVec4(iChannel0, ivec2(2, 0));\n\n        // W == 1 means accumulation should be reset\n        if (playerPos.w == 1.0)\n            playerPos.w = 0.0;\n\n        // Reset if needed\n        if (playerPos.xyz == vec3(0.0) || reset)\n            playerPos = vec4(defPlayerPos, 1.0);\n\n        // Get camera directions for movement\n        vec3 camOrient = fetchVec3(iChannel0, ivec2(1, 0));\n        vec3 camForward = orientationToDirection(camOrient);\n        vec3 camRight = normalize(cross(camForward, vec3(0, 0, 1)));\n\n        // Get velocity based on the keyboard input\n        vec3 velocity = vec3(0.0);\n        velocity += camForward * keyIsDownF(KEY_W, iChannel1);\n        velocity += -camForward * keyIsDownF(KEY_S, iChannel1);\n        velocity += -camRight * keyIsDownF(KEY_A, iChannel1);\n        velocity += camRight * keyIsDownF(KEY_D, iChannel1);\n        velocity.z = 0.0;\n\n        // Up/down movement\n        velocity.z += 0.5 * keyIsDownF(KEY_Q, iChannel1);\n        velocity.z -= 0.5 * keyIsDownF(KEY_Z, iChannel1);\n\n        // Speed multiplier\n        float speed = 1.5;\n        if (keyIsDown(KEY_SHIFT, iChannel1))\n            speed = 4.0;\n        if (keyIsDown(KEY_ALT, iChannel1))\n            speed = 0.4;\n        velocity *= speed;\n\n        // Move if needed\n        if (velocity != vec3(0.0))\n        {\n            playerPos.xyz += velocity * iTimeDelta;\n            playerPos.w = 1.0;\n        }\n\n        // Write\n        fragColor = playerPos;\n    }\n}\n",
     "name": "Buffer B",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "dd2yDz",
    "date": "1687622059",
    "viewed": 716,
    "name": "flim - Filmic Color Transform",
    "description": "Experimental Port of flim (Film Emulation Transform)\n\nOriginal Repo:\nhttps://github.com/bean-mhm/flim\n",
    "likes": 17,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "color",
     "display",
     "gamma",
     "filmic",
     "filmemulation",
     "viewtransform"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "void mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    vec2 uv = frag_coord.xy / iResolution.xy;\n\n    // RGB sweep test\n    vec3 col = flim_rgb_exposure_sweep_test(uv);\n\n    // alternate between flim and native sRGB\n    if (mod(iTime, 3.) > 1.5)\n    {\n        col = pow(col, vec3(1. / 2.2));\n    }\n    else\n    {\n        float exposure = 0.;\n        col = flim_transform(col, exposure, true);\n    }\n\n    // output\n    frag_col = vec4(col, 1.);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "/*-----------------------------------------------\n\nflim - Filmic Color Transform\n\nInput Color Space:   Linear BT.709 I-D65\nOutput Color Space:  Linear BT.709 I-D65 / sRGB 2.2 (depends on arguments)\n\nDescription:\n  Experimental port of flim for GLSL/Shadertoy\n  matching flim v1.1.0.\n\nAuthor:\n  Bean (beans_please on Shadertoy)\n\nOriginal Repo:\n  https://github.com/bean-mhm/flim\n\nOriginal Shader:\n  https://www.shadertoy.com/view/dd2yDz\n\n-----------------------------------------------*/\n\n// parameters\n\nconst float flim_pre_exposure = 4.3;\nconst vec3 flim_pre_formation_filter = vec3(1.);\nconst float flim_pre_formation_filter_strength = 0.;\n\nconst float flim_extended_gamut_red_scale = 1.05;\nconst float flim_extended_gamut_green_scale = 1.12;\nconst float flim_extended_gamut_blue_scale = 1.045;\nconst float flim_extended_gamut_red_rot = .5;\nconst float flim_extended_gamut_green_rot = 2.;\nconst float flim_extended_gamut_blue_rot = .1;\nconst float flim_extended_gamut_red_mul = 1.;\nconst float flim_extended_gamut_green_mul = 1.;\nconst float flim_extended_gamut_blue_mul = 1.;\n\nconst float flim_sigmoid_log2_min = -10.;\nconst float flim_sigmoid_log2_max = 22.;\nconst float flim_sigmoid_toe_x = .44;\nconst float flim_sigmoid_toe_y = .28;\nconst float flim_sigmoid_shoulder_x = .591;\nconst float flim_sigmoid_shoulder_y = .779;\n\nconst float flim_negative_film_exposure = 6.;\nconst float flim_negative_film_density = 5.;\n\nconst vec3 flim_print_backlight = vec3(1);\nconst float flim_print_film_exposure = 6.;\nconst float flim_print_film_density = 27.5;\n\nconst float flim_black_point = -1.; // -1 = auto\nconst vec3 flim_post_formation_filter = vec3(1);\nconst float flim_post_formation_filter_strength = 0.;\nconst float flim_midtone_saturation = 1.02;\n\n// color space conversions\n// the matrices below represent data in row-major, but GLSL matrices are in\n// column-major, so we need to multiply a vec3 by a matrix rather than\n// multiplying a matrix by a vec3.\n\nconst mat3 mat_bt2020_to_xyz = mat3(\n     0.6369580483,  0.1446169036,  0.1688809752,\n     0.2627002120,  0.6779980715,  0.0593017165,\n     0.0000000000,  0.0280726930,  1.0609850577\n);\n\nconst mat3 mat_xyz_to_bt2020 = mat3(\n     1.7166511880, -0.3556707838, -0.2533662814,\n    -0.6666843518,  1.6164812366,  0.0157685458,\n     0.0176398574, -0.0427706133,  0.9421031212\n);\n\nconst mat3 mat_bt709_to_xyz = mat3(\n     0.4123907993,  0.3575843394,  0.1804807884,\n     0.2126390059,  0.7151686788,  0.0721923154,\n     0.0193308187,  0.1191947798,  0.9505321522\n);\n\nconst mat3 mat_xyz_to_bt709 = mat3(\n     3.2409699419, -1.5373831776, -0.4986107603,\n    -0.9692436363,  1.8759675015,  0.0415550574,\n     0.0556300797, -0.2039769589,  1.0569715142\n);\n\nconst mat3 mat_dcip3_to_xyz = mat3(\n     0.4451698156,  0.2771344092,  0.1722826698,\n     0.2094916779,  0.7215952542,  0.0689130679,\n     0.0000000000,  0.0470605601,  0.9073553944\n);\n\nconst mat3 mat_xyz_to_dcip3 = mat3(\n     2.7253940305, -1.0180030062, -0.4401631952,\n    -0.7951680258,  1.6897320548,  0.0226471906,\n     0.0412418914, -0.0876390192,  1.1009293786\n);\n\nvec3 oetf_pow(vec3 col, float power)\n{\n    return pow(col, vec3(1. / power));\n}\n\nvec3 eotf_pow(vec3 col, float power)\n{\n    return pow(col, vec3(power));\n}\n\n// flim's utility functions\n\nfloat flim_wrap(float v, float start, float end)\n{\n    return start + mod(v - start, end - start);\n}\n\nfloat flim_remap(\n    float v,\n    float inp_start,\n    float inp_end,\n    float out_start,\n    float out_end\n)\n{\n    return out_start\n        + ((out_end - out_start) / (inp_end - inp_start)) * (v - inp_start);\n}\n\nfloat flim_remap_clamp(\n    float v,\n    float inp_start,\n    float inp_end,\n    float out_start,\n    float out_end\n)\n{\n    float t = clamp((v - inp_start) / (inp_end - inp_start), 0., 1.);\n    return out_start + t * (out_end - out_start);\n}\n\nfloat flim_remap01(\n    float v,\n    float inp_start,\n    float inp_end\n)\n{\n    return clamp((v - inp_start) / (inp_end - inp_start), 0., 1.);\n}\n\nvec3 flim_blender_rgb_to_hsv(vec3 rgb)\n{\n    float cmax, cmin, h, s, v, cdelta;\n    vec3 c;\n\n    cmax = max(rgb[0], max(rgb[1], rgb[2]));\n    cmin = min(rgb[0], min(rgb[1], rgb[2]));\n    cdelta = cmax - cmin;\n\n    v = cmax;\n    if (cmax != 0.)\n    {\n        s = cdelta / cmax;\n    }\n    else\n    {\n        s = 0.;\n        h = 0.;\n    }\n\n    if (s == 0.)\n    {\n        h = 0.;\n    }\n    else\n    {\n        c = (vec3(cmax) - rgb.xyz) / cdelta;\n\n        if (rgb.x == cmax)\n        {\n            h = c[2] - c[1];\n        }\n        else if (rgb.y == cmax)\n        {\n            h = 2. + c[0] - c[2];\n        }\n        else\n        {\n            h = 4. + c[1] - c[0];\n        }\n\n        h /= 6.;\n\n        if (h < 0.)\n        {\n            h += 1.;\n        }\n    }\n\n    return vec3(h, s, v);\n}\n\nvec3 flim_blender_hsv_to_rgb(vec3 hsv)\n{\n    float f, p, q, t, h, s, v;\n    vec3 rgb;\n\n    h = hsv[0];\n    s = hsv[1];\n    v = hsv[2];\n\n    if (s == 0.)\n    {\n        rgb = vec3(v, v, v);\n    }\n    else\n    {\n        if (h == 1.)\n        {\n            h = 0.;\n        }\n\n        h *= 6.;\n        int i = int(floor(h));\n        f = h - float(i);\n        rgb = vec3(f, f, f);\n        p = v * (1. - s);\n        q = v * (1. - (s * f));\n        t = v * (1. - (s * (1. - f)));\n\n        if (i == 0)\n        {\n            rgb = vec3(v, t, p);\n        }\n        else if (i == 1)\n        {\n            rgb = vec3(q, v, p);\n        }\n        else if (i == 2)\n        {\n            rgb = vec3(p, v, t);\n        }\n        else if (i == 3)\n        {\n            rgb = vec3(p, q, v);\n        }\n        else if (i == 4)\n        {\n            rgb = vec3(t, p, v);\n        }\n        else\n        {\n            rgb = vec3(v, p, q);\n        }\n    }\n\n    return rgb;\n}\n\nvec3 flim_blender_hue_sat(vec3 col, float hue, float sat, float value)\n{\n    vec3 hsv = flim_blender_rgb_to_hsv(col);\n\n    hsv[0] = fract(hsv[0] + hue + .5);\n    hsv[1] = clamp(hsv[1] * sat, 0., 1.);\n    hsv[2] = hsv[2] * value;\n\n    return flim_blender_hsv_to_rgb(hsv);\n}\n\nfloat flim_rgb_avg(vec3 col)\n{\n    return (col.x + col.y + col.z) / 3.;\n}\n\nfloat flim_rgb_sum(vec3 col)\n{\n    return col.x + col.y + col.z;\n}\n\nfloat flim_rgb_max(vec3 col)\n{\n    return max(max(col.x, col.y), col.z);\n}\n\nfloat flim_rgb_min(vec3 col)\n{\n    return min(min(col.x, col.y), col.z);\n}\n\nvec3 flim_rgb_uniform_offset(vec3 col, float black_point, float white_point)\n{\n    float mono = flim_rgb_avg(col);\n    float mono2 = flim_remap01(\n        mono, black_point / 1000.,\n        1. - (white_point / 1000.)\n    );\n    return col * (mono2 / mono);\n}\n\nvec3 flim_rgb_sweep(float hue)\n{\n    hue = flim_wrap(hue * 360., 0., 360.);\n\n    vec3 col = vec3(1, 0, 0);\n    col = mix(col, vec3(1, 1, 0), flim_remap01(hue, 0., 60.));\n    col = mix(col, vec3(0, 1, 0), flim_remap01(hue, 60., 120.));\n    col = mix(col, vec3(0, 1, 1), flim_remap01(hue, 120., 180.));\n    col = mix(col, vec3(0, 0, 1), flim_remap01(hue, 180., 240.));\n    col = mix(col, vec3(1, 0, 1), flim_remap01(hue, 240., 300.));\n    col = mix(col, vec3(1, 0, 0), flim_remap01(hue, 300., 360.));\n    \n    return col;\n}\n\nvec3 flim_rgb_exposure_sweep_test(vec2 uv0to1)\n{\n    float hue = 1. - uv0to1.y;\n    float exposure = flim_remap(uv0to1.x, 0., 1., -5., 10.);\n    return flim_rgb_sweep(hue) * pow(2., exposure);\n}\n\n// https://www.desmos.com/calculator/khkztixyeu\nfloat flim_super_sigmoid(\n    float v,\n    float toe_x,\n    float toe_y,\n    float shoulder_x,\n    float shoulder_y\n)\n{\n    // clip\n    v = clamp(v, 0., 1.);\n    toe_x = clamp(toe_x, 0., 1.);\n    toe_y = clamp(toe_y, 0., 1.);\n    shoulder_x = clamp(shoulder_x, 0., 1.);\n    shoulder_y = clamp(shoulder_y, 0., 1.);\n\n    // calculate straight line slope\n    float slope = (shoulder_y - toe_y) / (shoulder_x - toe_x);\n\n    // toe\n    if (v < toe_x)\n    {\n        float toe_pow = slope * toe_x / toe_y;\n        return toe_y * pow(v / toe_x, toe_pow);\n    }\n\n    // straight line\n    if (v < shoulder_x)\n    {\n        float intercept = toe_y - (slope * toe_x);\n        return slope * v + intercept;\n    }\n\n    // shoulder\n    float shoulder_pow =\n        -slope / (\n            ((shoulder_x - 1.) / pow(1. - shoulder_x, 2.))\n            * (1. - shoulder_y)\n        );\n    return\n        (1. - pow(1. - (v - shoulder_x) / (1. - shoulder_x), shoulder_pow))\n        * (1. - shoulder_y)\n        + shoulder_y;\n}\n\nfloat flim_dye_mix_factor(float mono, float max_density)\n{\n    // log2 and map range\n    float offset = pow(2., flim_sigmoid_log2_min);\n    float fac = flim_remap01(\n        log2(mono + offset),\n        flim_sigmoid_log2_min,\n        flim_sigmoid_log2_max\n    );\n\n    // calculate amount of exposure from 0 to 1\n    fac = flim_super_sigmoid(\n        fac,\n        flim_sigmoid_toe_x,\n        flim_sigmoid_toe_y,\n        flim_sigmoid_shoulder_x,\n        flim_sigmoid_shoulder_y\n    );\n\n    // calculate dye density\n    fac *= max_density;\n\n    // mix factor\n    fac = pow(2., -fac);\n\n    // clip and return\n    return clamp(fac, 0., 1.);\n}\n\nvec3 flim_rgb_color_layer(\n    vec3 col,\n    vec3 sensitivity_tone,\n    vec3 dye_tone,\n    float max_density\n)\n{\n    // normalize\n    vec3 sensitivity_tone_norm =\n        sensitivity_tone / flim_rgb_sum(sensitivity_tone);\n    vec3 dye_tone_norm = dye_tone / flim_rgb_max(dye_tone);\n\n    // dye mix factor\n    float mono = dot(col, sensitivity_tone_norm);\n    float mix_fac = flim_dye_mix_factor(mono, max_density);\n\n    // dye mixing\n    return mix(dye_tone_norm, vec3(1), mix_fac);\n}\n\nvec3 flim_rgb_develop(vec3 col, float exposure, float max_density)\n{\n    // exposure\n    col *= pow(2., exposure);\n\n    // blue-sensitive layer\n    vec3 result = flim_rgb_color_layer(\n        col,\n        vec3(0, 0, 1),\n        vec3(1, 1, 0),\n        max_density\n    );\n\n    // green-sensitive layer\n    result *= flim_rgb_color_layer(\n        col,\n        vec3(0, 1, 0),\n        vec3(1, 0, 1),\n        max_density\n    );\n\n    // red-sensitive layer\n    result *= flim_rgb_color_layer(\n        col,\n        vec3(1, 0, 0),\n        vec3(0, 1, 1),\n        max_density\n    );\n\n    return result;\n}\n\nvec3 flim_gamut_extension_mat_row(\n    float primary_hue,\n    float scale,\n    float rotate,\n    float mul\n)\n{\n    vec3 result = flim_blender_hsv_to_rgb(vec3(\n        flim_wrap(primary_hue + (rotate / 360.), 0., 1.),\n        1. / scale,\n        1.\n    ));\n    result /= flim_rgb_sum(result);\n    result *= mul;\n    return result;\n}\n\nmat3 flim_gamut_extension_mat(\n    float red_scale,\n    float green_scale,\n    float blue_scale,\n    float red_rot,\n    float green_rot,\n    float blue_rot,\n    float red_mul,\n    float green_mul,\n    float blue_mul\n)\n{\n    mat3 m;\n    m[0] = flim_gamut_extension_mat_row(\n        0.,\n        red_scale,\n        red_rot,\n        red_mul\n    );\n    m[1] = flim_gamut_extension_mat_row(\n        1. / 3.,\n        green_scale,\n        green_rot,\n        green_mul\n    );\n    m[2] = flim_gamut_extension_mat_row(\n        2. / 3.,\n        blue_scale,\n        blue_rot,\n        blue_mul\n    );\n    return m;\n}\n\nvec3 negative_and_print(vec3 col, vec3 backlight_ext)\n{\n    // develop negative\n    col = flim_rgb_develop(\n        col,\n        flim_negative_film_exposure,\n        flim_negative_film_density\n    );\n\n    // backlight\n    col *= backlight_ext;\n\n    // develop print\n    col = flim_rgb_develop(\n        col,\n        flim_print_film_exposure,\n        flim_print_film_density\n    );\n\n    return col;\n}\n\n// the flim transform\n\nvec3 flim_transform(vec3 col, float exposure, bool convert_to_srgb)\n{\n    // eliminate negative values\n    col = max(col, 0.);\n\n    // pre-Exposure\n    col *= pow(2., flim_pre_exposure + exposure);\n\n    // clip very large values for float precision issues\n    col = min(col, 5000.);\n\n    // gamut extension matrix (Linear BT.709)\n    mat3 extend_mat = flim_gamut_extension_mat(\n        flim_extended_gamut_red_scale,\n        flim_extended_gamut_green_scale,\n        flim_extended_gamut_blue_scale,\n        flim_extended_gamut_red_rot,\n        flim_extended_gamut_green_rot,\n        flim_extended_gamut_blue_rot,\n        flim_extended_gamut_red_mul,\n        flim_extended_gamut_green_mul,\n        flim_extended_gamut_blue_mul\n    );\n    mat3 extend_mat_inv = inverse(extend_mat);\n\n    // backlight in the extended gamut\n    vec3 backlight_ext = flim_print_backlight * extend_mat;\n\n    // upper limit in the print (highlight cap)\n    const float big = 10000000.;\n    vec3 white_cap = negative_and_print(vec3(big, big, big), backlight_ext);\n\n    // pre-formation filter\n    col = mix(\n        col,\n        col * flim_pre_formation_filter,\n        flim_pre_formation_filter_strength\n    );\n\n    // convert to the extended gamut\n    col *= extend_mat;\n\n    // negative & print\n    col = negative_and_print(col, backlight_ext);\n\n    // convert from the extended gamut\n    col *= extend_mat_inv;\n\n    // eliminate negative values\n    col = max(col, 0.);\n\n    // white cap\n    col /= white_cap;\n\n    // black cap (-1 = auto)\n    if (flim_black_point == -1.)\n    {\n        vec3 black_cap = negative_and_print(vec3(0.), backlight_ext);\n        black_cap /= white_cap;\n        col = flim_rgb_uniform_offset(\n            col,\n            flim_rgb_avg(black_cap) * 1000.,\n            0.\n        );\n    }\n    else\n    {\n        col = flim_rgb_uniform_offset(col, flim_black_point, 0.);\n    }\n\n    // post-formation filter\n    col = mix(\n        col,\n        col * flim_post_formation_filter,\n        flim_post_formation_filter_strength\n    );\n\n    // clip\n    col = clamp(col, 0., 1.);\n\n    // midtone saturation\n    float mono = flim_rgb_avg(col);\n    float mix_fac =\n        (mono < .5)\n        ? flim_remap01(mono, .05, .5)\n        : flim_remap01(mono, .95, .5);\n    col = mix(\n        col,\n        flim_blender_hue_sat(col, .5, flim_midtone_saturation, 1.),\n        mix_fac\n    );\n\n    // clip\n    col = clamp(col, 0., 1.);\n\n    // OETF\n    if (convert_to_srgb)\n    {\n        col = oetf_pow(col, 2.2);\n    }\n\n    return col;\n}\n\n/*____________________ end ____________________*/\n",
     "name": "Common",
     "description": "",
     "type": "common"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "mdScW1",
    "date": "1687653267",
    "viewed": 360,
    "name": "Interactive 2D Wave Simulation",
    "description": "*Drag your mouse, make a spiral or something.\n\nThis is a port of my Python wave simulation project:\nhttps://github.com/bean-mhm/wave-simulation-py\n",
    "likes": 6,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "wave",
     "simulation",
     "physics",
     "waveequation",
     "wavesim"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// iChannel0 = Buffer A\n\nvec3 get_col(vec2 uv)\n{\n    // UV\n    bool inside_buf;\n    vec2 buf_uv;\n    get_buf_uv(uv, iResolution.xy, buf_uv, inside_buf);\n    if (!inside_buf)\n    {\n        return colormap(0.0) * 0.5;\n    }\n\n    // Bilinear interpolation\n    vec2 buf_coord = buf_uv * vec2(wave_grid_res);\n    float v = sample_bilinear(buf_coord, iChannel0, wave_grid_res).x;\n\n    // Color map\n    v *= 1.5;\n    vec3 col = colormap(v);\n\n    return col;\n}\n\nvoid mainImage(out vec4 frag_col, in vec2 coord)\n{\n    vec2 uv = coord / iResolution.xy;\n\n    vec3 col = get_col(uv);\n    col = pow(col, vec3(1.0 / 2.2));\n\n    frag_col = vec4(col, 1.0);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "// iChannel0 = Buffer A (self-feeding)\n\nfloat wave_initial_val(ivec2 icoord)\n{\n    return 0.0;\n}\n\nfloat wave_update_val(ivec2 icoord, float curr, float sim_time)\n{\n    // Initial pulse at the center\n    if (icoord == wave_grid_res / 2)\n    {\n        float amp = map_range_clamp(sim_time, 0.0, 0.02, 0.5, 0.0);\n        float freq = 0.5 * wave_max_frequency;\n        if (amp > 0.001)\n        {\n            return amp * sin(TWO_PI * sim_time * freq);\n        }\n    }\n\n    bool inside_buf;\n    vec2 mouse_uv;\n    get_buf_uv(iMouse.xy / iResolution.xy, iResolution.xy, mouse_uv, inside_buf);\n    vec2 mouse_coord = mouse_uv * vec2(wave_grid_res);\n\n    float mouse_prox = distance(vec2(icoord) + 0.5, mouse_coord);\n    mouse_prox /= max(float(wave_grid_res.x), float(wave_grid_res.y));\n\n    // Create disturbance with mouse\n    if (iMouse.z > 0.0)\n    {\n        curr = mix(curr, curr + iTimeDelta * wave_dt * 1000.0, map_range_clamp(mouse_prox, 0.03, 0.0, 0.0, 1.0));\n    }\n\n    return curr;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    ivec2 icoord = ivec2(fragCoord);\n\n    // Skip pixels outside the grid\n    if (icoord.x >= wave_grid_res.x || icoord.y >= wave_grid_res.y)\n        return;\n\n    // X = current value\n    // Y = previous value\n    // Z = iteration\n    vec4 data = texelFetch(iChannel0, icoord, 0);\n    float curr = data.x;\n    float prev = data.y;\n    int iter = int(data.z);\n\n    // First frame (initial values)\n    if (iter == 0 || iFrame < 1 || iTime == 0.0)\n    {\n        float v = wave_initial_val(icoord);\n        fragColor = vec4(v, v, 1.0, 0.0);\n        return;\n    }\n\n    float next_in_x = 0.0;\n    float prev_in_x = 0.0;\n    float next_in_y = 0.0;\n    float prev_in_y = 0.0;\n    if ((icoord.x + 1) < wave_grid_res.x)\n    {\n        next_in_x = texelFetch(iChannel0, icoord + ivec2(1, 0), 0).x;\n    }\n    if ((icoord.x - 1) >= 0)\n    {\n        prev_in_x = texelFetch(iChannel0, icoord + ivec2(-1, 0), 0).x;\n    }\n    if ((icoord.y + 1) < wave_grid_res.y)\n    {\n        next_in_y = texelFetch(iChannel0, icoord + ivec2(0, 1), 0).x;\n    }\n    if ((icoord.y - 1) >= 0)\n    {\n        prev_in_y = texelFetch(iChannel0, icoord + ivec2(0, -1), 0).x;\n    }\n\n    float grad_x = next_in_x - curr - curr + prev_in_x;\n    float grad_y = next_in_y - curr - curr + prev_in_y;\n\n    float acc = (grad_x + grad_y) * wave_speed2 / wave_step2;\n    float vel = (curr - prev) / wave_dt;\n    vel += (acc * wave_dt);\n    vel *= pow(wave_stiffness, -wave_dt);\n\n    prev = curr;\n    curr += (vel * wave_dt);\n\n    float sim_time = wave_dt * float(iter);\n    curr = wave_update_val(icoord, curr, sim_time);\n\n    fragColor = vec4(curr, prev, float(iter + 1), 0.0);\n}\n",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "#define PI 3.14159265358979\n#define TWO_PI 6.28318530717959\n\n// Grid Resolution\nconst ivec2 wave_grid_res = ivec2(256, 256);\n\n// Minimum distance in the grid\nconst float wave_step = 0.01;\nconst float wave_step2 = wave_step * wave_step;\n\n// Grid dimensions\nconst vec2 wave_dims = wave_step * vec2(wave_grid_res - 1);\n\n// Propagation speed in 2D\nconst float wave_speed = 10.0;\nconst float wave_speed2 = wave_speed * wave_speed;\n\n// Minimum wavelength\n// At least 8 steps needed for a perfectly smooth spherical wave.\nconst float wave_min_wavelength = wave_step * sqrt(2.0) * 8.0;\n\n// Maximum frequency\nconst float wave_max_frequency = wave_speed / wave_min_wavelength;\n\n// Maximum timestep\nconst float wave_max_dt = wave_step / (wave_speed * sqrt(2.0));\n\n// Timestep\nconst float wave_dt = 0.95 * wave_max_dt;\n\n// Stiffness\n// Must be greater than or equal to 1 to function properly.\nconst float wave_stiffness = 15.0;\n\nfloat map_range(float inp, float inp_start, float inp_end, float out_start, float out_end)\n{\n    return out_start + ((out_end - out_start) / (inp_end - inp_start)) * (inp - inp_start);\n}\n\nfloat map_range_clamp(float inp, float inp_start, float inp_end, float out_start, float out_end)\n{\n    float t = clamp((inp - inp_start) / (inp_end - inp_start), 0.0, 1.0);\n    float v = out_start + t * (out_end - out_start);\n    return v;\n}\n\nfloat fit_to_screen(vec2 image_res, vec2 screen_res)\n{\n    return min(screen_res.x / image_res.x, screen_res.y / image_res.y);\n}\n\nvoid get_buf_uv(vec2 uv, vec2 res, out vec2 buf_uv, out bool inside_buf)\n{\n    buf_uv = uv * 2.0 - 1.0;\n    buf_uv.x *= res.x / res.y;\n    buf_uv.x *= float(wave_grid_res.y) / float(wave_grid_res.x);\n    buf_uv /= fit_to_screen(vec2(wave_grid_res) / float(wave_grid_res.y), res.xy / res.y);\n    buf_uv = (buf_uv + 1.0) / 2.0;\n    inside_buf = max(abs(buf_uv.x - 0.5), abs(buf_uv.y - 0.5)) <= 0.5;\n}\n\nbool icoord_in_bounds(ivec2 icoord, ivec2 res)\n{\n    return (icoord.x >= 0) && (icoord.x < res.x) && (icoord.y >= 0) && (icoord.y < res.y);\n}\n\nvec4 sample_bilinear(vec2 coord, sampler2D src, ivec2 src_res)\n{\n    ivec2 bottomLeftPos = ivec2(int(floor(coord.x - 0.5)), int(floor(coord.y - 0.5)));\n\n    ivec2 topRightPos = ivec2(bottomLeftPos.x + 1, bottomLeftPos.y + 1);\n\n    ivec2 bottomRightPos = ivec2(topRightPos.x, bottomLeftPos.y);\n\n    ivec2 topLeftPos = ivec2(bottomLeftPos.x, topRightPos.y);\n\n    float alongX = coord.x - (float(bottomLeftPos.x) + 0.5);\n    float alongY = coord.y - (float(bottomLeftPos.y) + 0.5);\n\n    float bottomLeftWeight = (1.0 - alongX) * (1.0 - alongY);\n    float bottomRightWeight = (alongX) * (1.0 - alongY);\n    float topLeftWeight = (1.0 - alongX) * (alongY);\n    float topRightWeight = (alongX) * (alongY);\n\n    vec4 result = vec4(0.0);\n\n    if (icoord_in_bounds(bottomLeftPos, src_res))\n        result += bottomLeftWeight * texelFetch(src, bottomLeftPos, 0);\n\n    if (icoord_in_bounds(topRightPos, src_res))\n        result += topRightWeight * texelFetch(src, topRightPos, 0);\n\n    if (icoord_in_bounds(bottomRightPos, src_res))\n        result += bottomRightWeight * texelFetch(src, bottomRightPos, 0);\n\n    if (icoord_in_bounds(topLeftPos, src_res))\n        result += topLeftWeight * texelFetch(src, topLeftPos, 0);\n\n    return result;\n}\n\n// https://www.desmos.com/calculator/n4mfhffj1n\nfloat colormap_expf(float x, float v)\n{\n    if (abs(v) < .0001) v = .0001;\n    float p = pow(2., v);\n    return (1. - pow(p, -x)) / (1. - 1. / p);\n}\n\nvec3 colormap(float x)\n{\n    float t = .18 * abs(x);\n    if (x < 0.)\n    {\n        x = -x;\n        t = -.37 - .14 * x;\n    }\n    \n    // https://www.desmos.com/calculator/sdqk904uu9\n    vec3 tone = 8. * vec3(\n        cos(6.283 * t),\n        cos(6.283 * (t - .3333)),\n        cos(6.283 * (t - .6667))\n    );\n    \n    x = smoothstep(0., 1., x);\n    vec3 c = vec3(\n        colormap_expf(x, tone.r),\n        colormap_expf(x, tone.g),\n        colormap_expf(x, tone.b)\n    );\n    \n    c = mix(c, c + vec3(.03, 0, .03), smoothstep(.1, 0., x));\n    \n    return c;\n}\n",
     "name": "Common",
     "description": "",
     "type": "common"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "mdSyD1",
    "date": "1692566748",
    "viewed": 11,
    "name": "Daft Punk",
    "description": "Cover",
    "likes": 0,
    "published": "Unlisted",
    "usePreview": 0,
    "tags": [
     "procedural",
     "sound",
     "music",
     "cover"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "const float bpm = 100.0;\nconst float beatLength = 60.0 / bpm;\nconst int key = 55; // G4\n\nconst int bassNotes[4] = int[4](\n    key - 36,\n    key - 36 + 3,\n    key - 36 + 7,\n    key - 36 + 5\n);\n\n// Each two elements contain the\n// notes of a single chord\nconst ivec4 guitarChords[20] = ivec4[20](\n    // [0] Chord 3 A\n    ivec4(\n        key + 12 - 5,\n        key + 12 - 2,\n        key + 12 + 2,\n        key + 12 + 17\n    ),\n    ivec4(\n        key + 12 + 7,\n        -1, -1, -1\n    ),\n    \n    // --------------------\n    \n    // [1] Chord 3 B\n    ivec4(\n        key + 12 - 5,\n        key + 12 - 2,\n        key + 12 + 2,\n        key + 12 + 10\n    ),\n    ivec4(\n        key + 12 + 7,\n        -1, -1, -1\n    ),\n    \n    // --------------------\n    \n    // [2] Chord 3 C\n    ivec4(\n        key + 12 - 5,\n        key + 12 - 2,\n        key + 12 + 2,\n        key + 12 + 14\n    ),\n    ivec4(\n        key + 12 + 7,\n        -1, -1, -1\n    ),\n    \n    // --------------------\n    \n    // [3] Chord 4 A\n    ivec4(\n        key + 12 + 2,\n        key + 12 - 3,\n        key + 12 + 17,\n        key + 12 - 7\n    ),\n    ivec4(\n        key + 12 + 5,\n        -1, -1, -1\n    ),\n    \n    // --------------------\n    \n    // [4] Chord 4 B\n    ivec4(\n        key + 12 + 2,\n        key + 12 - 3,\n        key + 12 + 14,\n        key + 12 - 7\n    ),\n    ivec4(\n        key + 12 + 5,\n        -1, -1, -1\n    ),\n\n    // --------------------\n    \n    // [5] Chord 1 A\n    ivec4(\n        key + 12,\n        key + 12 + 3,\n        key + 12 + 7,\n        key + 12 + 17\n    ),\n    ivec4(\n        key + 7,\n        -1, -1, -1\n    ),\n    \n    // --------------------\n    \n    // [6] Chord 1 B\n    ivec4(\n        key + 12,\n        key + 12 + 3,\n        key + 12 + 7,\n        key + 12 + 14\n    ),\n    ivec4(\n        key + 7,\n        -1, -1, -1\n    ),\n    \n    // --------------------\n    \n    // [7] Chord 1 C\n    ivec4(\n        key + 12,\n        key + 12 + 3,\n        key + 12 + 7,\n        key + 12 + 14\n    ),\n    ivec4(\n        key + 7,\n        key + 12 + 7,\n        -1, -1\n    ),\n    \n    // --------------------\n    \n    // [8] Chord 2 A\n    ivec4(\n        key + 12 + 3,\n        key + 12 + 7,\n        key + 12 - 2,\n        key + 12 + 17\n    ),\n    ivec4(\n        key + 12 - 5,\n        -1, -1, -1\n    ),\n    \n    // --------------------\n    \n    // [9] Chord 2 B\n    ivec4(\n        key + 12 + 3,\n        key + 12 + 7,\n        key + 12 - 2,\n        key + 12 + 14\n    ),\n    ivec4(\n        key + 12 - 5,\n        -1, -1, -1\n    )\n);\n\n// X = chord index\n// Y = volume\n// Z = start time (steps)\n// W = end time (steps)\nconst int guitarChordPatternSize = 95;\nconst vec4 guitarChordPattern[95] = vec4[](\n    // Bar 4 - Chord 3\n    vec4(0.0, 1.0, 64.0, 65.5),\n    vec4(0.0, 1.0, 67.0, 68.0),\n    vec4(1.0, 1.0, 70.0, 71.0),\n    vec4(1.0, 1.0, 71.0, 72.0),\n    vec4(1.0, 1.0, 72.0, 73.0),\n    vec4(0.0, 1.0, 73.0, 74.0),\n    vec4(0.0, 1.0, 76.0, 78.0),\n    \n    // Bar 5 - Chord 3\n    vec4(0.0, 1.0, 80.0, 81.5),\n    vec4(2.0, 1.0, 83.0, 84.0),\n    vec4(2.0, 1.0, 86.0, 87.0),\n    vec4(2.0, 1.0, 87.0, 88.0),\n    vec4(2.0, 1.0, 88.0, 89.0),\n    vec4(2.0, 1.0, 89.0, 90.0),\n    vec4(2.0, 1.0, 92.0, 94.0),\n    vec4(2.0, 1.0, 94.0, 96.0),\n    \n    // Bar 6 - Chord 4\n    vec4(3.0, 1.0, 96.0, 97.5),\n    vec4(4.0, 1.0, 99.0, 100.0),\n    vec4(4.0, 1.0, 102.0, 103.0),\n    vec4(4.0, 1.0, 103.0, 104.0),\n    vec4(4.0, 1.0, 104.0, 105.0),\n    vec4(4.0, 1.0, 105.0, 106.0),\n    vec4(4.0, 1.0, 108.0, 110.0),\n    vec4(4.0, 1.0, 110.0, 111.0),\n    \n    // Bar 7 - Chord 4\n    vec4(3.0, 1.0, 112.0, 113.5),\n    vec4(4.0, 1.0, 115.0, 116.0),\n    vec4(4.0, 1.0, 118.0, 119.0),\n    vec4(4.0, 1.0, 119.0, 120.0),\n    vec4(4.0, 1.0, 120.0, 121.0),\n    vec4(4.0, 1.0, 121.0, 123.0),\n    vec4(4.0, 1.0, 123.0, 124.0),\n    vec4(4.0, 1.0, 124.0, 126.0),\n    vec4(4.0, 1.0, 126.0, 127.2),\n    \n    // Bar 8 - Chord 1\n    vec4(5.0, 1.0, 48.0 + 80.0, 48.0 + 81.5),\n    vec4(6.0, 1.0, 48.0 + 83.0, 48.0 + 84.0),\n    vec4(6.0, 1.0, 48.0 + 86.0, 48.0 + 87.0),\n    vec4(6.0, 1.0, 48.0 + 87.0, 48.0 + 88.0),\n    vec4(6.0, 1.0, 48.0 + 88.0, 48.0 + 89.0),\n    vec4(6.0, 1.0, 48.0 + 89.0, 48.0 + 90.0),\n    vec4(6.0, 1.0, 48.0 + 92.0, 48.0 + 94.0),\n    vec4(6.0, 1.0, 48.0 + 94.0, 48.0 + 96.0),\n    \n    // Bar 9 - Chord 1\n    vec4(5.0, 1.0, 64.0 + 80.0, 64.0 + 81.5),\n    vec4(6.0, 1.0, 64.0 + 83.0, 64.0 + 84.0),\n    vec4(6.0, 1.0, 64.0 + 86.0, 64.0 + 87.0),\n    vec4(6.0, 1.0, 64.0 + 87.0, 64.0 + 88.0),\n    vec4(6.0, 1.0, 64.0 + 88.0, 64.0 + 89.0),\n    vec4(6.0, 1.0, 64.0 + 89.0, 64.0 + 90.0),\n    vec4(7.0, 1.0, 64.0 + 92.0, 64.0 + 95.5),\n    \n    // Bar 10 - Chord 2\n    vec4(8.0, 1.0, 80.0 + 80.0, 80.0 + 81.5),\n    vec4(9.0, 1.0, 80.0 + 83.0, 80.0 + 84.0),\n    vec4(9.0, 1.0, 80.0 + 86.0, 80.0 + 87.0),\n    vec4(9.0, 1.0, 80.0 + 87.0, 80.0 + 88.0),\n    vec4(9.0, 1.0, 80.0 + 88.0, 80.0 + 89.0),\n    vec4(9.0, 1.0, 80.0 + 89.0, 80.0 + 90.0),\n    vec4(9.0, 1.0, 80.0 + 92.0, 80.0 + 94.0),\n    vec4(9.0, 1.0, 80.0 + 94.0, 80.0 + 96.0),\n    \n    // Bar 11 - Chord 2\n    vec4(9.0, 1.0, 96.0 + 80.0, 96.0 + 81.5),\n    vec4(9.0, 1.0, 96.0 + 83.0, 96.0 + 84.0),\n    vec4(9.0, 1.0, 96.0 + 86.0, 96.0 + 87.0),\n    vec4(9.0, 1.0, 96.0 + 87.0, 96.0 + 88.0),\n    vec4(9.0, 1.0, 96.0 + 88.0, 96.0 + 89.0),\n    vec4(9.0, 1.0, 96.0 + 89.0, 96.0 + 90.0),\n    vec4(9.0, 1.0, 96.0 + 92.0, 96.0 + 94.0),\n    vec4(9.0, 1.0, 96.0 + 94.0, 96.0 + 94.66),\n    \n    // Bar 12 - Chord 3\n    vec4(0.0, 1.0, 128.0 + 64.0, 128.0 + 65.5),\n    vec4(2.0, 1.0, 128.0 + 67.0, 128.0 + 68.0),\n    vec4(2.0, 1.0, 128.0 + 70.0, 128.0 + 71.0),\n    vec4(2.0, 1.0, 128.0 + 71.0, 128.0 + 72.0),\n    vec4(2.0, 1.0, 128.0 + 72.0, 128.0 + 73.0),\n    vec4(2.0, 1.0, 128.0 + 73.0, 128.0 + 74.0),\n    vec4(2.0, 1.0, 128.0 + 76.0, 128.0 + 78.0),\n    \n    // Bar 13 - Chord 3\n    vec4(0.0, 1.0, 128.0 + 80.0, 128.0 + 81.5),\n    vec4(2.0, 1.0, 128.0 + 83.0, 128.0 + 84.0),\n    vec4(2.0, 1.0, 128.0 + 86.0, 128.0 + 87.0),\n    vec4(2.0, 1.0, 128.0 + 87.0, 128.0 + 88.0),\n    vec4(2.0, 1.0, 128.0 + 88.0, 128.0 + 89.0),\n    vec4(2.0, 1.0, 128.0 + 89.0, 128.0 + 90.0),\n    vec4(2.0, 1.0, 128.0 + 92.0, 128.0 + 94.0),\n    vec4(2.0, 1.0, 128.0 + 94.0, 128.0 + 96.0),\n    \n    // Bar 14 - Chord 4\n    vec4(3.0, 1.0, 128.0 + 96.0, 128.0 + 97.5),\n    vec4(4.0, 1.0, 128.0 + 99.0, 128.0 + 100.0),\n    vec4(4.0, 1.0, 128.0 + 102.0, 128.0 + 103.0),\n    vec4(4.0, 1.0, 128.0 + 103.0, 128.0 + 104.0),\n    vec4(4.0, 1.0, 128.0 + 104.0, 128.0 + 105.0),\n    vec4(4.0, 1.0, 128.0 + 105.0, 128.0 + 106.0),\n    vec4(4.0, 1.0, 128.0 + 108.0, 128.0 + 110.0),\n    vec4(4.0, 1.0, 128.0 + 110.0, 128.0 + 111.0),\n    \n    // Bar 15 - Chord 4\n    vec4(3.0, 1.0, 128.0 + 112.0, 128.0 + 113.5),\n    vec4(4.0, 1.0, 128.0 + 115.0, 128.0 + 116.0),\n    vec4(4.0, 1.0, 128.0 + 118.0, 128.0 + 119.0),\n    vec4(4.0, 1.0, 128.0 + 119.0, 128.0 + 120.0),\n    vec4(4.0, 1.0, 128.0 + 120.0, 128.0 + 121.0),\n    vec4(4.0, 1.0, 128.0 + 121.0, 128.0 + 122.0),\n    vec4(4.0, 1.0, 128.0 + 123.0, 128.0 + 124.0),\n    vec4(4.0, 1.0, 128.0 + 124.0, 128.0 + 126.0),\n    vec4(4.0, 1.0, 128.0 + 126.0, 128.0 + 127.2)\n);\n\n// X = note\n// Y = start time (thirds)\n// Z = end time (thirds)\nconst int introLeadPatternSize = 9;\nconst vec3 introLeadPattern[9] = vec3[](\n    vec3(float(key) + 29.0, 18.0, 18.5),\n    vec3(float(key) + 26.0, 18.5, 24.0),\n    vec3(float(key) + 24.0, 24.0 + 0.0, 24.0 + 9.0),\n    vec3(float(key) + 22.0, 24.0 + 10.0, 24.0 + 11.0),\n    vec3(float(key) + 24.0, 24.0 + 11.0, 24.0 + 12.0),\n    vec3(float(key) + 26.0, 36.0 + 0.0, 36.0 + 1.0),\n    vec3(float(key) + 24.0, 36.0 + 1.0, 36.0 + 2.0),\n    vec3(float(key) + 22.0, 36.0 + 2.0, 36.0 + 3.0),\n    vec3(float(key) + 19.0, 36.0 + 3.0, 36.0 + 8.0)\n);\n\n// X = note\n// Y = start time (steps)\n// Z = end time (steps)\nconst int vocode1PatternSize = 63;\nconst vec3 vocode1Pattern[63] = vec3[](\n    vec3(float(key) + 0.0, 128.0 + 2.0, 128.0 + 4.0),\n    vec3(float(key) + 0.0, 128.0 + 4.0, 128.0 + 6.0),\n    vec3(float(key) + 2.0, 128.0 + 6.0, 128.0 + 8.0),\n    vec3(float(key) + 2.0, 128.0 + 8.0, 128.0 + 10.0),\n    vec3(float(key) + 3.0, 128.0 + 10.0, 128.0 + 12.0),\n    vec3(float(key) + 3.0, 128.0 + 12.0, 128.0 + 14.0),\n    vec3(float(key) + 5.0, 128.0 + 14.0, 128.0 + 16.0),\n    vec3(float(key) + 5.0, 128.0 + 16.0, 128.0 + 18.0),\n    vec3(float(key) + 7.0, 128.0 + 18.0, 128.0 + 20.0),\n    vec3(float(key) + 7.0, 128.0 + 20.0, 128.0 + 24.0),\n    \n    vec3(float(key) + 3.0, 160.0 + 2.0, 160.0 + 4.0),\n    vec3(float(key) + 3.0, 160.0 + 4.0, 160.0 + 6.0),\n    vec3(float(key) + 5.0, 160.0 + 6.0, 160.0 + 8.0),\n    vec3(float(key) + 5.0, 160.0 + 8.0, 160.0 + 10.0),\n    vec3(float(key) + 7.0, 160.0 + 10.0, 160.0 + 12.0),\n    vec3(float(key) + 7.0, 160.0 + 12.0, 160.0 + 14.0),\n    vec3(float(key) + 9.0, 160.0 + 14.0, 160.0 + 16.0),\n    vec3(float(key) + 9.0, 160.0 + 16.0, 160.0 + 18.0),\n    vec3(float(key) + 10.0, 160.0 + 18.0, 160.0 + 20.0),\n    vec3(float(key) + 10.0, 160.0 + 20.0, 160.0 + 24.0),\n    \n    vec3(float(key) + 7.0,  192.0 + 2.0,  192.0 + 4.0),\n    vec3(float(key) + 7.0,  192.0 + 4.0,  192.0 + 6.0),\n    vec3(float(key) + 9.0,  192.0 + 6.0,  192.0 + 8.0),\n    vec3(float(key) + 9.0,  192.0 + 8.0,  192.0 + 10.0),\n    vec3(float(key) + 10.0,  192.0 + 10.0, 192.0 + 12.0),\n    vec3(float(key) + 10.0,  192.0 + 12.0, 192.0 + 14.0),\n    vec3(float(key) + 12.0,  192.0 + 14.0, 192.0 + 16.0),\n    vec3(float(key) + 12.0,  192.0 + 16.0, 192.0 + 18.0),\n    vec3(float(key) + 14.0, 192.0 + 18.0, 192.0 + 20.0),\n    vec3(float(key) + 21.0, 192.0 + 20.0, 192.0 + 22.0),\n    vec3(float(key) + 19.0, 192.0 + 22.0, 192.0 + 26.0),\n    \n    vec3(float(key) + 17.0,  224.0 + 2.0,  224.0 + 4.0),\n    vec3(float(key) + 17.0,  224.0 + 4.0,  224.0 + 6.0),\n    vec3(float(key) + 14.0,  224.0 + 6.0,  224.0 + 8.0),\n    vec3(float(key) + 12.0,  224.0 + 8.0,  224.0 + 10.0),\n    vec3(float(key) + 14.0,  224.0 + 10.0, 224.0 + 12.0),\n    vec3(float(key) + 19.0,  224.0 + 12.0, 224.0 + 14.0),\n    vec3(float(key) + 17.0,  224.0 + 14.0, 224.0 + 20.0),\n    vec3(float(key) + 17.0,  224.0 + 20.0, 224.0 + 24.0),\n    vec3(float(key) + 15.0, 224.0 + 24.0, 224.0 + 28.0),\n    vec3(float(key) + 14.0, 224.0 + 28.0, 224.0 + 32.0),\n    \n    vec3(float(key) + 19.0,  256.0 + 0.0,  256.0 + 2.0),\n    vec3(float(key) + 17.0,  256.0 + 2.0,  256.0 + 4.0),\n    vec3(float(key) + 15.0,  256.0 + 4.0,  256.0 + 6.0),\n    vec3(float(key) + 12.0,  256.0 + 6.0,  256.0 + 7.0),\n    vec3(float(key) + 10.0,  256.0 + 7.0,  256.0 + 12.0),\n    \n    vec3(float(key) + 12.0,  256.0 + 16.0,  256.0 + 16.33),\n    vec3(float(key) + 14.0,  256.0 + 16.33,  256.0 + 17.5),\n    vec3(float(key) + 12.0,  256.0 + 18.0,  256.0 + 20.0),\n    vec3(float(key) + 10.0,  256.0 + 20.0,  256.0 + 22.0),\n    vec3(float(key) + 7.0,  256.0 + 22.0,  256.0 + 23.0),\n    vec3(float(key) + 5.0,  256.0 + 23.0,  256.0 + 24.0),\n    vec3(float(key) + 7.0,  256.0 + 24.0,  256.0 + 30.0),\n    \n    vec3(float(key) + 21.0,  288.0 + 0.0,  288.0 + 2.0),\n    vec3(float(key) + 19.0,  288.0 + 2.0,  288.0 + 4.0),\n    vec3(float(key) + 17.0,  288.0 + 4.0,  288.0 + 6.0),\n    vec3(float(key) + 14.0,  288.0 + 6.0,  288.0 + 7.0),\n    vec3(float(key) + 21.0,  288.0 + 7.0,  288.0 + 12.0),\n    vec3(float(key) + 19.0,  288.0 + 12.0,  288.0 + 16.0),\n    \n    vec3(float(key) + 21.0,  288.0 + 16.0,  288.0 + 20.0),\n    vec3(float(key) + 19.0,  288.0 + 20.0,  288.0 + 24.0),\n    vec3(float(key) + 17.0,  288.0 + 24.0,  288.0 + 28.0),\n    vec3(float(key) + 14.0,  288.0 + 28.0,  288.0 + 32.0)\n);\n\nfloat instKick(TimeInfo ti, out float duck)\n{\n    float t = mod(ti.time, beatLength);\n\n    float initFreq = 115.0;\n    float freqDecayLength = 0.25;\n    float freqDecayPow = 2.0;\n    \n    AdsrInfo adsr;\n    adsr.attack = 0.01;\n    adsr.attackPow = -1.5;\n    adsr.decay = 1.0;\n    adsr.decayPow = 0.0;\n    adsr.sustain = 1.0;\n    adsr.release = 0.03;\n    adsr.releasePow = 0.0;\n\n    float amp = adsrEval(adsr, t, 0.0, freqDecayLength);\n    duck += amp;\n    \n    // https://www.desmos.com/calculator/2gzadq05qq\n    return amp * sin((-TWO_PI * freqDecayLength * initFreq * pow(1.0 - (t / freqDecayLength), freqDecayPow + 1.0)) / (freqDecayPow + 1.0));\n}\n\nfloat instBass(TimeInfo ti)\n{\n    int note = bassNotes[(ti.bar / 2) % 4];\n    float ampMul = 1.0;\n    \n    AdsrInfo adsr;\n    adsr.attack = 0.07;\n    adsr.attackPow = 0.0;\n    adsr.decay = 0.85;\n    adsr.decayPow = 0.0;\n    adsr.sustain = 0.0;\n    adsr.release = 0.03;\n    adsr.releasePow = 0.0;\n    \n    float a = ti.barT * 16.0;\n    a = clamp(a, 0.0, 15.0);\n    float t = mod(a / 3.0, 1.0);\n    \n    if (ti.bar == 1)\n    {\n        if (a < 2.0)\n        {\n            ampMul = 1.5;\n            t = map_range_clamp(a, 0.0, 2.0, 0.0, 1.0);\n        }\n        else if (a < 3.0)\n        {\n            adsr.attack = 0.1;\n            adsr.attackPow = -1.0;\n            adsr.decayPow = -1.0;\n            note += 12;\n            ampMul = 0.6;\n            t = map_range_clamp(a, 2.0, 3.0, 0.0, 1.0);\n        }\n        if (a > 6.0 && a < 10.0)\n        {\n            adsr.attack = 0.1;\n            adsr.attackPow = -1.0;\n            adsr.decayPow = -1.0;\n            t = map_range_clamp(a, 6.0, 9.0, 0.0, 1.0);\n        }\n        if (a >= 10.0)\n        {\n            t = map_range_clamp(a, 10.0, 13.0, 0.0, 1.0);\n        }\n    }\n    else\n    {\n        if (a > 6.0 && a < 10.0)\n        {\n            adsr.attack = 0.1;\n            adsr.attackPow = -1.0;\n            adsr.decayPow = -1.0;\n            \n            if (a < 7.0)\n                t = map_range_clamp(a, 6.0, 7.0, 0.0, 1.0);\n            else\n                t = map_range_clamp(a, 7.0, 10.0, 0.0, 1.0);\n        }\n        \n        if (a >= 10.0)\n        {\n            t = map_range_clamp(a, 10.0, 13.0, 0.0, 1.0);\n        }\n    }\n    \n    float freq = noteToFreq(note);\n    float amp = ampMul * adsrEval(adsr, t, 0.0, 0.0);\n    float v = amp * waveBass(ti.time, freq);\n    return v;\n}\n\nvec2 instChords(TimeInfo ti)\n{\n    if (ti.bar < 8)\n        return vec2(0.0);\n\n    vec2 v1 = vec2(0.0);\n    vec2 v2 = vec2(0.0);\n    vec2 v3 = vec2(0.0);\n    \n    int a = (ti.bar / 2) % 4;\n    if (a == 0)\n    {\n        v1 += waveCustom1(ti.time, noteToFreq(key));\n        v2 += waveCustom1(ti.time, noteToFreq(key + 7));\n        v3 += waveCustom1(ti.time, noteToFreq(key + 3));\n    }\n    if (a == 1)\n    {\n        v1 += waveCustom1(ti.time, noteToFreq(key + 3));\n        v2 += waveCustom1(ti.time, noteToFreq(key + 7));\n        v3 += waveCustom1(ti.time, noteToFreq(key - 2));\n        v1 += 0.3 * waveCustom1(ti.time, noteToFreq(key + 5));\n    }\n    if (a == 2)\n    {\n        v1 += waveCustom1(ti.time, noteToFreq(key - 2));\n        v2 += waveCustom1(ti.time, noteToFreq(key + 7));\n        v3 += waveCustom1(ti.time, noteToFreq(key + 2));\n    }\n    if (a == 3)\n    {\n        v1 += waveCustom1(ti.time, noteToFreq(key + 5));\n        v2 += waveCustom1(ti.time, noteToFreq(key - 3));\n        v3 += waveCustom1(ti.time, noteToFreq(key));\n        v2 += 0.8 * waveCustom1(ti.time, noteToFreq(key + 7));\n    }\n    \n    v1 = audioPan(v1, -0.2);\n    v3 = audioPan(v3, 0.2);\n    \n    vec2 v = v1 + v2 + v3;\n    \n    v *= map_range_clamp(sin(TWO_PI * ti.barT * 4.0), -1.0, 1.0, 0.9, 1.0);\n    v = audioPan(v, map_range_clamp(sin(TWO_PI * ti.barT * 16.0), -1.0, 1.0, 0.05, -0.1));\n    \n    if (ti.bar == 8)\n    {\n        v *= map_range_clamp(ti.barT, 0.0, 0.03, 0.0, 1.0);\n    }\n    \n    return v;\n}\n\nfloat instSnare(TimeInfo ti)\n{\n    if (ti.beat % 2 != 1)\n        return 0.0;\n\n    AdsrInfo adsr;\n    adsr.attack = 0.01;\n    adsr.attackPow = 0.0;\n    adsr.decay = 0.6;\n    adsr.decayPow = 1.5;\n    adsr.sustain = 0.0;\n    adsr.release = 0.05;\n    adsr.releasePow = 0.0;\n    \n    return adsrEval(adsr, ti.beatT, 0.02, 0.0) * pow(random() - 0.5, 3.0);\n}\n\nvec2 instHiHat(TimeInfo ti)\n{\n    AdsrInfo adsr;\n    adsr.attack = 0.005;\n    adsr.attackPow = 0.0;\n    adsr.decay = 0.25;\n    adsr.decayPow = 3.0;\n    adsr.sustain = 0.0;\n    adsr.release = 0.01;\n    adsr.releasePow = 0.0;\n    \n    return audioPan(vec2(adsrEval(adsr, ti.beatT, 0.0, 0.0) * pow(random() - 0.5, 3.0)), -0.15);\n}\n\nfloat instCrash(TimeInfo ti)\n{\n    if (ti.time > 8.0)\n        return 0.0;\n    \n    AdsrInfo adsr;\n    adsr.attack = 0.02;\n    adsr.attackPow = 0.0;\n    adsr.decay = 10.0;\n    adsr.decayPow = 2.0;\n    adsr.sustain = 0.0;\n    adsr.release = 0.05;\n    adsr.releasePow = 0.0;\n    \n    return adsrEval(adsr, ti.time, 0.0, 0.0) * (random() - 0.5);\n}\n\nvec2 instGuitar1(TimeInfo ti)\n{\n    if (ti.bar > 3)\n        return vec2(0.0);\n\n    AdsrInfo adsr;\n    adsr.attack = 0.01;\n    adsr.attackPow = 0.5;\n    adsr.decay = 1.2;\n    adsr.decayPow = 2.0;\n    adsr.sustain = 0.5;\n    adsr.release = 0.05;\n    adsr.releasePow = 0.5;\n    \n    vec2 v = vec2(0.0);\n\n    // Go through the pattern\n    for (int i = 0; i < introLeadPatternSize; i++)\n    {\n        // Note info\n        vec3 noteInfo = introLeadPattern[i];\n\n        // Note time\n        const float thirdToSec = beatLength / 3.0;\n        float noteStart = noteInfo.y * thirdToSec;\n        float noteEnd = noteInfo.z * thirdToSec;\n        float noteLen = noteEnd - noteStart;\n\n        // Skip if needed\n        if (ti.time < noteStart                   // start\n            || ti.time > noteEnd + adsr.release)  // end\n        {\n            continue;\n        }\n\n        int note = int(noteInfo.x);\n        float freq = noteToFreq(note);\n        v += adsrEval(adsr, ti.time, noteStart, noteLen) * waveGuitar(ti.time, freq);\n    }\n\n    // LFO pan\n    v = audioPan(v, map_range_clamp(sin(TWO_PI * ti.barT * 8.0), -1.0, 1.0, -0.08, 0.0));\n\n    return v;\n}\n\nvec2 instGuitar2(TimeInfo ti)\n{\n    if (ti.bar < 4)\n        return vec2(0.0);\n    \n    if (ti.bar >= 16)\n        ti.time = wrap(ti.time, 8.0 * beatLength * 4.0, 16.0 * beatLength * 4.0);\n    \n    AdsrInfo adsr;\n    adsr.attack = 0.005;\n    adsr.attackPow = 0.5;\n    adsr.decay = 1.0;\n    adsr.decayPow = 2.0;\n    adsr.sustain = 0.4;\n    adsr.release = 0.05;\n    adsr.releasePow = 0.5;\n    \n    vec2 v = vec2(0.0);\n    \n    // Go through the chord pattern\n    for (int i = 0; i < guitarChordPatternSize; i++)\n    {\n        // Chord info\n        vec4 chordInfo = guitarChordPattern[i];\n    \n        // Chord time\n        const float fourthToSec = 0.25 * beatLength;\n        float chordStart = chordInfo.z * fourthToSec;\n        float chordEnd = chordInfo.w * fourthToSec;\n        float chordLen = chordEnd - chordStart;\n        \n        // Skip if needed\n        if (chordInfo.y == 0.0                     // volume = 0\n            || ti.time < chordStart                // start\n            || ti.time > chordEnd + adsr.release)  // end\n        {\n            continue;\n        }\n        \n        // Chord notes\n        int chordIndex = int(chordInfo.x) * 2;\n        ivec4 notesA = guitarChords[chordIndex];\n        ivec4 notesB = guitarChords[chordIndex + 1];\n        \n        // Add the notes\n        for (int i = 0; i < 4; i++)\n        {\n            float freq = noteToFreq(notesA[i]);\n            v += chordInfo.y * adsrEval(adsr, ti.time, chordStart, chordLen) * waveGuitar2(ti.time, freq);\n            \n            freq = noteToFreq(notesB[i]);\n            v += chordInfo.y * adsrEval(adsr, ti.time, chordStart, chordLen) * waveGuitar2(ti.time, freq);\n        }\n    }\n    \n    // LFO pan\n    v = audioPan(v, map_range_clamp(sin(TWO_PI * ti.barT * 16.0), -1.0, 1.0, 0.0, 0.15));\n    \n    // LFO volume\n    v *= dBToLinear(map_range_clamp(cos(TWO_PI * ti.barT * 2.0), -1.0, 1.0, -1.0, 0.0));\n\n    return v;\n}\n\nvec2 instVocode1(TimeInfo ti)\n{\n    if (ti.bar < 8)\n        return vec2(0.0);\n\n    AdsrInfo adsr;\n    adsr.attack = 0.01;\n    adsr.attackPow = 0.5;\n    adsr.decay = 0.15;\n    adsr.decayPow = 1.0;\n    adsr.sustain = 0.6;\n    adsr.release = 0.1;\n    adsr.releasePow = 0.0;\n    \n    vec2 v = vec2(0.0);\n\n    // Go through the pattern\n    for (int i = 0; i < vocode1PatternSize; i++)\n    {\n        // Note info\n        vec3 noteInfo = vocode1Pattern[i];\n\n        // Note time\n        const float fourthToSec = 0.25 * beatLength;\n        float noteStart = noteInfo.y * fourthToSec;\n        float noteEnd = noteInfo.z * fourthToSec;\n        float noteLen = noteEnd - noteStart;\n\n        // Skip if needed\n        if (ti.time < noteStart                   // start\n            || ti.time > noteEnd + adsr.release)  // end\n        {\n            continue;\n        }\n\n        int note = int(noteInfo.x);\n        float freq = noteToFreq(note);\n        v += adsrEval(adsr, ti.time, noteStart, noteLen) * waveVocode1(ti.time, freq);\n    }\n\n    // Pan\n    v = audioPan(v, -0.1);\n\n    return v;\n}\n\nvec2 renderSound(float fSampleIndex, float time)\n{\n    if (time < 0.5)\n        return vec2(0.0);\n    else\n        time -= 0.5;\n\n    // Initialize PRNG\n    eprng_init(vec2(fSampleIndex * 40.25, fSampleIndex * 924.25 - 17.2), time);\n    \n    const float bar0 = 0.0;\n\n    TimeInfo ti = getTimeInfo(time + bar0 * beatLength * 4.0, beatLength);\n    float duck = 0.0;\n    \n    vec2 v = vec2(0.0);\n    v += instKick(ti, duck) * dBToLinear(-6.0);\n    v += instBass(ti) * dBToLinear(-7.0) * map_range_clamp(duck, 0.0, 1.0, 1.0, 0.6);\n    v += instChords(ti) * dBToLinear(-32.0);\n    v += instSnare(ti) * dBToLinear(-4.0) * map_range_clamp(duck, 0.0, 1.0, 1.0, 0.6);\n    v += instHiHat(ti) * dBToLinear(-15.0);\n    v += instCrash(ti) * dBToLinear(-35.0);\n    v += instGuitar1(ti) * dBToLinear(-23.0);\n    v += instGuitar2(ti) * dBToLinear(-26.0);\n    v += instVocode1(ti) * dBToLinear(-19.0);\n    \n    v *= dBToLinear(3.0);\n    \n    return v;\n}\n\nvec2 mainSound(int samp, float time)\n{\n    const int numSamples = 8;\n    float sampleTime = 1. / iSampleRate;\n    vec2 v = vec2(0);\n    for (int i = 0; i < numSamples; i++)\n    {\n        float t = float(i) / float(numSamples);\n        t -= .5;\n        v += renderSound(float(samp) + t, time + t * sampleTime);\n    }\n    v /= float(numSamples);\n    \n    return v;\n}\n",
     "name": "Sound",
     "description": "",
     "type": "sound"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "#define PI 3.14159265358979\n#define TWO_PI 6.28318530717959\n#define DEG_TO_RAD 0.01745329251994\n\nfloat wrap(float inp, float start, float end)\n{\n    return start + mod(inp - start, end - start);\n}\n\nfloat map_range(float inp, float inp_start, float inp_end, float out_start, float out_end)\n{\n    return out_start + ((out_end - out_start) / (inp_end - inp_start)) * (inp - inp_start);\n}\n\nfloat map_range_clamp(float inp, float inp_start, float inp_end, float out_start, float out_end)\n{\n    float t = clamp((inp - inp_start) / (inp_end - inp_start), 0.0, 1.0);\n    float v = out_start + t * (out_end - out_start);\n    return v;\n}\n\nstruct TimeInfo\n{\n    float time;\n    int bar;\n    float barT;\n    int beat;\n    float beatT;\n    int fourth;\n    float fourthT;\n    int third;\n    float thirdT;\n};\n\nstruct AdsrInfo\n{\n    float attack;\n    float attackPow;\n    float decay;\n    float decayPow;\n    float sustain;\n    float release;\n    float releasePow;\n};\n\nTimeInfo getTimeInfo(float time, float beatLength)\n{\n    TimeInfo ti;\n    ti.time = time;\n    ti.bar = int(floor(time / (4.0 * beatLength)));\n    ti.barT = mod(time / (4.0 * beatLength), 1.0);\n    ti.beat = int(floor(time / beatLength));\n    ti.beatT = mod(time / beatLength, 1.0);\n    ti.fourth = int(floor(4.0 * time / beatLength));\n    ti.fourthT = mod(4.0 * time / beatLength, 1.0);\n    ti.third = int(floor(3.0 * time / beatLength));\n    ti.thirdT = mod(3.0 * time / beatLength, 1.0);\n    return ti;\n}\n\n// 0 = C0\nfloat noteToFreq(int note) {\n    if (note < 0)\n        return 0.0;\n\n    const float a = 440.0;\n    return (a / 32.0) * pow(2.0, (float(note) - 9.0) / 12.0);\n}\n\nfloat dBToLinear(float dB)\n{\n    return pow(10.0, dB / 20.0);\n}\n\nfloat linearTodB(float lin)\n{\n    return 20.0 * log(lin) / log(10.0);\n}\n\n\n// https://www.desmos.com/calculator/ojkihg4hig\nfloat flPow(float x, float p)\n{\n    if (p >= 0.0)\n        return pow(x, pow(2.0, p));\n    return 1.0 - pow(1.0 - x, pow(2.0, -p));\n}\n\nfloat adsrEval_Decay(AdsrInfo adsr, float t)\n{\n    float v = map_range_clamp(t, adsr.attack, adsr.attack + adsr.decay, 1.0, 0.0);\n    v = flPow(v, adsr.decayPow);\n    v = map_range(v, 1.0, 0.0, 1.0, adsr.sustain);\n    return v;\n}\n\nfloat adsrEval(AdsrInfo adsr, float t, float noteStartT, float noteLengthT)\n{\n    t -= noteStartT;\n    \n    // Auto length\n    if (noteLengthT == 0.0)\n    {\n        noteLengthT = adsr.attack + adsr.decay;\n    }\n\n    // Before start\n    if (t < 0.0)\n        return 0.0;\n    \n    // After end and release\n    if (t > noteLengthT + adsr.release)\n        return 0.0;\n    \n    // Release\n    if (t > noteLengthT)\n    {\n        float v = map_range_clamp(t - noteLengthT, 0.0, adsr.release, 1.0, 0.0);\n        return adsrEval_Decay(adsr, noteLengthT) * flPow(v, adsr.releasePow);\n    }\n    \n    // Decay\n    if (t > adsr.attack)\n    {\n        return adsrEval_Decay(adsr, t);\n    }\n    \n    // Attack\n    return flPow(clamp(t / adsr.attack, 0.0, 1.0), adsr.attackPow);\n}\n\nfloat waveSine(float time, float freq)\n{\n    if (freq <= 0.0) return 0.0;\n    return sin(TWO_PI * time * freq);\n}\n\nfloat waveSaw(float time, float freq)\n{\n    if (freq <= 0.0) return 0.0;\n    return mod(time * freq, 1.0);\n}\n\nfloat waveTri(float time, float freq)\n{\n    if (freq <= 0.0) return 0.0;\n    return abs(mod(2.0 * time * freq - 0.5, 2.0) - 1.0) - 0.5;\n}\n\nfloat waveBass(float time, float freq)\n{\n    return\n        1.0 * pow(sin(TWO_PI * time * freq), 8.0) - 0.5\n        + 0.7 * waveTri(time, freq);\n}\n\nfloat waveCustom1(float time, float freq)\n{\n    if (freq <= 0.0) return 0.0;\n    return\n        0.05 * mod(time * freq, 1.0)\n        + 1.0 * sin(TWO_PI * (time + 0.3) * freq)\n        + 0.65 * waveTri(time + 0.4, 2.0 * freq);\n}\n\nfloat waveGuitar(float time, float freq)\n{\n    if (freq <= 0.0) return 0.0;\n    return waveTri(time, freq) + 0.2 * waveTri(time + 0.15, freq / 2.0);\n}\n\nfloat waveGuitar2(float time, float freq)\n{\n    if (freq <= 0.0) return 0.0;\n    return\n        waveTri(time, freq)\n        + 0.2 * waveTri(time + 0.15, freq)\n        + 0.2 * waveSine(time + 0.27, freq)\n        + 0.3 * waveTri(time - 0.372, freq * 2.0);\n}\n\nfloat waveVocode1(float time, float freq)\n{\n    if (freq <= 0.0) return 0.0;\n    return\n        waveTri(time, freq)\n        + 0.3 * waveSaw(time + 0.15, freq)\n        + 0.15 * waveSine(time + 0.27, freq)\n        + 0.35 * waveTri(time - 0.372, freq * 2.0);\n}\n\nvec2 audioPan(vec2 v, float pan)\n{\n    float angle = map_range_clamp(pan, -1.0, 1.0, 0.0, PI / 2.0);\n    return vec2(cos(angle) * v.x, sin(angle) * v.y) / 0.707106781;\n}\n\n// ***********************************************\n// Source: https://www.shadertoy.com/view/WdSSRt\n// ***********************************************\n\n/* Usage Example:\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Initialize PRNG\n    eprng_init(fragCoord.xy / max(iResolution.x, iResolution.y), iTime);\n\n    // Using the function:\n    float a = random();\n    vec3 b = vec3(random(), random(), random());\n    \n    ...\n}\n\n*/\n\nuint eprng_state[2];\n\nuint eprng_rot(uint x, int k)\n{\n    return (x << k) | (x >> (32 - k));\n}\n\nfloat random()\n{\n    uint s0 = eprng_state[0];\n    uint s1 = eprng_state[1];\n    uint result = eprng_rot(s0 * 0x9e3779bbu, 5) * 5u;\n    s1 ^= s0;\n    eprng_state[0] = eprng_rot(s0, 26) ^ s1 ^ (s1 << 9);\n    eprng_state[1] = eprng_rot(s1, 13);\n    // Not sure this is actually the best way to get evenly-distributed floats -\n    // precision will be lost converting from int to float, but how much depends on the order of magnitude\n    // I could use bit magic to build the bits of a float directly, then use uintBitsToFloat,\n    // but that also loses precision - just in a different way.\n    // I guess precision loss is inevitable, since if we want floats in the range 0.0 <= r <= 1.0 then\n    // there's only so many bits to work with. It's just a matter of how they're distributed.\n    return float(result) / float(0xffffffffu);\n}\n\nvoid eprng_init(vec2 uv, float iTime)\n{\n    uv *= (iTime + 10.258);\n\n    eprng_state[0] = floatBitsToUint(uv.x);\n    eprng_state[1] = floatBitsToUint(uv.y);\n\n    random();\n}\n\n// ***********************************************\n// End\n// ***********************************************\n",
     "name": "Common",
     "description": "",
     "type": "common"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "md2yWh",
    "date": "1687678448",
    "viewed": 159,
    "name": "experimenting with colormaps",
    "description": "will use this in another shader of mine",
    "likes": 4,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "test",
     "colormap"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "float map_range(float inp, float inp_start, float inp_end, float out_start, float out_end)\n{\n    return out_start + ((out_end - out_start) / (inp_end - inp_start)) * (inp - inp_start);\n}\n\nfloat map_range_clamp(float inp, float inp_start, float inp_end, float out_start, float out_end)\n{\n    float t = clamp((inp - inp_start) / (inp_end - inp_start), 0.0, 1.0);\n    float v = out_start + t * (out_end - out_start);\n    return v;\n}\n\nvec3 colormap(float x)\n{\n    vec3 c = vec3(1.0);\n    c = mix(c, 1.2 * vec3(0.3, 0.5, 0.8), map_range_clamp(x, -1.0, -0.6, 0.0, 1.0));\n    c = mix(c, 1.2 * vec3(0.1, 0.02, 0.4), map_range_clamp(x, -0.6, -0.25, 0.0, 1.0));\n    c = mix(c, vec3(0.0), map_range_clamp(x, -0.25, 0.0, 0.0, 1.0));\n    c = mix(c, 1.2 * vec3(0.4, 0.1, 0.02), map_range_clamp(x, 0.0, 0.25, 0.0, 1.0));\n    c = mix(c, 1.2 * vec3(0.8, 0.5, 0.3), map_range_clamp(x, 0.25, 0.6, 0.0, 1.0));\n    c = mix(c, vec3(1.0), map_range_clamp(x, 0.6, 1.0, 0.0, 1.0));\n    \n    c = pow(c, vec3(1.8));\n    c += vec3(0.03, 0.0, 0.02);\n    \n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 col = colormap(uv.x * 2.0 - 1.0);\n    \n    col = pow(col, vec3(1.0 / 2.2));\n\n    fragColor = vec4(col,1.0);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "mdByWW",
    "date": "1687704350",
    "viewed": 173,
    "name": "Discrete Land",
    "description": "Playing with integer coordinates",
    "likes": 5,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "math",
     "discrete",
     "maths",
     "integer",
     "integers"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "vec3 eval(vec2 coord)\n{\n    vec2 uv = coord / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv *= iResolution.xy / min(iResolution.x, iResolution.y);\n    \n    float scale = map_range(cos(TWO_PI * iTime * 0.05), -1.0, 1.0, 150.0, 35.0);\n    vec2 discrete = floor(uv * scale);\n    \n    int method = int(iTime / 1.2) % 5;\n    \n    bool b = false;\n    vec3 col;\n\n    switch (method) {\n    case 0:\n        b = fract(discrete.x * discrete.x / discrete.y) == 0.0;\n        col = vec3(0.01, 0.6, 0.7);\n        break;\n    case 1:\n        b = fract(sqrt(discrete.x * discrete.y)) < 0.01;\n        col = vec3(0.7, 0.55, 0.3);\n        break;\n    case 2:\n        b = fract(sqrt(abs(discrete.x * discrete.y))) > 0.95;\n        col = vec3(0.2, 0.6, 0.9);\n        break;\n    case 3:\n        b = cos(discrete.x * discrete.y / 6.0) > 0.95;\n        col = vec3(0.45, 0.6, 0.25);\n        break;\n    case 4:\n        b = fract(log(abs(discrete.x * discrete.y)) * sin(discrete.x)) < 0.05;\n        col = vec3(0.8, 0.35, 0.6);\n        break;\n    }\n    \n    return b ? col : 0.04 * pow(col, vec3(4.0));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Initialize PRNG\n    eprng_init(fragCoord.xy / max(iResolution.x, iResolution.y), iTime);\n\n    // Jitter sampling\n    const int numSamples = 32;\n    vec3 col = vec3(0.0);\n    for (int i = 0; i < numSamples; i++)\n    {\n        col += eval(fragCoord + vec2(random() - 0.5, random() - 0.5));\n    }\n    col /= float(numSamples);\n    \n    // Noise\n    eprng_init((floor(fragCoord.xy / 2.0) * 2.0) / max(iResolution.x, iResolution.y), floor(iTime * 15.0) / 15.0);\n    float noiseAmount = pow(sin(PI * rgb_max(col)), 2.0);\n    noiseAmount = map_range(noiseAmount, 0.0, 1.0, 0.01, 1.0);\n    col += noiseAmount * map_range(random(), 0.0, 1.0, -0.05, 0.1);\n    \n    // Vignette\n    float dist = length((fragCoord.xy / iResolution.xy) * 2.0 - 1.0);\n    col = pow(col, vec3(map_range_clamp(dist, 0.7, 6.0, 1.0, 4.0)));\n    col *= pow(2.0, map_range_clamp(dist, 0.75, 4.0, 0.0, -5.0));\n    \n    // OETF\n    col = pow(col, vec3(1.0 / 2.2));\n    \n    fragColor = vec4(col, 1.0);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "#define PI 3.14159265358979\n#define TWO_PI 6.28318530717959\n\nfloat map_range(float inp, float inp_start, float inp_end, float out_start, float out_end)\n{\n    return out_start + ((out_end - out_start) / (inp_end - inp_start)) * (inp - inp_start);\n}\n\nfloat map_range_clamp(float inp, float inp_start, float inp_end, float out_start, float out_end)\n{\n    float t = clamp((inp - inp_start) / (inp_end - inp_start), 0.0, 1.0);\n    float v = out_start + t * (out_end - out_start);\n    return v;\n}\n\nfloat rgb_max(vec3 inp)\n{\n    return max(max(inp.x, inp.y), inp.z);\n}\n\n// ***********************************************\n// Source: https://www.shadertoy.com/view/WdSSRt\n// ***********************************************\n\n/* Usage Example:\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Initialize PRNG\n    eprng_init(fragCoord.xy / max(iResolution.x, iResolution.y), iTime);\n\n    // Using the function:\n    float a = random();\n    vec3 b = vec3(random(), random(), random());\n    \n    ...\n}\n\n*/\n\nuint eprng_state[2];\n\nuint eprng_rot(uint x, int k)\n{\n    return (x << k) | (x >> (32 - k));\n}\n\nfloat random()\n{\n    uint s0 = eprng_state[0];\n    uint s1 = eprng_state[1];\n    uint result = eprng_rot(s0 * 0x9e3779bbu, 5) * 5u;\n    s1 ^= s0;\n    eprng_state[0] = eprng_rot(s0, 26) ^ s1 ^ (s1 << 9);\n    eprng_state[1] = eprng_rot(s1, 13);\n    // Not sure this is actually the best way to get evenly-distributed floats -\n    // precision will be lost converting from int to float, but how much depends on the order of magnitude\n    // I could use bit magic to build the bits of a float directly, then use uintBitsToFloat,\n    // but that also loses precision - just in a different way.\n    // I guess precision loss is inevitable, since if we want floats in the range 0.0 <= r <= 1.0 then\n    // there's only so many bits to work with. It's just a matter of how they're distributed.\n    return float(result) / float(0xffffffffu);\n}\n\nvoid eprng_init(vec2 uv, float iTime)\n{\n    uv *= (iTime + 10.258);\n\n    eprng_state[0] = floatBitsToUint(uv.x);\n    eprng_state[1] = floatBitsToUint(uv.y);\n\n    random();\n}\n\n// ***********************************************\n// End\n// ***********************************************\n",
     "name": "Common",
     "description": "",
     "type": "common"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "mdBcz3",
    "date": "1688036284",
    "viewed": 507,
    "name": "3D Wave Simulation",
    "description": "Check out my Interactive 2D Wave Simulation:\nhttps://www.shadertoy.com/view/mdScW1\n\nCheck out my Python wave simulation project:\nhttps://github.com/bean-mhm/wave-simulation-py",
    "likes": 23,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "wave",
     "simulation",
     "physics",
     "waveequation",
     "wavesim"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// iChannel0 = Buffer A\n// iChannel1 = Buffer B\n\nfloat wave_fetch_curr(ivec3 icoord)\n{\n    if (!icoord_in_bounds(icoord, wave_res))\n        return 0.0;\n    return texelFetch(iChannel0, icoord3d_to_2d(icoord, wave_res, ivec2(iResolution.xy)), 0).x;\n}\n\nvec3 get_col(vec2 frag_coord, vec3 tint)\n{\n    // UV\n    vec2 uv = frag_coord / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv *= iResolution.xy / min(iResolution.x, iResolution.y);\n    \n    // Setup camera\n\n    float r = 1.25 * max(wave_dims.x, wave_dims.y);\n    float theta = TWO_PI * iTime * 0.08 - (PI / 2.0);\n    vec3 cam_pos = vec3(r * cos(theta), r * sin(theta), wave_dims.z * 0.2);\n    float cam_fov = 80.0;\n    float cam_zoom = 90.0 / cam_fov;\n\n    vec3 cam_forward = normalize(vec3(0.0, 0.0, wave_dims.z * -0.04) - cam_pos);\n    vec3 cam_right = normalize(cross(cam_forward, vec3(0, 0, 1)));\n    vec3 cam_up = cross(cam_right, cam_forward);\n\n    // Ray\n    Ray ray;\n    ray.orig = cam_pos;\n    ray.dir = normalize(cam_forward + cam_right * (uv.x / cam_zoom) + cam_up * (uv.y / cam_zoom));\n    \n    // Box that contains the wave field\n    vec3 box_min = -wave_dims / 2.0;\n    vec3 box_max = wave_dims / 2.0;\n    \n    // Check intersection with the box\n    Hit hit;\n    ray_aabb(box_min, box_max, ray, hit);\n    \n    // Shade\n    vec3 col = vec3(0.0);\n    if (hit.hit)\n    {\n        col += vec3(0.01);\n        \n        // Intersection length along the ray\n        float len = max(0.0, hit.tmax - hit.tmin);\n        \n        // Step size for traversing the volume\n        const float volume_traverse_step = max(max(wave_dims.x, wave_dims.y), wave_dims.z) / 40.0;\n        \n        // Number of volume samples\n        int num_volume_samples = int(max(4.0, len / volume_traverse_step));\n        \n        // Constants multiplier\n        float mul = pow(2.0, 25.0) / float(num_volume_samples);\n        \n        // Samples\n        for (int i = 0; i < num_volume_samples; i++)\n        {\n            // Point along the ray inside the volume\n            float t = mix(hit.tmin, hit.tmax, float(i) / float(num_volume_samples));\n            vec3 p = ray.orig + t * ray.dir;\n            \n            // Trilinear interpolation\n            vec3 coord = vec3(wave_res) * (p - box_min) / wave_dims;\n            ivec3 p0 = ivec3(floor(coord));\n            ivec3 p1 = p0 + 1;\n            float x0y0z0 = wave_fetch_curr(p0);\n            float x1y0z0 = wave_fetch_curr(ivec3(p1.x, p0.y, p0.z));\n            float x0y1z0 = wave_fetch_curr(ivec3(p0.x, p1.y, p0.z));\n            float x1y1z0 = wave_fetch_curr(ivec3(p1.x, p1.y, p0.z));\n            float x0y0z1 = wave_fetch_curr(ivec3(p0.x, p0.y, p1.z));\n            float x1y0z1 = wave_fetch_curr(ivec3(p1.x, p0.y, p1.z));\n            float x0y1z1 = wave_fetch_curr(ivec3(p0.x, p1.y, p1.z));\n            float x1y1z1 = wave_fetch_curr(p1);\n            float v = interpolate3D(\n                coord - vec3(p0),\n                x0y0z0,\n                x1y0z0,\n                x0y1z0,\n                x1y1z0,\n                x0y0z1,\n                x1y0z1,\n                x0y1z1,\n                x1y1z1\n            );\n            \n            // Update the color\n            col += pow(abs(v), 3.0) * mul * tint;\n        }\n    }\n    \n    // Glow\n    col += tint * 0.15 * pow(max(0.0, dot(ray.dir, normalize(-cam_pos))), 9.0);\n    \n    return col;\n}\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    // Initialize PRNG\n    eprng_init(frag_coord.xy / max(iResolution.x, iResolution.y), iTime);\n\n    // RGB sweep\n    vec3 tint = rgb_sweep(iTime * 0.05 + 0.53);\n\n    // Jitter sampling\n    const int num_samples = 4;\n    vec3 col = vec3(0.0);\n    for (int i = 0; i < num_samples; i++)\n    {\n        col += get_col(frag_coord + vec2(random() - 0.5, random() - 0.5), tint);\n    }\n    col /= float(num_samples);\n    \n    // Color grading\n    col = pow(col, vec3(1.2));\n    col += 0.015 * pow(tint, vec3(6.0));\n    \n    // Noise\n    col += map_range_clamp(random(), 0.0, 1.0, -0.01, 0.005);\n    \n    // flim\n    col = flim_transform(col, 0.0, iChannel1);\n    \n    frag_col = vec4(col, 1.0);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "#define PI 3.14159265358979\n#define TWO_PI 6.28318530717959\n\nstruct Ray\n{\n    vec3 orig;\n    vec3 dir;\n};\n\nstruct Hit\n{\n    bool hit;\n    float tmin;\n    float tmax;\n};\n\n// Grid Resolution\nconst ivec3 wave_res = ivec3(50, 50, 50);\n\n// Minimum distance in the grid\nconst float wave_step = 0.01;\nconst float wave_step2 = wave_step * wave_step;\n\n// Grid dimensions\nconst vec3 wave_dims = wave_step * vec3(wave_res - 1);\n\n// Propagation speed in 2D\nconst float wave_speed = 10.0;\nconst float wave_speed2 = wave_speed * wave_speed;\n\n// Minimum wavelength\n// At least 8 steps needed for a perfectly smooth spherical wave.\nconst float wave_min_wavelength = wave_step * sqrt(3.0) * 8.0;\n\n// Maximum frequency\nconst float wave_max_frequency = wave_speed / wave_min_wavelength;\n\n// Maximum timestep\nconst float wave_max_dt = wave_step / (wave_speed * sqrt(3.0));\n\n// Timestep\nconst float wave_dt = 0.3 * wave_max_dt;\n\n// Stiffness\n// Must be greater than or equal to 1 to function properly.\nconst float wave_stiffness = 10.0;\n\nfloat map_range(float inp, float inp_start, float inp_end, float out_start, float out_end)\n{\n    return out_start + ((out_end - out_start) / (inp_end - inp_start)) * (inp - inp_start);\n}\n\nfloat map_range_clamp(float inp, float inp_start, float inp_end, float out_start, float out_end)\n{\n    float t = clamp((inp - inp_start) / (inp_end - inp_start), 0.0, 1.0);\n    float v = out_start + t * (out_end - out_start);\n    return v;\n}\n\nfloat fit_to_screen(vec2 image_res, vec2 screen_res)\n{\n    return min(screen_res.x / image_res.x, screen_res.y / image_res.y);\n}\n\nvec3 colormap(float x)\n{\n    vec3 c = vec3(1.0);\n    c = mix(c, 1.2 * vec3(0.3, 0.5, 0.8), map_range_clamp(x, -1.0, -0.6, 0.0, 1.0));\n    c = mix(c, 1.2 * vec3(0.1, 0.02, 0.4), map_range_clamp(x, -0.6, -0.25, 0.0, 1.0));\n    c = mix(c, vec3(0.0), map_range_clamp(x, -0.25, 0.0, 0.0, 1.0));\n    c = mix(c, 1.2 * vec3(0.4, 0.1, 0.02), map_range_clamp(x, 0.0, 0.25, 0.0, 1.0));\n    c = mix(c, 1.2 * vec3(0.8, 0.5, 0.3), map_range_clamp(x, 0.25, 0.6, 0.0, 1.0));\n    c = mix(c, vec3(1.0), map_range_clamp(x, 0.6, 1.0, 0.0, 1.0));\n\n    c = pow(c, vec3(1.8));\n    c += vec3(0.03, 0.0, 0.02);\n\n    return c;\n}\n\nbool icoord_in_bounds(ivec2 icoord, ivec2 res)\n{\n    return\n        (icoord.x >= 0) && (icoord.x < res.x)\n        && (icoord.y >= 0) && (icoord.y < res.y);\n}\n\nbool icoord_in_bounds(ivec3 icoord, ivec3 res)\n{\n    return\n        (icoord.x >= 0) && (icoord.x < res.x)\n        && (icoord.y >= 0) && (icoord.y < res.y)\n        && (icoord.z >= 0) && (icoord.z < res.z);\n}\n\nivec3 idx_to_icoord3d(int idx, ivec3 res)\n{\n    return ivec3(\n        idx % res.x,\n        (idx % (res.x * res.y)) / res.x,\n        idx / (res.x * res.y)\n    );\n}\n\nint icoord3d_to_idx(ivec3 icoord, ivec3 res)\n{\n    return\n        icoord.x\n        + icoord.y * res.x\n        + icoord.z * res.x * res.y;\n}\n\nivec2 idx_to_icoord2d(int idx, ivec2 res)\n{\n    return ivec2(idx % res.x, idx / res.x);\n}\n\nint icoord2d_to_idx(ivec2 icoord, ivec2 res)\n{\n    return icoord.x + icoord.y * res.x;\n}\n\nivec3 icoord2d_to_3d(ivec2 icoord2d, ivec2 res2d, ivec3 res3d)\n{\n    return idx_to_icoord3d(icoord2d_to_idx(icoord2d, res2d), res3d);\n}\n\nivec2 icoord3d_to_2d(ivec3 icoord3d, ivec3 res3d, ivec2 res2d)\n{\n    return idx_to_icoord2d(icoord3d_to_idx(icoord3d, res3d), res2d);\n}\n\n// https://www.reddit.com/r/opengl/comments/8ntzz5/comment/dzyqwgr\nvoid ray_aabb(const vec3 box_min, const vec3 box_max, const Ray r, out Hit hit) {\n    vec3 inv_dir = 1.0 / r.dir;\n    vec3 tbot = inv_dir * (box_min - r.orig);\n    vec3 ttop = inv_dir * (box_max - r.orig);\n    vec3 tmin = min(ttop, tbot);\n    vec3 tmax = max(ttop, tbot);\n    vec2 t = max(tmin.xx, tmin.yz);\n    float t0 = max(t.x, t.y);\n    t = min(tmax.xx, tmax.yz);\n    float t1 = min(t.x, t.y);\n    hit.tmin = t0;\n    hit.tmax = t1;\n    hit.hit = t1 > max(t0, 0.0);\n}\n\nvec4 sample_bilinear(vec2 coord, sampler2D src, ivec2 src_res)\n{\n    ivec2 bottomLeftPos = ivec2(int(floor(coord.x - 0.5)), int(floor(coord.y - 0.5)));\n\n    ivec2 topRightPos = ivec2(bottomLeftPos.x + 1, bottomLeftPos.y + 1);\n\n    ivec2 bottomRightPos = ivec2(topRightPos.x, bottomLeftPos.y);\n\n    ivec2 topLeftPos = ivec2(bottomLeftPos.x, topRightPos.y);\n\n    float alongX = coord.x - (float(bottomLeftPos.x) + 0.5);\n    float alongY = coord.y - (float(bottomLeftPos.y) + 0.5);\n\n    float bottomLeftWeight = (1.0 - alongX) * (1.0 - alongY);\n    float bottomRightWeight = (alongX) * (1.0 - alongY);\n    float topLeftWeight = (1.0 - alongX) * (alongY);\n    float topRightWeight = (alongX) * (alongY);\n\n    vec4 result = vec4(0.0);\n\n    if (icoord_in_bounds(bottomLeftPos, src_res))\n        result += bottomLeftWeight * texelFetch(src, bottomLeftPos, 0);\n\n    if (icoord_in_bounds(topRightPos, src_res))\n        result += topRightWeight * texelFetch(src, topRightPos, 0);\n\n    if (icoord_in_bounds(bottomRightPos, src_res))\n        result += bottomRightWeight * texelFetch(src, bottomRightPos, 0);\n\n    if (icoord_in_bounds(topLeftPos, src_res))\n        result += topLeftWeight * texelFetch(src, topLeftPos, 0);\n\n    return result;\n}\n\n#define FUNC_LERP(T) \\\nT lerp(T a, T b, float t) \\\n{ \\\n    return a + t*(b-a); \\\n}\n\n#define FUNC_INTERPOLATE_2D(T) T \\\ninterpolate2D(vec2 p, T x0y0, T x1y0, T x0y1, T x1y1) \\\n{ \\\n    T s = lerp(x0y0, x1y0, p.x); \\\n    T t = lerp(x0y1, x1y1, p.x); \\\n    return lerp(s, t, p.y); \\\n}\n\n#define FUNC_INTERPOLATE_3D(T) \\\nT interpolate3D( \\\n    vec3 p, \\\n    T x0y0z0, \\\n    T x1y0z0, \\\n    T x0y1z0, \\\n    T x1y1z0, \\\n    T x0y0z1, \\\n    T x1y0z1, \\\n    T x0y1z1, \\\n    T x1y1z1) \\\n{ \\\n    T s = interpolate2D(p.xy, x0y0z0, x1y0z0, x0y1z0, x1y1z0); \\\n    T t = interpolate2D(p.xy, x0y0z1, x1y0z1, x0y1z1, x1y1z1); \\\n    return lerp(s, t, p.z); \\\n}\n\nFUNC_LERP(float)\nFUNC_LERP(vec2)\nFUNC_LERP(vec3)\nFUNC_LERP(vec4)\n\nFUNC_INTERPOLATE_2D(float)\nFUNC_INTERPOLATE_2D(vec2)\nFUNC_INTERPOLATE_2D(vec3)\nFUNC_INTERPOLATE_2D(vec4)\n\nFUNC_INTERPOLATE_3D(float)\nFUNC_INTERPOLATE_3D(vec2)\nFUNC_INTERPOLATE_3D(vec3)\nFUNC_INTERPOLATE_3D(vec4)\n\n/***********************************\n\nflim - Filmic Color Transform\n\nInput Color Space:   Linear BT.709 I-D65\nOutput Color Space:  sRGB 2.2\n\nShadertoy Unit:\n  Common\n\nDescription:\n  Experimental port of flim for GLSL/Shadertoy\n  matching flim v1.1.0.\n  The common unit contains most of the code, and\n  receives gamut extension matrices from a buffer.\n\nAuthor:\n  Bean (beans_please on Shadertoy)\n\nOriginal Repo:\n  https://github.com/bean-mhm/flim\n\nOriginal Shader:\n  https://www.shadertoy.com/view/dd2yDz\n\n***********************************/\n\n// Parameters\n\nconst float flim_pre_exposure = 4.3;\nconst vec3 flim_pre_formation_filter = vec3(1.0);\nconst float flim_pre_formation_filter_strength = 0.0;\n\nconst float flim_extended_gamut_red_scale = 1.05;\nconst float flim_extended_gamut_green_scale = 1.12;\nconst float flim_extended_gamut_blue_scale = 1.045;\nconst float flim_extended_gamut_red_rot = 0.5;\nconst float flim_extended_gamut_green_rot = 2.0;\nconst float flim_extended_gamut_blue_rot = 0.1;\nconst float flim_extended_gamut_red_mul = 1.0;\nconst float flim_extended_gamut_green_mul = 1.0;\nconst float flim_extended_gamut_blue_mul = 1.0;\n\nconst float flim_sigmoid_log2_min = -10.0;\nconst float flim_sigmoid_log2_max = 22.0;\nconst float flim_sigmoid_toe_x = 0.44;\nconst float flim_sigmoid_toe_y = 0.28;\nconst float flim_sigmoid_shoulder_x = 0.591;\nconst float flim_sigmoid_shoulder_y = 0.779;\n\nconst float flim_negative_film_exposure = 6.0;\nconst float flim_negative_film_density = 5.0;\n\nconst vec3 flim_print_backlight = vec3(1.0);\nconst float flim_print_film_exposure = 6.0;\nconst float flim_print_film_density = 27.5;\n\nconst float flim_black_point = -1.0; // -1 = auto\nconst vec3 flim_post_formation_filter = vec3(1.0);\nconst float flim_post_formation_filter_strength = 0.0;\nconst float flim_midtone_saturation = 1.02;\n\n// -------------------------------\n\nfloat wrap(float inp, float start, float end)\n{\n    return start + mod(inp - start, end - start);\n}\n\nvec3 blender_rgb_to_hsv(vec3 rgb)\n{\n    float cmax, cmin, h, s, v, cdelta;\n    vec3 c;\n\n    cmax = max(rgb[0], max(rgb[1], rgb[2]));\n    cmin = min(rgb[0], min(rgb[1], rgb[2]));\n    cdelta = cmax - cmin;\n\n    v = cmax;\n    if (cmax != 0.0)\n    {\n        s = cdelta / cmax;\n    }\n    else\n    {\n        s = 0.0;\n        h = 0.0;\n    }\n\n    if (s == 0.0)\n    {\n        h = 0.0;\n    }\n    else\n    {\n        c = (vec3(cmax) - rgb.xyz) / cdelta;\n\n        if (rgb.x == cmax)\n        {\n            h = c[2] - c[1];\n        }\n        else if (rgb.y == cmax)\n        {\n            h = 2.0 + c[0] - c[2];\n        }\n        else\n        {\n            h = 4.0 + c[1] - c[0];\n        }\n\n        h /= 6.0;\n\n        if (h < 0.0)\n        {\n            h += 1.0;\n        }\n    }\n\n    return vec3(h, s, v);\n}\n\nvec3 blender_hsv_to_rgb(vec3 hsv)\n{\n    float i, f, p, q, t, h, s, v;\n    vec3 rgb;\n\n    h = hsv[0];\n    s = hsv[1];\n    v = hsv[2];\n\n    if (s == 0.0)\n    {\n        rgb = vec3(v, v, v);\n    }\n    else\n    {\n        if (h == 1.0)\n        {\n            h = 0.0;\n        }\n\n        h *= 6.0;\n        i = floor(h);\n        f = h - i;\n        rgb = vec3(f, f, f);\n        p = v * (1.0 - s);\n        q = v * (1.0 - (s * f));\n        t = v * (1.0 - (s * (1.0 - f)));\n\n        if (i == 0.0)\n        {\n            rgb = vec3(v, t, p);\n        }\n        else if (i == 1.0)\n        {\n            rgb = vec3(q, v, p);\n        }\n        else if (i == 2.0)\n        {\n            rgb = vec3(p, v, t);\n        }\n        else if (i == 3.0)\n        {\n            rgb = vec3(p, q, v);\n        }\n        else if (i == 4.0)\n        {\n            rgb = vec3(t, p, v);\n        }\n        else\n        {\n            rgb = vec3(v, p, q);\n        }\n    }\n\n    return rgb;\n}\n\nvec3 blender_hue_sat(vec3 col, float hue, float sat, float value)\n{\n    vec3 hsv = blender_rgb_to_hsv(col);\n\n    hsv[0] = fract(hsv[0] + hue + 0.5);\n    hsv[1] = clamp(hsv[1] * sat, 0.0, 1.0);\n    hsv[2] = hsv[2] * value;\n\n    return blender_hsv_to_rgb(hsv);\n}\n\nfloat rgb_avg(vec3 inp)\n{\n    return (inp.x + inp.y + inp.z) / 3.0;\n}\n\nfloat rgb_sum(vec3 inp)\n{\n    return inp.x + inp.y + inp.z;\n}\n\nfloat rgb_max(vec3 inp)\n{\n    return max(max(inp.x, inp.y), inp.z);\n}\n\nfloat rgb_min(vec3 inp)\n{\n    return min(min(inp.x, inp.y), inp.z);\n}\n\nvec3 rgb_uniform_offset(vec3 inp, float black_point, float white_point)\n{\n    float mono = rgb_avg(inp);\n    float mono2 = map_range_clamp(mono, black_point / 1000.0, 1.0 - (white_point / 1000.0), 0.0, 1.0);\n    return inp * (mono2 / mono);\n}\n\nvec3 rgb_sweep(float hue)\n{\n    hue = wrap(hue * 360.0, 0.0, 360.0);\n\n    vec3 col = vec3(1, 0, 0);\n    col = mix(col, vec3(1, 1, 0), map_range_clamp(hue, 0.0, 60.0, 0.0, 1.0));\n    col = mix(col, vec3(0, 1, 0), map_range_clamp(hue, 60.0, 120.0, 0.0, 1.0));\n    col = mix(col, vec3(0, 1, 1), map_range_clamp(hue, 120.0, 180.0, 0.0, 1.0));\n    col = mix(col, vec3(0, 0, 1), map_range_clamp(hue, 180.0, 240.0, 0.0, 1.0));\n    col = mix(col, vec3(1, 0, 1), map_range_clamp(hue, 240.0, 300.0, 0.0, 1.0));\n    col = mix(col, vec3(1, 0, 0), map_range_clamp(hue, 300.0, 360.0, 0.0, 1.0));\n    \n    return col;\n}\n\n// -------------------------------\n\nvec3 flim_rgb_sweep(vec2 uv0to1)\n{\n    float hue = 1.0 - uv0to1.y;\n    float exposure = map_range(uv0to1.x, 0.0, 1.0, -5.0, 10.0);\n    return rgb_sweep(hue) * pow(2.0, exposure);\n}\n\n// https://www.desmos.com/calculator/khkztixyeu\nfloat flim_super_sigmoid(float inp, float toe_x, float toe_y, float shoulder_x, float shoulder_y)\n{\n    // Clip\n    inp = clamp(inp, 0.0, 1.0);\n    toe_x = clamp(toe_x, 0.0, 1.0);\n    toe_y = clamp(toe_y, 0.0, 1.0);\n    shoulder_x = clamp(shoulder_x, 0.0, 1.0);\n    shoulder_y = clamp(shoulder_y, 0.0, 1.0);\n\n    // Calculate straight line slope\n    float slope = (shoulder_y - toe_y) / (shoulder_x - toe_x);\n\n    // Toe\n    if (inp < toe_x)\n    {\n        float toe_pow = slope * toe_x / toe_y;\n        return toe_y * pow(inp / toe_x, toe_pow);\n    }\n\n    // Straight line\n    if (inp < shoulder_x)\n    {\n        float intercept = toe_y - (slope * toe_x);\n        return slope * inp + intercept;\n    }\n\n    // Shoulder\n    float shoulder_pow = -slope / (((shoulder_x - 1.0) / pow(1.0 - shoulder_x, 2.0)) * (1.0 - shoulder_y));\n    return (1.0 - pow(1.0 - (inp - shoulder_x) / (1.0 - shoulder_x), shoulder_pow)) * (1.0 - shoulder_y) + shoulder_y;\n}\n\nfloat flim_dye_mix_factor(float mono, float max_density)\n{\n    // log2 and map range\n    float offset = pow(2.0, flim_sigmoid_log2_min);\n    float fac = map_range_clamp(log2(mono + offset), flim_sigmoid_log2_min, flim_sigmoid_log2_max, 0.0, 1.0);\n\n    // Calculate amount of exposure from 0 to 1\n    fac = flim_super_sigmoid(fac, flim_sigmoid_toe_x, flim_sigmoid_toe_y, flim_sigmoid_shoulder_x, flim_sigmoid_shoulder_y);\n\n    // Calculate dye density\n    fac *= max_density;\n\n    // Mix factor\n    fac = pow(2.0, -fac);\n\n    // Clip and return\n    return clamp(fac, 0.0, 1.0);\n}\n\nvec3 flim_rgb_color_layer(vec3 inp, vec3 sensitivity_tone, vec3 dye_tone, float max_density)\n{\n    // Normalize\n    vec3 sensitivity_tone_norm = sensitivity_tone / rgb_sum(sensitivity_tone);\n    vec3 dye_tone_norm = dye_tone / rgb_max(dye_tone);\n\n    // Dye mix factor\n    float mono = dot(inp, sensitivity_tone_norm);\n    float mixFac = flim_dye_mix_factor(mono, max_density);\n\n    // Dye mixing\n    return lerp(dye_tone_norm, vec3(1.0), mixFac);\n}\n\nvec3 flim_rgb_develop(vec3 inp, float exposure, float max_density)\n{\n    // Exposure\n    inp *= pow(2.0, exposure);\n\n    // Blue-sensitive layer\n    vec3 result = flim_rgb_color_layer(inp, vec3(0, 0, 1), vec3(1, 1, 0), max_density);\n\n    // Green-sensitive layer\n    result *= flim_rgb_color_layer(inp, vec3(0, 1, 0), vec3(1, 0, 1), max_density);\n\n    // Red-sensitive layer\n    result *= flim_rgb_color_layer(inp, vec3(1, 0, 0), vec3(0, 1, 1), max_density);\n\n    return result;\n}\n\nvec3 flim_gamut_extension_mat_row(float primary_hue, float scale, float rotate, float mul)\n{\n    vec3 result = blender_hsv_to_rgb(vec3(wrap(primary_hue + (rotate / 360.0), 0.0, 1.0), 1.0 / scale, 1.0));\n    result /= rgb_sum(result);\n    result *= mul;\n    return result;\n}\n\nmat3 flim_gamut_extension_mat(\n    float red_scale,\n    float green_scale,\n    float blue_scale,\n    float red_rot,\n    float green_rot,\n    float blue_rot,\n    float red_mul,\n    float green_mul,\n    float blue_mul\n)\n{\n    mat3 m;\n    m[0] = flim_gamut_extension_mat_row(0.0, red_scale, red_rot, red_mul);\n    m[1] = flim_gamut_extension_mat_row(1.0 / 3.0, green_scale, green_rot, green_mul);\n    m[2] = flim_gamut_extension_mat_row(2.0 / 3.0, blue_scale, blue_rot, blue_mul);\n    return m;\n}\n\nvec3 negative_and_print(vec3 inp, vec3 backlight_ext)\n{\n    // Develop Negative\n    inp = flim_rgb_develop(inp, flim_negative_film_exposure, flim_negative_film_density);\n\n    // Backlight\n    inp *= backlight_ext;\n\n    // Develop Print\n    inp = flim_rgb_develop(inp, flim_print_film_exposure, flim_print_film_density);\n\n    return inp;\n}\n\nbool flim_load_matrices(sampler2D matrix_ch, out mat3 extend_mat, out mat3 extend_mat_inv)\n{\n    // W == valid_w means the matrices have been calculated\n    // in the source buffer.\n    const float valid_w = 2.0;\n\n    vec4 row;\n\n    // extend_mat\n    {\n        row = texelFetch(matrix_ch, ivec2(0, 0), 0);\n        if (row.w != valid_w)\n            return false;\n        extend_mat[0] = row.xyz;\n\n        row = texelFetch(matrix_ch, ivec2(1, 0), 0);\n        if (row.w != valid_w)\n            return false;\n        extend_mat[1] = row.xyz;\n\n        row = texelFetch(matrix_ch, ivec2(2, 0), 0);\n        if (row.w != valid_w)\n            return false;\n        extend_mat[2] = row.xyz;\n    }\n\n    // extend_mat_inv\n    {\n        row = texelFetch(matrix_ch, ivec2(3, 0), 0);\n        if (row.w != valid_w)\n            return false;\n        extend_mat_inv[0] = row.xyz;\n\n        row = texelFetch(matrix_ch, ivec2(4, 0), 0);\n        if (row.w != valid_w)\n            return false;\n        extend_mat_inv[1] = row.xyz;\n\n        row = texelFetch(matrix_ch, ivec2(5, 0), 0);\n        if (row.w != valid_w)\n            return false;\n        extend_mat_inv[2] = row.xyz;\n    }\n\n    return true;\n}\n\n// -------------------------------\n\n// matrix_ch: Which channel provides the buffer\n// containing gamut extension matrices?\nvec3 flim_transform(vec3 inp, float exposure, sampler2D matrix_ch)\n{\n    // Eliminate negative values\n    inp = max(inp, 0.0);\n\n    // Pre-Exposure\n    inp *= pow(2.0, flim_pre_exposure + exposure);\n\n    // Clip very large values for float precision reasons\n    inp = min(inp, 5000.0);\n\n    // Gamut Extension Matrix (Linear BT.709)\n    mat3 extend_mat, extend_mat_inv;\n    if (!flim_load_matrices(matrix_ch, extend_mat, extend_mat_inv))\n    {\n        return vec3(1, 0, 1);\n    }\n\n    // Backlight (extended gamut)\n    vec3 backlight_ext = flim_print_backlight * extend_mat;\n\n    // Upper limit in the print (highlight cap)\n    const float big = 10000000.0;\n    vec3 white_cap = negative_and_print(vec3(big, big, big), backlight_ext);\n\n    // Pre-Formation Filter\n    inp = lerp(inp, inp * flim_pre_formation_filter, flim_pre_formation_filter_strength);\n\n    // Convert to extended gamut\n    inp *= extend_mat;\n\n    // Negative & Print\n    inp = negative_and_print(inp, backlight_ext);\n\n    // Convert from extended gamut\n    inp *= extend_mat_inv;\n\n    // Eliminate negative values\n    inp = max(inp, 0.0);\n\n    // White cap\n    inp /= white_cap;\n\n    // Black cap\n    if (flim_black_point == -1.0) // -1 = auto\n    {\n        vec3 black_cap = negative_and_print(vec3(0.0), backlight_ext);\n        black_cap /= white_cap;\n        inp = rgb_uniform_offset(inp, rgb_avg(black_cap) * 1000.0, 0.0);\n    }\n    else\n    {\n        inp = rgb_uniform_offset(inp, flim_black_point, 0.0);\n    }\n\n    // Post-Formation Filter\n    inp = lerp(inp, inp * flim_post_formation_filter, flim_post_formation_filter_strength);\n\n    // Clip\n    inp = clamp(inp, 0.0, 1.0);\n\n    // Midtone Saturation\n    float mono = rgb_avg(inp);\n    float mixFac = (mono < 0.5) ? map_range_clamp(mono, 0.05, 0.5, 0.0, 1.0) : map_range_clamp(mono, 0.5, 0.95, 1.0, 0.0);\n    inp = lerp(inp, blender_hue_sat(inp, 0.5, flim_midtone_saturation, 1.0), mixFac);\n\n    // Clip\n    inp = clamp(inp, 0.0, 1.0);\n\n    // OETF (Gamma 2.2)\n    inp = pow(inp, vec3(1.0 / 2.2));\n\n    return inp;\n}\n\n/***********************************\n\nEnd of flim's implementation for Shadertoy Unit: Common\n\n***********************************/\n\n// ***********************************************\n// Source: https://www.shadertoy.com/view/WdSSRt\n// ***********************************************\n\n/* Usage Example:\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Initialize PRNG\n    eprng_init(fragCoord.xy / max(iResolution.x, iResolution.y), iTime);\n\n    // Using the function:\n    float a = random();\n    vec3 b = vec3(random(), random(), random());\n    \n    ...\n}\n\n*/\n\nuint eprng_state[2];\n\nuint eprng_rot(uint x, int k)\n{\n    return (x << k) | (x >> (32 - k));\n}\n\nfloat random()\n{\n    uint s0 = eprng_state[0];\n    uint s1 = eprng_state[1];\n    uint result = eprng_rot(s0 * 0x9e3779bbu, 5) * 5u;\n    s1 ^= s0;\n    eprng_state[0] = eprng_rot(s0, 26) ^ s1 ^ (s1 << 9);\n    eprng_state[1] = eprng_rot(s1, 13);\n    // Not sure this is actually the best way to get evenly-distributed floats -\n    // precision will be lost converting from int to float, but how much depends on the order of magnitude\n    // I could use bit magic to build the bits of a float directly, then use uintBitsToFloat,\n    // but that also loses precision - just in a different way.\n    // I guess precision loss is inevitable, since if we want floats in the range 0.0 <= r <= 1.0 then\n    // there's only so many bits to work with. It's just a matter of how they're distributed.\n    return float(result) / float(0xffffffffu);\n}\n\nvoid eprng_init(vec2 uv, float iTime)\n{\n    uv *= (iTime + 10.258);\n\n    eprng_state[0] = floatBitsToUint(uv.x);\n    eprng_state[1] = floatBitsToUint(uv.y);\n\n    random();\n}\n\n// ***********************************************\n// End\n// ***********************************************\n",
     "name": "Common",
     "description": "",
     "type": "common"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4sXGR8",
       "filepath": "/media/previz/buffer02.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "// iChannel0 = Buffer A (self-feeding)\n// iChannel1 = Buffer C\n\nfloat wave_initial_val(ivec3 icoord)\n{\n    return 0.0;\n}\n\nfloat wave_update_val(ivec3 icoord, float curr, float sim_time)\n{\n    // Initial pulse at the center\n    if (icoord == wave_res / 2)\n    {\n        float amp = map_range_clamp(sim_time, 0.0, 0.006, 1.0, 0.0);\n        float freq = 0.95 * wave_max_frequency;\n        if (amp > 0.001)\n        {\n            return amp * sin(TWO_PI * sim_time * freq);\n        }\n    }\n\n    return curr;\n}\n\nfloat wave_fetch_curr(ivec3 icoord)\n{\n    //if (!icoord_in_bounds(icoord, wave_res))\n    //    return 0.0;\n    \n    // Disabled bounds checking because below we\n    // do manual bounds checking ONLY on the axis\n    // needed, reducing the overall number of\n    // checks.\n    \n    return texelFetch(iChannel0, icoord3d_to_2d(icoord, wave_res, ivec2(iResolution.xy)), 0).x;\n}\n\n// X = current value\n// Y = previous value\n// Z = iteration\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    ivec3 icoord = icoord2d_to_3d(ivec2(frag_coord), ivec2(iResolution.xy), wave_res);\n\n    // Skip if we're outside the grid\n    if (!icoord_in_bounds(icoord, wave_res))\n        return;\n\n    vec4 data = texelFetch(iChannel0, icoord3d_to_2d(icoord, wave_res, ivec2(iResolution.xy)), 0);\n    float curr = data.x;\n    float prev = data.y;\n    int iter = int(data.z);\n\n    // First frame (initial values)\n    bool reset =\n        iter == 0\n        || iFrame < 1\n        || iTime == 0.0\n        || ivec2(iResolution.xy) != ivec2(texelFetch(iChannel1, ivec2(0), 0).xy);\n    if (reset)\n    {\n        float v = wave_initial_val(icoord);\n        frag_col = vec4(v, v, 1.0, 0.0);\n        return;\n    }\n\n    float next_in_x = 0.0;\n    float prev_in_x = 0.0;\n    float next_in_y = 0.0;\n    float prev_in_y = 0.0;\n    float next_in_z = 0.0;\n    float prev_in_z = 0.0;\n    if ((icoord.x + 1) < wave_res.x)\n    {\n        next_in_x = wave_fetch_curr(icoord + ivec3(1, 0, 0));\n    }\n    if ((icoord.x - 1) >= 0)\n    {\n        prev_in_x = wave_fetch_curr(icoord + ivec3(-1, 0, 0));\n    }\n    if ((icoord.y + 1) < wave_res.y)\n    {\n        next_in_y = wave_fetch_curr(icoord + ivec3(0, 1, 0));\n    }\n    if ((icoord.y - 1) >= 0)\n    {\n        prev_in_y = wave_fetch_curr(icoord + ivec3(0, -1, 0));\n    }\n    if ((icoord.z + 1) < wave_res.z)\n    {\n        next_in_z = wave_fetch_curr(icoord + ivec3(0, 0, 1));\n    }\n    if ((icoord.z - 1) >= 0)\n    {\n        prev_in_z = wave_fetch_curr(icoord + ivec3(0, 0, -1));\n    }\n\n    float grad_x = next_in_x - curr - curr + prev_in_x;\n    float grad_y = next_in_y - curr - curr + prev_in_y;\n    float grad_z = next_in_z - curr - curr + prev_in_z;\n\n    float acc = (grad_x + grad_y + grad_z) * wave_speed2 / wave_step2;\n    float vel = (curr - prev) / wave_dt;\n    vel += (acc * wave_dt);\n    vel *= pow(wave_stiffness, -wave_dt);\n\n    prev = curr;\n    curr += (vel * wave_dt);\n\n    float sim_time = wave_dt * float(iter);\n    curr = wave_update_val(icoord, curr, sim_time);\n\n    frag_col = vec4(curr, prev, float(iter + 1), 0.0);\n}\n",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "XsXGR8",
       "channel": 0
      }
     ],
     "code": "/***********************************\n\nflim - Filmic Color Transform\n\nInput Color Space:   Linear BT.709 I-D65\nOutput Color Space:  sRGB 2.2\n\nShadertoy Unit:\n  Buffer X\n\nDescription:\n  Experimental port of flim for GLSL/Shadertoy\n  matching flim v1.1.0.\n  The buffer unit performs a one-time calculation\n  of flim's gamut extension matrices.\n\nAuthor:\n  Bean (beans_please on Shadertoy)\n\nOriginal Repo:\n  https://github.com/bean-mhm/flim\n\nOriginal Shader:\n  https://www.shadertoy.com/view/dd2yDz\n\n***********************************/\n\n// NOTE:\n// iChannel0 must be set to this buffer (self-feeding).\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // W == valid_w means the matrices have already been calculated.\n    const float valid_w = 2.0;\n\n    // We only care about the first 6 pixels\n    if (ivec2(fragCoord).x > 5 || ivec2(fragCoord).y > 0)\n        return;\n\n    // Previous frame's value\n    vec4 prev = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    fragColor = prev;\n\n    // Do we need to recalculate the matrices?\n    bool needToCalc = (prev.w != valid_w) || (iTime == 0.0) || (iFrame < 1);\n    if (!needToCalc)\n        return;\n\n    // (Re)calculate the matrices\n    mat3 extend_mat = flim_gamut_extension_mat(flim_extended_gamut_red_scale, flim_extended_gamut_green_scale, flim_extended_gamut_blue_scale, flim_extended_gamut_red_rot, flim_extended_gamut_green_rot, flim_extended_gamut_blue_rot, flim_extended_gamut_red_mul, flim_extended_gamut_green_mul, flim_extended_gamut_blue_mul);\n    mat3 extend_mat_inv = inverse(extend_mat);\n\n    // extend_mat\n    {\n        if (ivec2(fragCoord) == ivec2(0, 0))\n        {\n            fragColor = vec4(extend_mat[0], valid_w);\n        }\n        if (ivec2(fragCoord) == ivec2(1, 0))\n        {\n            fragColor = vec4(extend_mat[1], valid_w);\n        }\n        if (ivec2(fragCoord) == ivec2(2, 0))\n        {\n            fragColor = vec4(extend_mat[2], valid_w);\n        }\n    }\n\n    // extend_mat_inv\n    {\n        if (ivec2(fragCoord) == ivec2(3, 0))\n        {\n            fragColor = vec4(extend_mat_inv[0], valid_w);\n        }\n        if (ivec2(fragCoord) == ivec2(4, 0))\n        {\n            fragColor = vec4(extend_mat_inv[1], valid_w);\n        }\n        if (ivec2(fragCoord) == ivec2(5, 0))\n        {\n            fragColor = vec4(extend_mat_inv[2], valid_w);\n        }\n    }\n}\n\n/***********************************\n\nEnd of flim's implementation for Shadertoy Unit: Buffer X\n\n***********************************/\n",
     "name": "Buffer B",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4sXGR8",
       "channel": 0
      }
     ],
     "code": "void mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    frag_col = vec4(iResolution.xy, 1.0, 1.0);\n}\n",
     "name": "Buffer C",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "csjfDh",
    "date": "1689671017",
    "viewed": 190,
    "name": "2D Occlusion Test",
    "description": "Drag to move the middle circle",
    "likes": 5,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "2d",
     "sdf",
     "shadows",
     "occlusion"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "vec2 screen_to_world(vec2 coord)\n{\n    vec2 v = (2.0 * coord - iResolution.xy) / min(iResolution.x, iResolution.y);\n    v *= 5.0;\n    return v;\n}\n\nfloat sd_scene(vec2 p)\n{\n    vec2 circ1_pos = vec2(0.0);\n    if (iMouse.z > 0.0)\n        circ1_pos = screen_to_world(iMouse.xy);\n    \n    vec2 circ2_pos = vec2(4.5 + sin(TAU * 0.6 * iTime) * 0.25, cos(TAU * 0.22 * iTime) * 2.0);\n    vec2 circ3_pos = vec2(-4.5 - cos(TAU * 0.6 * iTime) * 0.25, cos(TAU * 0.22 * iTime + PI) * 2.0);\n\n    float d = 10000000.0;\n    #if 1\n    d = min(d, distance(p, circ1_pos) - 1.0);\n    d = min(d, distance(p, circ2_pos) - 0.7);\n    d = min(d, distance(p, circ3_pos) - 0.7);\n    #else\n    d = min(d, distance_alt(p, circ1_pos) - 1.0);\n    d = min(d, distance_alt(p, circ2_pos) - 0.7);\n    d = min(d, distance_alt(p, circ3_pos) - 0.7);\n    #endif\n    return d;\n}\n\nbool march(vec2 ro, vec2 rd)\n{\n    // Constants\n    const int max_steps = 100;\n    const float max_dist = 100.0;\n    const float hit_thres = 0.005;\n    \n    // March\n    float sd = 1.0;\n    float traveled = 0.0;\n    for (int i = 0; i < max_steps; i++)\n    {\n        // Get SD\n        sd = sd_scene(ro);\n        \n        // Are we inside an object?\n        if (sd < 0.0)\n            break;\n        \n        // Move forward\n        ro += rd * sd;\n        traveled += sd;\n        \n        // Did we hit something?\n        if (sd < hit_thres)\n            break;\n        \n        // Did we go too far?\n        if (traveled > max_dist)\n            break;\n    }\n    \n    return (sd < hit_thres);\n}\n\nvoid mainImage( out vec4 frag_color, in vec2 frag_coord )\n{\n    // Initialize PRNG\n    eprng_init(frag_coord.xy / max(iResolution.x, iResolution.y), iTime);\n\n    // Calculate occlusion\n    const int num_angles = 100;\n    float v = 0.0;\n    for (int i = 0; i < num_angles; i++)\n    {\n        // Ray origin\n        vec2 ro = screen_to_world(frag_coord + vec2(random(), random()) - 0.5);\n    \n        // Ray direction\n        #if 1\n        float angle = TAU * random();\n        vec2 rd = vec2(cos(angle), sin(angle));\n        #else\n        float angle = random();\n        vec2 rd = vec2(cos_alt_use_t(angle), sin_alt_use_t(angle));\n        #endif\n        \n        // March\n        if (!march(ro, rd)) v += 1.0;\n    }\n    v /= float(num_angles);\n    \n    // Colorize\n    v = clamp(v * v * 1.15, 0.0, 1.0);\n    vec3 col = mix(vec3(0.7, 0.03, 0.02), vec3(1.0, 0.95, 0.75), v);\n    \n    // Output\n    col = pow(col, vec3(1.0 / 2.2));\n    frag_color = vec4(col,1.0);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "#define PI 3.1415926535897932384626433832795\n#define TAU 6.283185307179586476925286766559\n\n// Not faster than built-in functions\n// t = angle_in_radians / tau\nfloat cos_alt_use_t(float t)\n{\n    t = fract(t);\n    t -= .25 + floor(t + .25);\n    t *= 16. * (abs(t) - 0.5);\n    #if 1\n    t += .225 * t * (abs(t) - 1.);\n    #endif\n    return t;\n}\nfloat sin_alt_use_t(float t)\n{\n    return cos_alt_use_t(t - 0.25);\n}\n\n// Not faster than built-in functions,\n// I'm just experimenting\nfloat distance_alt(vec2 a, vec2 b)\n{\n    a -= b;\n    return intBitsToFloat(0x1fbb4000 + (floatBitsToInt(a.x*a.x+a.y*a.y) >> 1));  \n}\n\n\n\n// ***********************************************\n// PRNG\n// Source: https://www.shadertoy.com/view/WdSSRt\n// ***********************************************\n\n/* Usage Example:\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Initialize PRNG\n    eprng_init(fragCoord.xy / max(iResolution.x, iResolution.y), iTime);\n\n    // Using the function:\n    float a = random();\n    vec3 b = vec3(random(), random(), random());\n    \n    ...\n}\n\n*/\n\nuint eprng_state[2];\n\nuint eprng_rot(uint x, int k)\n{\n    return (x << k) | (x >> (32 - k));\n}\n\nfloat random()\n{\n    uint s0 = eprng_state[0];\n    uint s1 = eprng_state[1];\n    uint result = eprng_rot(s0 * 0x9e3779bbu, 5) * 5u;\n    s1 ^= s0;\n    eprng_state[0] = eprng_rot(s0, 26) ^ s1 ^ (s1 << 9);\n    eprng_state[1] = eprng_rot(s1, 13);\n    // Not sure this is actually the best way to get evenly-distributed floats -\n    // precision will be lost converting from int to float, but how much depends on the order of magnitude\n    // I could use bit magic to build the bits of a float directly, then use uintBitsToFloat,\n    // but that also loses precision - just in a different way.\n    // I guess precision loss is inevitable, since if we want floats in the range 0.0 <= r <= 1.0 then\n    // there's only so many bits to work with. It's just a matter of how they're distributed.\n    return float(result) / float(0xffffffffu);\n}\n\nvoid eprng_init(vec2 uv, float iTime)\n{\n    uv *= (iTime + 10.258);\n\n    eprng_state[0] = floatBitsToUint(uv.x);\n    eprng_state[1] = floatBitsToUint(uv.y);\n\n    random();\n}\n\n// ***********************************************\n// End\n// ***********************************************\n",
     "name": "Common",
     "description": "",
     "type": "common"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "cdjfRc",
    "date": "1689964097",
    "viewed": 82,
    "name": "Deprecated,Bean's Default Shader",
    "description": "- My starting point for a new shader.\n\n- Helper \"modules\" can be enabled/disabled separately in the Common tab.\n\n- Each tab starts with a description of itself to make it easier to store local backups.\n\n- Feel free to copy and reuse.  :)",
    "likes": 2,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "default",
     "shader",
     "utils",
     "helpers"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "/* -----------------------------------------------\n  Shadertoy Unit: Image\n  Description: None\n  iChannel0: None\n  iChannel1: None\n  iChannel2: None\n  iChannel3: None\n----------------------------------------------- */\n\nvec2 screen_to_uv(vec2 coord)\n{\n    return (2.0 * coord - iResolution.xy) / min(iResolution.x, iResolution.y);\n}\n\nvec3 view_transform(vec3 col)\n{\n\t// OETF (Gamma)\n    return pow(col, vec3(1.0 / 2.2));\n}\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    // Initialize PRNG\n    prng_init(vec3(frag_coord / iResolution.y, iTime));\n    \n    // UV\n    vec2 uv = screen_to_uv(frag_coord);\n    \n    // Render\n    vec3 col = vec3(uv, 0.0) + 0.1 * random();\n    \n    // Output\n    col = view_transform(col);\n    frag_col = vec4(col, 1.0);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "/* -----------------------------------------------\n  Shadertoy Unit: Common\n----------------------------------------------- */\n\n\n\n// -----------------------------------------------\n// What to define\n// -----------------------------------------------\n\n/* Math Utils */\n#define MATH_UTILS 1\n\n/* Pseudo-Random Number Generator */\n#define PRNG 1\n\n/* Color Utils (requires MATH_UTILS) */\n#define COLOR_UTILS 0\n\n/* Keyboard Utils */\n#define KEYBOARD_UTILS 0\n\n// -----------------------------------------------\n// End\n// -----------------------------------------------\n\n\n\n// -----------------------------------------------\n// Math Utils\n// -----------------------------------------------\n\n#if MATH_UTILS\n\n#define PI 3.1415926535897932384626433832\n#define TAU 6.283185307179586476925286766\n#define PI_OVER_2 1.57079632679489661923132169163\n#define DEG_TO_RAD 0.01745329251994329576923690768\n#define RAD_TO_DEG 57.2957795130823208767981548141\n\n#define FUNC_LERP(T) \\\nT lerp(T a, T b, float t) \\\n{ \\\n    return a + t*(b-a); \\\n}\n\n#define FUNC_WRAP(T) \\\nT wrap(T inp, float start, float end) \\\n{ \\\n    return start + mod(inp - start, end - start); \\\n}\n\n#define FUNC_MAP_RANGE(T) \\\nT map_range(T inp, float inp_start, float inp_end, float out_start, float out_end) \\\n{ \\\n    return out_start + ((out_end - out_start) / (inp_end - inp_start)) * (inp - inp_start); \\\n}\n\n#define FUNC_MAP_RANGE_CLAMP(T) \\\nT map_range_clamp(T inp, float inp_start, float inp_end, float out_start, float out_end) \\\n{ \\\n    T t = clamp((inp - inp_start) / (inp_end - inp_start), 0.0, 1.0); \\\n    return out_start + t * (out_end - out_start); \\\n}\n\nFUNC_LERP(float)\nFUNC_LERP(vec2)\nFUNC_LERP(vec3)\nFUNC_LERP(vec4)\n\nFUNC_WRAP(float)\nFUNC_WRAP(vec2)\nFUNC_WRAP(vec3)\nFUNC_WRAP(vec4)\n\nFUNC_MAP_RANGE(float)\nFUNC_MAP_RANGE(vec2)\nFUNC_MAP_RANGE(vec3)\nFUNC_MAP_RANGE(vec4)\n\nFUNC_MAP_RANGE_CLAMP(float)\nFUNC_MAP_RANGE_CLAMP(vec2)\nFUNC_MAP_RANGE_CLAMP(vec3)\nFUNC_MAP_RANGE_CLAMP(vec4)\n\n#endif\n\n// -----------------------------------------------\n// End\n// -----------------------------------------------\n\n\n\n// -----------------------------------------------\n// Pseudo-Random Number Generator\n// Source: https://www.shadertoy.com/view/WdSSRt\n// -----------------------------------------------\n\n/* Usage Example:\n    void mainImage(out vec4 frag_col, in vec2 frag_coord)\n    {\n        // Initialize PRNG\n        prng_init(vec3(frag_coord / iResolution.y, iTime));\n    \n        // Using the function\n        float a = random();\n        vec3 b = vec3(random(), random(), random());\n        \n        ...\n    }\n*/\n\n#if PRNG\n\nuint prng_state[2];\n\nuint prng_rot(uint x, int k)\n{\n    return (x << k) | (x >> (32 - k));\n}\n\nfloat random()\n{\n    uint s0 = prng_state[0];\n    uint s1 = prng_state[1];\n    uint result = prng_rot(s0 * 0x9e3779bbu, 5) * 5u;\n    s1 ^= s0;\n    prng_state[0] = prng_rot(s0, 26) ^ s1 ^ (s1 << 9);\n    prng_state[1] = prng_rot(s1, 13);\n    return float(result) / float(0xffffffffu);\n}\n\nvoid prng_init(vec3 seed)\n{\n    seed.xy *= (seed.z + 10.258);\n    seed += 3.49276101561702;\n    prng_state[0] = floatBitsToUint(seed.x);\n    prng_state[1] = floatBitsToUint(seed.y);\n    random();\n}\n\n#endif\n\n// -----------------------------------------------\n// End\n// -----------------------------------------------\n\n\n\n// -----------------------------------------------\n// Color Utils (requires MATH_UTILS)\n// -----------------------------------------------\n\n#if COLOR_UTILS\n\nconst vec3 lum_linear_bt709 = vec3(0.2126, 0.7152, 0.0722);\n\nvec3 blender_rgb_to_hsv(vec3 rgb)\n{\n    float cmax, cmin, h, s, v, cdelta;\n    vec3 c;\n\n    cmax = max(rgb[0], max(rgb[1], rgb[2]));\n    cmin = min(rgb[0], min(rgb[1], rgb[2]));\n    cdelta = cmax - cmin;\n\n    v = cmax;\n    if (cmax != 0.0)\n    {\n        s = cdelta / cmax;\n    }\n    else\n    {\n        s = 0.0;\n        h = 0.0;\n    }\n\n    if (s == 0.0)\n    {\n        h = 0.0;\n    }\n    else\n    {\n        c = (vec3(cmax) - rgb.xyz) / cdelta;\n\n        if (rgb.x == cmax)\n        {\n            h = c[2] - c[1];\n        }\n        else if (rgb.y == cmax)\n        {\n            h = 2.0 + c[0] - c[2];\n        }\n        else\n        {\n            h = 4.0 + c[1] - c[0];\n        }\n\n        h /= 6.0;\n\n        if (h < 0.0)\n        {\n            h += 1.0;\n        }\n    }\n\n    return vec3(h, s, v);\n}\n\nvec3 blender_hsv_to_rgb(vec3 hsv)\n{\n    float i, f, p, q, t, h, s, v;\n    vec3 rgb;\n\n    h = hsv[0];\n    s = hsv[1];\n    v = hsv[2];\n\n    if (s == 0.0)\n    {\n        rgb = vec3(v, v, v);\n    }\n    else\n    {\n        if (h == 1.0)\n        {\n            h = 0.0;\n        }\n\n        h *= 6.0;\n        i = floor(h);\n        f = h - i;\n        rgb = vec3(f, f, f);\n        p = v * (1.0 - s);\n        q = v * (1.0 - (s * f));\n        t = v * (1.0 - (s * (1.0 - f)));\n\n        if (i == 0.0)\n        {\n            rgb = vec3(v, t, p);\n        }\n        else if (i == 1.0)\n        {\n            rgb = vec3(q, v, p);\n        }\n        else if (i == 2.0)\n        {\n            rgb = vec3(p, v, t);\n        }\n        else if (i == 3.0)\n        {\n            rgb = vec3(p, q, v);\n        }\n        else if (i == 4.0)\n        {\n            rgb = vec3(t, p, v);\n        }\n        else\n        {\n            rgb = vec3(v, p, q);\n        }\n    }\n\n    return rgb;\n}\n\nvec3 blender_hue_sat(vec3 col, float hue, float sat, float value)\n{\n    vec3 hsv = blender_rgb_to_hsv(col);\n\n    hsv[0] = fract(hsv[0] + hue + 0.5);\n    hsv[1] = clamp(hsv[1] * sat, 0.0, 1.0);\n    hsv[2] = hsv[2] * value;\n\n    return blender_hsv_to_rgb(hsv);\n}\n\nfloat rgb_avg(vec3 inp)\n{\n    return (inp.x + inp.y + inp.z) / 3.0;\n}\n\nfloat rgb_sum(vec3 inp)\n{\n    return inp.x + inp.y + inp.z;\n}\n\nfloat rgb_max(vec3 inp)\n{\n    return max(max(inp.x, inp.y), inp.z);\n}\n\nfloat rgb_min(vec3 inp)\n{\n    return min(min(inp.x, inp.y), inp.z);\n}\n\nvec3 rgb_sweep(float hue)\n{\n    hue = wrap(hue * 360.0, 0.0, 360.0);\n\n    vec3 col = vec3(1, 0, 0);\n    col = mix(col, vec3(1, 1, 0), map_range_clamp(hue, 0.0, 60.0, 0.0, 1.0));\n    col = mix(col, vec3(0, 1, 0), map_range_clamp(hue, 60.0, 120.0, 0.0, 1.0));\n    col = mix(col, vec3(0, 1, 1), map_range_clamp(hue, 120.0, 180.0, 0.0, 1.0));\n    col = mix(col, vec3(0, 0, 1), map_range_clamp(hue, 180.0, 240.0, 0.0, 1.0));\n    col = mix(col, vec3(1, 0, 1), map_range_clamp(hue, 240.0, 300.0, 0.0, 1.0));\n    col = mix(col, vec3(1, 0, 0), map_range_clamp(hue, 300.0, 360.0, 0.0, 1.0));\n    \n    return col;\n}\n\nfloat rgb_variance(vec3 a, vec3 b)\n{\n    a = max(a, 0.0);\n    b = max(b, 0.0);\n    \n    a += 0.001;\n    b += 0.001;\n    \n    float v = dot(abs(log2(a / b)), vec3(0.3, 0.59, 0.11));\n    return v*v;\n}\n\n#endif\n\n// -----------------------------------------------\n// End\n// -----------------------------------------------\n\n\n\n// -----------------------------------------------\n// Keyboard Utils\n// -----------------------------------------------\n\n#if KEYBOARD_UTILS\n\n#define KEY_BACKSPACE 8\n#define KEY_TAB 9\n#define KEY_ENTER 13\n#define KEY_SHIFT 16\n#define KEY_CTRL 17\n#define KEY_ALT 18\n#define KEY_PAUSE_BREAK 19\n#define KEY_CAPS_LOCK 20\n#define KEY_ESC 27\n#define KEY_SPACE 32\n#define KEY_PAGE_UP 33\n#define KEY_PAGE_DOWN 34\n#define KEY_END 35\n#define KEY_HOME 36\n#define KEY_LEFT 37\n#define KEY_UP 38\n#define KEY_RIGHT 39\n#define KEY_DOWN 40\n#define KEY_PRINT_SCREEN 44\n#define KEY_INSERT 45\n#define KEY_DELETE 46\n#define KEY_0 48\n#define KEY_1 49\n#define KEY_2 50\n#define KEY_3 51\n#define KEY_4 52\n#define KEY_5 53\n#define KEY_6 54\n#define KEY_7 55\n#define KEY_8 56\n#define KEY_9 57\n#define KEY_A 65\n#define KEY_B 66\n#define KEY_C 67\n#define KEY_D 68\n#define KEY_E 69\n#define KEY_F 70\n#define KEY_G 71\n#define KEY_H 72\n#define KEY_I 73\n#define KEY_J 74\n#define KEY_K 75\n#define KEY_L 76\n#define KEY_M 77\n#define KEY_N 78\n#define KEY_O 79\n#define KEY_P 80\n#define KEY_Q 81\n#define KEY_R 82\n#define KEY_S 83\n#define KEY_T 84\n#define KEY_U 85\n#define KEY_V 86\n#define KEY_W 87\n#define KEY_X 88\n#define KEY_Y 89\n#define KEY_Z 90\n#define KEY_LWIN 91\n#define KEY_RWIN 92\n#define KEY_POPUP 93\n#define KEY_NUMPAD_0 96\n#define KEY_NUMPAD_1 97\n#define KEY_NUMPAD_2 98\n#define KEY_NUMPAD_3 99\n#define KEY_NUMPAD_4 100\n#define KEY_NUMPAD_5 101\n#define KEY_NUMPAD_6 102\n#define KEY_NUMPAD_7 103\n#define KEY_NUMPAD_8 104\n#define KEY_NUMPAD_9 105\n#define KEY_NUMPAD_ASTERISK 106 \n#define KEY_NUMPAD_PLUS 107\n#define KEY_NUMPAD_MINUS 109\n#define KEY_NUMPAD_PERIOD 110\n#define KEY_NUMPAD_SLASH 111\n#define KEY_F1 112\n#define KEY_F2 113\n#define KEY_F3 114\n#define KEY_F4 115\n#define KEY_F5 116\n#define KEY_F6 117\n#define KEY_F7 118\n#define KEY_F8 119\n#define KEY_F9 120\n#define KEY_F10 121\n#define KEY_F11 122\n#define KEY_F12 123\n#define KEY_NUM_LOCK 144\n#define KEY_SCROLL_LOCK 145\n#define KEY_LSHIFT 160\n#define KEY_RSHIFT 161\n#define KEY_LCTRL 162\n#define KEY_RCTRL 163\n\nbool key_is_down(int key, sampler2D keyboard_channel)\n{\n    return texelFetch(keyboard_channel, ivec2(key, 0), 0).x != 0.0;\n}\n\nbool key_got_pressed(int key, sampler2D keyboard_channel)\n{\n    return texelFetch(keyboard_channel, ivec2(key, 1), 0).x != 0.0;\n}\n\nbool key_toggle_state(int key, sampler2D keyboard_channel)\n{\n    return texelFetch(keyboard_channel, ivec2(key, 2), 0).x != 0.0;\n}\n\nfloat fkey_is_down(int key, sampler2D keyboard_channel)\n{\n    return key_is_down(key, keyboard_channel) ? 1.0 : 0.0;\n}\n\nfloat fkey_got_pressed(int key, sampler2D keyboard_channel)\n{\n    return key_got_pressed(key, keyboard_channel) ? 1.0 : 0.0;\n}\n\nfloat fkey_toggle_state(int key, sampler2D keyboard_channel)\n{\n    return key_toggle_state(key, keyboard_channel) ? 1.0 : 0.0;\n}\n\n#endif\n\n// -----------------------------------------------\n// End\n// -----------------------------------------------\n",
     "name": "Common",
     "description": "",
     "type": "common"
    },
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "/* -----------------------------------------------\n  Shadertoy Unit: Buffer A\n  Description: None\n  iChannel0: None\n  iChannel1: None\n  iChannel2: None\n  iChannel3: None\n----------------------------------------------- */\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{}\n",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "dsjBDy",
    "date": "1690140863",
    "viewed": 494,
    "name": "2D Fourier Transform",
    "description": "(Not so fast) 2D Fourier Transform implemented in glsl\n\n- Enable fft_preview_input in the Common tab to see the input shapes.\n\n- You can also change the FFT resolution in the Common tab.",
    "likes": 3,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "2d",
     "fft",
     "experiment"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "/* -----------------------------------------------\n  Shadertoy Unit: Image\n  Description: None\n  iChannel0: Buffer A\n  iChannel1: None\n  iChannel2: None\n  iChannel3: None\n----------------------------------------------- */\n\nvec2 screen_to_uv(vec2 coord)\n{\n    return (2.0 * coord - iResolution.xy) / min(iResolution.x, iResolution.y);\n}\n\nvec3 view_transform(vec3 col)\n{\n\t// OETF (Gamma)\n    return pow(col, vec3(1.0 / 2.5));\n}\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    // UV\n    vec2 uv = screen_to_uv(frag_coord);\n    \n    // Render\n    vec3 col = vec3(0.0);\n    if (max(abs(uv.x), abs(uv.y)) < 1.0)\n    {\n        col = texture(iChannel0, vec2(uv * 0.5 + 0.5) * vec2(fft_res) / iResolution.xy).rgb;\n        \n        vec3 tint = rgb_sweep(iTime * 0.14) + 0.03;\n        tint /= dot(tint, vec3(0.3, 0.59, 0.12));\n        col *= tint;\n    }\n    else\n    {\n        col = vec3(0);\n        //col = vec3(0.005, 0.01, 0.02);\n    }\n    \n    // Output\n    col = view_transform(col);\n    frag_col = vec4(col, 1.0);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "/* -----------------------------------------------\n  Shadertoy Unit: Common\n----------------------------------------------- */\n\nconst ivec2 fft_res = ivec2(185);\nconst bool fft_preview_input = bool(0);\nconst float fft_mul = 50.0 / float(fft_res.x * fft_res.y);\n\n\n\n// -----------------------------------------------\n// What to define\n// -----------------------------------------------\n\n/* Math Utils */\n#define MATH_UTILS 1\n\n/* Pseudo-Random Number Generator */\n#define PRNG 0\n\n/* Color Utils (requires MATH_UTILS) */\n#define COLOR_UTILS 1\n\n/* Keyboard Utils */\n#define KEYBOARD_UTILS 0\n\n// -----------------------------------------------\n// End\n// -----------------------------------------------\n\n\n\n// -----------------------------------------------\n// Math Utils\n// -----------------------------------------------\n\n#if MATH_UTILS\n\n#define PI 3.1415926535897932384626433832\n#define TAU 6.283185307179586476925286766\n#define PI_OVER_2 1.57079632679489661923132169163\n#define DEG_TO_RAD 0.01745329251994329576923690768\n#define RAD_TO_DEG 57.2957795130823208767981548141\n\n#define FUNC_LERP(T) \\\nT lerp(T a, T b, float t) \\\n{ \\\n    return a + t*(b-a); \\\n}\n\n#define FUNC_WRAP(T) \\\nT wrap(T inp, float start, float end) \\\n{ \\\n    return start + mod(inp - start, end - start); \\\n}\n\n#define FUNC_MAP_RANGE(T) \\\nT map_range(T inp, float inp_start, float inp_end, float out_start, float out_end) \\\n{ \\\n    return out_start + ((out_end - out_start) / (inp_end - inp_start)) * (inp - inp_start); \\\n}\n\n#define FUNC_MAP_RANGE_CLAMP(T) \\\nT map_range_clamp(T inp, float inp_start, float inp_end, float out_start, float out_end) \\\n{ \\\n    T t = clamp((inp - inp_start) / (inp_end - inp_start), 0.0, 1.0); \\\n    return out_start + t * (out_end - out_start); \\\n}\n\nFUNC_LERP(float)\nFUNC_LERP(vec2)\nFUNC_LERP(vec3)\nFUNC_LERP(vec4)\n\nFUNC_WRAP(float)\nFUNC_WRAP(vec2)\nFUNC_WRAP(vec3)\nFUNC_WRAP(vec4)\n\nFUNC_MAP_RANGE(float)\nFUNC_MAP_RANGE(vec2)\nFUNC_MAP_RANGE(vec3)\nFUNC_MAP_RANGE(vec4)\n\nFUNC_MAP_RANGE_CLAMP(float)\nFUNC_MAP_RANGE_CLAMP(vec2)\nFUNC_MAP_RANGE_CLAMP(vec3)\nFUNC_MAP_RANGE_CLAMP(vec4)\n\n#endif\n\n// -----------------------------------------------\n// End\n// -----------------------------------------------\n\n\n\n// -----------------------------------------------\n// Pseudo-Random Number Generator\n// Source: https://www.shadertoy.com/view/WdSSRt\n// -----------------------------------------------\n\n/* Usage Example:\n    void mainImage(out vec4 frag_col, in vec2 frag_coord)\n    {\n        // Initialize PRNG\n        prng_init(vec3(frag_coord / iResolution.y, iTime));\n    \n        // Using the function\n        float a = random();\n        vec3 b = vec3(random(), random(), random());\n        \n        ...\n    }\n*/\n\n#if PRNG\n\nuint prng_state[2];\n\nuint prng_rot(uint x, int k)\n{\n    return (x << k) | (x >> (32 - k));\n}\n\nfloat random()\n{\n    uint s0 = prng_state[0];\n    uint s1 = prng_state[1];\n    uint result = prng_rot(s0 * 0x9e3779bbu, 5) * 5u;\n    s1 ^= s0;\n    prng_state[0] = prng_rot(s0, 26) ^ s1 ^ (s1 << 9);\n    prng_state[1] = prng_rot(s1, 13);\n    return float(result) / float(0xffffffffu);\n}\n\nvoid prng_init(vec3 seed)\n{\n    seed.xy *= (seed.z + 10.258);\n    seed += 3.49276101561702;\n    prng_state[0] = floatBitsToUint(seed.x);\n    prng_state[1] = floatBitsToUint(seed.y);\n    random();\n}\n\n#endif\n\n// -----------------------------------------------\n// End\n// -----------------------------------------------\n\n\n\n// -----------------------------------------------\n// Color Utils (requires MATH_UTILS)\n// -----------------------------------------------\n\n#if COLOR_UTILS\n\nconst vec3 lum_linear_bt709 = vec3(0.2126, 0.7152, 0.0722);\n\nvec3 blender_rgb_to_hsv(vec3 rgb)\n{\n    float cmax, cmin, h, s, v, cdelta;\n    vec3 c;\n\n    cmax = max(rgb[0], max(rgb[1], rgb[2]));\n    cmin = min(rgb[0], min(rgb[1], rgb[2]));\n    cdelta = cmax - cmin;\n\n    v = cmax;\n    if (cmax != 0.0)\n    {\n        s = cdelta / cmax;\n    }\n    else\n    {\n        s = 0.0;\n        h = 0.0;\n    }\n\n    if (s == 0.0)\n    {\n        h = 0.0;\n    }\n    else\n    {\n        c = (vec3(cmax) - rgb.xyz) / cdelta;\n\n        if (rgb.x == cmax)\n        {\n            h = c[2] - c[1];\n        }\n        else if (rgb.y == cmax)\n        {\n            h = 2.0 + c[0] - c[2];\n        }\n        else\n        {\n            h = 4.0 + c[1] - c[0];\n        }\n\n        h /= 6.0;\n\n        if (h < 0.0)\n        {\n            h += 1.0;\n        }\n    }\n\n    return vec3(h, s, v);\n}\n\nvec3 blender_hsv_to_rgb(vec3 hsv)\n{\n    float i, f, p, q, t, h, s, v;\n    vec3 rgb;\n\n    h = hsv[0];\n    s = hsv[1];\n    v = hsv[2];\n\n    if (s == 0.0)\n    {\n        rgb = vec3(v, v, v);\n    }\n    else\n    {\n        if (h == 1.0)\n        {\n            h = 0.0;\n        }\n\n        h *= 6.0;\n        i = floor(h);\n        f = h - i;\n        rgb = vec3(f, f, f);\n        p = v * (1.0 - s);\n        q = v * (1.0 - (s * f));\n        t = v * (1.0 - (s * (1.0 - f)));\n\n        if (i == 0.0)\n        {\n            rgb = vec3(v, t, p);\n        }\n        else if (i == 1.0)\n        {\n            rgb = vec3(q, v, p);\n        }\n        else if (i == 2.0)\n        {\n            rgb = vec3(p, v, t);\n        }\n        else if (i == 3.0)\n        {\n            rgb = vec3(p, q, v);\n        }\n        else if (i == 4.0)\n        {\n            rgb = vec3(t, p, v);\n        }\n        else\n        {\n            rgb = vec3(v, p, q);\n        }\n    }\n\n    return rgb;\n}\n\nvec3 blender_hue_sat(vec3 col, float hue, float sat, float value)\n{\n    vec3 hsv = blender_rgb_to_hsv(col);\n\n    hsv[0] = fract(hsv[0] + hue + 0.5);\n    hsv[1] = clamp(hsv[1] * sat, 0.0, 1.0);\n    hsv[2] = hsv[2] * value;\n\n    return blender_hsv_to_rgb(hsv);\n}\n\nfloat rgb_avg(vec3 inp)\n{\n    return (inp.x + inp.y + inp.z) / 3.0;\n}\n\nfloat rgb_sum(vec3 inp)\n{\n    return inp.x + inp.y + inp.z;\n}\n\nfloat rgb_max(vec3 inp)\n{\n    return max(max(inp.x, inp.y), inp.z);\n}\n\nfloat rgb_min(vec3 inp)\n{\n    return min(min(inp.x, inp.y), inp.z);\n}\n\nvec3 rgb_sweep(float hue)\n{\n    hue = wrap(hue * 360.0, 0.0, 360.0);\n\n    vec3 col = vec3(1, 0, 0);\n    col = mix(col, vec3(1, 1, 0), map_range_clamp(hue, 0.0, 60.0, 0.0, 1.0));\n    col = mix(col, vec3(0, 1, 0), map_range_clamp(hue, 60.0, 120.0, 0.0, 1.0));\n    col = mix(col, vec3(0, 1, 1), map_range_clamp(hue, 120.0, 180.0, 0.0, 1.0));\n    col = mix(col, vec3(0, 0, 1), map_range_clamp(hue, 180.0, 240.0, 0.0, 1.0));\n    col = mix(col, vec3(1, 0, 1), map_range_clamp(hue, 240.0, 300.0, 0.0, 1.0));\n    col = mix(col, vec3(1, 0, 0), map_range_clamp(hue, 300.0, 360.0, 0.0, 1.0));\n    \n    return col;\n}\n\nfloat rgb_variance(vec3 a, vec3 b)\n{\n    a = max(a, 0.0);\n    b = max(b, 0.0);\n    \n    a += 0.001;\n    b += 0.001;\n    \n    float v = dot(abs(log2(a / b)), vec3(0.3, 0.59, 0.11));\n    return v*v;\n}\n\n#endif\n\n// -----------------------------------------------\n// End\n// -----------------------------------------------\n\n\n\n// -----------------------------------------------\n// Keyboard Utils\n// -----------------------------------------------\n\n#if KEYBOARD_UTILS\n\n#define KEY_BACKSPACE 8\n#define KEY_TAB 9\n#define KEY_ENTER 13\n#define KEY_SHIFT 16\n#define KEY_CTRL 17\n#define KEY_ALT 18\n#define KEY_PAUSE_BREAK 19\n#define KEY_CAPS_LOCK 20\n#define KEY_ESC 27\n#define KEY_SPACE 32\n#define KEY_PAGE_UP 33\n#define KEY_PAGE_DOWN 34\n#define KEY_END 35\n#define KEY_HOME 36\n#define KEY_LEFT 37\n#define KEY_UP 38\n#define KEY_RIGHT 39\n#define KEY_DOWN 40\n#define KEY_PRINT_SCREEN 44\n#define KEY_INSERT 45\n#define KEY_DELETE 46\n#define KEY_0 48\n#define KEY_1 49\n#define KEY_2 50\n#define KEY_3 51\n#define KEY_4 52\n#define KEY_5 53\n#define KEY_6 54\n#define KEY_7 55\n#define KEY_8 56\n#define KEY_9 57\n#define KEY_A 65\n#define KEY_B 66\n#define KEY_C 67\n#define KEY_D 68\n#define KEY_E 69\n#define KEY_F 70\n#define KEY_G 71\n#define KEY_H 72\n#define KEY_I 73\n#define KEY_J 74\n#define KEY_K 75\n#define KEY_L 76\n#define KEY_M 77\n#define KEY_N 78\n#define KEY_O 79\n#define KEY_P 80\n#define KEY_Q 81\n#define KEY_R 82\n#define KEY_S 83\n#define KEY_T 84\n#define KEY_U 85\n#define KEY_V 86\n#define KEY_W 87\n#define KEY_X 88\n#define KEY_Y 89\n#define KEY_Z 90\n#define KEY_LWIN 91\n#define KEY_RWIN 92\n#define KEY_POPUP 93\n#define KEY_NUMPAD_0 96\n#define KEY_NUMPAD_1 97\n#define KEY_NUMPAD_2 98\n#define KEY_NUMPAD_3 99\n#define KEY_NUMPAD_4 100\n#define KEY_NUMPAD_5 101\n#define KEY_NUMPAD_6 102\n#define KEY_NUMPAD_7 103\n#define KEY_NUMPAD_8 104\n#define KEY_NUMPAD_9 105\n#define KEY_NUMPAD_ASTERISK 106 \n#define KEY_NUMPAD_PLUS 107\n#define KEY_NUMPAD_MINUS 109\n#define KEY_NUMPAD_PERIOD 110\n#define KEY_NUMPAD_SLASH 111\n#define KEY_F1 112\n#define KEY_F2 113\n#define KEY_F3 114\n#define KEY_F4 115\n#define KEY_F5 116\n#define KEY_F6 117\n#define KEY_F7 118\n#define KEY_F8 119\n#define KEY_F9 120\n#define KEY_F10 121\n#define KEY_F11 122\n#define KEY_F12 123\n#define KEY_NUM_LOCK 144\n#define KEY_SCROLL_LOCK 145\n#define KEY_LSHIFT 160\n#define KEY_RSHIFT 161\n#define KEY_LCTRL 162\n#define KEY_RCTRL 163\n\nbool key_is_down(int key, sampler2D keyboard_channel)\n{\n    return texelFetch(keyboard_channel, ivec2(key, 0), 0).x != 0.0;\n}\n\nbool key_got_pressed(int key, sampler2D keyboard_channel)\n{\n    return texelFetch(keyboard_channel, ivec2(key, 1), 0).x != 0.0;\n}\n\nbool key_toggle_state(int key, sampler2D keyboard_channel)\n{\n    return texelFetch(keyboard_channel, ivec2(key, 2), 0).x != 0.0;\n}\n\nfloat fkey_is_down(int key, sampler2D keyboard_channel)\n{\n    return key_is_down(key, keyboard_channel) ? 1.0 : 0.0;\n}\n\nfloat fkey_got_pressed(int key, sampler2D keyboard_channel)\n{\n    return key_got_pressed(key, keyboard_channel) ? 1.0 : 0.0;\n}\n\nfloat fkey_toggle_state(int key, sampler2D keyboard_channel)\n{\n    return key_toggle_state(key, keyboard_channel) ? 1.0 : 0.0;\n}\n\n#endif\n\n// -----------------------------------------------\n// End\n// -----------------------------------------------\n\n\n\n// Just linear mapping\nfloat not_so_smoothstep(float e0, float e1, float x)\n{\n    return clamp((x - e0) / (e1 - e0), 0.0, 1.0);\n}\n\n// 1D slit function\nfloat slit(float x, float center, float half_width, float fade_width)\n{\n    return not_so_smoothstep(-half_width - fade_width, -half_width, x - center)\n        * not_so_smoothstep(half_width + fade_width, half_width, x - center);\n}\n\n// Regular polygon\n// Source: https://www.shadertoy.com/view/tdsXz8\nfloat sd_npoly(float n, float radius, float rotation, vec2 p)\n{\n    n *= .5;\n    float o = PI_OVER_2 / n;\n    float a = atan(p.y / p.x);\n    if(p.x < 0.)\n        a += PI;\n    float s = round((a + rotation) / PI * n) / n * PI - rotation;\n    float d = round((a + o + rotation) / PI * n) / n * PI - o - rotation;\n    vec2 c = vec2(cos(d), sin(d)) * radius;\n    vec2 f = vec2(cos(s), sin(s));\n    float b = length(p - c);\n    float l = dot(p, f);\n    l -= cos(o) * radius;\n    float m = b;\n    if(abs(dot(vec2(p.x, -p.y), f.yx)) <= sin(o) * radius)\n        m = l;\n    return m;\n}\n",
     "name": "Common",
     "description": "",
     "type": "common"
    },
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "/* -----------------------------------------------\n  Shadertoy Unit: Buffer A\n  Description: FFT is performed in this buffer.\n  iChannel0: None\n  iChannel1: None\n  iChannel2: None\n  iChannel3: None\n----------------------------------------------- */\n\nfloat shape0_radius;\nfloat shape1_slit1_half_width;\nfloat shape1_slit2_center;\nfloat shape1_slit2_fade;\nfloat shape1_cutout_radius;\n\nfloat fft_input(vec2 uv)\n{\n    int shape = int(floor(0.34 * iTime)) % 3;\n    if (shape == 0)\n    {\n        // Circle\n        return not_so_smoothstep(shape0_radius, shape0_radius - 0.02, distance(uv, vec2(0.5, 0.5)));\n    }\n    else if (shape == 1)\n    {\n        // Double slit\n        float v = slit(uv.x, 0.44, shape1_slit1_half_width, 0.004);\n        v += slit(uv.x, shape1_slit2_center, 0.02, shape1_slit2_fade);\n        v *= slit(uv.y, 0.5, 0.25, 0.004);\n        float d = distance(uv, vec2(0.5, 0.5));\n        v *= not_so_smoothstep(shape1_cutout_radius, shape1_cutout_radius - 0.01, d);\n        v *= not_so_smoothstep(0.3, 0.01, d) * 0.5 + 0.5;\n        return v;\n    }\n    else if (shape == 2)\n    {\n        // Pentagon\n        return not_so_smoothstep(0.01, 0.0, sd_npoly(5.0, 0.15, iTime * 0.25, uv - 0.5));\n    }\n    return 0.0;\n}\n\n// How much of this frequency is present in fft_input?\nvec2 freq_amount(ivec2 freq)\n{\n    const vec2 uv00 = 0.5 / vec2(fft_res);\n    const vec2 uv_step = 1.0 / vec2(fft_res);\n    vec2 f2 = vec2(freq) * TAU;\n    vec2 v = vec2(0.0);\n    float a = 0.0;\n    for (float y = uv00.y; y < 1.0; y += uv_step.y)\n    {\n        for (float x = uv00.x; x < 1.0; x += uv_step.x)\n        {\n            a = dot(vec2(x, y), f2);\n            v += fft_input(vec2(x, y)) * vec2(cos(a), sin(a));\n        }\n    }\n    return v * fft_mul;\n}\n\n// Simpler but less optimized version of freq_amount()\nvec2 freq_amount_unoptimized_but_simpler(ivec2 freq)\n{\n    // Complex coefficient or something\n    float vcos = 0.0;\n    float vsin = 0.0;\n    \n    // Basically a huge dot product (input . some_wavy_pattern_based_on_freq)\n    // (we treat those \"images\" as very long 1D vectors)\n    for (int y = 0; y < fft_res.y; y++)\n    {\n        for (int x = 0; x < fft_res.x; x++)\n        {\n            vec2 uv = (vec2(float(x), float(y)) + 0.5) / vec2(fft_res);\n            \n            vcos += fft_input(uv) * cos(dot(uv, vec2(freq)) * TAU);\n            vsin += fft_input(uv) * sin(dot(uv, vec2(freq)) * TAU);\n        }\n    }\n    \n    return vec2(vcos, vsin) * fft_mul;\n}\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    // If iResolution is not large enough\n    if (int(floor(iResolution.x)) < fft_res.x || int(floor(iResolution.y)) < fft_res.y)\n    {\n        frag_col = vec4(1, 0, 1, 1);\n        return;\n    }\n    \n    // Integer coordinates & UV\n    ivec2 icoord = ivec2(floor(frag_coord));\n    vec2 uv = (vec2(icoord) + 0.5) / vec2(fft_res);\n    \n    // If outside the region of interest\n    if (icoord.x >= fft_res.x || icoord.y >= fft_res.y)\n    {\n        frag_col = vec4(0, 0, 0, 1);\n        return;\n    }\n    \n    // Init variables for fft_input\n    float t = TAU * iTime;\n    shape0_radius = 0.16 + 0.07 * cos(t * 0.2);\n    shape1_slit1_half_width = 0.02 + 0.007 * cos(t * 0.2286);\n    shape1_slit2_center = 0.56 + 0.01 * cos(t * 0.4);\n    shape1_slit2_fade = 0.005 + 0.004 * cos(t * 0.3772);\n    shape1_cutout_radius = 0.254 + 0.02 * cos(t * 0.1689);\n    \n    float v = 0.0;\n    if (fft_preview_input)\n    {\n        // Preview FFT input\n        v = fft_input(uv);\n    }\n    else\n    {\n        // What 2D frequency to check\n        ivec2 freq = icoord - (fft_res / 2);\n        \n        // How much of the frequency is present\n        v = length(freq_amount(freq));\n    }\n    \n    // Output\n    frag_col = vec4(v, v, v, 1.0);\n}\n",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "mdjBWK",
    "date": "1690217266",
    "viewed": 245,
    "name": "Triangle Barycentric Coordinates",
    "description": "This started as a 4 AM question: \"How do vertex attributes get interpolated in a fragment shader?\"\nThe Wikipedia page for Barycentric Coordinates was too complicated for me, so hopefully this is easier to und.\nhttps://www.desmos.com/calculator/8g8xjejuox\n",
    "likes": 3,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "2d",
     "triangle",
     "barycentric",
     "linear",
     "matrix",
     "interpolation",
     "vectors",
     "matrices"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "vec3 view_transform(vec3 col)\n{\n\t// OETF\n    return pow(col, vec3(1. / 2.2));\n}\n\nvoid get_vertices(out vec2 v0, out vec2 v1, out vec2 v2)\n{\n    v0 = vec2(random() - .5, random() - .5);\n    v1 = vec2(random() - .5, random() - .5);\n    v2 = vec2(random() - .5, random() - .5);\n    \n    v0 = mix(v0, 1.3 * vec2(0., .4), .6);\n    v1 = mix(v1, 1.3 * vec2(-.5, -.3), .6);\n    v2 = mix(v2, 1.3 * vec2(.5, -.3), .6);\n}\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    // time\n    const float speed = 1.7;\n    float ti = floor(iTime * speed);\n    float tfrac = fract(iTime * speed);\n    \n    // UV\n    vec2 uv = screen_to_uv_fit(frag_coord, iResolution.xy);\n    \n    // triangle vertices\n    vec2 v0, v1, v2,\n        v0a, v0b,\n        v1a, v1b,\n        v2a, v2b;\n    {\n        prng_init(vec3(float(int(ti)), 1, 2));\n        get_vertices(v0a, v1a, v2a);\n        \n        prng_init(vec3(float(int(ti) + 1), 1, 2));\n        get_vertices(v0b, v1b, v2b);\n        \n        float t = smoothstep(.1, .9, tfrac);\n        v0 = mix(v0a, v0b, t);\n        v1 = mix(v1a, v1b, t);\n        v2 = mix(v2a, v2b, t);\n    }\n    \n    // get barycentric coords\n    bool outside;\n    vec3 col = cartesian_to_barycentric(uv, v0, v1, v2, true, outside);\n    \n    // darken the outer areas\n    if (outside)\n    {\n        col *= cos(TAU * speed * .1 * iTime) * .45 + .55;\n    }\n    \n    // output\n    col = view_transform(col);\n    frag_col = vec4(col, 1);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "/*_________________ math utils ________________*/\n\n#define PI 3.1415926535897932384626433832\n#define TAU 6.283185307179586476925286766\n#define PI_OVER_2 1.57079632679489661923132169163\n\n#define FUNC_LERP(T) \\\nT lerp(T a, T b, float t) \\\n{ \\\n    return a + t * (b - a); \\\n}\n\n#define FUNC_WRAP(T) \\\nT wrap(T inp, float start, float end) \\\n{ \\\n    return start + mod(inp - start, end - start); \\\n}\n\n#define FUNC_REMAP(T) \\\nT remap(T inp, float inp_start, float inp_end, float out_start, float out_end) \\\n{ \\\n    return out_start \\\n        + ((out_end - out_start) / (inp_end - inp_start)) * (inp - inp_start); \\\n}\n\n#define FUNC_REMAP_CLAMP(T) \\\nT remap_clamp( \\\n    T inp, \\\n    float inp_start, \\\n    float inp_end, \\\n    float out_start, \\\n    float out_end \\\n) \\\n{ \\\n    T t = clamp((inp - inp_start) / (inp_end - inp_start), 0.0, 1.0); \\\n    return out_start + t * (out_end - out_start); \\\n}\n\n#define FUNC_REMAP01(T) \\\nT remap01(T inp, float inp_start, float inp_end) \\\n{ \\\n    return clamp((inp - inp_start) / (inp_end - inp_start), 0.0, 1.0); \\\n}\n\nFUNC_LERP(float)\nFUNC_LERP(vec2)\nFUNC_LERP(vec3)\nFUNC_LERP(vec4)\n\nFUNC_WRAP(float)\nFUNC_WRAP(vec2)\nFUNC_WRAP(vec3)\nFUNC_WRAP(vec4)\n\nFUNC_REMAP(float)\nFUNC_REMAP(vec2)\nFUNC_REMAP(vec3)\nFUNC_REMAP(vec4)\n\nFUNC_REMAP_CLAMP(float)\nFUNC_REMAP_CLAMP(vec2)\nFUNC_REMAP_CLAMP(vec3)\nFUNC_REMAP_CLAMP(vec4)\n\nFUNC_REMAP01(float)\nFUNC_REMAP01(vec2)\nFUNC_REMAP01(vec3)\nFUNC_REMAP01(vec4)\n\nfloat min_component(vec2 inp)\n{\n    return min(inp.x, inp.y);\n}\n\nfloat min_component(vec3 inp)\n{\n    return min(min(inp.x, inp.y), inp.z);\n}\n\nfloat min_component(vec4 inp)\n{\n    return min(min(min(inp.x, inp.y), inp.z), inp.w);\n}\n\nfloat max_component(vec2 inp)\n{\n    return max(inp.x, inp.y);\n}\n\nfloat max_component(vec3 inp)\n{\n    return max(max(inp.x, inp.y), inp.z);\n}\n\nfloat max_component(vec4 inp)\n{\n    return max(max(max(inp.x, inp.y), inp.z), inp.w);\n}\n\n// |a| * |b| * sin(theta)\nfloat cross2d(vec2 a, vec2 b)\n{\n    return a.x * b.y - a.y * b.x;\n}\n\n// references for barycentric coordinates\n// https://www.desmos.com/calculator/8g8xjejuox\n// https://www.shadertoy.com/view/mdjBWK\n\nvec3 cartesian_to_barycentric(\n    vec2 p,\n    vec2 v0,\n    vec2 v1,\n    vec2 v2,\n    bool clamp_,\n    out bool p_is_outside\n)\n{\n    vec3 b = vec3(\n        cross2d(v1 - p, v2 - p),\n        cross2d(v2 - p, v0 - p),\n        cross2d(v0 - p, v1 - p)\n    ) / cross2d(v1 - v0, v2 - v0);\n    p_is_outside = min(min(b.x, b.y), b.z) < 0.;\n    if (clamp_)\n    {\n        b = max(b, 0.);\n        b /= (b.x + b.y + b.z);\n    }\n    return b;\n}\n\nvec3 cartesian_to_barycentric(\n    vec3 p,\n    vec3 v0,\n    vec3 v1,\n    vec3 v2,\n    bool clamp_,\n    out bool p_is_outside\n)\n{\n    vec3 b = vec3(\n        length(cross(v1 - p, v2 - p)),\n        length(cross(v2 - p, v0 - p)),\n        length(cross(v0 - p, v1 - p))\n    ) / length(cross(v1 - v0, v2 - v0));\n    p_is_outside = min(min(b.x, b.y), b.z) < 0.;\n    if (clamp_)\n    {\n        b = max(b, 0.);\n        b /= (b.x + b.y + b.z);\n    }\n    return b;\n}\n\nfloat barycentric_interpolate(vec3 b, float v0, float v1, float v2)\n{\n    return dot(b, vec3(v0, v1, v2));\n}\n\nvec2 barycentric_interpolate(vec3 b, vec2 v0, vec2 v1, vec2 v2)\n{\n    return b.x * v0 + b.y * v1 + b.z * v2;\n}\n\nvec3 barycentric_interpolate(vec3 b, vec3 v0, vec3 v1, vec3 v2)\n{\n    return b.x * v0 + b.y * v1 + b.z * v2;\n}\n\nvec4 barycentric_interpolate(vec3 b, vec4 v0, vec4 v1, vec4 v2)\n{\n    return b.x * v0 + b.y * v1 + b.z * v2;\n}\n\nfloat barycentric_interpolate(vec2 b, float v0, float v1, float v2)\n{\n    return barycentric_interpolate(\n        vec3(b.x, b.y, 1. - b.x - b.y),\n        v0, v1, v2\n    );\n}\n\nvec2 barycentric_interpolate(vec2 b, vec2 v0, vec2 v1, vec2 v2)\n{\n    return barycentric_interpolate(\n        vec3(b.x, b.y, 1. - b.x - b.y),\n        v0, v1, v2\n    );\n}\n\nvec3 barycentric_interpolate(vec2 b, vec3 v0, vec3 v1, vec3 v2)\n{\n    return barycentric_interpolate(\n        vec3(b.x, b.y, 1. - b.x - b.y),\n        v0, v1, v2\n    );\n}\n\nvec4 barycentric_interpolate(vec2 b, vec4 v0, vec4 v1, vec4 v2)\n{\n    return barycentric_interpolate(\n        vec3(b.x, b.y, 1. - b.x - b.y),\n        v0, v1, v2\n    );\n}\n\nmat2 rotate_2d(float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(\n        c, s,\n        -s, c\n    );\n}\n\nvec3 spherical_to_cartesian(vec2 s)\n{\n    float sin_theta = sin(s.x);\n    return vec3(\n        sin_theta * cos(s.y),\n        sin_theta * sin(s.y),\n        cos(s.x)\n    );\n}\n\nvec2 screen_to_uv01(vec2 coord, vec2 res)\n{\n    return coord / res;\n}\n\nvec2 screen_to_uv_horizontal(vec2 coord, vec2 res)\n{\n    return (2. * coord - res) / res.x;\n}\n\nvec2 screen_to_uv_vertical(vec2 coord, vec2 res)\n{\n    return (2. * coord - res) / res.y;\n}\n\nvec2 screen_to_uv_fit(vec2 coord, vec2 res)\n{\n    return (2. * coord - res) / min_component(res);\n}\n\nvec2 screen_to_uv_fill(vec2 coord, vec2 res)\n{\n    return (2. * coord - res) / max_component(res);\n}\n\n\n\n/*_______ pseudo-random number generator ______*/\n// source: https://www.shadertoy.com/view/WdSSRt\n\n/* usage example:\n    void mainImage(out vec4 frag_col, in vec2 frag_coord)\n    {\n        // initialize PRNG\n        prng_init(vec3(frag_coord / iResolution.y, iTime));\n    \n        // use the function\n        float a = random();\n        vec3 b = vec3(random(), random(), random());\n        \n        ...\n    }\n*/\n\nuint prng_state[2];\n\nuint prng_rot(uint x, int k)\n{\n    return (x << k) | (x >> (32 - k));\n}\n\n// random uint from 0 to 2^32-1\nuint randomui()\n{\n    uint s0 = prng_state[0];\n    uint s1 = prng_state[1];\n    uint result = prng_rot(s0 * 2654435771u, 5) * 5u;\n    s1 ^= s0;\n    prng_state[0] = prng_rot(s0, 26) ^ s1 ^ (s1 << 9);\n    prng_state[1] = prng_rot(s1, 13);\n    return result;\n}\n\n// random int from 0 to 2^31-1\nint randomi()\n{\n    return int(randomui() % 0x7FFFFFFFu);\n}\n\n// random float from 0 to 1\nfloat random()\n{\n    return float(randomui()) / float(0xffffffffu);\n}\n\n// generate two normally distributed random numbers using the\n// Box-Muller transform\n// source: https://www.baeldung.com/cs/uniform-to-normal-distribution\nvec2 random_gauss()\n{\n    float u1 = random();\n    float u2 = random() * TAU;\n    float temp = sqrt(-2. * log(u1));\n    return temp * vec2(cos(u2), sin(u2));\n    \n    // unoptimized version\n    //float u1 = random();\n    //float u2 = random();\n    //return vec2(cos(TAU * u2), sin(TAU * u2)) * sqrt(-2. * log(u1));\n}\n\nvec2 random_unit_vec2()\n{\n    vec2 v = vec2(1);\n    float lensqr;\n\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec2(2. * random() - 1., 2. * random() - 1.);\n        lensqr = dot(v, v);\n        if (lensqr == 0.)\n            i--;\n        else if (lensqr <= 1.)\n            break;\n    }\n    return v / sqrt(lensqr);\n}\n\nvec3 random_unit_vec3()\n{\n    vec3 v = vec3(1);\n    float lensqr;\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec3(2. * random() - 1., 2. * random() - 1., 2. * random() - 1.);\n        lensqr = dot(v, v);\n        if (lensqr == 0.)\n            i--;\n        else if (lensqr <= 1.)\n            break;\n    }\n    return v / sqrt(lensqr);\n}\n\nvec2 random_in_circle()\n{\n    vec2 v = vec2(1);\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec2(2. * random() - 1., 2. * random() - 1.);\n        if (dot(v, v) <= 1.)\n            return v;\n    }\n    return v;\n}\n\nvec3 random_in_sphere()\n{\n    vec3 v = vec3(1);\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec3(2. * random() - 1., 2. * random() - 1., 2. * random() - 1.);\n        if (dot(v, v) <= 1.)\n            return v;\n    }\n    return v;\n}\n\n// initialize with uvec2\nvoid prng_init(uvec2 seed)\n{\n    seed += uvec2(1317, 944573125);\n    seed *= 464973573u;\n    prng_state[0] = seed.x;\n    prng_state[1] = seed.y;\n    randomi();\n}\n\n// initialize with uint\nvoid prng_init(uint seed)\n{\n    prng_init(uvec2(seed, 1));\n}\n\n// initialize with vec3\nvoid prng_init(vec3 seed)\n{\n    seed += 3.49276101561702;\n    seed.xy *= (seed.z + 10.258);\n    prng_state[0] = floatBitsToUint(seed.x);\n    prng_state[1] = floatBitsToUint(seed.y);\n    randomui();\n}\n\n// initialize with vec2\nvoid prng_init(vec2 seed)\n{\n    prng_init(vec3(seed, 1));\n}\n\n// initialize with float\nvoid prng_init(float seed)\n{\n    prng_init(vec3(seed, 1, 1));\n}\n",
     "name": "Common",
     "description": "",
     "type": "common"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "msjfDt",
    "date": "1690292056",
    "viewed": 296,
    "name": "Moving White Point",
    "description": "Random experiment\n\n- Drag to move the white point",
    "likes": 6,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "2d",
     "triangle",
     "colors",
     "barycentric",
     "colorspace"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "vec2 screen_to_uv(vec2 coord)\n{\n    return (2.0 * coord - iResolution.xy) / min(iResolution.x, iResolution.y);\n}\n\nvec3 view_transform(vec3 col)\n{\n\t// OETF (Gamma)\n    return pow(col, vec3(1.0 / 2.2));\n}\n\nvec3 render(vec2 coord)\n{\n    // UV\n    vec2 uv = screen_to_uv(coord);\n    \n    // Primaries and white point\n    vec2 r = vec2(0.7, -0.5);\n    vec2 g = vec2(0.0, 0.5);\n    vec2 b = vec2(-0.7, -0.5);\n    vec2 w = vec2(0.0, -0.16667);\n    \n    // Animate the white point\n    float t = TAU * iTime * 0.5;\n    w += vec2(cos(t), sin(t)) * cos(0.2 * t) * 0.2;\n    \n    // Drag the white point\n    if (iMouse.z > 0.5)\n    {\n        w = screen_to_uv(iMouse.xy);\n    }\n    \n    // Stuff\n    vec3 col = vec3(0.0);\n    bool outside;\n    vec3 bary;\n    \n    // Check if UV is inside\n    bary = cart2barycentric(uv, r, g, b, false, outside);\n    if (!outside)\n    {\n        // Check if white point is inside\n        bary = cart2barycentric(w, r, g, b, false, outside);\n        if (outside)\n        {\n            col = vec3(1.0, 0.05, 0.03);\n        }\n        else\n        {\n            // Get interpolated color\n            bary = cart2barycentric(uv, r, w, b, false, outside);\n            if (!outside)\n            {\n                col = bary.x * vec3(1, 0, 0)\n                    + bary.y * vec3(1.0 / 3.0)\n                    + bary.z * vec3(0, 0, 1);\n            }\n            bary = cart2barycentric(uv, g, w, r, false, outside);\n            if (!outside)\n            {\n                col = bary.x * vec3(0, 1, 0)\n                    + bary.y * vec3(1.0 / 3.0)\n                    + bary.z * vec3(1, 0, 0);\n            }\n            bary = cart2barycentric(uv, b, w, g, false, outside);\n            if (!outside)\n            {\n                col = bary.x * vec3(0, 0, 1)\n                    + bary.y * vec3(1.0 / 3.0)\n                    + bary.z * vec3(0, 1, 0);\n            }\n            col = max(col, 0.0);\n            float mono = max(max(col.r, col.g), col.b);\n            if (mono > 0.0) col /= mono;\n        }\n    }\n    \n    // Draw dots on the points\n    if (inside_circle(uv, r, 0.03)) col = vec3(0.5);\n    if (inside_circle(uv, g, 0.03)) col = vec3(0.5);\n    if (inside_circle(uv, b, 0.03)) col = vec3(0.5);\n    if (inside_circle(uv, w, 0.01)) col = vec3(0.5);\n    \n    return col;\n}\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    // Initialize PRNG\n    prng_init(vec3(frag_coord / iResolution.y, iTime));\n    \n    // Jitter sampling\n    const int jitter_samples = 32;\n    vec3 col = vec3(0.0);\n    for (int i = 0; i < jitter_samples; i++)\n    {\n        col += render(frag_coord + vec2(random(), random()) - 0.5);\n    }\n    col /= float(jitter_samples);\n    \n    // Output\n    col = view_transform(col);\n    frag_col = vec4(col, 1.0);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "#define PI 3.1415926535897932384626433832\n#define TAU 6.283185307179586476925286766\n\n// Basically |a| * |b| * sin(theta)\nfloat cross2d(vec2 a, vec2 b)\n{\n    return a.x * b.y - a.y * b.x;\n}\n\nvec2 barycentric2cart(vec3 b, vec2 v0, vec2 v1, vec2 v2)\n{\n    return b.x * v0 + b.y * v1 + b.z * v2;\n}\n\n// https://www.desmos.com/calculator/8g8xjejuox\nvec3 cart2barycentric(vec2 p, vec2 v0, vec2 v1, vec2 v2)\n{\n    vec3 b = vec3(\n        cross2d(v1 - p, v2 - p),\n        cross2d(v2 - p, v0 - p),\n        cross2d(v0 - p, v1 - p)\n    ) / cross2d(v1 - v0, v2 - v0);\n    return b;\n}\n\nvec3 cart2barycentric(vec2 p, vec2 v0, vec2 v1, vec2 v2, bool clamped, out bool outside)\n{\n    vec3 b = vec3(\n        cross2d(v1 - p, v2 - p),\n        cross2d(v2 - p, v0 - p),\n        cross2d(v0 - p, v1 - p)\n    ) / cross2d(v1 - v0, v2 - v0);\n    outside = min(min(b.x, b.y), b.z) < -0.001;\n    if (clamped)\n    {\n        b = max(b, 0.0);\n        b /= (b.x + b.y + b.z);\n    }\n    return b;\n}\n\nbool inside_circle(vec2 p, vec2 center, float radius)\n{\n    return distance(p, center) < radius;\n}\n\n\n\n// -----------------------------------------------\n// Pseudo-Random Number Generator\n// Source: https://www.shadertoy.com/view/WdSSRt\n// -----------------------------------------------\n\n/* Usage Example:\n    void mainImage(out vec4 frag_col, in vec2 frag_coord)\n    {\n        // Initialize PRNG\n        prng_init(vec3(frag_coord / iResolution.y, iTime));\n    \n        // Using the function\n        float a = random();\n        vec3 b = vec3(random(), random(), random());\n        \n        ...\n    }\n*/\n\nuint prng_state[2];\n\nuint prng_rot(uint x, int k)\n{\n    return (x << k) | (x >> (32 - k));\n}\n\nfloat random()\n{\n    uint s0 = prng_state[0];\n    uint s1 = prng_state[1];\n    uint result = prng_rot(s0 * 0x9e3779bbu, 5) * 5u;\n    s1 ^= s0;\n    prng_state[0] = prng_rot(s0, 26) ^ s1 ^ (s1 << 9);\n    prng_state[1] = prng_rot(s1, 13);\n    return float(result) / float(0xffffffffu);\n}\n\nvoid prng_init(vec3 seed)\n{\n    seed.xy *= (seed.z + 10.258);\n    seed += 3.49276101561702;\n    prng_state[0] = floatBitsToUint(seed.x);\n    prng_state[1] = floatBitsToUint(seed.y);\n    random();\n}\n\n// -----------------------------------------------\n// End\n// -----------------------------------------------\n",
     "name": "Common",
     "description": "",
     "type": "common"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "mlscWr",
    "date": "1690662251",
    "viewed": 363,
    "name": "Blinn-Phong Shading",
    "description": "Sphere",
    "likes": 5,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "3d",
     "raytracing",
     "phong",
     "lighting",
     "sphere",
     "shading",
     "blinn"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "/* -----------------------------------------------\n  Shadertoy Unit: Image\n  Description: None\n  iChannel0: None\n  iChannel1: None\n  iChannel2: None\n  iChannel3: None\n----------------------------------------------- */\n\nvec2 screen_to_uv(vec2 coord)\n{\n    return (2.0 * coord - iResolution.xy) / min(iResolution.x, iResolution.y);\n}\n\nvec3 view_transform(vec3 col)\n{\n\t// OETF (Gamma)\n    return pow(col, vec3(1.0 / 2.2));\n}\n\nvec3 render(vec2 frag_coord)\n{\n    // UV\n    vec2 uv = screen_to_uv(frag_coord);\n    \n    // Camera params\n    const vec3 cam_pos = vec3(0.0, -1.6, 0.5);\n    const float cam_fov = 90.0;\n    \n    // Camera details\n    float cam_zoom = 90.0 / cam_fov;\n    vec3 cam_forward = normalize(-cam_pos);\n    vec3 cam_right = normalize(cross(cam_forward, vec3(0, 0, 1)));\n    vec3 cam_up = cross(cam_right, cam_forward);\n    \n    // Setup ray\n    ray_info r;\n    r.orig = cam_pos;\n    r.dir = normalize(cam_forward + cam_right * (uv.x / cam_zoom) + cam_up * (uv.y / cam_zoom));\n    \n    // Cast ray\n    ray_sphere(0.8, r);\n    if (r.hit)\n    {\n        // Material params\n        const vec3 mat_diffuse = vec3(1.0, 0.5, 0.0);\n        const float mat_specular = 0.1;\n        const float mat_specular_pow = 300.0;\n        \n        // Point light params\n        const vec3 light_col = vec3(10.5);\n        const vec3 light_pos = vec3(1.0, -1.8, 3.0);\n        \n        // Light details\n        float light_dist = distance(r.pos, light_pos);\n        vec3 light_dir = (light_pos - r.pos) / light_dist;\n        \n        // Lambertian diffuse\n        vec3 diffuse =\n            mat_diffuse * light_col\n            * max(0.0, dot(r.normal, light_dir))\n            / (light_dist * light_dist);\n        \n        // Blinn specular\n        vec3 hv = normalize(light_dir - r.dir);\n        vec3 spec =\n            mat_specular * light_col\n            * pow(max(0.0, dot(hv, r.normal)), mat_specular_pow);\n        \n        // Ambient\n        vec3 ambient = 0.05 * mat_diffuse + 0.02 * vec3(0.04, 0.3, 0.7);\n        \n        // Shade\n        vec3 col = diffuse + spec + ambient;\n        \n        return col;\n    }\n    else\n    {\n        // Background color\n        vec3 col = vec3(0.04, 0.3, 0.7);\n        col *= map_range_clamp(uv.y, -0.5, 0.7, 1.1, 0.8);\n        col *= map_range(smoothstep(2.0, 0.7, length(uv)), 0.0, 1.0, 0.9, 1.0);\n        col *= 1.1;\n        col = pow(col, vec3(map_range(smoothstep(2.0, 0.7, length(uv)), 0.0, 1.0, 1.1, 1.0)));\n        return col;\n    }\n}\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    // Initialize PRNG\n    prng_init(vec3(frag_coord / iResolution.y, iTime));\n    \n    // Render with jitter sampling\n    const int num_samples = 24;\n    vec3 col = vec3(0.0);\n    for (int i = 0; i < num_samples; i++)\n    {\n        vec2 offs = vec2(random(), random()) - 0.5;\n        col += render(frag_coord + offs);\n    }\n    col /= float(num_samples);\n    \n    // Output\n    col = view_transform(col);\n    frag_col = vec4(col, 1.0);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "/* -----------------------------------------------\n  Shadertoy Unit: Common\n----------------------------------------------- */\n\n\n\n// -----------------------------------------------\n// What to define\n// -----------------------------------------------\n\n/* Math Utils */\n#define MATH_UTILS 1\n\n/* Pseudo-Random Number Generator */\n#define PRNG 1\n\n/* Color Utils (requires MATH_UTILS) */\n#define COLOR_UTILS 0\n\n/* Keyboard Utils */\n#define KEYBOARD_UTILS 0\n\n// -----------------------------------------------\n// End\n// -----------------------------------------------\n\n\n\n// -----------------------------------------------\n// Math Utils\n// -----------------------------------------------\n\n#if MATH_UTILS\n\n#define PI 3.1415926535897932384626433832\n#define TAU 6.283185307179586476925286766\n#define PI_OVER_2 1.57079632679489661923132169163\n#define DEG_TO_RAD 0.01745329251994329576923690768\n#define RAD_TO_DEG 57.2957795130823208767981548141\n\n#define FUNC_LERP(T) \\\nT lerp(T a, T b, float t) \\\n{ \\\n    return a + t*(b-a); \\\n}\n\n#define FUNC_WRAP(T) \\\nT wrap(T inp, float start, float end) \\\n{ \\\n    return start + mod(inp - start, end - start); \\\n}\n\n#define FUNC_MAP_RANGE(T) \\\nT map_range(T inp, float inp_start, float inp_end, float out_start, float out_end) \\\n{ \\\n    return out_start + ((out_end - out_start) / (inp_end - inp_start)) * (inp - inp_start); \\\n}\n\n#define FUNC_MAP_RANGE_CLAMP(T) \\\nT map_range_clamp(T inp, float inp_start, float inp_end, float out_start, float out_end) \\\n{ \\\n    T t = clamp((inp - inp_start) / (inp_end - inp_start), 0.0, 1.0); \\\n    return out_start + t * (out_end - out_start); \\\n}\n\nFUNC_LERP(float)\nFUNC_LERP(vec2)\nFUNC_LERP(vec3)\nFUNC_LERP(vec4)\n\nFUNC_WRAP(float)\nFUNC_WRAP(vec2)\nFUNC_WRAP(vec3)\nFUNC_WRAP(vec4)\n\nFUNC_MAP_RANGE(float)\nFUNC_MAP_RANGE(vec2)\nFUNC_MAP_RANGE(vec3)\nFUNC_MAP_RANGE(vec4)\n\nFUNC_MAP_RANGE_CLAMP(float)\nFUNC_MAP_RANGE_CLAMP(vec2)\nFUNC_MAP_RANGE_CLAMP(vec3)\nFUNC_MAP_RANGE_CLAMP(vec4)\n\n#endif\n\n// -----------------------------------------------\n// End\n// -----------------------------------------------\n\n\n\n// -----------------------------------------------\n// Pseudo-Random Number Generator\n// Source: https://www.shadertoy.com/view/WdSSRt\n// -----------------------------------------------\n\n/* Usage Example:\n    void mainImage(out vec4 frag_col, in vec2 frag_coord)\n    {\n        // Initialize PRNG\n        prng_init(vec3(frag_coord / iResolution.y, iTime));\n    \n        // Using the function\n        float a = random();\n        vec3 b = vec3(random(), random(), random());\n        \n        ...\n    }\n*/\n\n#if PRNG\n\nuint prng_state[2];\n\nuint prng_rot(uint x, int k)\n{\n    return (x << k) | (x >> (32 - k));\n}\n\nfloat random()\n{\n    uint s0 = prng_state[0];\n    uint s1 = prng_state[1];\n    uint result = prng_rot(s0 * 0x9e3779bbu, 5) * 5u;\n    s1 ^= s0;\n    prng_state[0] = prng_rot(s0, 26) ^ s1 ^ (s1 << 9);\n    prng_state[1] = prng_rot(s1, 13);\n    return float(result) / float(0xffffffffu);\n}\n\nvoid prng_init(vec3 seed)\n{\n    seed.xy *= (seed.z + 10.258);\n    seed += 3.49276101561702;\n    prng_state[0] = floatBitsToUint(seed.x);\n    prng_state[1] = floatBitsToUint(seed.y);\n    random();\n}\n\n#endif\n\n// -----------------------------------------------\n// End\n// -----------------------------------------------\n\n\n\n// -----------------------------------------------\n// Color Utils (requires MATH_UTILS)\n// -----------------------------------------------\n\n#if COLOR_UTILS\n\nconst vec3 lum_linear_bt709 = vec3(0.2126, 0.7152, 0.0722);\n\nvec3 blender_rgb_to_hsv(vec3 rgb)\n{\n    float cmax, cmin, h, s, v, cdelta;\n    vec3 c;\n\n    cmax = max(rgb[0], max(rgb[1], rgb[2]));\n    cmin = min(rgb[0], min(rgb[1], rgb[2]));\n    cdelta = cmax - cmin;\n\n    v = cmax;\n    if (cmax != 0.0)\n    {\n        s = cdelta / cmax;\n    }\n    else\n    {\n        s = 0.0;\n        h = 0.0;\n    }\n\n    if (s == 0.0)\n    {\n        h = 0.0;\n    }\n    else\n    {\n        c = (vec3(cmax) - rgb.xyz) / cdelta;\n\n        if (rgb.x == cmax)\n        {\n            h = c[2] - c[1];\n        }\n        else if (rgb.y == cmax)\n        {\n            h = 2.0 + c[0] - c[2];\n        }\n        else\n        {\n            h = 4.0 + c[1] - c[0];\n        }\n\n        h /= 6.0;\n\n        if (h < 0.0)\n        {\n            h += 1.0;\n        }\n    }\n\n    return vec3(h, s, v);\n}\n\nvec3 blender_hsv_to_rgb(vec3 hsv)\n{\n    float i, f, p, q, t, h, s, v;\n    vec3 rgb;\n\n    h = hsv[0];\n    s = hsv[1];\n    v = hsv[2];\n\n    if (s == 0.0)\n    {\n        rgb = vec3(v, v, v);\n    }\n    else\n    {\n        if (h == 1.0)\n        {\n            h = 0.0;\n        }\n\n        h *= 6.0;\n        i = floor(h);\n        f = h - i;\n        rgb = vec3(f, f, f);\n        p = v * (1.0 - s);\n        q = v * (1.0 - (s * f));\n        t = v * (1.0 - (s * (1.0 - f)));\n\n        if (i == 0.0)\n        {\n            rgb = vec3(v, t, p);\n        }\n        else if (i == 1.0)\n        {\n            rgb = vec3(q, v, p);\n        }\n        else if (i == 2.0)\n        {\n            rgb = vec3(p, v, t);\n        }\n        else if (i == 3.0)\n        {\n            rgb = vec3(p, q, v);\n        }\n        else if (i == 4.0)\n        {\n            rgb = vec3(t, p, v);\n        }\n        else\n        {\n            rgb = vec3(v, p, q);\n        }\n    }\n\n    return rgb;\n}\n\nvec3 blender_hue_sat(vec3 col, float hue, float sat, float value)\n{\n    vec3 hsv = blender_rgb_to_hsv(col);\n\n    hsv[0] = fract(hsv[0] + hue + 0.5);\n    hsv[1] = clamp(hsv[1] * sat, 0.0, 1.0);\n    hsv[2] = hsv[2] * value;\n\n    return blender_hsv_to_rgb(hsv);\n}\n\nfloat rgb_avg(vec3 inp)\n{\n    return (inp.x + inp.y + inp.z) / 3.0;\n}\n\nfloat rgb_sum(vec3 inp)\n{\n    return inp.x + inp.y + inp.z;\n}\n\nfloat rgb_max(vec3 inp)\n{\n    return max(max(inp.x, inp.y), inp.z);\n}\n\nfloat rgb_min(vec3 inp)\n{\n    return min(min(inp.x, inp.y), inp.z);\n}\n\nvec3 rgb_sweep(float hue)\n{\n    hue = wrap(hue * 360.0, 0.0, 360.0);\n\n    vec3 col = vec3(1, 0, 0);\n    col = mix(col, vec3(1, 1, 0), map_range_clamp(hue, 0.0, 60.0, 0.0, 1.0));\n    col = mix(col, vec3(0, 1, 0), map_range_clamp(hue, 60.0, 120.0, 0.0, 1.0));\n    col = mix(col, vec3(0, 1, 1), map_range_clamp(hue, 120.0, 180.0, 0.0, 1.0));\n    col = mix(col, vec3(0, 0, 1), map_range_clamp(hue, 180.0, 240.0, 0.0, 1.0));\n    col = mix(col, vec3(1, 0, 1), map_range_clamp(hue, 240.0, 300.0, 0.0, 1.0));\n    col = mix(col, vec3(1, 0, 0), map_range_clamp(hue, 300.0, 360.0, 0.0, 1.0));\n    \n    return col;\n}\n\nfloat rgb_variance(vec3 a, vec3 b)\n{\n    a = max(a, 0.0);\n    b = max(b, 0.0);\n    \n    a += 0.001;\n    b += 0.001;\n    \n    float v = dot(abs(log2(a / b)), vec3(0.3, 0.59, 0.11));\n    return v*v;\n}\n\n#endif\n\n// -----------------------------------------------\n// End\n// -----------------------------------------------\n\n\n\n// -----------------------------------------------\n// Keyboard Utils\n// -----------------------------------------------\n\n#if KEYBOARD_UTILS\n\n#define KEY_BACKSPACE 8\n#define KEY_TAB 9\n#define KEY_ENTER 13\n#define KEY_SHIFT 16\n#define KEY_CTRL 17\n#define KEY_ALT 18\n#define KEY_PAUSE_BREAK 19\n#define KEY_CAPS_LOCK 20\n#define KEY_ESC 27\n#define KEY_SPACE 32\n#define KEY_PAGE_UP 33\n#define KEY_PAGE_DOWN 34\n#define KEY_END 35\n#define KEY_HOME 36\n#define KEY_LEFT 37\n#define KEY_UP 38\n#define KEY_RIGHT 39\n#define KEY_DOWN 40\n#define KEY_PRINT_SCREEN 44\n#define KEY_INSERT 45\n#define KEY_DELETE 46\n#define KEY_0 48\n#define KEY_1 49\n#define KEY_2 50\n#define KEY_3 51\n#define KEY_4 52\n#define KEY_5 53\n#define KEY_6 54\n#define KEY_7 55\n#define KEY_8 56\n#define KEY_9 57\n#define KEY_A 65\n#define KEY_B 66\n#define KEY_C 67\n#define KEY_D 68\n#define KEY_E 69\n#define KEY_F 70\n#define KEY_G 71\n#define KEY_H 72\n#define KEY_I 73\n#define KEY_J 74\n#define KEY_K 75\n#define KEY_L 76\n#define KEY_M 77\n#define KEY_N 78\n#define KEY_O 79\n#define KEY_P 80\n#define KEY_Q 81\n#define KEY_R 82\n#define KEY_S 83\n#define KEY_T 84\n#define KEY_U 85\n#define KEY_V 86\n#define KEY_W 87\n#define KEY_X 88\n#define KEY_Y 89\n#define KEY_Z 90\n#define KEY_LWIN 91\n#define KEY_RWIN 92\n#define KEY_POPUP 93\n#define KEY_NUMPAD_0 96\n#define KEY_NUMPAD_1 97\n#define KEY_NUMPAD_2 98\n#define KEY_NUMPAD_3 99\n#define KEY_NUMPAD_4 100\n#define KEY_NUMPAD_5 101\n#define KEY_NUMPAD_6 102\n#define KEY_NUMPAD_7 103\n#define KEY_NUMPAD_8 104\n#define KEY_NUMPAD_9 105\n#define KEY_NUMPAD_ASTERISK 106 \n#define KEY_NUMPAD_PLUS 107\n#define KEY_NUMPAD_MINUS 109\n#define KEY_NUMPAD_PERIOD 110\n#define KEY_NUMPAD_SLASH 111\n#define KEY_F1 112\n#define KEY_F2 113\n#define KEY_F3 114\n#define KEY_F4 115\n#define KEY_F5 116\n#define KEY_F6 117\n#define KEY_F7 118\n#define KEY_F8 119\n#define KEY_F9 120\n#define KEY_F10 121\n#define KEY_F11 122\n#define KEY_F12 123\n#define KEY_NUM_LOCK 144\n#define KEY_SCROLL_LOCK 145\n#define KEY_LSHIFT 160\n#define KEY_RSHIFT 161\n#define KEY_LCTRL 162\n#define KEY_RCTRL 163\n\nbool key_is_down(int key, sampler2D keyboard_channel)\n{\n    return texelFetch(keyboard_channel, ivec2(key, 0), 0).x != 0.0;\n}\n\nbool key_got_pressed(int key, sampler2D keyboard_channel)\n{\n    return texelFetch(keyboard_channel, ivec2(key, 1), 0).x != 0.0;\n}\n\nbool key_toggle_state(int key, sampler2D keyboard_channel)\n{\n    return texelFetch(keyboard_channel, ivec2(key, 2), 0).x != 0.0;\n}\n\nfloat fkey_is_down(int key, sampler2D keyboard_channel)\n{\n    return key_is_down(key, keyboard_channel) ? 1.0 : 0.0;\n}\n\nfloat fkey_got_pressed(int key, sampler2D keyboard_channel)\n{\n    return key_got_pressed(key, keyboard_channel) ? 1.0 : 0.0;\n}\n\nfloat fkey_toggle_state(int key, sampler2D keyboard_channel)\n{\n    return key_toggle_state(key, keyboard_channel) ? 1.0 : 0.0;\n}\n\n#endif\n\n// -----------------------------------------------\n// End\n// -----------------------------------------------\n\n\n\nstruct ray_info\n{\n    vec3 orig;\n    vec3 dir;\n    bool hit;\n    vec3 pos;\n    vec3 normal;\n};\n\nvoid ray_sphere(float radius, inout ray_info r)\n{\n    // Quadratic equation\n    float a = dot(r.dir, r.dir);\n    float b = 2.0 * dot(r.orig, r.dir);\n    float c = dot(r.orig, r.orig) - radius*radius;\n    float discriminant = (b * b) - (4.0 * a * c);\n    \n    if (discriminant < 0.0)\n    {\n        // No hits\n        r.hit = false;\n        return;\n    }\n    \n    float sqrt_d = sqrt(discriminant);\n    float t1 = (-b - sqrt_d) / (2.0 * a);\n    float t2 = (-b + sqrt_d) / (2.0 * a);\n    \n    if (t1 < 0.0 && t2 < 0.0)\n    {\n        // Fully behind the origin\n        r.hit = false;\n        return;\n    }\n    \n    if (t1 < 0.0)\n    {\n        // Partially behind the origin\n        r.hit = true;\n        r.pos = r.orig + (t2 * r.dir);\n    }\n    else\n    {\n        // Fully in front\n        r.hit = true;\n        r.pos = r.orig + (t1 * r.dir);\n    }\n    \n    // Normal\n    r.normal = r.pos / radius;\n}\n",
     "name": "Common",
     "description": "",
     "type": "common"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "dlfcD8",
    "date": "1692139870",
    "viewed": 299,
    "name": "Path Tracing name already in use",
    "description": "Good old naive path tracing",
    "likes": 7,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "3d",
     "raytracing",
     "lighting",
     "sphere",
     "pathtracing"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "/* -----------------------------------------------\n  Shadertoy Unit: Image\n  Description: Output\n  iChannel0: Buffer A\n  iChannel1: Buffer B\n  iChannel2: None\n  iChannel3: None\n----------------------------------------------- */\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    // Skip the bottom row of pixels (data row)\n    if (int(frag_coord.y) < 1)\n    {\n        frag_col = vec4(0, 0, 0, 1);\n        return;\n    }\n    \n    // Read the data from Buffer A\n    vec3 col = texelFetch(iChannel0, ivec2(frag_coord), 0).xyz;\n    \n    // flim\n    col = flim_transform(col, 4., iChannel1);\n    \n    // Output\n    frag_col = vec4(col, 1.);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "/* -----------------------------------------------\n  Shadertoy Unit: Common\n----------------------------------------------- */\n\n\n\n// -----------------------------------------------\n// Math Utils\n// -----------------------------------------------\n\n#define PI 3.1415926535897932384626433832\n#define TAU 6.283185307179586476925286766\n#define PI_OVER_2 1.57079632679489661923132169163\n#define DEG_TO_RAD 0.01745329251994329576923690768\n#define RAD_TO_DEG 57.2957795130823208767981548141\n\n#define FUNC_LERP(T) \\\nT lerp(T a, T b, float t) \\\n{ \\\n    return a + t*(b-a); \\\n}\n\n#define FUNC_WRAP(T) \\\nT wrap(T inp, float start, float end) \\\n{ \\\n    return start + mod(inp - start, end - start); \\\n}\n\n#define FUNC_REMAP(T) \\\nT remap(T inp, float inp_start, float inp_end, float out_start, float out_end) \\\n{ \\\n    return out_start + ((out_end - out_start) / (inp_end - inp_start)) * (inp - inp_start); \\\n}\n\n#define FUNC_REMAP_CLAMP(T) \\\nT remap_clamp(T inp, float inp_start, float inp_end, float out_start, float out_end) \\\n{ \\\n    T t = clamp((inp - inp_start) / (inp_end - inp_start), 0.0, 1.0); \\\n    return out_start + t * (out_end - out_start); \\\n}\n\nFUNC_LERP(float)\nFUNC_LERP(vec2)\nFUNC_LERP(vec3)\nFUNC_LERP(vec4)\n\nFUNC_WRAP(float)\nFUNC_WRAP(vec2)\nFUNC_WRAP(vec3)\nFUNC_WRAP(vec4)\n\nFUNC_REMAP(float)\nFUNC_REMAP(vec2)\nFUNC_REMAP(vec3)\nFUNC_REMAP(vec4)\n\nFUNC_REMAP_CLAMP(float)\nFUNC_REMAP_CLAMP(vec2)\nFUNC_REMAP_CLAMP(vec3)\nFUNC_REMAP_CLAMP(vec4)\n\n// -----------------------------------------------\n// End\n// -----------------------------------------------\n\n\n\n// -----------------------------------------------\n// Pseudo-Random Number Generator\n// Source: https://www.shadertoy.com/view/WdSSRt\n// -----------------------------------------------\n\n/* Usage Example:\n    void mainImage(out vec4 frag_col, in vec2 frag_coord)\n    {\n        // Initialize PRNG\n        prng_init(vec3(frag_coord / iResolution.y, iTime));\n    \n        // Using the function\n        float a = random();\n        vec3 b = vec3(random(), random(), random());\n        \n        ...\n    }\n*/\n\nuint prng_state[2];\n\nuint prng_rot(uint x, int k)\n{\n    return (x << k) | (x >> (32 - k));\n}\n\nfloat random()\n{\n    uint s0 = prng_state[0];\n    uint s1 = prng_state[1];\n    uint result = prng_rot(s0 * 0x9e3779bbu, 5) * 5u;\n    s1 ^= s0;\n    prng_state[0] = prng_rot(s0, 26) ^ s1 ^ (s1 << 9);\n    prng_state[1] = prng_rot(s1, 13);\n    return float(result) / float(0xffffffffu);\n}\n\nvoid prng_init(vec3 seed)\n{\n    seed.xy *= (seed.z + 10.258);\n    seed += 3.49276101561702;\n    prng_state[0] = floatBitsToUint(seed.x);\n    prng_state[1] = floatBitsToUint(seed.y);\n    random();\n}\n\n// -----------------------------------------------\n// End\n// -----------------------------------------------\n\n\n\n// -----------------------------------------------\n// Additional Color Utils (most functions are in flim)\n// -----------------------------------------------\n\nconst vec3 lum_linear_bt709 = vec3(0.2126, 0.7152, 0.0722);\n\nfloat rgb_variance(vec3 a, vec3 b)\n{\n    a = max(a, 0.0);\n    b = max(b, 0.0);\n    \n    a += 0.001;\n    b += 0.001;\n    \n    float v = dot(abs(log2(a / b)), vec3(0.3, 0.59, 0.11));\n    return v*v;\n}\n\n// -----------------------------------------------\n// End\n// -----------------------------------------------\n\n\n\n// -----------------------------------------------\n// Keyboard Utils\n// -----------------------------------------------\n\n#define KEY_BACKSPACE 8\n#define KEY_TAB 9\n#define KEY_ENTER 13\n#define KEY_SHIFT 16\n#define KEY_CTRL 17\n#define KEY_ALT 18\n#define KEY_PAUSE_BREAK 19\n#define KEY_CAPS_LOCK 20\n#define KEY_ESC 27\n#define KEY_SPACE 32\n#define KEY_PAGE_UP 33\n#define KEY_PAGE_DOWN 34\n#define KEY_END 35\n#define KEY_HOME 36\n#define KEY_LEFT 37\n#define KEY_UP 38\n#define KEY_RIGHT 39\n#define KEY_DOWN 40\n#define KEY_PRINT_SCREEN 44\n#define KEY_INSERT 45\n#define KEY_DELETE 46\n#define KEY_0 48\n#define KEY_1 49\n#define KEY_2 50\n#define KEY_3 51\n#define KEY_4 52\n#define KEY_5 53\n#define KEY_6 54\n#define KEY_7 55\n#define KEY_8 56\n#define KEY_9 57\n#define KEY_A 65\n#define KEY_B 66\n#define KEY_C 67\n#define KEY_D 68\n#define KEY_E 69\n#define KEY_F 70\n#define KEY_G 71\n#define KEY_H 72\n#define KEY_I 73\n#define KEY_J 74\n#define KEY_K 75\n#define KEY_L 76\n#define KEY_M 77\n#define KEY_N 78\n#define KEY_O 79\n#define KEY_P 80\n#define KEY_Q 81\n#define KEY_R 82\n#define KEY_S 83\n#define KEY_T 84\n#define KEY_U 85\n#define KEY_V 86\n#define KEY_W 87\n#define KEY_X 88\n#define KEY_Y 89\n#define KEY_Z 90\n#define KEY_LWIN 91\n#define KEY_RWIN 92\n#define KEY_POPUP 93\n#define KEY_NUMPAD_0 96\n#define KEY_NUMPAD_1 97\n#define KEY_NUMPAD_2 98\n#define KEY_NUMPAD_3 99\n#define KEY_NUMPAD_4 100\n#define KEY_NUMPAD_5 101\n#define KEY_NUMPAD_6 102\n#define KEY_NUMPAD_7 103\n#define KEY_NUMPAD_8 104\n#define KEY_NUMPAD_9 105\n#define KEY_NUMPAD_ASTERISK 106 \n#define KEY_NUMPAD_PLUS 107\n#define KEY_NUMPAD_MINUS 109\n#define KEY_NUMPAD_PERIOD 110\n#define KEY_NUMPAD_SLASH 111\n#define KEY_F1 112\n#define KEY_F2 113\n#define KEY_F3 114\n#define KEY_F4 115\n#define KEY_F5 116\n#define KEY_F6 117\n#define KEY_F7 118\n#define KEY_F8 119\n#define KEY_F9 120\n#define KEY_F10 121\n#define KEY_F11 122\n#define KEY_F12 123\n#define KEY_NUM_LOCK 144\n#define KEY_SCROLL_LOCK 145\n#define KEY_LSHIFT 160\n#define KEY_RSHIFT 161\n#define KEY_LCTRL 162\n#define KEY_RCTRL 163\n\nbool key_is_down(int key, sampler2D keyboard_channel)\n{\n    return texelFetch(keyboard_channel, ivec2(key, 0), 0).x != 0.0;\n}\n\nbool key_got_pressed(int key, sampler2D keyboard_channel)\n{\n    return texelFetch(keyboard_channel, ivec2(key, 1), 0).x != 0.0;\n}\n\nbool key_toggle_state(int key, sampler2D keyboard_channel)\n{\n    return texelFetch(keyboard_channel, ivec2(key, 2), 0).x != 0.0;\n}\n\nfloat fkey_is_down(int key, sampler2D keyboard_channel)\n{\n    return key_is_down(key, keyboard_channel) ? 1.0 : 0.0;\n}\n\nfloat fkey_got_pressed(int key, sampler2D keyboard_channel)\n{\n    return key_got_pressed(key, keyboard_channel) ? 1.0 : 0.0;\n}\n\nfloat fkey_toggle_state(int key, sampler2D keyboard_channel)\n{\n    return key_toggle_state(key, keyboard_channel) ? 1.0 : 0.0;\n}\n\n// -----------------------------------------------\n// End\n// -----------------------------------------------\n\n\n\n/***********************************\n\nflim - Filmic Color Transform\n\nInput Color Space:   Linear BT.709 I-D65\nOutput Color Space:  sRGB 2.2\n\nShadertoy Unit:\n  Common\n\nDescription:\n  Experimental port of flim for GLSL/Shadertoy\n  matching flim v1.1.0.\n  The common unit contains most of the code, and\n  receives gamut extension matrices from a buffer.\n\nAuthor:\n  Bean (beans_please on Shadertoy)\n\nOriginal Repo:\n  https://github.com/bean-mhm/flim\n\nOriginal Shader:\n  https://www.shadertoy.com/view/dd2yDz\n\n***********************************/\n\n// Parameters\n\nconst float flim_pre_exposure = 4.3;\nconst vec3 flim_pre_formation_filter = vec3(1.0);\nconst float flim_pre_formation_filter_strength = 0.0;\n\nconst float flim_extended_gamut_red_scale = 1.05;\nconst float flim_extended_gamut_green_scale = 1.12;\nconst float flim_extended_gamut_blue_scale = 1.045;\nconst float flim_extended_gamut_red_rot = 0.5;\nconst float flim_extended_gamut_green_rot = 2.0;\nconst float flim_extended_gamut_blue_rot = 0.1;\nconst float flim_extended_gamut_red_mul = 1.0;\nconst float flim_extended_gamut_green_mul = 1.0;\nconst float flim_extended_gamut_blue_mul = 1.0;\n\nconst float flim_sigmoid_log2_min = -10.0;\nconst float flim_sigmoid_log2_max = 22.0;\nconst float flim_sigmoid_toe_x = 0.44;\nconst float flim_sigmoid_toe_y = 0.28;\nconst float flim_sigmoid_shoulder_x = 0.591;\nconst float flim_sigmoid_shoulder_y = 0.779;\n\nconst float flim_negative_film_exposure = 6.0;\nconst float flim_negative_film_density = 5.0;\n\nconst vec3 flim_print_backlight = vec3(1.0);\nconst float flim_print_film_exposure = 6.0;\nconst float flim_print_film_density = 27.5;\n\nconst float flim_black_point = -1.0; // -1 = auto\nconst vec3 flim_post_formation_filter = vec3(1.0);\nconst float flim_post_formation_filter_strength = 0.0;\nconst float flim_midtone_saturation = 1.02;\n\n// -------------------------------\n\nvec3 blender_rgb_to_hsv(vec3 rgb)\n{\n    float cmax, cmin, h, s, v, cdelta;\n    vec3 c;\n\n    cmax = max(rgb[0], max(rgb[1], rgb[2]));\n    cmin = min(rgb[0], min(rgb[1], rgb[2]));\n    cdelta = cmax - cmin;\n\n    v = cmax;\n    if (cmax != 0.0)\n    {\n        s = cdelta / cmax;\n    }\n    else\n    {\n        s = 0.0;\n        h = 0.0;\n    }\n\n    if (s == 0.0)\n    {\n        h = 0.0;\n    }\n    else\n    {\n        c = (vec3(cmax) - rgb.xyz) / cdelta;\n\n        if (rgb.x == cmax)\n        {\n            h = c[2] - c[1];\n        }\n        else if (rgb.y == cmax)\n        {\n            h = 2.0 + c[0] - c[2];\n        }\n        else\n        {\n            h = 4.0 + c[1] - c[0];\n        }\n\n        h /= 6.0;\n\n        if (h < 0.0)\n        {\n            h += 1.0;\n        }\n    }\n\n    return vec3(h, s, v);\n}\n\nvec3 blender_hsv_to_rgb(vec3 hsv)\n{\n    float i, f, p, q, t, h, s, v;\n    vec3 rgb;\n\n    h = hsv[0];\n    s = hsv[1];\n    v = hsv[2];\n\n    if (s == 0.0)\n    {\n        rgb = vec3(v, v, v);\n    }\n    else\n    {\n        if (h == 1.0)\n        {\n            h = 0.0;\n        }\n\n        h *= 6.0;\n        i = floor(h);\n        f = h - i;\n        rgb = vec3(f, f, f);\n        p = v * (1.0 - s);\n        q = v * (1.0 - (s * f));\n        t = v * (1.0 - (s * (1.0 - f)));\n\n        if (i == 0.0)\n        {\n            rgb = vec3(v, t, p);\n        }\n        else if (i == 1.0)\n        {\n            rgb = vec3(q, v, p);\n        }\n        else if (i == 2.0)\n        {\n            rgb = vec3(p, v, t);\n        }\n        else if (i == 3.0)\n        {\n            rgb = vec3(p, q, v);\n        }\n        else if (i == 4.0)\n        {\n            rgb = vec3(t, p, v);\n        }\n        else\n        {\n            rgb = vec3(v, p, q);\n        }\n    }\n\n    return rgb;\n}\n\nvec3 blender_hue_sat(vec3 col, float hue, float sat, float value)\n{\n    vec3 hsv = blender_rgb_to_hsv(col);\n\n    hsv[0] = fract(hsv[0] + hue + 0.5);\n    hsv[1] = clamp(hsv[1] * sat, 0.0, 1.0);\n    hsv[2] = hsv[2] * value;\n\n    return blender_hsv_to_rgb(hsv);\n}\n\nfloat rgb_avg(vec3 inp)\n{\n    return (inp.x + inp.y + inp.z) / 3.0;\n}\n\nfloat rgb_sum(vec3 inp)\n{\n    return inp.x + inp.y + inp.z;\n}\n\nfloat rgb_max(vec3 inp)\n{\n    return max(max(inp.x, inp.y), inp.z);\n}\n\nfloat rgb_min(vec3 inp)\n{\n    return min(min(inp.x, inp.y), inp.z);\n}\n\nvec3 rgb_uniform_offset(vec3 inp, float black_point, float white_point)\n{\n    float mono = rgb_avg(inp);\n    float mono2 = remap_clamp(mono, black_point / 1000.0, 1.0 - (white_point / 1000.0), 0.0, 1.0);\n    return inp * (mono2 / mono);\n}\n\nvec3 rgb_sweep(float hue)\n{\n    hue = wrap(hue * 360.0, 0.0, 360.0);\n\n    vec3 col = vec3(1, 0, 0);\n    col = mix(col, vec3(1, 1, 0), remap_clamp(hue, 0.0, 60.0, 0.0, 1.0));\n    col = mix(col, vec3(0, 1, 0), remap_clamp(hue, 60.0, 120.0, 0.0, 1.0));\n    col = mix(col, vec3(0, 1, 1), remap_clamp(hue, 120.0, 180.0, 0.0, 1.0));\n    col = mix(col, vec3(0, 0, 1), remap_clamp(hue, 180.0, 240.0, 0.0, 1.0));\n    col = mix(col, vec3(1, 0, 1), remap_clamp(hue, 240.0, 300.0, 0.0, 1.0));\n    col = mix(col, vec3(1, 0, 0), remap_clamp(hue, 300.0, 360.0, 0.0, 1.0));\n    \n    return col;\n}\n\n// -------------------------------\n\nvec3 flim_rgb_sweep(vec2 uv0to1)\n{\n    float hue = 1.0 - uv0to1.y;\n    float exposure = remap(uv0to1.x, 0.0, 1.0, -5.0, 10.0);\n    return rgb_sweep(hue) * pow(2.0, exposure);\n}\n\n// https://www.desmos.com/calculator/khkztixyeu\nfloat flim_super_sigmoid(float inp, float toe_x, float toe_y, float shoulder_x, float shoulder_y)\n{\n    // Clip\n    inp = clamp(inp, 0.0, 1.0);\n    toe_x = clamp(toe_x, 0.0, 1.0);\n    toe_y = clamp(toe_y, 0.0, 1.0);\n    shoulder_x = clamp(shoulder_x, 0.0, 1.0);\n    shoulder_y = clamp(shoulder_y, 0.0, 1.0);\n\n    // Calculate straight line slope\n    float slope = (shoulder_y - toe_y) / (shoulder_x - toe_x);\n\n    // Toe\n    if (inp < toe_x)\n    {\n        float toe_pow = slope * toe_x / toe_y;\n        return toe_y * pow(inp / toe_x, toe_pow);\n    }\n\n    // Straight line\n    if (inp < shoulder_x)\n    {\n        float intercept = toe_y - (slope * toe_x);\n        return slope * inp + intercept;\n    }\n\n    // Shoulder\n    float shoulder_pow = -slope / (((shoulder_x - 1.0) / pow(1.0 - shoulder_x, 2.0)) * (1.0 - shoulder_y));\n    return (1.0 - pow(1.0 - (inp - shoulder_x) / (1.0 - shoulder_x), shoulder_pow)) * (1.0 - shoulder_y) + shoulder_y;\n}\n\nfloat flim_dye_mix_factor(float mono, float max_density)\n{\n    // log2 and map range\n    float offset = pow(2.0, flim_sigmoid_log2_min);\n    float fac = remap_clamp(log2(mono + offset), flim_sigmoid_log2_min, flim_sigmoid_log2_max, 0.0, 1.0);\n\n    // Calculate amount of exposure from 0 to 1\n    fac = flim_super_sigmoid(fac, flim_sigmoid_toe_x, flim_sigmoid_toe_y, flim_sigmoid_shoulder_x, flim_sigmoid_shoulder_y);\n\n    // Calculate dye density\n    fac *= max_density;\n\n    // Mix factor\n    fac = pow(2.0, -fac);\n\n    // Clip and return\n    return clamp(fac, 0.0, 1.0);\n}\n\nvec3 flim_rgb_color_layer(vec3 inp, vec3 sensitivity_tone, vec3 dye_tone, float max_density)\n{\n    // Normalize\n    vec3 sensitivity_tone_norm = sensitivity_tone / rgb_sum(sensitivity_tone);\n    vec3 dye_tone_norm = dye_tone / rgb_max(dye_tone);\n\n    // Dye mix factor\n    float mono = dot(inp, sensitivity_tone_norm);\n    float mixFac = flim_dye_mix_factor(mono, max_density);\n\n    // Dye mixing\n    return lerp(dye_tone_norm, vec3(1.0), mixFac);\n}\n\nvec3 flim_rgb_develop(vec3 inp, float exposure, float max_density)\n{\n    // Exposure\n    inp *= pow(2.0, exposure);\n\n    // Blue-sensitive layer\n    vec3 result = flim_rgb_color_layer(inp, vec3(0, 0, 1), vec3(1, 1, 0), max_density);\n\n    // Green-sensitive layer\n    result *= flim_rgb_color_layer(inp, vec3(0, 1, 0), vec3(1, 0, 1), max_density);\n\n    // Red-sensitive layer\n    result *= flim_rgb_color_layer(inp, vec3(1, 0, 0), vec3(0, 1, 1), max_density);\n\n    return result;\n}\n\nvec3 flim_gamut_extension_mat_row(float primary_hue, float scale, float rotate, float mul)\n{\n    vec3 result = blender_hsv_to_rgb(vec3(wrap(primary_hue + (rotate / 360.0), 0.0, 1.0), 1.0 / scale, 1.0));\n    result /= rgb_sum(result);\n    result *= mul;\n    return result;\n}\n\nmat3 flim_gamut_extension_mat(\n    float red_scale,\n    float green_scale,\n    float blue_scale,\n    float red_rot,\n    float green_rot,\n    float blue_rot,\n    float red_mul,\n    float green_mul,\n    float blue_mul\n)\n{\n    mat3 m;\n    m[0] = flim_gamut_extension_mat_row(0.0, red_scale, red_rot, red_mul);\n    m[1] = flim_gamut_extension_mat_row(1.0 / 3.0, green_scale, green_rot, green_mul);\n    m[2] = flim_gamut_extension_mat_row(2.0 / 3.0, blue_scale, blue_rot, blue_mul);\n    return m;\n}\n\nvec3 negative_and_print(vec3 inp, vec3 backlight_ext)\n{\n    // Develop Negative\n    inp = flim_rgb_develop(inp, flim_negative_film_exposure, flim_negative_film_density);\n\n    // Backlight\n    inp *= backlight_ext;\n\n    // Develop Print\n    inp = flim_rgb_develop(inp, flim_print_film_exposure, flim_print_film_density);\n\n    return inp;\n}\n\nbool flim_load_matrices(sampler2D matrix_ch, out mat3 extend_mat, out mat3 extend_mat_inv)\n{\n    // W == valid_w means the matrices have been calculated\n    // in the source buffer.\n    const float valid_w = 2.0;\n\n    vec4 row;\n\n    // extend_mat\n    {\n        row = texelFetch(matrix_ch, ivec2(0, 0), 0);\n        if (row.w != valid_w)\n            return false;\n        extend_mat[0] = row.xyz;\n\n        row = texelFetch(matrix_ch, ivec2(1, 0), 0);\n        if (row.w != valid_w)\n            return false;\n        extend_mat[1] = row.xyz;\n\n        row = texelFetch(matrix_ch, ivec2(2, 0), 0);\n        if (row.w != valid_w)\n            return false;\n        extend_mat[2] = row.xyz;\n    }\n\n    // extend_mat_inv\n    {\n        row = texelFetch(matrix_ch, ivec2(3, 0), 0);\n        if (row.w != valid_w)\n            return false;\n        extend_mat_inv[0] = row.xyz;\n\n        row = texelFetch(matrix_ch, ivec2(4, 0), 0);\n        if (row.w != valid_w)\n            return false;\n        extend_mat_inv[1] = row.xyz;\n\n        row = texelFetch(matrix_ch, ivec2(5, 0), 0);\n        if (row.w != valid_w)\n            return false;\n        extend_mat_inv[2] = row.xyz;\n    }\n\n    return true;\n}\n\n// -------------------------------\n\n// matrix_ch: Which channel provides the buffer\n// containing gamut extension matrices?\nvec3 flim_transform(vec3 inp, float exposure, sampler2D matrix_ch)\n{\n    // Eliminate negative values\n    inp = max(inp, 0.0);\n\n    // Pre-Exposure\n    inp *= pow(2.0, flim_pre_exposure + exposure);\n\n    // Clip very large values for float precision reasons\n    inp = min(inp, 5000.0);\n\n    // Gamut Extension Matrix (Linear BT.709)\n    mat3 extend_mat, extend_mat_inv;\n    if (!flim_load_matrices(matrix_ch, extend_mat, extend_mat_inv))\n    {\n        return vec3(1, 0, 1);\n    }\n\n    // Backlight (extended gamut)\n    vec3 backlight_ext = flim_print_backlight * extend_mat;\n\n    // Upper limit in the print (highlight cap)\n    const float big = 10000000.0;\n    vec3 white_cap = negative_and_print(vec3(big, big, big), backlight_ext);\n\n    // Pre-Formation Filter\n    inp = lerp(inp, inp * flim_pre_formation_filter, flim_pre_formation_filter_strength);\n\n    // Convert to extended gamut\n    inp *= extend_mat;\n\n    // Negative & Print\n    inp = negative_and_print(inp, backlight_ext);\n\n    // Convert from extended gamut\n    inp *= extend_mat_inv;\n\n    // Eliminate negative values\n    inp = max(inp, 0.0);\n\n    // White cap\n    inp /= white_cap;\n\n    // Black cap\n    if (flim_black_point == -1.0) // -1 = auto\n    {\n        vec3 black_cap = negative_and_print(vec3(0.0), backlight_ext);\n        black_cap /= white_cap;\n        inp = rgb_uniform_offset(inp, rgb_avg(black_cap) * 1000.0, 0.0);\n    }\n    else\n    {\n        inp = rgb_uniform_offset(inp, flim_black_point, 0.0);\n    }\n\n    // Post-Formation Filter\n    inp = lerp(inp, inp * flim_post_formation_filter, flim_post_formation_filter_strength);\n\n    // Clip\n    inp = clamp(inp, 0.0, 1.0);\n\n    // Midtone Saturation\n    float mono = rgb_avg(inp);\n    float mixFac = (mono < 0.5) ? remap_clamp(mono, 0.05, 0.5, 0.0, 1.0) : remap_clamp(mono, 0.5, 0.95, 1.0, 0.0);\n    inp = lerp(inp, blender_hue_sat(inp, 0.5, flim_midtone_saturation, 1.0), mixFac);\n\n    // Clip\n    inp = clamp(inp, 0.0, 1.0);\n\n    // OETF (Gamma 2.2)\n    inp = pow(inp, vec3(1.0 / 2.2));\n\n    return inp;\n}\n\n/***********************************\n\nEnd of flim's implementation for Shadertoy Unit: Common\n\n***********************************/\n\n\n\nvec3 random_unit_vector()\n{\n    vec3 v = vec3(1);\n    float lensqr;\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec3(2. * random() - 1., 2. * random() - 1., 2. * random() - 1.);\n        lensqr = dot(v, v);\n        if (lensqr <= 1.) break;\n    }\n    return v / sqrt(lensqr);\n}\n\nvec3 random_in_sphere()\n{\n    vec3 v = vec3(1);\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec3(2. * random() - 1., 2. * random() - 1., 2. * random() - 1.);\n        if (dot(v, v) <= 1.) return v;\n    }\n    return v;\n}\n\nvec2 random_in_circle()\n{\n    vec2 v = vec2(1);\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec2(2. * random() - 1., 2. * random() - 1.);\n        if (dot(v, v) <= 1.) return v;\n    }\n    return v;\n}\n\n// Basic perspective camera\nstruct cam_t\n{\n    vec3 pos;\n    float fov;\n    float internal_zoom;\n    vec3 internal_forward;\n    vec3 internal_right;\n    vec3 internal_up;\n};\n\n// Ray\nstruct ray_t\n{\n    vec3 orig;\n    vec3 dir;\n};\n\n// Hit info\nstruct hit_t\n{\n    bool hit;\n    float t;\n    vec3 pos;\n    vec3 normal;\n    int mat_id;\n};\n\n// Material info\nstruct mat_t\n{\n    vec3 diffuse;\n    float roughness;\n    vec3 emission;\n    bool no_bounce;\n};\n\n// Ray offset\nconst float ray_offset = .001;\n\n// cam_t: Update internal zoom factor\nvoid cam_update_zoom(inout cam_t cam)\n{\n    cam.internal_zoom = 90. / cam.fov;\n}\n\n// cam_t: Look at a point\nvoid cam_look_at(inout cam_t cam, vec3 look_at)\n{\n    cam.internal_forward = normalize(vec3(0., 0., 1.) - cam.pos);\n    cam.internal_right = normalize(cross(cam.internal_forward, vec3(0, 0, 1)));\n    cam.internal_up = cross(cam.internal_right, cam.internal_forward);\n}\n\n// cam_t: Generate a camera ray for a given set of UV coords\nray_t cam_gen_ray(in cam_t cam, vec2 uv)\n{\n    ray_t r;\n    r.orig = cam.pos;\n    r.dir = normalize(\n        cam.internal_forward\n        + cam.internal_right * (uv.x / cam.internal_zoom)\n        + cam.internal_up * (uv.y / cam.internal_zoom)\n    );\n    return r;\n}\n\n// cam_t: Generate a camera ray for a given set of UV coords (includes DOF)\nray_t cam_gen_ray_dof(in cam_t cam, vec2 uv, float focus_dist, float jitter)\n{\n    // Generate normal ray without normalizing the direction\n    ray_t r;\n    r.orig = cam.pos;\n    r.dir =\n        cam.internal_forward\n        + cam.internal_right * (uv.x / cam.internal_zoom)\n        + cam.internal_up * (uv.y / cam.internal_zoom);\n    \n    // Focal point\n    vec3 fp = r.orig + focus_dist * r.dir;\n    \n    // Randomly offset the ray origin\n    vec2 offs = jitter * random_in_circle();\n    r.orig += cam.internal_right * offs.x + cam.internal_up * offs.y;\n    \n    // Look at the focal point again\n    r.dir = normalize(fp - r.orig);\n    \n    return r;\n}\n\n// https://www.reddit.com/r/opengl/comments/8ntzz5/comment/dzyqwgr\nvoid ray_aabb(int mat_id, const vec3 box_min, const vec3 box_max, in ray_t r, out hit_t h) {\n    vec3 inv_dir = 1.0 / r.dir;\n    vec3 tbot = inv_dir * (box_min - r.orig);\n    vec3 ttop = inv_dir * (box_max - r.orig);\n    vec3 tmin = min(ttop, tbot);\n    vec3 tmax = max(ttop, tbot);\n    vec2 t = max(tmin.xx, tmin.yz);\n    float t0 = max(t.x, t.y);\n    t = min(tmax.xx, tmax.yz);\n    float t1 = min(t.x, t.y);\n    if (t1 > max(t0, 0.0))\n    {\n        h.hit = true;\n        h.t = t0;\n        h.pos = r.orig + r.dir * t0;\n        h.normal = vec3(0.0, 0.0, 1.0); // what's the proper way? please comment\n        \n        // Material ID\n        h.mat_id = mat_id;\n    }\n}\n\nvoid ray_sphere(int mat_id, const vec3 center, const float radius, in ray_t r, out hit_t h)\n{\n    vec3 ro = r.orig - center;\n    \n    // Quadratic equation\n    float a = dot(r.dir, r.dir);\n    float b = 2.0 * dot(ro, r.dir);\n    float c = dot(ro, ro) - radius*radius;\n    float discriminant = (b * b) - (4.0 * a * c);\n    \n    if (discriminant < 0.0)\n    {\n        // No hits\n        h.hit = false;\n        return;\n    }\n    \n    float sqrt_d = sqrt(discriminant);\n    float t = (-b - sqrt_d) / (2.0 * a);\n    \n    if (t < 0.0)\n    {\n        h.hit = false;\n        return;\n    }\n    \n    h.hit = true;\n    h.t = t;\n    h.pos = r.orig + (t * r.dir);\n    \n    // Normal\n    h.normal = (h.pos - center) / radius;\n    \n    // Material ID\n    h.mat_id = mat_id;\n}\n",
     "name": "Common",
     "description": "",
     "type": "common"
    },
    {
     "inputs": [
      {
       "id": "XsfGzn",
       "filepath": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg",
       "type": "cubemap",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "clamp",
        "vflip": "false",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "/* -----------------------------------------------\n  Shadertoy Unit: Buffer A\n  Description: Rendering\n  iChannel0: Cubemap\n  iChannel1: Buffer A (self-feeding)\n  iChannel2: None\n  iChannel3: None\n----------------------------------------------- */\n\n// Sample the environment\nvec3 get_env(vec3 dir)\n{\n    return .02 * pow(texture(iChannel0, dir.xzy).xyz, vec3(2.2));\n}\n\n// Materials\nvoid get_mat(int id, out mat_t m)\n{\n    // Default values\n    m.diffuse = vec3(1);\n    m.roughness = 1.;\n    m.emission = vec3(0);\n    m.no_bounce = false;\n\n    // Ground\n    if (id == 0)\n    {\n        m.diffuse = vec3(.6);\n        m.roughness = .9;\n        return;\n    }\n    \n    // Sphere 1\n    if (id == 1)\n    {\n        m.diffuse = vec3(.1, .25, .9);\n        m.roughness = .9;\n        return;\n    }\n    \n    // Sphere 2\n    if (id == 2)\n    {\n        m.diffuse = vec3(.9, .05, .01);\n        m.roughness = .12;\n        return;\n    }\n    \n    // LEDs\n    if (id >= 3 && id <= 7)\n    {\n        float hue = .1 * iTime +  247.34 * float(id - 3) / 4.;\n        m.emission = 10. * rgb_sweep(hue);\n        m.no_bounce = true;\n        return;\n    }\n}\n\nray_t gen_ray(vec2 uv)\n{\n    const vec3 cam_target = vec3(0, 0, 1);\n    \n    // Camera params\n    cam_t cam;\n    cam.pos = vec3(-.3, -3., 1.5);\n    cam.fov = 60.0;\n    cam_update_zoom(cam);\n    cam_look_at(cam, cam_target);\n    \n    // Ray\n    return cam_gen_ray_dof(cam, uv, iTime * .5, .2);\n}\n\n// Cast a ray to the scene and return information about it\nvoid cast_ray(ray_t r, out hit_t h_final)\n{\n    // Reset\n    h_final.hit = false;\n    h_final.t = 1e9;\n    h_final.mat_id = -1;\n    \n    // Ground\n    {\n        hit_t h;\n        ray_aabb(0, vec3(-8., -8., -.1), vec3(8., 8., 0.), r, h);\n        if (h.hit && h.t < h_final.t) h_final = h;\n    }\n    \n    // Sphere 1\n    {\n        hit_t h;\n        const vec3 sphere_pos = vec3(-.55, 0., 0.5);\n        const float sphere_radius = 0.5;\n        ray_sphere(1, sphere_pos, sphere_radius, r, h);\n        if (h.hit && h.t < h_final.t) h_final = h;\n    }\n    \n    // Sphere 2\n    {\n        hit_t h;\n        const vec3 sphere_pos = vec3(.55, 0., 0.5);\n        const float sphere_radius = 0.5;\n        ray_sphere(2, sphere_pos, sphere_radius, r, h);\n        if (h.hit && h.t < h_final.t) h_final = h;\n    }\n    \n    // LEDs\n    for (int i = 0; i < 5; i++)\n    {\n        hit_t h;\n        float t = iTime * .4;\n        vec3 sphere_pos = vec3(\n            1.8 * cos(TAU * .48 * t + float(i)),\n            -.1 + .2 * cos(TAU * t + float(i)),\n            2. + .2 * cos(TAU * 1.35 * t + 3.72 * float(i)));\n        ray_sphere(i + 3, sphere_pos, .1, r, h);\n        if (h.hit && h.t < h_final.t) h_final = h;\n    }\n}\n\n// Update a given set of absorption and emission spectra based on given ray hit info\nvoid shade_ray(inout ray_t r, inout hit_t h, inout vec3 absorbed, inout vec3 emitted, out bool no_bounce)\n{\n    if (h.hit)\n    {\n        // Get material info\n        mat_t mat;\n        get_mat(h.mat_id, mat);\n        \n        // Emission\n        emitted += mat.emission;\n        \n        // Absorption (Diffuse)\n        absorbed *= mat.diffuse;\n        \n        // Should we stop bouncing?\n        if (mat.no_bounce)\n        {\n            no_bounce = true;\n            return;\n        }\n        \n        // Bounce ray\n        r.orig = h.pos + ray_offset * h.normal;\n        vec3 dir_refl = reflect(r.dir, h.normal);\n        vec3 dir_rand = normalize(h.normal + random_in_sphere());\n        r.dir = normalize(mix(dir_refl, dir_rand, mat.roughness));\n    }\n    else\n    {\n        // Environment\n        emitted += get_env(r.dir);\n        no_bounce = true;\n    }\n}\n\nvec2 screen_to_uv(vec2 coord)\n{\n    return (2.0 * coord - iResolution.xy) / min(iResolution.x, iResolution.y);\n}\n\nvec3 render(vec2 frag_coord)\n{\n    // UV\n    vec2 uv = screen_to_uv(frag_coord);\n    \n    // Generate camera ray\n    ray_t r = gen_ray(uv);\n    \n    // Ray info\n    hit_t h;\n    vec3 absorbed = vec3(1);\n    vec3 emitted = vec3(0);\n    \n    // Bounce ray and shade\n    bool no_bounce = false;\n    for (int i = 0; i <= 4; i++)\n    {\n        cast_ray(r, h);\n        shade_ray(r, h, absorbed, emitted, no_bounce);\n        if (no_bounce) break;\n    }\n    \n    // Final color\n    return absorbed * emitted;\n}\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    // Read data from the previous frame, stored at the bottom row of pixels.\n    \n    // Data: Resolution\n    vec4 prev_res;\n    {\n        const ivec2 data_coord = ivec2(0, 0);\n        if (ivec2(frag_coord) == data_coord)\n        {\n            frag_col = vec4(iResolution.xy, 0., 0.);\n            return;\n        }\n        prev_res = texelFetch(iChannel1, data_coord, 0);\n    }\n    \n    // Read the previous value of the current pixel\n    vec4 data = texelFetch(iChannel1, ivec2(frag_coord), 0);\n    \n    // Initialize PRNG\n    prng_init(vec3(frag_coord / iResolution.y, iTime));\n    \n    // Render with jitter sampling\n    const int num_samples = 50;\n    vec3 col = vec3(0.0);\n    for (int i = 0; i < num_samples; i++)\n    {\n        vec2 offs = vec2(random(), random()) - 0.5;\n        col += render(frag_coord + offs);\n    }\n    col /= float(num_samples);\n    \n    // Frame blending\n    frag_col = vec4(mix(data.xyz, col, .3), 1.);\n}\n",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "XsXGR8",
       "channel": 0
      }
     ],
     "code": "/***********************************\n\nflim - Filmic Color Transform\n\nInput Color Space:   Linear BT.709 I-D65\nOutput Color Space:  sRGB 2.2\n\nShadertoy Unit:\n  Buffer X\n\nDescription:\n  Experimental port of flim for GLSL/Shadertoy\n  matching flim v1.1.0.\n  The buffer unit performs a one-time calculation\n  of flim's gamut extension matrices.\n\nAuthor:\n  Bean (beans_please on Shadertoy)\n\nOriginal Repo:\n  https://github.com/bean-mhm/flim\n\nOriginal Shader:\n  https://www.shadertoy.com/view/dd2yDz\n\n***********************************/\n\n// NOTE:\n// iChannel0 must be set to this buffer (self-feeding).\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // W == valid_w means the matrices have already been calculated.\n    const float valid_w = 2.0;\n\n    // We only care about the first 6 pixels\n    if (ivec2(fragCoord).x > 5 || ivec2(fragCoord).y > 0)\n        return;\n\n    // Previous frame's value\n    vec4 prev = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    fragColor = prev;\n\n    // Do we need to recalculate the matrices?\n    bool needToCalc = (prev.w != valid_w) || (iTime == 0.0) || (iFrame < 1);\n    if (!needToCalc)\n        return;\n\n    // (Re)calculate the matrices\n    mat3 extend_mat = flim_gamut_extension_mat(flim_extended_gamut_red_scale, flim_extended_gamut_green_scale, flim_extended_gamut_blue_scale, flim_extended_gamut_red_rot, flim_extended_gamut_green_rot, flim_extended_gamut_blue_rot, flim_extended_gamut_red_mul, flim_extended_gamut_green_mul, flim_extended_gamut_blue_mul);\n    mat3 extend_mat_inv = inverse(extend_mat);\n\n    // extend_mat\n    {\n        if (ivec2(fragCoord) == ivec2(0, 0))\n        {\n            fragColor = vec4(extend_mat[0], valid_w);\n        }\n        if (ivec2(fragCoord) == ivec2(1, 0))\n        {\n            fragColor = vec4(extend_mat[1], valid_w);\n        }\n        if (ivec2(fragCoord) == ivec2(2, 0))\n        {\n            fragColor = vec4(extend_mat[2], valid_w);\n        }\n    }\n\n    // extend_mat_inv\n    {\n        if (ivec2(fragCoord) == ivec2(3, 0))\n        {\n            fragColor = vec4(extend_mat_inv[0], valid_w);\n        }\n        if (ivec2(fragCoord) == ivec2(4, 0))\n        {\n            fragColor = vec4(extend_mat_inv[1], valid_w);\n        }\n        if (ivec2(fragCoord) == ivec2(5, 0))\n        {\n            fragColor = vec4(extend_mat_inv[2], valid_w);\n        }\n    }\n}\n\n/***********************************\n\nEnd of flim's implementation for Shadertoy Unit: Buffer X\n\n***********************************/\n",
     "name": "Buffer B",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "ctfcD7",
    "date": "1690805466",
    "viewed": 148,
    "name": "colorful thing",
    "description": "random shader (i was bored)",
    "likes": 2,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "colors",
     "color",
     "idk",
     "nice"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "/* -----------------------------------------------\n  Shadertoy Unit: Image\n  Description: None\n  iChannel0: None\n  iChannel1: None\n  iChannel2: None\n  iChannel3: None\n----------------------------------------------- */\n\nvec2 screen_to_uv(vec2 coord)\n{\n    return (2.0 * coord - iResolution.xy) / min(iResolution.x, iResolution.y);\n}\n\nvec3 view_transform(vec3 col)\n{\n\t// OETF (Gamma)\n    return pow(col, vec3(1.0 / 2.2));\n}\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    float t = 0.9 * floor(iTime * 30.0) / 30.0;\n    vec2 c = floor(frag_coord / 2.0) * 2.0 + 0.5;\n    \n    // Initialize PRNG\n    prng_init(vec3(c / iResolution.y, t));\n    \n    // UV\n    vec2 uv = screen_to_uv(c);\n    \n    // Render\n    uv += vec2(0.5, 0.0);\n    float r = length(uv) + random() * 0.05;\n    float a = (0.55 * get_angle(uv) / TAU) + t * 0.1 + random() * 0.01;\n    vec3 col = rgb_sweep(a);\n    col = mix(col, col * dot(col, vec3(0.5, 0.3, 0.2)) * 1.1, 0.25);\n    col = mix(col, vec3(1.02), pow(map_range_clamp(r, 2.5, 0.0, 0.0, 1.0), 6.0));\n    float ring = 0.6 + cos(t * TAU * 0.5) * 0.04 + cos(t * TAU * 0.3) * 0.02 + cos(t * TAU * 1.5) * 0.005;\n    float ring_width = 0.04 + cos(t * TAU * 0.4) * 0.015;\n    if (r > ring && r < (ring + ring_width))\n    {\n        float fac = 1.0 - 2.0 * abs((get_angle(uv) / TAU) - 0.5);\n        fac *= fac;\n        col = pow(col, vec3(map_range(fac, 0.0, 1.0, 1.0, 2.5)));\n        col *= map_range(fac, 0.0, 1.0, 1.0, 1.2);\n    }\n    col = pow(col, vec3(map_range_clamp(r, 0.5, 5.0, 0.9, 5.0)));\n    \n    // Output\n    col = view_transform(col);\n    frag_col = vec4(col, 1.0);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "/* -----------------------------------------------\n  Shadertoy Unit: Common\n----------------------------------------------- */\n\n\n\n// -----------------------------------------------\n// What to define\n// -----------------------------------------------\n\n/* Math Utils */\n#define MATH_UTILS 1\n\n/* Pseudo-Random Number Generator */\n#define PRNG 1\n\n// -----------------------------------------------\n// End\n// -----------------------------------------------\n\n\n\n// -----------------------------------------------\n// Math Utils\n// -----------------------------------------------\n\n#if MATH_UTILS\n\n#define PI 3.1415926535897932384626433832\n#define TAU 6.283185307179586476925286766\n#define PI_OVER_2 1.57079632679489661923132169163\n#define DEG_TO_RAD 0.01745329251994329576923690768\n#define RAD_TO_DEG 57.2957795130823208767981548141\n\n#define FUNC_LERP(T) \\\nT lerp(T a, T b, float t) \\\n{ \\\n    return a + t*(b-a); \\\n}\n\n#define FUNC_WRAP(T) \\\nT wrap(T inp, float start, float end) \\\n{ \\\n    return start + mod(inp - start, end - start); \\\n}\n\n#define FUNC_MAP_RANGE(T) \\\nT map_range(T inp, float inp_start, float inp_end, float out_start, float out_end) \\\n{ \\\n    return out_start + ((out_end - out_start) / (inp_end - inp_start)) * (inp - inp_start); \\\n}\n\n#define FUNC_MAP_RANGE_CLAMP(T) \\\nT map_range_clamp(T inp, float inp_start, float inp_end, float out_start, float out_end) \\\n{ \\\n    T t = clamp((inp - inp_start) / (inp_end - inp_start), 0.0, 1.0); \\\n    return out_start + t * (out_end - out_start); \\\n}\n\nFUNC_LERP(float)\nFUNC_LERP(vec2)\nFUNC_LERP(vec3)\nFUNC_LERP(vec4)\n\nFUNC_WRAP(float)\nFUNC_WRAP(vec2)\nFUNC_WRAP(vec3)\nFUNC_WRAP(vec4)\n\nFUNC_MAP_RANGE(float)\nFUNC_MAP_RANGE(vec2)\nFUNC_MAP_RANGE(vec3)\nFUNC_MAP_RANGE(vec4)\n\nFUNC_MAP_RANGE_CLAMP(float)\nFUNC_MAP_RANGE_CLAMP(vec2)\nFUNC_MAP_RANGE_CLAMP(vec3)\nFUNC_MAP_RANGE_CLAMP(vec4)\n\n#endif\n\n// -----------------------------------------------\n// End\n// -----------------------------------------------\n\n\n\n// -----------------------------------------------\n// Pseudo-Random Number Generator\n// Source: https://www.shadertoy.com/view/WdSSRt\n// -----------------------------------------------\n\n/* Usage Example:\n    void mainImage(out vec4 frag_col, in vec2 frag_coord)\n    {\n        // Initialize PRNG\n        prng_init(vec3(frag_coord / iResolution.y, iTime));\n    \n        // Using the function\n        float a = random();\n        vec3 b = vec3(random(), random(), random());\n        \n        ...\n    }\n*/\n\n#if PRNG\n\nuint prng_state[2];\n\nuint prng_rot(uint x, int k)\n{\n    return (x << k) | (x >> (32 - k));\n}\n\nfloat random()\n{\n    uint s0 = prng_state[0];\n    uint s1 = prng_state[1];\n    uint result = prng_rot(s0 * 0x9e3779bbu, 5) * 5u;\n    s1 ^= s0;\n    prng_state[0] = prng_rot(s0, 26) ^ s1 ^ (s1 << 9);\n    prng_state[1] = prng_rot(s1, 13);\n    return float(result) / float(0xffffffffu);\n}\n\nvoid prng_init(vec3 seed)\n{\n    seed.xy *= (seed.z + 10.258);\n    seed += 3.49276101561702;\n    prng_state[0] = floatBitsToUint(seed.x);\n    prng_state[1] = floatBitsToUint(seed.y);\n    random();\n}\n\n#endif\n\n// -----------------------------------------------\n// End\n// -----------------------------------------------\n\n\n\nfloat get_angle(vec2 v)\n{\n    v /= length(v);\n    return atan(-v.y, -v.x) + PI;\n}\n\nvec3 rgb_sweep(float hue)\n{\n    hue = wrap(hue * 360.0, 0.0, 360.0);\n\n    vec3 col = vec3(1, 0, 0);\n    col = mix(col, vec3(1, 1, 0), smoothstep(0.0, 60.0, hue));\n    col = mix(col, vec3(0, 1, 0), smoothstep(60.0, 120.0, hue));\n    col = mix(col, vec3(0, 1, 1), smoothstep(120.0, 180.0, hue));\n    col = mix(col, vec3(0, 0, 1), smoothstep(180.0, 240.0, hue));\n    col = mix(col, vec3(1, 0, 1), smoothstep(240.0, 300.0, hue));\n    col = mix(col, vec3(1, 0, 0), smoothstep(300.0, 360.0, hue));\n    \n    return col;\n}\n",
     "name": "Common",
     "description": "",
     "type": "common"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "mlsyDj",
    "date": "1691237601",
    "viewed": 230,
    "name": "Balls Simulated (updated)",
    "description": "This is my first physics simulation, and I just followed my gut, so feel free to comment on how this can be improved\n\nUpdate: Implemented suggestions by @fenix (no more jittering + general improvements)",
    "likes": 12,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "simulation",
     "sphere",
     "balls",
     "ball",
     "physics"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "XdX3zn",
       "filepath": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg",
       "type": "cubemap",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "clamp",
        "vflip": "false",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "/* -----------------------------------------------\n  Shadertoy Unit: Image\n  Description: Rendering\n  iChannel0: Cubemap\n  iChannel1: Buffer A\n  iChannel2: None\n  iChannel3: None\n----------------------------------------------- */\n\nfloat fake_hdr(float x)\n{\n    if (x < 0.6) return x;\n    const float a = 1.5, b = 2.0;\n    return a * pow(x, b) + 0.6 - a * pow(0.6, b);\n}\n\nvec3 get_env(vec3 dir)\n{\n    vec3 c = pow(texture(iChannel0, dir.xzy).xyz, vec3(2.2));\n    c *= vec3(0.32, 0.8, 1.0) * 2.5;\n    //c = vec3(fake_hdr(c.r), fake_hdr(c.g), fake_hdr(c.b));\n    c *= 1.1;\n    return c;\n}\n\nfloat get_visibility(ray_t r)\n{\n    // Raycast to the balls\n    for (int i = 0; i < num_balls; i++)\n    {\n        vec4 data = texelFetch(iChannel1, index2icoord(i * ppe + 1), 0);\n        vec3 ball_pos = vec3(data.x, 1.0, data.y);\n        hit_t h2;\n        ray_sphere(ball_pos, ball_radius, r, h2);\n        if (h2.hit)\n        {\n            return 0.0;\n        }\n    }\n    return 1.0;\n}\n\nvec2 screen_to_uv(vec2 coord)\n{\n    return (2.0 * coord - iResolution.xy) / min(iResolution.x, iResolution.y);\n}\n\nray_t gen_cam_ray(vec2 uv)\n{\n    // Camera params\n    const vec3 cam_pos = vec3(0.0, -4.3, 1.5);\n    const float cam_fov = 47.0;\n    \n    // Camera details\n    const float cam_zoom = 90.0 / cam_fov;\n    const vec3 cam_forward = normalize(vec3(0.0, 0.0, 1.85) - cam_pos);\n    const vec3 cam_right = normalize(cross(cam_forward, vec3(0, 0, 1)));\n    const vec3 cam_up = cross(cam_right, cam_forward);\n    \n    // Ray\n    ray_t r;\n    r.orig = cam_pos;\n    r.dir = normalize(cam_forward + cam_right * (uv.x / cam_zoom) + cam_up * (uv.y / cam_zoom));\n    return r;\n}\n\nvec3 view_transform(vec3 col)\n{\n\t// OETF (Gamma)\n    return pow(col, vec3(1.0 / 2.2));\n}\n\nvec3 render(vec2 frag_coord)\n{\n    // UV\n    vec2 uv = screen_to_uv(frag_coord);\n    \n    // Generate camera ray\n    ray_t r = gen_cam_ray(uv);\n    \n    // Hit info\n    int ball_id = -1;\n    hit_t closest;\n    closest.hit = false;\n    closest.t = 1000.;\n    \n    // Raycast to ground\n    hit_t h;\n    ray_aabb(vec3(-7.0, -7.0, -0.1), vec3(7.0, 7.0, 0.0), r, h);\n    if (h.hit && h.t < closest.t)\n    {\n        ball_id = -1;\n        closest = h;\n    }\n    \n    // Raycast to the balls\n    for (int i = 0; i < num_balls; i++)\n    {\n        vec4 data = texelFetch(iChannel1, index2icoord(i * ppe + 1), 0);\n        vec3 ball_pos = vec3(data.x, 1.0, data.y);\n        hit_t h2;\n        ray_sphere(ball_pos, ball_radius, r, h2);\n        if (h2.hit && h2.t < closest.t)\n        {\n            ball_id = i;\n            closest = h2;\n        }\n    }\n    \n    // Shade\n    vec3 col = vec3(0);\n    if (closest.hit)\n    {\n        float t = -TAU * iTime * 0.1;\n        vec3 light_dir = normalize(vec3(cos(t), sin(t), 2.5));\n        if (ball_id < 0)\n        {\n            // Ground shading\n            const vec3 mat_diff = vec3(.14, .4, .7);\n            vec3 diffuse = 0.8 * mat_diff * max(0., dot(closest.normal, light_dir));\n            vec3 hv = normalize(light_dir - r.dir);\n            vec3 spec = vec3(1.0) * pow(dot(hv, closest.normal), 15.0);\n            col = diffuse + spec;\n            \n            // Shadows\n            ray_t rshadow;\n            rshadow.orig = closest.pos + r.dir * 0.002;\n            rshadow.dir = light_dir;\n            col *= get_visibility(rshadow);\n            \n            // Ambient\n            col += mat_diff * 0.1;\n        }\n        else\n        {\n            // Ball shading\n            \n            const vec3 mat_diff = vec3(1.0, 0.5, 0.06);\n            vec3 diffuse = mat_diff * max(0., dot(closest.normal, light_dir));\n            vec3 ambient = 0.065 * mat_diff + vec3(0., .002, .01);\n            \n            vec3 envref = get_env(reflect(r.dir, closest.normal));\n            float fresnel = pow(1.0 - dot(-r.dir, closest.normal), 5.0);\n            vec3 spec = envref * lerp(0.01, 0.8, fresnel);\n            \n            col = diffuse + ambient + spec;\n        }\n    }\n    else\n    {\n        col = get_env(r.dir);\n    }\n    return col;\n}\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    // Render with super sampling\n    vec3 col = vec3(0.0);\n    col += render(frag_coord + vec2(-0.25, -0.25));\n    col += render(frag_coord + vec2(-0.25, +0.25));\n    col += render(frag_coord + vec2(+0.25, +0.25));\n    col += render(frag_coord + vec2(+0.25, -0.25));\n    col /= 4.;\n    \n    // Output\n    col *= 1.2;\n    col = view_transform(col);\n    frag_col = vec4(col, 1.0);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "/* -----------------------------------------------\n  Shadertoy Unit: Common\n----------------------------------------------- */\n\n\n\n// -----------------------------------------------\n// What to define\n// -----------------------------------------------\n\n/* Math Utils */\n#define MATH_UTILS 1\n\n// -----------------------------------------------\n// End\n// -----------------------------------------------\n\n\n\n// -----------------------------------------------\n// Math Utils\n// -----------------------------------------------\n\n#if MATH_UTILS\n\n#define PI 3.1415926535897932384626433832\n#define TAU 6.283185307179586476925286766\n#define PI_OVER_2 1.57079632679489661923132169163\n#define DEG_TO_RAD 0.01745329251994329576923690768\n#define RAD_TO_DEG 57.2957795130823208767981548141\n\n#define FUNC_LERP(T) \\\nT lerp(T a, T b, float t) \\\n{ \\\n    return a + t*(b-a); \\\n}\n\n#define FUNC_WRAP(T) \\\nT wrap(T inp, float start, float end) \\\n{ \\\n    return start + mod(inp - start, end - start); \\\n}\n\n#define FUNC_MAP_RANGE(T) \\\nT map_range(T inp, float inp_start, float inp_end, float out_start, float out_end) \\\n{ \\\n    return out_start + ((out_end - out_start) / (inp_end - inp_start)) * (inp - inp_start); \\\n}\n\n#define FUNC_MAP_RANGE_CLAMP(T) \\\nT map_range_clamp(T inp, float inp_start, float inp_end, float out_start, float out_end) \\\n{ \\\n    T t = clamp((inp - inp_start) / (inp_end - inp_start), 0.0, 1.0); \\\n    return out_start + t * (out_end - out_start); \\\n}\n\nFUNC_LERP(float)\nFUNC_LERP(vec2)\nFUNC_LERP(vec3)\nFUNC_LERP(vec4)\n\nFUNC_WRAP(float)\nFUNC_WRAP(vec2)\nFUNC_WRAP(vec3)\nFUNC_WRAP(vec4)\n\nFUNC_MAP_RANGE(float)\nFUNC_MAP_RANGE(vec2)\nFUNC_MAP_RANGE(vec3)\nFUNC_MAP_RANGE(vec4)\n\nFUNC_MAP_RANGE_CLAMP(float)\nFUNC_MAP_RANGE_CLAMP(vec2)\nFUNC_MAP_RANGE_CLAMP(vec3)\nFUNC_MAP_RANGE_CLAMP(vec4)\n\n#endif\n\n// -----------------------------------------------\n// End\n// -----------------------------------------------\n\n\n\nstruct ray_t\n{\n    vec3 orig;\n    vec3 dir;\n};\n\nstruct hit_t\n{\n    bool hit;\n    float t;\n    vec3 pos;\n    vec3 normal;\n};\n\n// https://www.reddit.com/r/opengl/comments/8ntzz5/comment/dzyqwgr\nvoid ray_aabb(const vec3 box_min, const vec3 box_max, in ray_t r, out hit_t h) {\n    vec3 inv_dir = 1.0 / r.dir;\n    vec3 tbot = inv_dir * (box_min - r.orig);\n    vec3 ttop = inv_dir * (box_max - r.orig);\n    vec3 tmin = min(ttop, tbot);\n    vec3 tmax = max(ttop, tbot);\n    vec2 t = max(tmin.xx, tmin.yz);\n    float t0 = max(t.x, t.y);\n    t = min(tmax.xx, tmax.yz);\n    float t1 = min(t.x, t.y);\n    if (t1 > max(t0, 0.0))\n    {\n        h.hit = true;\n        h.t = t0;\n        h.pos = r.orig + r.dir * t0;\n        h.normal = vec3(0.0, 0.0, 1.0); // what's the proper way? please comment\n    }\n}\n\nvoid ray_sphere(const vec3 center, const float radius, in ray_t r, out hit_t h)\n{\n    vec3 ro = r.orig - center;\n    \n    // Quadratic equation\n    float a = dot(r.dir, r.dir);\n    float b = 2.0 * dot(ro, r.dir);\n    float c = dot(ro, ro) - radius*radius;\n    float discriminant = (b * b) - (4.0 * a * c);\n    \n    if (discriminant < 0.0)\n    {\n        // No hits\n        h.hit = false;\n        return;\n    }\n    \n    float sqrt_d = sqrt(discriminant);\n    float t = (-b - sqrt_d) / (2.0 * a);\n    \n    if (t < 0.0)\n    {\n        h.hit = false;\n        return;\n    }\n    \n    h.hit = true;\n    h.t = t;\n    h.pos = r.orig + (t * r.dir);\n    \n    // Normal\n    h.normal = (h.pos - center) / radius;\n}\n\n// A 20x10 grid of pixels in buffer A will be used to store\n// and manipulate simulation data.\nconst ivec2 data_res = ivec2(20, 10);\n\n// Pixels per element. Every N pixels hold information about\n// one ball.\nconst int ppe = 2;\n\n// Ball parameters\nconst int num_balls = 100;\nconst float ball_radius = 0.2;\n\n// Convert pixel indices in the data buffer to a 1D index\nint icoord2index(ivec2 icoord)\n{\n    if (icoord.x >= data_res.x || icoord.y >= data_res.y)\n        return -1;\n    return icoord.x + icoord.y * data_res.x;\n}\n\n// Convert a 1D index to pixel indices in the data buffer\nivec2 index2icoord(int index)\n{\n    return ivec2(index % data_res.x, index / data_res.x);\n}\n",
     "name": "Common",
     "description": "",
     "type": "common"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "/* -----------------------------------------------\n  Shadertoy Unit: Buffer A\n  Description: Simulation\n  iChannel0: Buffer A (self-feeding)\n  iChannel1: None\n  iChannel2: None\n  iChannel3: None\n----------------------------------------------- */\n\nvoid mainImage(out vec4 o, in vec2 frag_coord)\n{\n    // Integer coordinates\n    ivec2 icoord = ivec2(floor(frag_coord));\n    \n    // Are we outside the data buffer?\n    if (icoord.x >= data_res.x || icoord.y >= data_res.y)\n    {\n        o = vec4(0);\n        return;\n    }\n    \n    // Convert pixel indices to 1D index\n    int idx = icoord2index(icoord);\n    \n    // Ball index\n    int ball_id = int(floor(float(idx) / float(ppe)));\n    \n    // Ball data index\n    // 0 = Velocity,\n    // 1 = Position\n    int data_id = idx % ppe;\n    \n    // Ball data\n    vec4 vel = texelFetch(iChannel0, index2icoord(idx + 0 - data_id), 0);\n    vec4 pos = texelFetch(iChannel0, index2icoord(idx + 1 - data_id), 0);\n    \n    // First frames / Initialization\n    const float valid_w = 2.0;\n    bool init = (iFrame < 5 || iTime <= 0. || texelFetch(iChannel0, icoord, 0).w != valid_w);\n    \n    // Delta time\n    float dt = 1.0 * min(iTimeDelta, 0.016);\n    \n    // Step\n    if (!init)\n    {\n        // Update values\n        const vec2 gravity = vec2(0.0, -2.);\n        vel.xy += gravity * dt;\n        pos.xy += vel.xy * dt;\n        \n        if (pos.y < ball_radius)\n        {\n            // Collision with the ground\n            vel.y *= -.3;\n            pos.y = ball_radius;\n        }\n        else\n        {\n            // (2 * radius) ^ 2\n            const float d2 = 4. * ball_radius * ball_radius;\n            \n            // Collision with the other balls\n            for (int i = 0; i < num_balls; i++)\n            {\n                // Skip self\n                if (i == ball_id) continue;\n                \n                // Get other ball's position\n                vec2 vel2 = texelFetch(iChannel0, index2icoord(i * ppe + 0), 0).xy;\n                vec2 pos2 = texelFetch(iChannel0, index2icoord(i * ppe + 1), 0).xy;\n                \n                // Check their distance\n                vec2 temp = pos.xy - pos2;\n                if (pos.y > pos2.y && dot(temp, temp) < d2)\n                {\n                    vec2 rel_vel = vel2 - vel.xy;\n                    vel.xy += normalize(temp) * max(0., dot(rel_vel, temp));\n                    pos.xy = pos2 + normalize(pos.xy - pos2) * ball_radius * 2.;\n                }\n            }\n        }\n    }\n    \n    // Velocity\n    if (data_id == 0)\n    {\n        // First frame\n        if (init)\n        {\n            o = vec4(0.0, 0.0, 0.0, valid_w);\n            return;\n        }\n        o = vel;\n    }\n    \n    // Position\n    if (data_id == 1)\n    {\n        // First frame\n        if (init)\n        {\n            int ix = ball_id % 10;\n            int iy = ball_id / 10;\n            o = vec4(\n                float(ix - 5) * 2.0 * ball_radius * 1.2 + sin(float(iy) * 500.0) * .4,\n                0.005 + ball_radius + float(iy) * 2.0 * ball_radius * 1.2,\n                0.0, valid_w\n            );\n            return;\n        }\n        o = pos;\n    }\n}\n",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "cl2cRD",
    "date": "1691530674",
    "viewed": 81,
    "name": "Fixed FPS Experiment",
    "description": "Adjusting the amount of computation in order to keep the FPS constant.\nMight take up to 20 seconds to reach the target FPS.\nDoesn't work well on my phone, probably because of 16 bit precision.",
    "likes": 1,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "fps",
     "constant"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = texelFetch(iChannel0, ivec2(0), 0);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Target FPS and delta time\n    const float targetFPS = 42.;\n    const float targetDT = 1. / targetFPS;\n    \n    // prevN = Number of computations in the previous frame\n    float prevN = texelFetch(iChannel0, ivec2(0), 0).x;\n    if (prevN < 2.) prevN = 2.;\n    \n    // Calculate new N\n    float n;\n    if (iTimeDelta < targetDT)\n    {\n        float targetN = prevN * 1.01;\n        n = max(targetN, prevN + .5);\n    }\n    else\n    {\n        float targetN = prevN * 0.99;\n        n = min(targetN, prevN - .5);\n    }\n    \n    // Heavy ish computations\n    float a = 2. + fragCoord.x;\n    int n_int = max(int(floor(n)), 1);\n    for (int i = 0; i < n_int; i++)\n    {\n        a *= (a + 0.5);\n        a /= 0.01 + 0.02*a;\n        a /= (a + 9.);\n        a = sqrt(a);\n        //a /= pow(a, 2.5 * log2(a));\n    }\n    \n    // Output\n    fragColor = vec4(n, 0.0, a, 1.0);\n}\n",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "mtScWm",
    "date": "1691841683",
    "viewed": 309,
    "name": "Blue Noise Dithering vs OETF 2.2",
    "description": "Try commenting out the OETF to see how the dithered version and the clean version don't match in brightness anymore",
    "likes": 10,
    "published": "Public API",
    "usePreview": 1,
    "tags": [
     "dither",
     "gamma",
     "dithering",
     "bluenoise",
     "srgb",
     "oetf"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "XsBSR3",
       "filepath": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png",
       "type": "texture",
       "channel": 0,
       "sampler": {
        "filter": "nearest",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // UV\n    vec2 uv = 3. * (fragCoord - .5*iResolution.xy) / iResolution.y;\n    \n    // Wavy pattern\n    float f = cos(6.28 * (uv.x*uv.x*uv.x+uv.y*uv.y*uv.y))*.5+.5;\n    \n    // Dither\n    if (mod(iTime, 3.) < 1.5)\n        f = (f > texture(iChannel0, fragCoord / vec2(textureSize(iChannel0, 0))).x) ? 1. : 0.;\n    \n    // OETF 2.2 (Gamma)\n    f = pow(f, 1. / 2.2);\n    \n    fragColor = vec4(f, f, f, 1.0);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "mtjyDw",
    "date": "1691962447",
    "viewed": 166,
    "name": "1D Continuous Function Graphing",
    "description": "Basically sample points on the function and connect them with line segments",
    "likes": 6,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "2d",
     "graph",
     "plot",
     "plotting",
     "graphs"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4df3Rr",
       "filepath": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg",
       "type": "texture",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "/************************/\n/*                      */\n/*  YOUR FUNCTION HERE  */\n/*                      */\n/************************/\nfloat f(float x)\n{\n    return .6 * sin(4. * x + iTime * 3.) * exp(-x * .25);\n}\n\n\n\nconst float zoom = 2.8;  // Zoom-out\nfloat px2uv;             // Pixel to UV conversion factor (defined in main)\nfloat max_thickness;     // Line thickness (defined in main)\n\nfloat dist_f(vec2 p)\n{\n    // We have a line between every something pixels.\n    // The line vertices lie on f(x).\n    int n = int(.5 * iResolution.x);\n    \n    // Total horizontal length of the lines (screen length in UV)\n    float total_len = iResolution.x * px2uv;\n    \n    // Distance between the line vertices (in UV)\n    float step_size = total_len / float(n);\n    \n    // Index range of the lines which we want to check\n    int idx0 = int(floor((p.x - max(max_thickness, step_size)) / step_size));\n    int idx1 = int(floor((p.x + max(max_thickness, step_size)) / step_size));\n    \n    // Initial distance\n    float dist = 1e9;\n    \n    // Find the minimum distance from the lines we chose\n    for (int i = idx0; i <= idx1; i++)\n    {\n        // Point A of the line segment\n        float ax = float(i) * step_size;\n        float ay = f(ax);\n        \n        // Point B of the line segment\n        float bx = float(i + 1) * step_size;\n        float by = f(bx);\n        \n        // Distance\n        dist = min(dist, sd_segment(p, vec2(ax, ay), vec2(bx, by)));\n    }\n    \n    return dist;\n}\n\nvec3 render(vec2 frag_coord)\n{\n    // UV\n    vec2 uv = px2uv * (frag_coord - iResolution.xy * .5);\n    if (iMouse.z > .2)\n    {\n        uv += px2uv * (abs(iMouse.zw) - iMouse.xy);\n    }\n    \n    // Cartoon paper effect\n    uv += (texture(iChannel0, .4 * uv + vec2(13.4823 * SNAP(iTime, .125), 0.)).xy - .5) * .02;\n    \n    // Render grid\n    vec3 col = vec3(1., .9, 0.72);\n    vec3 col_grid = vec3(0.3, 0.1, 0.065);\n    #if 0\n    {\n        // Snap grid lines to pixels\n        // For this to work you need to disable the paper effect above\n        \n        #define SNAP_PX(X) SNAP(X, px2uv)\n        \n        float d = min(abs(uv.x - SNAP_PX(round(uv.x))), abs(uv.y - SNAP_PX(round(uv.y))));\n        if (d < .5 * px2uv) col = mix(col, col_grid, .5);\n        \n        vec2 t = uv * 4.;\n        d = min(abs(t.x - SNAP_PX(round(t.x))), abs(t.y - SNAP_PX(round(t.y))));\n        if (d < .5 * px2uv * 4.) col = mix(col, col_grid, .2);\n        \n        d = min(abs(uv.x), abs(uv.y));\n        if (d < 1. * px2uv) col = col_grid;\n    }\n    #else\n    {\n        // Don't snap to pixels\n        \n        float d = min(abs(uv.x - round(uv.x)), abs(uv.y - round(uv.y)));\n        if (d < .006) col = mix(col, col_grid, .5);\n        \n        vec2 t = uv * 4.;\n        d = min(abs(t.x - round(t.x)), abs(t.y - round(t.y)));\n        if (d < .006 * 4.) col = mix(col, col_grid, .2);\n        \n        d = min(abs(uv.x), abs(uv.y));\n        if (d < .012) col = col_grid;\n    }\n    #endif\n    \n    // Distance from f(x)\n    float d = dist_f(uv);\n    \n    // Render lines\n    float thick = max_thickness;\n    col = mix(col, vec3(.03, .04, 0.6), smoothstep(thick, thick - px2uv, d));\n    \n    return col;\n}\n\nvoid main_image(out vec4 frag_col, in vec2 frag_coord)\n{\n    // Pixel to UV conversion factor\n    px2uv = 2. * zoom / min(iResolution.x, iResolution.y);\n    \n    // Line thickness\n    max_thickness = .03;\n    \n    // Super-sampling\n    vec3 col = vec3(0);\n    {\n        col += render(frag_coord + vec2(-.25, -.25));\n        col += render(frag_coord + vec2(-.25, +.25));\n        col += render(frag_coord + vec2(+.25, +.25));\n        col += render(frag_coord + vec2(+.25, -.25));\n    }\n    col /= 4.;\n    \n    // Output\n    col = pow(col, vec3(1. / 2.2));\n    frag_col = vec4(col, 1.);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "#define main_image mainImage /* force snake_case */\n\n#define SNAP(X, STEP) ((floor(X / STEP) + .5) * STEP)\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sd_segment(in vec2 p, in vec2 a, in vec2 b)\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n",
     "name": "Common",
     "description": "",
     "type": "common"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "cljczd",
    "date": "1692189706",
    "viewed": 105,
    "name": "Mod of 01000001's FXAA Shader",
    "description": "Original shader: https://www.shadertoy.com/view/mljyzc",
    "likes": 1,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "fxaa"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "float get_luminance(vec3 col)\n{\n    return dot(col, vec3(.3, .58, .12));\n}\n\nvoid mainImage(out vec4 O, in vec2 U)\n{\n    vec2 r = iResolution.xy;\n    \n    // Find the normal\n    vec2 normal = vec2(0);\n    {\n        float next_lum = get_luminance(texelFetch(iChannel0, ivec2(U) + ivec2(1, 0), 0).xyz);\n        float prev_lum = get_luminance(texelFetch(iChannel0, ivec2(U) + ivec2(-1, 0), 0).xyz);\n        normal.x = (prev_lum - next_lum) / 2.;\n    }\n    {\n        float next_lum = get_luminance(texelFetch(iChannel0, ivec2(U) + ivec2(0, 1), 0).xyz);\n        float prev_lum = get_luminance(texelFetch(iChannel0, ivec2(U) + ivec2(0, -1), 0).xyz);\n        normal.y = (prev_lum - next_lum) / 2.;\n    }\n    \n    // Tangent\n    vec2 tangent = normal * mat2(0, 1, -1, 0);\n    \n    // Directional blur along the tangent\n    const int num_samples = 20;\n    const float len = 10.;\n    vec3 col = vec3(0);\n    float sum_weights = 0.;\n    for (int i = 0; i < num_samples; i++)\n    {\n        // 0 to 1\n        float t = float(i) / float(num_samples - 1);\n        \n        // -len/2 to len/2\n        float offs_along_tanget = len * (t - .5);\n        \n        // Target pixel's coordinates\n        vec2 target_coord = U + tangent * offs_along_tanget;\n        \n        // Weight of this sample\n        //float weight = 1. - abs(2. * t - 1.); // Tent\n        float weight = cos(3.14159265359 * (t - .5)); // Cosine\n        //float weight = 1.;\n        \n        // Update the sum of all weights\n        sum_weights += weight;\n        \n        col += weight * texture(iChannel0, target_coord / r).xyz;\n    }\n    col /= sum_weights;\n    \n    // Output\n    col = pow(col, vec3(1. / 2.2));\n    O = vec4(col, 1.);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "void mainImage(out vec4 O, in vec2 U)\n{\n    vec2 uv = U / iResolution.y * (sin(iTime*.1) * .5 + .6);\n    \n    vec3 col = vec3(0.15, 1., 0.05);\n    \n    float a = length(mod(uv*10., vec2(2))-1.)>.8?0.:1.;\n    col *= a;\n    \n    O = vec4(col, 1.);\n}\n",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "DljyDG",
    "date": "1692469704",
    "viewed": 202,
    "name": "Breathing Fractal",
    "description": "Drag to explore the complex universe!\n",
    "likes": 6,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "fractal"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "vec2 screen_to_uv(vec2 coord)\n{\n    return 2.4 * (coord - .5 * iResolution.xy) / min(iResolution.x, iResolution.y);\n}\n\n// Returns a value in [0, 1] which will be fed to the color map\nfloat fractal(vec2 coord)\n{\n    vec2 uv = screen_to_uv(coord);\n    \n    // Number of iterations\n    const int max_iters = 120;\n    int iters;\n    \n    // Starting complex number\n    vec2 a = uv;\n    \n    // Constant to add in each iteration\n    vec2 c;\n    if (iMouse.z > .5)\n    {\n        vec2 m = .5 * screen_to_uv(iMouse.xy);\n        m /= sqrt(length(m));\n        c = m;\n    }\n    else\n    {\n        c = vec2(-0.756924804733 + .008 * cos(1.2 * iTime), 0.210445461405);\n    }\n    \n    while (iters++ < max_iters)\n    {\n        // a = a^2\n        a = vec2(a.x * a.x - a.y * a.y, 2. * a.x * a.y);\n        \n        // Add constant\n        a += c;\n        \n        // Break if a is too large\n        if (dot(a, a) > pow(1.25 + .25 * cos(iTime * 1.2), 2.))\n            break;\n    }\n    \n    // Return a value based on the number of iterations \n    // done before becoming too large.\n    return remap(\n        exp(-float(iters) / float(max_iters)),\n        1., exp(-1.),\n        0., 1.15\n    );\n}\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    // Super sampling\n    float v = 0.;\n    {\n        const ivec2 ssaa_res = ivec2(4);\n        for (int y = 1; y <= ssaa_res.x; y++)\n        {\n            for (int x = 1; x <= ssaa_res.y; x++)\n            {\n                vec2 offs = vec2(float(x) / float(ssaa_res.x + 1), float(y) / float(ssaa_res.y + 1)) - .5;\n                v += fractal(frag_coord + offs);\n            }\n        }\n        v /= float(ssaa_res.x * ssaa_res.y);\n    }\n    \n    // Colormap\n    vec3 col = colormap(v);\n    col = mix(vec3(dot(col, vec3(1. / 3.))), col, 1.1);\n\n    // Output\n    col = pow(col, vec3(1. / 2.2));\n    frag_col = vec4(col, 1.);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "float remap(float inp, float inp_start, float inp_end, float out_start, float out_end)\n{\n    return out_start + ((out_end - out_start) / (inp_end - inp_start)) * (inp - inp_start);\n}\n\nfloat remap_clamp(float inp, float inp_start, float inp_end, float out_start, float out_end)\n{\n    float t = clamp((inp - inp_start) / (inp_end - inp_start), 0.0, 1.0);\n    return out_start + t * (out_end - out_start);\n}\n\nvec3 colormap(float x)\n{\n    vec3 c = vec3(1.0);\n    c = mix(c, 1.2 * vec3(0.3, 0.5, 0.8), remap_clamp(x, -1.0, -0.6, 0.0, 1.0));\n    c = mix(c, 1.2 * vec3(0.1, 0.02, 0.4), remap_clamp(x, -0.6, -0.25, 0.0, 1.0));\n    c = mix(c, vec3(0.0), remap_clamp(x, -0.25, 0.0, 0.0, 1.0));\n    c = mix(c, 1.2 * vec3(0.4, 0.1, 0.02), remap_clamp(x, 0.0, 0.25, 0.0, 1.0));\n    c = mix(c, 1.2 * vec3(0.8, 0.5, 0.3), remap_clamp(x, 0.25, 0.6, 0.0, 1.0));\n    c = mix(c, vec3(1.0), remap_clamp(x, 0.6, 1.0, 0.0, 1.0));\n    \n    c = pow(c, vec3(1.8));\n    c += vec3(0.03, 0.0, 0.02);\n    \n    return c;\n}\n",
     "name": "Common",
     "description": "",
     "type": "common"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "DtfBRn",
    "date": "1692473050",
    "viewed": 136,
    "name": "Deprecated: My 2nd Def. Shader",
    "description": "My starting point for new shaders (not anymore)\nnew one coming soon",
    "likes": 1,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "default",
     "shader",
     "utils",
     "common"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "vec2 screen_to_uv(vec2 coord)\n{\n    return (2. * coord - iResolution.xy) / min(iResolution.x, iResolution.y);\n}\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    vec2 uv = screen_to_uv(frag_coord);\n    \n    vec3 col = vec3(uv, 0);\n    \n    // Output\n    col = pow(col, vec3(1. / 2.2));\n    frag_col = vec4(col, 1.);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "/*_________________ Math Utils ________________*/\n\n#define PI 3.1415926535897932384626433832\n#define TAU 6.283185307179586476925286766\n#define PI_OVER_2 1.57079632679489661923132169163\n\n#define FUNC_LERP(T) \\\nT lerp(T a, T b, float t) \\\n{ \\\n    return a + t*(b-a); \\\n}\n\n#define FUNC_WRAP(T) \\\nT wrap(T inp, float start, float end) \\\n{ \\\n    return start + mod(inp - start, end - start); \\\n}\n\n#define FUNC_REMAP(T) \\\nT remap(T inp, float inp_start, float inp_end, float out_start, float out_end) \\\n{ \\\n    return out_start + ((out_end - out_start) / (inp_end - inp_start)) * (inp - inp_start); \\\n}\n\n#define FUNC_REMAP_CLAMP(T) \\\nT remap_clamp(T inp, float inp_start, float inp_end, float out_start, float out_end) \\\n{ \\\n    T t = clamp((inp - inp_start) / (inp_end - inp_start), 0.0, 1.0); \\\n    return out_start + t * (out_end - out_start); \\\n}\n\n#define FUNC_REMAP01(T) \\\nT remap01(T inp, float inp_start, float inp_end) \\\n{ \\\n    return clamp((inp - inp_start) / (inp_end - inp_start), 0.0, 1.0); \\\n}\n\nFUNC_LERP(float)\nFUNC_LERP(vec2)\nFUNC_LERP(vec3)\nFUNC_LERP(vec4)\n\nFUNC_WRAP(float)\nFUNC_WRAP(vec2)\nFUNC_WRAP(vec3)\nFUNC_WRAP(vec4)\n\nFUNC_REMAP(float)\nFUNC_REMAP(vec2)\nFUNC_REMAP(vec3)\nFUNC_REMAP(vec4)\n\nFUNC_REMAP_CLAMP(float)\nFUNC_REMAP_CLAMP(vec2)\nFUNC_REMAP_CLAMP(vec3)\nFUNC_REMAP_CLAMP(vec4)\n\nFUNC_REMAP01(float)\nFUNC_REMAP01(vec2)\nFUNC_REMAP01(vec3)\nFUNC_REMAP01(vec4)\n\nmat2 rotate_2d(float angle)\n{\n    return mat2(cos(angle), sin(angle), cos(angle + PI_OVER_2), sin(angle + PI_OVER_2));\n}\n\n/*____________________ End ____________________*/\n\n\n\n/*_______ Pseudo-Random Number Generator ______*/\n// Source: https://www.shadertoy.com/view/WdSSRt\n\n/* Usage Example:\n    void mainImage(out vec4 frag_col, in vec2 frag_coord)\n    {\n        // Initialize PRNG\n        prng_init(vec3(frag_coord / iResolution.y, iTime));\n    \n        // Using the function\n        float a = random();\n        vec3 b = vec3(random(), random(), random());\n        \n        ...\n    }\n*/\n\nuint prng_state[2];\n\nuint prng_rot(uint x, int k)\n{\n    return (x << k) | (x >> (32 - k));\n}\n\n// Random uint from 0 to 2^32-1\nuint randomui()\n{\n    uint s0 = prng_state[0];\n    uint s1 = prng_state[1];\n    uint result = prng_rot(s0 * 0x9e3779bbu, 5) * 5u;\n    s1 ^= s0;\n    prng_state[0] = prng_rot(s0, 26) ^ s1 ^ (s1 << 9);\n    prng_state[1] = prng_rot(s1, 13);\n    return result;\n}\n\n// Random int from 0 to 2^31-1\nint randomi()\n{\n    return int(randomui() % 0x7FFFFFFFu);\n}\n\n// Random float from 0 to 1\nfloat random()\n{\n    return float(randomui()) / float(0xffffffffu);\n}\n\n// Generate two normally distributed random numbers using the\n// Box-Muller Transform.\n// https://www.baeldung.com/cs/uniform-to-normal-distribution\nvec2 random_gauss()\n{\n    float u1 = random();\n    float u2 = random() * TAU;\n    float temp = sqrt(-2. * log(u1));\n    return temp * vec2(cos(u2), sin(u2));\n    \n    // Unoptimized version\n    //float u1 = random();\n    //float u2 = random();\n    //return vec2(cos(TAU * u2), sin(TAU * u2)) * sqrt(-2. * log(u1));\n}\n\nvec2 random_unit_vec2()\n{\n    vec2 v = vec2(1);\n    float lensqr;\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec2(2. * random() - 1., 2. * random() - 1.);\n        lensqr = dot(v, v);\n        if (lensqr == 0.)\n            i--;\n        else if (lensqr <= 1.)\n            break;\n    }\n    return v / sqrt(lensqr);\n}\n\nvec3 random_unit_vec3()\n{\n    vec3 v = vec3(1);\n    float lensqr;\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec3(2. * random() - 1., 2. * random() - 1., 2. * random() - 1.);\n        lensqr = dot(v, v);\n        if (lensqr == 0.)\n            i--;\n        else if (lensqr <= 1.)\n            break;\n    }\n    return v / sqrt(lensqr);\n}\n\nvec2 random_in_circle()\n{\n    vec2 v = vec2(1);\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec2(2. * random() - 1., 2. * random() - 1.);\n        if (dot(v, v) <= 1.)\n            return v;\n    }\n    return v;\n}\n\nvec3 random_in_sphere()\n{\n    vec3 v = vec3(1);\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec3(2. * random() - 1., 2. * random() - 1., 2. * random() - 1.);\n        if (dot(v, v) <= 1.)\n            return v;\n    }\n    return v;\n}\n\n// Initialize with uvec2\nvoid prng_init(uvec2 seed)\n{\n    seed += uvec2(1317, 944573125);\n    seed *= 464973573u;\n    prng_state[0] = seed.x;\n    prng_state[1] = seed.y;\n    randomi();\n}\n\n// Initialize with uint\nvoid prng_init(uint seed)\n{\n    prng_init(uvec2(seed, 1));\n}\n\n// Initialize with vec3\nvoid prng_init(vec3 seed)\n{\n    seed += 3.49276101561702;\n    seed.xy *= (seed.z + 10.258);\n    prng_state[0] = floatBitsToUint(seed.x);\n    prng_state[1] = floatBitsToUint(seed.y);\n    randomui();\n}\n\n// Initialize with vec2\nvoid prng_init(vec2 seed)\n{\n    prng_init(vec3(seed, 1));\n}\n\n// Initialize with float\nvoid prng_init(float seed)\n{\n    prng_init(vec3(seed, 1, 1));\n}\n\n/*____________________ End ____________________*/\n\n\n\n// ...\n",
     "name": "Common",
     "description": "",
     "type": "common"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "DlfBzN",
    "date": "1692651978",
    "viewed": 168,
    "name": "Square Fourier Transform?",
    "description": "What if we used square waves instead of (co)sine waves in Fourier transforms?\nSee sqsin() and sqcos() at the end of Common.\n\n- Enable fft_preview_input in the Common tab to see the input shapes.\n\n- You can also change the resolution in the Common tab.",
    "likes": 5,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "2d",
     "fft",
     "experiment",
     "square",
     "fourier"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "/* -----------------------------------------------\n  Shadertoy Unit: Image\n  Description: None\n  iChannel0: Buffer A\n  iChannel1: None\n  iChannel2: None\n  iChannel3: None\n----------------------------------------------- */\n\nvec2 screen_to_uv(vec2 coord)\n{\n    return (2.0 * coord - iResolution.xy) / min(iResolution.x, iResolution.y);\n}\n\nvec3 view_transform(vec3 col)\n{\n\t// OETF (Gamma)\n    return pow(col, vec3(1.0 / 2.5));\n}\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    // UV\n    vec2 uv = screen_to_uv(frag_coord);\n    \n    // Render\n    vec3 col = vec3(0.0);\n    if (max(abs(uv.x), abs(uv.y)) < 1.0)\n    {\n        col = texture(iChannel0, vec2(uv * 0.5 + 0.5) * vec2(fft_res) / iResolution.xy).rgb;\n        \n        vec3 tint = rgb_sweep(iTime * 0.14) + 0.03;\n        tint /= dot(tint, vec3(0.3, 0.59, 0.12));\n        col *= tint;\n    }\n    else\n    {\n        col = vec3(0);\n        //col = vec3(0.005, 0.01, 0.02);\n    }\n    \n    // Output\n    col = view_transform(col);\n    frag_col = vec4(col, 1.0);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "/* -----------------------------------------------\n  Shadertoy Unit: Common\n----------------------------------------------- */\n\nconst ivec2 fft_res = ivec2(150);\nconst bool fft_preview_input = bool(0);\nconst float fft_mul = 50.0 / float(fft_res.x * fft_res.y);\n\n\n\n// -----------------------------------------------\n// What to define\n// -----------------------------------------------\n\n/* Math Utils */\n#define MATH_UTILS 1\n\n/* Pseudo-Random Number Generator */\n#define PRNG 0\n\n/* Color Utils (requires MATH_UTILS) */\n#define COLOR_UTILS 1\n\n/* Keyboard Utils */\n#define KEYBOARD_UTILS 0\n\n// -----------------------------------------------\n// End\n// -----------------------------------------------\n\n\n\n// -----------------------------------------------\n// Math Utils\n// -----------------------------------------------\n\n#if MATH_UTILS\n\n#define PI 3.1415926535897932384626433832\n#define TAU 6.283185307179586476925286766\n#define PI_OVER_2 1.57079632679489661923132169163\n#define DEG_TO_RAD 0.01745329251994329576923690768\n#define RAD_TO_DEG 57.2957795130823208767981548141\n\n#define FUNC_LERP(T) \\\nT lerp(T a, T b, float t) \\\n{ \\\n    return a + t*(b-a); \\\n}\n\n#define FUNC_WRAP(T) \\\nT wrap(T inp, float start, float end) \\\n{ \\\n    return start + mod(inp - start, end - start); \\\n}\n\n#define FUNC_MAP_RANGE(T) \\\nT map_range(T inp, float inp_start, float inp_end, float out_start, float out_end) \\\n{ \\\n    return out_start + ((out_end - out_start) / (inp_end - inp_start)) * (inp - inp_start); \\\n}\n\n#define FUNC_MAP_RANGE_CLAMP(T) \\\nT map_range_clamp(T inp, float inp_start, float inp_end, float out_start, float out_end) \\\n{ \\\n    T t = clamp((inp - inp_start) / (inp_end - inp_start), 0.0, 1.0); \\\n    return out_start + t * (out_end - out_start); \\\n}\n\nFUNC_LERP(float)\nFUNC_LERP(vec2)\nFUNC_LERP(vec3)\nFUNC_LERP(vec4)\n\nFUNC_WRAP(float)\nFUNC_WRAP(vec2)\nFUNC_WRAP(vec3)\nFUNC_WRAP(vec4)\n\nFUNC_MAP_RANGE(float)\nFUNC_MAP_RANGE(vec2)\nFUNC_MAP_RANGE(vec3)\nFUNC_MAP_RANGE(vec4)\n\nFUNC_MAP_RANGE_CLAMP(float)\nFUNC_MAP_RANGE_CLAMP(vec2)\nFUNC_MAP_RANGE_CLAMP(vec3)\nFUNC_MAP_RANGE_CLAMP(vec4)\n\n#endif\n\n// -----------------------------------------------\n// End\n// -----------------------------------------------\n\n\n\n// -----------------------------------------------\n// Pseudo-Random Number Generator\n// Source: https://www.shadertoy.com/view/WdSSRt\n// -----------------------------------------------\n\n/* Usage Example:\n    void mainImage(out vec4 frag_col, in vec2 frag_coord)\n    {\n        // Initialize PRNG\n        prng_init(vec3(frag_coord / iResolution.y, iTime));\n    \n        // Using the function\n        float a = random();\n        vec3 b = vec3(random(), random(), random());\n        \n        ...\n    }\n*/\n\n#if PRNG\n\nuint prng_state[2];\n\nuint prng_rot(uint x, int k)\n{\n    return (x << k) | (x >> (32 - k));\n}\n\nfloat random()\n{\n    uint s0 = prng_state[0];\n    uint s1 = prng_state[1];\n    uint result = prng_rot(s0 * 0x9e3779bbu, 5) * 5u;\n    s1 ^= s0;\n    prng_state[0] = prng_rot(s0, 26) ^ s1 ^ (s1 << 9);\n    prng_state[1] = prng_rot(s1, 13);\n    return float(result) / float(0xffffffffu);\n}\n\nvoid prng_init(vec3 seed)\n{\n    seed.xy *= (seed.z + 10.258);\n    seed += 3.49276101561702;\n    prng_state[0] = floatBitsToUint(seed.x);\n    prng_state[1] = floatBitsToUint(seed.y);\n    random();\n}\n\n#endif\n\n// -----------------------------------------------\n// End\n// -----------------------------------------------\n\n\n\n// -----------------------------------------------\n// Color Utils (requires MATH_UTILS)\n// -----------------------------------------------\n\n#if COLOR_UTILS\n\nconst vec3 lum_linear_bt709 = vec3(0.2126, 0.7152, 0.0722);\n\nvec3 blender_rgb_to_hsv(vec3 rgb)\n{\n    float cmax, cmin, h, s, v, cdelta;\n    vec3 c;\n\n    cmax = max(rgb[0], max(rgb[1], rgb[2]));\n    cmin = min(rgb[0], min(rgb[1], rgb[2]));\n    cdelta = cmax - cmin;\n\n    v = cmax;\n    if (cmax != 0.0)\n    {\n        s = cdelta / cmax;\n    }\n    else\n    {\n        s = 0.0;\n        h = 0.0;\n    }\n\n    if (s == 0.0)\n    {\n        h = 0.0;\n    }\n    else\n    {\n        c = (vec3(cmax) - rgb.xyz) / cdelta;\n\n        if (rgb.x == cmax)\n        {\n            h = c[2] - c[1];\n        }\n        else if (rgb.y == cmax)\n        {\n            h = 2.0 + c[0] - c[2];\n        }\n        else\n        {\n            h = 4.0 + c[1] - c[0];\n        }\n\n        h /= 6.0;\n\n        if (h < 0.0)\n        {\n            h += 1.0;\n        }\n    }\n\n    return vec3(h, s, v);\n}\n\nvec3 blender_hsv_to_rgb(vec3 hsv)\n{\n    float i, f, p, q, t, h, s, v;\n    vec3 rgb;\n\n    h = hsv[0];\n    s = hsv[1];\n    v = hsv[2];\n\n    if (s == 0.0)\n    {\n        rgb = vec3(v, v, v);\n    }\n    else\n    {\n        if (h == 1.0)\n        {\n            h = 0.0;\n        }\n\n        h *= 6.0;\n        i = floor(h);\n        f = h - i;\n        rgb = vec3(f, f, f);\n        p = v * (1.0 - s);\n        q = v * (1.0 - (s * f));\n        t = v * (1.0 - (s * (1.0 - f)));\n\n        if (i == 0.0)\n        {\n            rgb = vec3(v, t, p);\n        }\n        else if (i == 1.0)\n        {\n            rgb = vec3(q, v, p);\n        }\n        else if (i == 2.0)\n        {\n            rgb = vec3(p, v, t);\n        }\n        else if (i == 3.0)\n        {\n            rgb = vec3(p, q, v);\n        }\n        else if (i == 4.0)\n        {\n            rgb = vec3(t, p, v);\n        }\n        else\n        {\n            rgb = vec3(v, p, q);\n        }\n    }\n\n    return rgb;\n}\n\nvec3 blender_hue_sat(vec3 col, float hue, float sat, float value)\n{\n    vec3 hsv = blender_rgb_to_hsv(col);\n\n    hsv[0] = fract(hsv[0] + hue + 0.5);\n    hsv[1] = clamp(hsv[1] * sat, 0.0, 1.0);\n    hsv[2] = hsv[2] * value;\n\n    return blender_hsv_to_rgb(hsv);\n}\n\nfloat rgb_avg(vec3 inp)\n{\n    return (inp.x + inp.y + inp.z) / 3.0;\n}\n\nfloat rgb_sum(vec3 inp)\n{\n    return inp.x + inp.y + inp.z;\n}\n\nfloat rgb_max(vec3 inp)\n{\n    return max(max(inp.x, inp.y), inp.z);\n}\n\nfloat rgb_min(vec3 inp)\n{\n    return min(min(inp.x, inp.y), inp.z);\n}\n\nvec3 rgb_sweep(float hue)\n{\n    hue = wrap(hue * 360.0, 0.0, 360.0);\n\n    vec3 col = vec3(1, 0, 0);\n    col = mix(col, vec3(1, 1, 0), map_range_clamp(hue, 0.0, 60.0, 0.0, 1.0));\n    col = mix(col, vec3(0, 1, 0), map_range_clamp(hue, 60.0, 120.0, 0.0, 1.0));\n    col = mix(col, vec3(0, 1, 1), map_range_clamp(hue, 120.0, 180.0, 0.0, 1.0));\n    col = mix(col, vec3(0, 0, 1), map_range_clamp(hue, 180.0, 240.0, 0.0, 1.0));\n    col = mix(col, vec3(1, 0, 1), map_range_clamp(hue, 240.0, 300.0, 0.0, 1.0));\n    col = mix(col, vec3(1, 0, 0), map_range_clamp(hue, 300.0, 360.0, 0.0, 1.0));\n    \n    return col;\n}\n\nfloat rgb_variance(vec3 a, vec3 b)\n{\n    a = max(a, 0.0);\n    b = max(b, 0.0);\n    \n    a += 0.001;\n    b += 0.001;\n    \n    float v = dot(abs(log2(a / b)), vec3(0.3, 0.59, 0.11));\n    return v*v;\n}\n\n#endif\n\n// -----------------------------------------------\n// End\n// -----------------------------------------------\n\n\n\n// -----------------------------------------------\n// Keyboard Utils\n// -----------------------------------------------\n\n#if KEYBOARD_UTILS\n\n#define KEY_BACKSPACE 8\n#define KEY_TAB 9\n#define KEY_ENTER 13\n#define KEY_SHIFT 16\n#define KEY_CTRL 17\n#define KEY_ALT 18\n#define KEY_PAUSE_BREAK 19\n#define KEY_CAPS_LOCK 20\n#define KEY_ESC 27\n#define KEY_SPACE 32\n#define KEY_PAGE_UP 33\n#define KEY_PAGE_DOWN 34\n#define KEY_END 35\n#define KEY_HOME 36\n#define KEY_LEFT 37\n#define KEY_UP 38\n#define KEY_RIGHT 39\n#define KEY_DOWN 40\n#define KEY_PRINT_SCREEN 44\n#define KEY_INSERT 45\n#define KEY_DELETE 46\n#define KEY_0 48\n#define KEY_1 49\n#define KEY_2 50\n#define KEY_3 51\n#define KEY_4 52\n#define KEY_5 53\n#define KEY_6 54\n#define KEY_7 55\n#define KEY_8 56\n#define KEY_9 57\n#define KEY_A 65\n#define KEY_B 66\n#define KEY_C 67\n#define KEY_D 68\n#define KEY_E 69\n#define KEY_F 70\n#define KEY_G 71\n#define KEY_H 72\n#define KEY_I 73\n#define KEY_J 74\n#define KEY_K 75\n#define KEY_L 76\n#define KEY_M 77\n#define KEY_N 78\n#define KEY_O 79\n#define KEY_P 80\n#define KEY_Q 81\n#define KEY_R 82\n#define KEY_S 83\n#define KEY_T 84\n#define KEY_U 85\n#define KEY_V 86\n#define KEY_W 87\n#define KEY_X 88\n#define KEY_Y 89\n#define KEY_Z 90\n#define KEY_LWIN 91\n#define KEY_RWIN 92\n#define KEY_POPUP 93\n#define KEY_NUMPAD_0 96\n#define KEY_NUMPAD_1 97\n#define KEY_NUMPAD_2 98\n#define KEY_NUMPAD_3 99\n#define KEY_NUMPAD_4 100\n#define KEY_NUMPAD_5 101\n#define KEY_NUMPAD_6 102\n#define KEY_NUMPAD_7 103\n#define KEY_NUMPAD_8 104\n#define KEY_NUMPAD_9 105\n#define KEY_NUMPAD_ASTERISK 106 \n#define KEY_NUMPAD_PLUS 107\n#define KEY_NUMPAD_MINUS 109\n#define KEY_NUMPAD_PERIOD 110\n#define KEY_NUMPAD_SLASH 111\n#define KEY_F1 112\n#define KEY_F2 113\n#define KEY_F3 114\n#define KEY_F4 115\n#define KEY_F5 116\n#define KEY_F6 117\n#define KEY_F7 118\n#define KEY_F8 119\n#define KEY_F9 120\n#define KEY_F10 121\n#define KEY_F11 122\n#define KEY_F12 123\n#define KEY_NUM_LOCK 144\n#define KEY_SCROLL_LOCK 145\n#define KEY_LSHIFT 160\n#define KEY_RSHIFT 161\n#define KEY_LCTRL 162\n#define KEY_RCTRL 163\n\nbool key_is_down(int key, sampler2D keyboard_channel)\n{\n    return texelFetch(keyboard_channel, ivec2(key, 0), 0).x != 0.0;\n}\n\nbool key_got_pressed(int key, sampler2D keyboard_channel)\n{\n    return texelFetch(keyboard_channel, ivec2(key, 1), 0).x != 0.0;\n}\n\nbool key_toggle_state(int key, sampler2D keyboard_channel)\n{\n    return texelFetch(keyboard_channel, ivec2(key, 2), 0).x != 0.0;\n}\n\nfloat fkey_is_down(int key, sampler2D keyboard_channel)\n{\n    return key_is_down(key, keyboard_channel) ? 1.0 : 0.0;\n}\n\nfloat fkey_got_pressed(int key, sampler2D keyboard_channel)\n{\n    return key_got_pressed(key, keyboard_channel) ? 1.0 : 0.0;\n}\n\nfloat fkey_toggle_state(int key, sampler2D keyboard_channel)\n{\n    return key_toggle_state(key, keyboard_channel) ? 1.0 : 0.0;\n}\n\n#endif\n\n// -----------------------------------------------\n// End\n// -----------------------------------------------\n\n\n\n// Just linear mapping\nfloat not_so_smoothstep(float e0, float e1, float x)\n{\n    return clamp((x - e0) / (e1 - e0), 0.0, 1.0);\n}\n\n// 1D slit function\nfloat slit(float x, float center, float half_width, float fade_width)\n{\n    return not_so_smoothstep(-half_width - fade_width, -half_width, x - center)\n        * not_so_smoothstep(half_width + fade_width, half_width, x - center);\n}\n\n// Regular polygon\n// Source: https://www.shadertoy.com/view/tdsXz8\nfloat sd_npoly(float n, float radius, float rotation, vec2 p)\n{\n    n *= .5;\n    float o = PI_OVER_2 / n;\n    float a = atan(p.y / p.x);\n    if(p.x < 0.)\n        a += PI;\n    float s = round((a + rotation) / PI * n) / n * PI - rotation;\n    float d = round((a + o + rotation) / PI * n) / n * PI - o - rotation;\n    vec2 c = vec2(cos(d), sin(d)) * radius;\n    vec2 f = vec2(cos(s), sin(s));\n    float b = length(p - c);\n    float l = dot(p, f);\n    l -= cos(o) * radius;\n    float m = b;\n    if(abs(dot(vec2(p.x, -p.y), f.yx)) <= sin(o) * radius)\n        m = l;\n    return m;\n}\n\nfloat sqsin(float x)\n{\n    return mod(x / TAU, 1.) < .5 ? 1. : -1.;\n}\n\nfloat sqcos(float x)\n{\n    return mod((x / TAU) + .25, 1.) < .5 ? 1. : -1.;\n}\n",
     "name": "Common",
     "description": "",
     "type": "common"
    },
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "/* -----------------------------------------------\n  Shadertoy Unit: Buffer A\n  Description: FFT is performed in this buffer.\n  iChannel0: None\n  iChannel1: None\n  iChannel2: None\n  iChannel3: None\n----------------------------------------------- */\n\nfloat shape0_radius;\nfloat shape1_slit1_half_width;\nfloat shape1_slit2_center;\nfloat shape1_slit2_fade;\nfloat shape1_cutout_radius;\n\nfloat fft_input(vec2 uv)\n{\n    int shape = int(floor(0.34 * iTime)) % 3;\n    if (shape == 0)\n    {\n        // Circle\n        return not_so_smoothstep(shape0_radius, shape0_radius - 0.02, distance(uv, vec2(0.5, 0.5)));\n    }\n    else if (shape == 1)\n    {\n        // Double slit\n        float v = slit(uv.x, 0.44, shape1_slit1_half_width, 0.004);\n        v += slit(uv.x, shape1_slit2_center, 0.02, shape1_slit2_fade);\n        v *= slit(uv.y, 0.5, 0.25, 0.004);\n        float d = distance(uv, vec2(0.5, 0.5));\n        v *= not_so_smoothstep(shape1_cutout_radius, shape1_cutout_radius - 0.01, d);\n        v *= not_so_smoothstep(0.3, 0.01, d) * 0.5 + 0.5;\n        return v;\n    }\n    else if (shape == 2)\n    {\n        // Pentagon\n        return not_so_smoothstep(0.01, 0.0, sd_npoly(5.0, 0.15, iTime * 0.25, uv - 0.5));\n    }\n    return 0.0;\n}\n\n// How much of this frequency is present in fft_input?\nvec2 freq_amount(ivec2 freq)\n{\n    const vec2 uv00 = 0.5 / vec2(fft_res);\n    const vec2 uv_step = 1.0 / vec2(fft_res);\n    vec2 f2 = vec2(freq) * TAU;\n    vec2 v = vec2(0.0);\n    float a = 0.0;\n    for (float y = uv00.y; y < 1.0; y += uv_step.y)\n    {\n        for (float x = uv00.x; x < 1.0; x += uv_step.x)\n        {\n            a = dot(vec2(x, y), f2);\n            v += fft_input(vec2(x, y)) * vec2(sqcos(a), sqsin(a));\n        }\n    }\n    return v * fft_mul;\n}\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    // If iResolution is not large enough\n    if (int(floor(iResolution.x)) < fft_res.x || int(floor(iResolution.y)) < fft_res.y)\n    {\n        frag_col = vec4(1, 0, 1, 1);\n        return;\n    }\n    \n    // Integer coordinates & UV\n    ivec2 icoord = ivec2(floor(frag_coord));\n    vec2 uv = (vec2(icoord) + 0.5) / vec2(fft_res);\n    \n    // If outside the region of interest\n    if (icoord.x >= fft_res.x || icoord.y >= fft_res.y)\n    {\n        frag_col = vec4(0, 0, 0, 1);\n        return;\n    }\n    \n    // Init variables for fft_input\n    float t = TAU * iTime;\n    shape0_radius = 0.16 + 0.07 * cos(t * 0.2);\n    shape1_slit1_half_width = 0.02 + 0.007 * cos(t * 0.2286);\n    shape1_slit2_center = 0.56 + 0.01 * cos(t * 0.4);\n    shape1_slit2_fade = 0.005 + 0.004 * cos(t * 0.3772);\n    shape1_cutout_radius = 0.254 + 0.02 * cos(t * 0.1689);\n    \n    float v = 0.0;\n    if (fft_preview_input)\n    {\n        // Preview FFT input\n        v = fft_input(uv);\n    }\n    else\n    {\n        // What 2D frequency to check\n        ivec2 freq = icoord - (fft_res / 2);\n        \n        // How much of the frequency is present\n        v = length(freq_amount(freq));\n    }\n    \n    // Output\n    frag_col = vec4(v, v, v, 1.0);\n}\n",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "mlfBR4",
    "date": "1692737129",
    "viewed": 164,
    "name": "Boids + Packed Voronoi Tracking",
    "description": "Finally learned Voronoi Tracking, read the explanations in Buffer A.",
    "likes": 3,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "voronoi",
     "simulation",
     "particles",
     "boids"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Read the explanations in Buffer A.\n\n#define BUFF_A iChannel0\n#define BUFF_B iChannel1\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    // Debug\n    if (false)\n    {\n        uvec4 stored_ids = floatBitsToUint(texelFetch(BUFF_A, ivec2(frag_coord), 0));\n        for (uint i = 0u; i < 4u; i++)\n        {\n            frag_col[i] = float(load_u16(stored_ids, i)) / float(max_particle_id(uvec2(iResolution.xy)));\n        }\n        return;\n    }\n    \n    // UV\n    px2uv_init(iResolution.xy);\n    vec2 uv = screen_to_uv(frag_coord);\n    \n    // Colliders\n    vec3 col = mix(\n        vec3(.2, .6, 1.),\n        vec3(.2, .8, .1),\n        remap01(sd_colliders(uv, iTime, iMouse), px2uv, 0.)\n    );\n    \n    // Particles distance (using the Voronoi buffer)\n    uvec4 stored_ids = floatBitsToUint(texelFetch(BUFF_A, ivec2(frag_coord), 0));\n    float dist_sqr = 1e9;\n    for (uint i = 0u; i < n_ids_in_voronoi; i++)\n    {\n        // ID\n        uint curr_id = load_u16(stored_ids, i);\n        \n        // Check if ID is invalid\n        if (curr_id > max_particle_id(uvec2(iResolution.xy)))\n            continue;\n        \n        // Matching pixel coordinates in the data buffer (this)\n        ivec2 icoord = idx_to_icoord2(int(curr_id), ivec2(iResolution.xy));\n        \n        // Get the distance\n        vec2 pos = texelFetch(BUFF_B, icoord, 0).xy;\n        pos -= uv;\n        dist_sqr = min(dist_sqr, dot(pos, pos));\n    }\n    \n    // Particles\n    col = mix(\n        col,\n        vec3(.05),\n        remap01(sqrt(dist_sqr), particle_radius + px2uv * .5, particle_radius - px2uv * .5)\n    );\n    \n    // Point of attraction\n    vec2 poa = get_point_of_attraction(iTime, iMouse);\n    col = mix(\n        col,\n        vec3(.8, 0.05, 0.04),\n        remap01(distance(uv, poa), .03, .03 - px2uv)\n    );\n    \n    // Output\n    col = pow(col, vec3(1. / 2.2));\n    frag_col = vec4(col, 1.);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "// Desired number of particles (actual count might be less)\nconst uint n_particles = 400u;\n\n// Number of particle IDs stored in each pixel in the Voronoi buffer\nconst uint n_ids_in_voronoi = 8u;\n\n// Particle position bounds\nconst vec2 min_pos = vec2(-.9);\nconst vec2 max_pos = vec2(.9);\n\n// Boid movement speed\nconst float move_speed = .6;\n\n// Particle radius for rendering\nconst float particle_radius = .006;\n\n// Particle attention radius\nconst float attention_radius = .2;\n\n// Epsilon\nconst float eps = .001;\n\n// Pixel to UV conversion factor\nfloat px2uv;\n\n// iResolution\nvec2 gres;\n\n// Initialize px2uv and gres\nvoid px2uv_init(vec2 res)\n{\n    px2uv = 2. / min(res.x, res.y);\n    gres = res;\n}\n\n// Screen to UV\nvec2 screen_to_uv(vec2 coord)\n{\n    return px2uv * (coord - .5 * gres);\n}\n\n// UV to screen\nvec2 uv_to_screen(vec2 uv)\n{\n    return (uv / px2uv) + (.5 * gres);\n}\n\n// Signed distance from the colliders\n// Make sure you have called px2uv_init() before\nfloat sd_colliders(vec2 p, float time, vec4 mouse)\n{\n    float d = 1e9;\n    \n    // Walls (bounds)\n    d = min(d, p.x - min_pos.x);\n    d = min(d, p.y - min_pos.y);\n    d = min(d, max_pos.x - p.x);\n    d = min(d, max_pos.y - p.y);\n    \n    // Circle\n    vec2 center;\n    if (false && mouse.z > .1)\n    {\n        center = screen_to_uv(mouse.xy);\n    }\n    else\n    {\n        center = vec2(sin(time) * .4, 0.);\n    }\n    d = min(d, length(p - center) - .15);\n    \n    return d;\n}\n\n// Get the point of attraction\nvec2 get_point_of_attraction(float time, vec4 mouse)\n{\n    if (true && mouse.z > .1)\n    {\n        return screen_to_uv(mouse.xy);\n    }\n    else\n    {\n        float a = .8 * time;\n        return .7 * vec2(cos(a), sin(a));\n    }\n}\n\nuint umin(uint a, uint b)\n{\n    return (a < b) ? a : b;\n}\n\nuint max_particle_id(uvec2 res)\n{\n    return umin(umin(n_particles - 1u, res.x * res.y - 1u), 65535u);\n}\n\n\n\n/*_________________ Math Utils ________________*/\n\n#define PI 3.1415926535897932384626433832\n#define TAU 6.283185307179586476925286766\n#define PI_OVER_2 1.57079632679489661923132169163\n\n#define FUNC_LERP(T) \\\nT lerp(T a, T b, float t) \\\n{ \\\n    return a + t*(b-a); \\\n}\n\n#define FUNC_WRAP(T) \\\nT wrap(T inp, float start, float end) \\\n{ \\\n    return start + mod(inp - start, end - start); \\\n}\n\n#define FUNC_REMAP(T) \\\nT remap(T inp, float inp_start, float inp_end, float out_start, float out_end) \\\n{ \\\n    return out_start + ((out_end - out_start) / (inp_end - inp_start)) * (inp - inp_start); \\\n}\n\n#define FUNC_REMAP_CLAMP(T) \\\nT remap_clamp(T inp, float inp_start, float inp_end, float out_start, float out_end) \\\n{ \\\n    T t = clamp((inp - inp_start) / (inp_end - inp_start), 0.0, 1.0); \\\n    return out_start + t * (out_end - out_start); \\\n}\n\n#define FUNC_REMAP01(T) \\\nT remap01(T inp, float inp_start, float inp_end) \\\n{ \\\n    return clamp((inp - inp_start) / (inp_end - inp_start), 0.0, 1.0); \\\n}\n\nFUNC_LERP(float)\nFUNC_LERP(vec2)\nFUNC_LERP(vec3)\nFUNC_LERP(vec4)\n\nFUNC_WRAP(float)\nFUNC_WRAP(vec2)\nFUNC_WRAP(vec3)\nFUNC_WRAP(vec4)\n\nFUNC_REMAP(float)\nFUNC_REMAP(vec2)\nFUNC_REMAP(vec3)\nFUNC_REMAP(vec4)\n\nFUNC_REMAP_CLAMP(float)\nFUNC_REMAP_CLAMP(vec2)\nFUNC_REMAP_CLAMP(vec3)\nFUNC_REMAP_CLAMP(vec4)\n\nFUNC_REMAP01(float)\nFUNC_REMAP01(vec2)\nFUNC_REMAP01(vec3)\nFUNC_REMAP01(vec4)\n\n/*____________________ End ____________________*/\n\n\n\n/*_______ Pseudo-Random Number Generator ______*/\n// Source: https://www.shadertoy.com/view/WdSSRt\n\n/* Usage Example:\n    void mainImage(out vec4 frag_col, in vec2 frag_coord)\n    {\n        // Initialize PRNG\n        prng_init(vec3(frag_coord / iResolution.y, iTime));\n    \n        // Using the function\n        float a = random();\n        vec3 b = vec3(random(), random(), random());\n        \n        ...\n    }\n*/\n\nuint prng_state[2];\n\nuint prng_rot(uint x, int k)\n{\n    return (x << k) | (x >> (32 - k));\n}\n\n// Random uint from 0 to 2^32-1\nuint randomui()\n{\n    uint s0 = prng_state[0];\n    uint s1 = prng_state[1];\n    uint result = prng_rot(s0 * 0x9e3779bbu, 5) * 5u;\n    s1 ^= s0;\n    prng_state[0] = prng_rot(s0, 26) ^ s1 ^ (s1 << 9);\n    prng_state[1] = prng_rot(s1, 13);\n    return result;\n}\n\n// Random int from 0 to 2^31-1\nint randomi()\n{\n    uint s0 = prng_state[0];\n    uint s1 = prng_state[1];\n    uint result = prng_rot(s0 * 0x9e3779bbu, 5) * 5u;\n    s1 ^= s0;\n    prng_state[0] = prng_rot(s0, 26) ^ s1 ^ (s1 << 9);\n    prng_state[1] = prng_rot(s1, 13);\n    return int(result % 0x7FFFFFFFu);\n}\n\n// Random float from 0 to 1\nfloat random()\n{\n    uint s0 = prng_state[0];\n    uint s1 = prng_state[1];\n    uint result = prng_rot(s0 * 0x9e3779bbu, 5) * 5u;\n    s1 ^= s0;\n    prng_state[0] = prng_rot(s0, 26) ^ s1 ^ (s1 << 9);\n    prng_state[1] = prng_rot(s1, 13);\n    return float(result) / float(0xffffffffu);\n}\n\n// Generate two normally distributed random numbers using the\n// Box-Muller Transform.\n// https://www.baeldung.com/cs/uniform-to-normal-distribution\nvec2 random_gauss()\n{\n    float u1 = random();\n    float u2 = random();\n    float temp = sqrt(-2. * log(u1));\n    return vec2(temp * cos(TAU * u2), temp * sin(TAU * u2));\n}\n\n// Initialize\nvoid prng_init(vec3 seed)\n{\n    seed.xy *= (seed.z + 10.258);\n    seed += 3.49276101561702;\n    prng_state[0] = floatBitsToUint(seed.x);\n    prng_state[1] = floatBitsToUint(seed.y);\n    randomui();\n}\n\n/*____________________ End ____________________*/\n\n\n\n// 1D index --> 2D integer coordinates\nivec2 idx_to_icoord2(int idx, ivec2 res)\n{\n    return ivec2(idx % res.x, idx / res.x);\n}\n\n// 1D index --> 3D integer coordinates\nivec3 idx_to_icoord3(int idx, ivec3 res)\n{\n    return ivec3(\n        idx % res.x,\n        (idx % (res.x * res.y)) / res.x,\n        idx / (res.x * res.y)\n    );\n}\n\n// 2D integer coordinates --> 1D index\nint icoord2_to_idx(ivec2 icoord, ivec2 res)\n{\n    return icoord.x + icoord.y * res.x;\n}\n\n// 3D integer coordinates --> 1D index\nint icoord3_to_idx(ivec3 icoord, ivec3 res)\n{\n    return\n        icoord.x\n        + icoord.y * res.x\n        + icoord.z * res.x * res.y;\n}\n\n// 2D integer coordinates --> 3D integer coordinates\nivec3 icoord2_to_3(ivec2 icoord2, ivec2 res2d, ivec3 res3d)\n{\n    return idx_to_icoord3(icoord2_to_idx(icoord2, res2d), res3d);\n}\n\n// 3D integer coordinates --> 2D integer coordinates\nivec2 icoord3_to_2(ivec3 icoord3, ivec3 res3d, ivec2 res2d)\n{\n    return idx_to_icoord2(icoord3_to_idx(icoord3, res3d), res2d);\n}\n\n// Check if 2D integer coordinates 'icoord' fit in a 2D screen of size 'res'\nbool icoord_in_bounds(ivec2 icoord, ivec2 res)\n{\n    return\n        (icoord.x >= 0) && (icoord.x < res.x)\n        && (icoord.y >= 0) && (icoord.y < res.y);\n}\n\n// Check if 3D integer coordinates 'icoord' fit in a 3D screen of size 'res'\nbool icoord_in_bounds(ivec3 icoord, ivec3 res)\n{\n    return\n        (icoord.x >= 0) && (icoord.x < res.x)\n        && (icoord.y >= 0) && (icoord.y < res.y)\n        && (icoord.z >= 0) && (icoord.z < res.z);\n}\n\n// Load a 16-bit unsigned integer from a uvec4. Max index is 7.\nuint load_u16(in uvec4 container, uint idx)\n{\n    if ((idx % 2u) == 0u)\n    {\n        return container[idx / 2u] & 65535u;\n    }\n    else\n    {\n        return (container[idx / 2u] & (65535u << 16)) >> 16;\n    }\n}\n\n// Store a 16-bit unsigned integer in a uvec4. Max index is 7.\nvoid store_u16(inout uvec4 container, uint idx, uint value)\n{\n    if (value > 65535u) value = 65535u;\n    container[idx / 2u] |= value << (16u * (idx % 2u));\n}\n\nvec2 random_unit_vec2()\n{\n    vec2 v = vec2(1);\n    float lensqr;\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec2(2. * random() - 1., 2. * random() - 1.);\n        lensqr = dot(v, v);\n        if (lensqr <= 1. && lensqr != 0.) break;\n    }\n    return v / sqrt(lensqr);\n}\n\nvec3 random_unit_vec3()\n{\n    vec3 v = vec3(1);\n    float lensqr;\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec3(2. * random() - 1., 2. * random() - 1., 2. * random() - 1.);\n        lensqr = dot(v, v);\n        if (lensqr <= 1. && lensqr != 0.) break;\n    }\n    return v / sqrt(lensqr);\n}\n\nvec2 random_in_circle()\n{\n    vec2 v = vec2(1);\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec2(2. * random() - 1., 2. * random() - 1.);\n        if (dot(v, v) <= 1.) return v;\n    }\n    return v;\n}\n\nvec3 random_in_sphere()\n{\n    vec3 v = vec3(1);\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec3(2. * random() - 1., 2. * random() - 1., 2. * random() - 1.);\n        if (dot(v, v) <= 1.) return v;\n    }\n    return v;\n}\n\nmat2 rotate2D(float angle)\n{\n    return mat2(cos(angle), sin(angle), cos(angle + PI_OVER_2), sin(angle + PI_OVER_2));\n}\n",
     "name": "Common",
     "description": "",
     "type": "common"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "// Voronoi buffer\n\n// Each pixel stores 8 IDs that are supposed to be the IDs of the eight closest\n// particles to the current pixel's matching UV coordinates. We store 8 IDs by\n// embedding them in the output as 16-bit integers. This is done by the help\n// of functions load_u16() and store_u16() implemented in Common, and built-in\n// functions uintBitsToFloat() and floatBitsToUint().\n\n// Each frame, we calculate the distances of the particles associated with the\n// IDs stored in a few randomly selected neighboring pixels (using a gaussian\n// distribution around the current pixel) from the current pixel's UV\n// coordinates, and we also do some checks against a few random particles in\n// the data buffer. After we have gathered all of the distances and their\n// corresponding particle IDs (the dist and id arrays), we sort them and\n// output the first 8 unique IDs to frag_col, storing them as 16-bit integers.\n\n// We have a mechanism for converting integer pixel coordinates to 1D indices\n// and vice versa. This lets us treat the data buffer (B) as a 1D array\n// instead of a 2D texture. This is how we calculate the integer pixel\n// coordinates from the particle ID. This also means we need to reset every\n// time the resolution changes. We do this by storing the resolution data in\n// the last pixel in the buffer. The last pixel in the Voronoi buffer also\n// contains the iteration number (number of frames since the last reset).\n\n// The data buffer (B) stores and updates the particle data. Each pixel stores\n// the position and the velocity of one particle in xy and zw. Every frame, we\n// use the Voronoi buffer (this) to get information about the 8 closest\n// particles.\n\n// You can find related constants in the Common tab.\n\n#define BUFF_A iChannel0\n#define BUFF_B iChannel1\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    // Info about the last pixel where we store useful data\n    ivec2 res_coord = ivec2(iResolution.xy) - 1;\n    vec4 res_data = texelFetch(BUFF_A, res_coord, 0);\n\n    // Should we reset?\n    bool should_reset =\n        iFrame < 1 ||\n        iTime < .02 ||\n        res_data.xy != iResolution.xy;\n    \n    // Store the current resolution in the last pixel, also store the number of\n    // frames passed since the last reset/initialization (Voronoi iteration).\n    if (ivec2(frag_coord) == res_coord)\n    {\n        frag_col = vec4(iResolution.xy, should_reset ? 0. : res_data.z + 1., 0);\n        return;\n    }\n    \n    // UV\n    px2uv_init(iResolution.xy);\n    vec2 uv = screen_to_uv(frag_coord);\n    \n    // Are we outside the bounds?\n    if (any(lessThan(uv, min_pos - .05)) || any(greaterThan(uv, max_pos + .05)))\n    {\n        frag_col = vec4(0);\n        return;\n    }\n\n    // Initialize PRNG\n    prng_init(vec3(frag_coord / iResolution.y, iTime));\n    \n    // Initialize with randomized IDs\n    if (should_reset)\n    {\n        uvec4 ids = uvec4(0);\n        for (uint i = 0u; i < n_ids_in_voronoi; i++)\n        {\n            store_u16(ids, i, randomui() % (max_particle_id(uvec2(iResolution.xy)) + 1u));\n        }\n        frag_col = uintBitsToFloat(ids);\n        return;\n    }\n    \n    // Gather the distances of the particles associated with the IDs stored in\n    // some neighboring pixels, and a few randomly selected particles.\n    const uint neighbors = 3u;\n    const uint random_checks = 2u;\n    \n    // A pixel in the Voronoi buffer (this) stores 8 IDs but a random check\n    // only checks a single particle.\n    const uint total_checks = n_ids_in_voronoi * neighbors + random_checks;\n    \n    // Array for storing the distances (squared for performance) and their\n    // associated IDs.\n    float dist_sqr[total_checks];\n    uint id[total_checks];\n    uint head = 0u;\n    \n    // Neighboring pixels\n    for (uint i = 0u; i < neighbors; i++)\n    {\n        // Coordinates of the pixel to check in the Voronoi buffer (this)\n        // Using gaussian distribution to focus around the center\n        vec2 offs = 3. * random_gauss();\n        ivec2 icoord = ivec2(floor(frag_coord + offs));\n        \n        // Check the IDs\n        uvec4 stored_ids = floatBitsToUint(texelFetch(BUFF_A, icoord, 0));\n        for (uint j = 0u; j < n_ids_in_voronoi; j++)\n        {\n            // ID\n            uint curr_id = load_u16(stored_ids, j);\n            id[head] = curr_id;\n            \n            // Get pixel coordinates in the data buffer (B)\n            ivec2 icoord2 = idx_to_icoord2(int(curr_id), ivec2(iResolution.xy));\n            \n            // Get the position from the data buffer (B)\n            vec2 curr_pos = texelFetch(BUFF_B, icoord2, 0).xy;\n            \n            // Distance squared\n            curr_pos -= uv;\n            dist_sqr[head] = dot(curr_pos, curr_pos);\n            \n            head++;\n        }\n    }\n    \n    // Also check against a few random particles in the data buffer (B)\n    for (uint i = 0u; i < random_checks; i++)\n    {\n        // ID\n        uint curr_id = randomui() % (max_particle_id(uvec2(iResolution.xy)) + 1u);\n        id[head] = curr_id;\n        \n        // Get pixel coordinates in the data buffer (B)\n        ivec2 icoord = idx_to_icoord2(int(curr_id), ivec2(iResolution.xy));\n        \n        // Get the position from the data buffer (B)\n        vec2 curr_pos = texelFetch(BUFF_B, icoord, 0).xy;\n        \n        // Distance squared\n        curr_pos -= uv;\n        dist_sqr[head] = dot(curr_pos, curr_pos);\n        \n        head++;\n    }\n    \n    // Sort id and dist based on dist in increasing order (Insertion Sort)\n    // https://betterprogramming.pub/5-basic-sorting-algorithms-you-must-know-9ef5b1f3949c\n    {\n        int i, j;\n        float keyf;\n        uint keyi;\n        for (i = 1; i < int(total_checks); i++)\n        {\n            keyf = dist_sqr[i];\n            keyi = id[i];\n            j = i - 1;\n            \n            /* Move elements of arr[0..i-1], that are greater than key, to one position ahead \n            of their current position */\n            while (j >= 0 && dist_sqr[j] > keyf)\n            {\n                dist_sqr[j + 1] = dist_sqr[j];\n                id[j + 1] = id[j];\n                j--;\n            }\n            dist_sqr[j + 1] = keyf;\n            id[j + 1] = keyi;\n        }\n    }\n    \n    // Pick the first 8 unique IDs and store as 16-bit ints\n    uvec4 closest_ids = uvec4(0);\n    head = 0u;\n    for (uint i = 0u; i < total_checks; i++)\n    {\n        // Check if this ID is unique\n        bool unique = true;\n        for (uint j = 0u; j < i; j++)\n        {\n            if (id[i] == id[j])\n            {\n                unique = false;\n                break;\n            }\n        }\n        \n        if (unique)\n        {\n            // Store new unique ID in closest_ids\n            uint curr_id = id[i];\n            store_u16(closest_ids, head++, curr_id);\n            if (head >= n_ids_in_voronoi)\n                break;\n        }\n    }\n    \n    // Output closest_ids\n    frag_col = uintBitsToFloat(closest_ids);\n}\n",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "XsXGR8",
       "channel": 0
      }
     ],
     "code": "// Data buffer\n// Read the explanations in Buffer A.\n\n#define BUFF_A iChannel0\n#define BUFF_B iChannel1\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    // Store the current resolution in the last pixel\n    ivec2 res_coord = ivec2(iResolution.xy) - 1;\n    if (ivec2(frag_coord) == res_coord)\n    {\n        frag_col = vec4(iResolution.xy, 0, 0);\n        return;\n    }\n    \n    // Are we outside the region of interest?\n    uint idx = uint(icoord2_to_idx(ivec2(frag_coord), ivec2(iResolution.xy)));\n    if (idx > max_particle_id(uvec2(iResolution.xy)))\n    {\n        return;\n    }\n    \n    // Initialize PRNG\n    prng_init(vec3(5. + frag_coord / iResolution.y, iTime + 5.));\n    \n    // Should we reset?\n    bool should_reset =\n        iFrame < 1 ||\n        iTime < .02 ||\n        texelFetch(BUFF_B, res_coord, 0).xy != iResolution.xy;\n    \n    // Initialize with random position and velocity\n    if (should_reset)\n    {\n        vec2 pos = vec2(remap(random(), 0., 1., min_pos.x, max_pos.x), remap(random(), 0., 1., min_pos.y, max_pos.y));\n        float angle = random() * TAU;\n        vec2 vel = move_speed * vec2(cos(angle), sin(angle));\n        frag_col = vec4(pos, vel);\n        return;\n    }\n    \n    // UV\n    px2uv_init(iResolution.xy);\n    \n    // Get last frame's value\n    vec4 data = texelFetch(BUFF_B, ivec2(frag_coord), 0);\n    vec2 pos = data.xy;\n    vec2 vel = data.zw;\n    \n    // Wait until the Voronoi buffer is relatively stable.\n    float voronoi_iter = texelFetch(BUFF_A, res_coord, 0).z;\n    if (voronoi_iter < 25.)\n    {\n        frag_col = vec4(pos, vel);\n        return;\n    }\n    \n    // Where does pos fall on the screen?\n    ivec2 icoord_pos = ivec2(floor(uv_to_screen(pos)));\n    \n    // Information about the 8 closest particles (using the Voronoi buffer)\n    uvec4 stored_ids = floatBitsToUint(texelFetch(BUFF_A, icoord_pos, 0));\n    vec2 nearby_pos[8];\n    vec2 nearby_vel[8];\n    float nearby_dist[8];\n    for (uint i = 0u; i < n_ids_in_voronoi; i++)\n    {\n        // ID\n        uint curr_id = load_u16(stored_ids, i);\n        \n        // Check if ID is invalid\n        if (curr_id > max_particle_id(uvec2(iResolution.xy)))\n        {\n            nearby_pos[i] = vec2(-100000.);\n            nearby_vel[i] = vec2(0);\n            nearby_dist[i] = 100000.;\n        }\n        else\n        {\n            // Matching pixel coordinates in the data buffer (this)\n            ivec2 icoord = idx_to_icoord2(int(curr_id), ivec2(iResolution.xy));\n            \n            // Get information\n            vec4 data2 = texelFetch(BUFF_B, icoord, 0);\n            nearby_pos[i] = data2.xy;\n            nearby_vel[i] = data2.zw;\n            nearby_dist[i] = distance(pos, nearby_pos[i]);\n        }\n    }\n    \n    // Delta time\n    float dt = min(iTimeDelta, 0.02);\n    \n    // Steer away from nearby boids\n    for (uint i = 0u; i < n_ids_in_voronoi; i++)\n    {\n        // Is the other boid in my view cone?\n        if (dot(normalize(vel), normalize(nearby_vel[i])) > cos(1.1))\n        {\n            // Vector between us\n            vec2 this_to_other = nearby_pos[i] - pos;\n            \n            // How much do I steer away?\n            float fac = 1. - clamp(nearby_dist[i] / attention_radius, 0., 1.);\n            \n            // Steer\n            float deg_per_sec = 20. * fac;\n            vel *= rotate2D(radians(deg_per_sec * dt));\n            \n            // Move away\n            vel -= 5. * fac * dt * this_to_other;\n        }\n    }\n    \n    // Try to go in the same direction as the neighbors\n    if (true)\n    {\n        // Weighted average of the neighbor velocities\n        vec2 avg_vel = vec2(0);\n        for (uint i = 0u; i < n_ids_in_voronoi; i++)\n        {\n            float weight = 1. - clamp(nearby_dist[i] / attention_radius, 0., 1.);\n            avg_vel += weight * nearby_vel[i];\n        }\n        \n        // Check if the lengths (squared) are zero\n        float lensqr_avg_vel = dot(avg_vel, avg_vel);\n        float lensqr_vel = dot(vel, vel);\n        if (lensqr_avg_vel > 0. && lensqr_vel > 0.)\n        {\n            // Tend toward the average direction\n            vel = mix(vel, avg_vel, min(.3 * dt, 1.));\n        }\n    }\n    \n    // Try to follow the point of attraction\n    if (true)\n    {\n        vec2 poa = get_point_of_attraction(iTime, iMouse);\n        vel = mix(vel, (poa - pos), min(1. * dt, 1.));\n    }\n    \n    // Constant speed\n    vel = move_speed * normalize(vel);\n\n    // Update position\n    pos += vel * dt;\n    \n    // Get away from the colliders\n    if (true)\n    {\n        // Signed distance\n        float sd = sd_colliders(pos, iTime, iMouse);\n        \n        // Normal\n        vec2 normal = normalize(vec2(\n            sd_colliders(pos + vec2(eps, 0.0), iTime, iMouse) - sd,\n            sd_colliders(pos + vec2(0.0, eps), iTime, iMouse) - sd\n        ));\n        \n        // If inside\n        if (sd < 0.)\n        {\n            // Snap to outside\n            pos += (.001 - sd) * normal;\n            \n            // Bounce\n            vel = reflect(vel, normal);\n        }\n        \n        // Steer away\n        float temp = max(0., sd);\n        float deg_per_sec = -50. * exp(-15. * temp);\n        float angle = radians(deg_per_sec * dt);\n        vel *= rotate2D(angle);\n        \n        // Move away\n        temp *= temp;\n        float force = 1. / (100. * temp + .1);\n        vel += force * dt * normal;\n    }\n    \n    // Output\n    frag_col = vec4(pos, vel);\n}\n",
     "name": "Buffer B",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "clXBW4",
    "date": "1692902788",
    "viewed": 86,
    "name": "Fork polygon :D beans_plea 404",
    "description": "challenge shader",
    "likes": 0,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "2d",
     "sdf",
     "distance",
     "polygon"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// The MIT License\n// Copyright  2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Distance to a regular pentagon, without trigonometric functions. \n\n// List of some other 2D distances: https://www.shadertoy.com/playlist/MXdSRf\n//\n// and iquilezles.org/articles/distfunctions2d\n\n\n\n\n\n\n\n\n// NO STEALING CODE FROM THE ORIGINAL!\n\n\n\n\n\n\n\n\n\nconst int N = 5;\n\nfloat sdPolygon( in vec2 p, in vec2[N] v )\n{\n    // Minimum distance\n    float m = 1e9;\n    \n    // How many segments intersect a half line from p to (+inf, p.y)\n    int num_intersections = 0;\n    \n    // The segments\n    for (int i = 0; i < N; i++)\n    {\n        // Line segment vertices\n        vec2 a = v[i];\n        vec2 b = v[(i + 1) % N];\n        \n        // Slope and intercept\n        float temp = b.x - a.x;\n        if (temp == 0.) temp = 1e-9;\n        float slope = (b.y - a.y) / temp;\n        float intercept = a.y - slope * a.x;\n        \n        // Should we use the endpoints or the line?\n        if (min(dot(p - a, b - a), dot(p - b, a - b)) < 0.)\n        {\n            // Distance from the endpoints\n            m = min(m, min(distance(p, a), distance(p, b)));\n        }\n        else\n        {\n            // Distance from the line\n            m = min(m, abs(slope * p.x - p.y + intercept) / sqrt(slope * slope + 1.));\n        }\n        \n        // Intersect AB with half line from p to (+inf, p.y)\n        // (only if p.y is between a.y and b.y)\n        if (p.y > min(a.y, b.y) && p.y < max(a.y, b.y))\n        {\n            float x_where_y_equals_py = (p.y - intercept) / slope;\n            if (x_where_y_equals_py > p.x)\n            {\n                num_intersections++;\n            }\n        }\n    }\n    \n    // Is num_intersections odd?\n    if (num_intersections % 2 == 1) m = -m;\n    \n    return m;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n        \n    // add more points\n    vec2[] polygon = vec2[N](\n        0.8*cos( 0.40*iTime + vec2(0.0,2.00) + 0.0 ),\n        0.8*cos( 0.45*iTime + vec2(0.0,1.50) + 1.0 ),\n        0.8*cos( 0.50*iTime + vec2(0.0,3.00) + 2.0 ),\n        0.8*cos( 0.55*iTime + vec2(0.0,2.00) + 4.0 ),\n        0.8*cos( 0.60*iTime + vec2(0.0,1.00) + 5.0 )\n    );\n    \n\tfloat d = sdPolygon(p, polygon);\n\n    vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.65,0.85,1.0);\n\tcol *= 1.0 - exp(-6.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(140.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.015,abs(d)) );\n    \n    if( iMouse.z>0.001 ){\n        d = sdPolygon( m, polygon );\n        col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n        col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n    \n    fragColor = col.xyzz;\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "dlsBDM",
    "date": "1693112135",
    "viewed": 218,
    "name": "Inverse Square Fourier Transform",
    "description": "0 = Input\n1 = 2D FFT\n2 = Inverse FFT\n\nSee use_sq at the top of Common.",
    "likes": 3,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "fft",
     "square",
     "fourier",
     "transform",
     "dft"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGzr",
       "filepath": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png",
       "type": "texture",
       "channel": 2,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "nearest",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "nearest",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "vec3 view_transform(vec3 col)\n{\n\t// OETF (Gamma)\n    return pow(col, vec3(1.0 / 2.2));\n}\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    // UV\n    vec2 uv = (2.0 * frag_coord - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    // What to render at this time?\n    int mode = int(floor(3. * iTime / sec_per_shape)) % 3;\n    \n    // UV for text\n    vec2 uv2 = frag_coord / min(iResolution.x, iResolution.y);\n    uv2 -= .1;\n    uv2 /= 1.5;\n    const vec2 uv2max = vec2(64. / 1024.) - .001;\n    \n    // Render\n    vec3 col = vec3(0.0);\n    if (all(greaterThan(uv2, vec2(.001))) && all(lessThan(uv2, uv2max)))\n    {\n        // Text\n        col = vec3(texture(iChannel2, vec2(0., .75) + vec2(float(mode) * 64. / 1024., 0.) + uv2).x);\n    }\n    else if (max(abs(uv.x), abs(uv.y)) < 1.0)\n    {\n        float v = 0.;\n        switch (mode)\n        {\n        case 0:\n            // Input\n            ft_input_init(iTime);\n            v = ft_input(vec2(uv * 0.5 + 0.5), iTime);\n            break;\n        case 1:\n            // FFT\n            v = length(texelFetch(iChannel0, ivec2(vec2(uv * 0.5 + 0.5) * vec2(ft_res)), 0).rg);\n            break;\n        case 2:\n            // Inverse FFT\n            v = length(texelFetch(iChannel1, ivec2(vec2(uv * 0.5 + 0.5) * vec2(ft_res)), 0).rg);\n            break;\n        }\n        col = vec3(v);\n    }\n    else\n    {\n        col = vec3(0);\n    }\n    \n    // Output\n    col = view_transform(col);\n    frag_col = vec4(col, 1.0);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "// Use square sin/cos?\nconst bool use_sq = true;\n\n// FT resolution\nconst ivec2 ft_res = ivec2(100);\n\n// FT multiplier. Do not modify\nconst float ft_mul = 1. / sqrt(float(ft_res.x * ft_res.y));\n\n// Seconds per shape\nconst float sec_per_shape = 6.;\n\n\n\n/*_________________ Math Utils ________________*/\n\n#define PI 3.1415926535897932384626433832\n#define TAU 6.283185307179586476925286766\n#define PI_OVER_2 1.57079632679489661923132169163\n\n#define FUNC_LERP(T) \\\nT lerp(T a, T b, float t) \\\n{ \\\n    return a + t*(b-a); \\\n}\n\n#define FUNC_WRAP(T) \\\nT wrap(T inp, float start, float end) \\\n{ \\\n    return start + mod(inp - start, end - start); \\\n}\n\n#define FUNC_REMAP(T) \\\nT remap(T inp, float inp_start, float inp_end, float out_start, float out_end) \\\n{ \\\n    return out_start + ((out_end - out_start) / (inp_end - inp_start)) * (inp - inp_start); \\\n}\n\n#define FUNC_REMAP_CLAMP(T) \\\nT remap_clamp(T inp, float inp_start, float inp_end, float out_start, float out_end) \\\n{ \\\n    T t = clamp((inp - inp_start) / (inp_end - inp_start), 0.0, 1.0); \\\n    return out_start + t * (out_end - out_start); \\\n}\n\n#define FUNC_REMAP01(T) \\\nT remap01(T inp, float inp_start, float inp_end) \\\n{ \\\n    return clamp((inp - inp_start) / (inp_end - inp_start), 0.0, 1.0); \\\n}\n\nFUNC_LERP(float)\nFUNC_LERP(vec2)\nFUNC_LERP(vec3)\nFUNC_LERP(vec4)\n\nFUNC_WRAP(float)\nFUNC_WRAP(vec2)\nFUNC_WRAP(vec3)\nFUNC_WRAP(vec4)\n\nFUNC_REMAP(float)\nFUNC_REMAP(vec2)\nFUNC_REMAP(vec3)\nFUNC_REMAP(vec4)\n\nFUNC_REMAP_CLAMP(float)\nFUNC_REMAP_CLAMP(vec2)\nFUNC_REMAP_CLAMP(vec3)\nFUNC_REMAP_CLAMP(vec4)\n\nFUNC_REMAP01(float)\nFUNC_REMAP01(vec2)\nFUNC_REMAP01(vec3)\nFUNC_REMAP01(vec4)\n\n/*____________________ End ____________________*/\n\n\n\n// 1D slit function\nfloat slit(float x, float center, float half_width, float fade_width)\n{\n    return remap01(x - center, -half_width - fade_width, -half_width)\n        * remap01(x - center, half_width + fade_width, half_width);\n}\n\n// Regular polygon\n// Source: https://www.shadertoy.com/view/tdsXz8\nfloat sd_npoly(float n, float radius, float rotation, vec2 p)\n{\n    n *= .5;\n    float o = PI_OVER_2 / n;\n    float a = atan(p.y / p.x);\n    if(p.x < 0.)\n        a += PI;\n    float s = round((a + rotation) / PI * n) / n * PI - rotation;\n    float d = round((a + o + rotation) / PI * n) / n * PI - o - rotation;\n    vec2 c = vec2(cos(d), sin(d)) * radius;\n    vec2 f = vec2(cos(s), sin(s));\n    float b = length(p - c);\n    float l = dot(p, f);\n    l -= cos(o) * radius;\n    float m = b;\n    if(abs(dot(vec2(p.x, -p.y), f.yx)) <= sin(o) * radius)\n        m = l;\n    return m;\n}\n\n// FT input variables\nfloat ft_input_shape0_radius;\nfloat ft_input_shape1_slit1_half_width;\nfloat ft_input_shape1_slit2_center;\nfloat ft_input_shape1_slit2_fade;\nfloat ft_input_shape1_cutout_radius;\n\n// Initialize FT input variables\nvoid ft_input_init(float time)\n{\n    float t = TAU * time;\n    ft_input_shape0_radius = 0.16 + 0.07 * cos(t * 0.2);\n    ft_input_shape1_slit1_half_width = 0.02 + 0.007 * cos(t * 0.2286);\n    ft_input_shape1_slit2_center = 0.56 + 0.01 * cos(t * 0.4);\n    ft_input_shape1_slit2_fade = 0.005 + 0.004 * cos(t * 0.3772);\n    ft_input_shape1_cutout_radius = 0.254 + 0.02 * cos(t * 0.1689);\n}\n\n// Evaluate FT input at uv and time\nfloat ft_input(vec2 uv, float time)\n{\n    int shape = int(floor(time / sec_per_shape)) % 3;\n    if (shape == 0)\n    {\n        // Circle\n        return remap01(distance(uv, vec2(0.5, 0.5)), ft_input_shape0_radius, ft_input_shape0_radius - 0.02);\n    }\n    else if (shape == 1)\n    {\n        // Double slit\n        float v = slit(uv.x, 0.44, ft_input_shape1_slit1_half_width, 0.004);\n        v += slit(uv.x, ft_input_shape1_slit2_center, 0.02, ft_input_shape1_slit2_fade);\n        v *= slit(uv.y, 0.5, 0.25, 0.004);\n        float d = distance(uv, vec2(0.5, 0.5));\n        v *= remap01(d, ft_input_shape1_cutout_radius, ft_input_shape1_cutout_radius - 0.01);\n        v *= remap01(d, 0.3, 0.01) * 0.5 + 0.5;\n        return v;\n    }\n    else if (shape == 2)\n    {\n        // Pentagon\n        return remap01(sd_npoly(5.0, 0.15, time * 0.25, uv - 0.5), 0.01, 0.0);\n    }\n    return 0.;\n}\n\n// Square sin\nfloat sqsin(float x)\n{\n    if (use_sq)\n        return mod(x / TAU, 1.) < .5 ? 1. : -1.;\n    else\n        return sin(x);\n}\n\n// Square cos\nfloat sqcos(float x)\n{\n    if (use_sq)\n        return mod((x / TAU) + .25, 1.) < .5 ? 1. : -1.;\n    else\n        return cos(x);\n}\n\n// Multiply two complex numbers\nvec2 complex_mul(vec2 a, vec2 b)\n{\n    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);\n}\n",
     "name": "Common",
     "description": "",
     "type": "common"
    },
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "// FT is performed in this buffer.\n\n// How much of this frequency is present in fft_input?\nvec2 freq_amount(ivec2 freq)\n{\n    vec2 f2 = vec2(freq) * TAU;\n    vec2 v = vec2(0);\n    for (int y = 0; y < ft_res.y; y++)\n    {\n        for (int x = 0; x < ft_res.x; x++)\n        {\n            vec2 uv = (vec2(x, y) + .5) / vec2(ft_res);\n            float a = dot(uv, f2);\n            v += ft_input(uv, iTime) * vec2(sqcos(a), sqsin(a));\n            // Same thing:\n            //v += complex_mul(vec2(ft_input(uv, iTime), 0.), vec2(sqcos(a), sqsin(a)));\n        }\n    }\n    return v * ft_mul;\n}\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    // If iResolution is not large enough\n    if (int(floor(iResolution.x)) < ft_res.x || int(floor(iResolution.y)) < ft_res.y)\n    {\n        frag_col = vec4(1, 0, 1, 1);\n        return;\n    }\n    \n    // Integer coordinates & UV\n    ivec2 icoord = ivec2(floor(frag_coord));\n    \n    // If outside the region of interest\n    if (icoord.x >= ft_res.x || icoord.y >= ft_res.y)\n    {\n        frag_col = vec4(0, 0, 0, 1);\n        return;\n    }\n    \n    // Init variables for ft_input\n    ft_input_init(iTime);\n    \n    // What 2D frequency to check\n    ivec2 freq = icoord - (ft_res / 2);\n    \n    // How much of the frequency is present\n    frag_col = vec4(freq_amount(freq), 0., 1.);\n}\n",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "nearest",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "XsXGR8",
       "channel": 0
      }
     ],
     "code": "// Inverse FT is performed in this buffer.\n\n// How much of this frequency is present in the input?\nvec2 freq_amount(ivec2 freq)\n{\n    vec2 f2 = vec2(freq) * -TAU;\n    vec2 v = vec2(0);\n    for (int y = 0; y < ft_res.y; y++)\n    {\n        for (int x = 0; x < ft_res.x; x++)\n        {\n            vec2 uv = (vec2(x, y) + .5) / vec2(ft_res);\n            float a = dot(uv, f2);\n            v += complex_mul(texelFetch(iChannel0, ivec2(x, y), 0).xy, vec2(sqcos(a), sqsin(a)));\n        }\n    }\n    return v * ft_mul;\n}\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    // If iResolution is not large enough\n    if (int(floor(iResolution.x)) < ft_res.x || int(floor(iResolution.y)) < ft_res.y)\n    {\n        frag_col = vec4(1, 0, 1, 1);\n        return;\n    }\n    \n    // Integer coordinates & UV\n    ivec2 icoord = ivec2(floor(frag_coord));\n    \n    // If outside the region of interest\n    if (icoord.x >= ft_res.x || icoord.y >= ft_res.y)\n    {\n        frag_col = vec4(0, 0, 0, 1);\n        return;\n    }\n    \n    // What 2D frequency to check\n    ivec2 freq = icoord;\n    \n    // How much of the frequency is present\n    frag_col = vec4(freq_amount(freq), 0., 1.);\n}\n",
     "name": "Buffer B",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "mtlfRs",
    "date": "1693363623",
    "viewed": 142,
    "name": "Local Sorting Challenge",
    "description": "What's the fastest way to sort a local float array? (in practice this array will be different for each pixel)\nKeep in mind we can't use recursion or dynamic memory allocation unless we emulate them which would probably slow things down more.",
    "likes": 1,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "sort",
     "sorting"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "const int N = 90;\nfloat arr[N] = float[](17., 16., 19., 4., 32., 7., 9., 500., 21., 54., 33., 35., 47., 96., 64., 17., 16., 19., 4., 32., 7., 9., 500., 21.,  31., 1., -5., 7., 30., 22., 97., 4., 44., 79., 799., 9973., 64., -47., -8520., -9., 974., 34., 21., 54., 35., 47., 96., 64., 31., 1., -5., 7., 30., 22., 97., 4., 44., 79., 799., 9973., 64., -47., -8520., -9., 974., 21., 54., 35., 47., 96., 64., 31., 1., -5., 7., 30., 22., 97., 4., 44., 79., 799., 9973., 64., -47., -8520., -9., 974., 21., 54.);\n\n\n\n// Bubble Sort\n// https://www.geeksforgeeks.org/bubble-sort\nvoid bubble_sort()\n{\n    bool swapped;\n    float temp;\n    for (int i = 0; i < N - 1; i++)\n    {\n        swapped = false;\n        for (int j = 0; j < N - i - 1; j++)\n        {\n            if (arr[j] > arr[j + 1])\n            {\n                    // Swap\n                arr[j] += arr[j + 1];\n                arr[j + 1] = arr[j] - arr[j + 1];\n                arr[j] -= arr[j + 1];\n                swapped = true;\n            }\n        }\n\n        // If no two elements were swapped by inner loop, then break.\n        if (!swapped)\n            break;\n    }\n}\n\n\n\n// Insertion Sort\n// https://betterprogramming.pub/5-basic-sorting-algorithms-you-must-know-9ef5b1f3949c\nvoid insertion_sort()\n{\n    int i, j;\n    float key;\n    for (i = 1; i < N; i++)\n    {\n        key = arr[i];\n        j = i - 1;\n\n        /* Move elements of arr[0..i-1], that are greater than key, to one position ahead \n        of their current position */\n        while (j >= 0 && arr[j] > key)\n        {\n            arr[j + 1] = arr[j];\n            j--;\n        }\n        arr[j + 1] = key;\n    }\n}\n\n\n\n// Selection Sort\n// https://betterprogramming.pub/5-basic-sorting-algorithms-you-must-know-9ef5b1f3949c\nvoid selection_sort()\n{\n    int i, j, min0;\n    float temp;\n    for (i = 0; i < N - 1; i++)\n    {\n        min0 = i;\n        for (j = i + 1; j < N; j++) if (arr[j] < arr[min0])\n            {\n                min0 = j;\n            }\n        temp = arr[i];\n        arr[i] = arr[min0];\n        arr[min0] = temp;\n    }\n}\n\n\n\n// Shaker Sort\n// Suggested by Envy24\n// https://www.shadertoy.com/view/stVfDV\nvoid shaker_sort()\n{\n    for (int L = N - 1, E = 1, C = -1; L > E; --L, ++E)\n    {\n        while (++C < L)\n        {\n            if (arr[C] > arr[C + 1])\n            {\n                float A = arr[C];\n                arr[C] = arr[C + 1];\n                arr[C + 1] = A;\n            }\n        }\n\n        while (--C >= E)\n        {\n            if (arr[C - 1] > arr[C])\n            {\n                float A = arr[C - 1];\n                arr[C - 1] = arr[C];\n                arr[C] = A;\n            }\n        }\n    }\n}\n\n\n\n// Radix Sort\n// Suggested by Envy24\n// https://www.shadertoy.com/view/stVfDV\nvoid radix_sort()\n{\n    const int max_num_of_digits = 3; // base 10 digits for max element value 255.\n    const int base = 10;\n\n    int temp[N];\n    int digits_arr[10];\n    int power = 1;\n    float inv = 1. / 255.;\n\n    for (int k = 0; k < max_num_of_digits; ++k)\n    {\n        for (int i = 0; i < 10; ++i)\n        {\n            digits_arr[i] = 0;\n        }\n\n        for (int i = 0; i < N; ++i)\n        {\n            int value = int(arr[i] * 255.);\n            int digit = (value / power) % base;\n            ++digits_arr[digit];\n            temp[i] = value;\n        }\n\n        for (int i = 0; i < 9; ++i)\n        {\n            digits_arr[i + 1] += digits_arr[i];\n        }\n\n        for (int i = N - 1; i >= 0; --i)\n        {\n            float value = float(temp[i]) * inv;\n            int digit = (temp[i] / power) % base;\n            arr[--digits_arr[digit]] = value;\n        }\n\n        power *= base;\n    }\n}\n\n\n\n// Quick Sort\n// Suggested by Envy24\n// https://www.shadertoy.com/view/stVfDV\nvoid quick_sort()\n{\n    int pairs[2 * N], rw_offset = 0;\n\n    pairs[rw_offset++] = 0;\n    pairs[rw_offset++] = N - 1;\n\n    while (rw_offset != 0)\n    {\n        /* Tony Hoare's partition. */\n        int high = pairs[--rw_offset], low = pairs[--rw_offset];\n\n        float pivot = (arr[low] + arr[high]) * 0.5;\n        int i = low, j = high;\n\n        for (int k = 0; k < N; ++k)\n        {\n            while (arr[i] < pivot)\n            {\n                ++i;\n            }\n            while (arr[j] > pivot)\n            {\n                --j;\n            }\n\n            if (i >= j)\n            {\n                break;\n            }\n\n            float t = arr[i];\n            arr[i] = arr[j];\n            arr[j] = t;\n            ++i;\n            --j;\n        }\n        /* Tony Hoare's partition. */\n\n        if (low < j)\n        {\n            pairs[rw_offset++] = low;\n            pairs[rw_offset++] = j;\n        }\n        if (j + 1 < high)\n        {\n            pairs[rw_offset++] = j + 1;\n            pairs[rw_offset++] = high;\n        }\n    }\n}\n\n\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    // Sort arr in increasing order\n\n    //bubble_sort();      // 10.6 fps\n    //insertion_sort();   // 18.9 fps\n    //selection_sort();   // 12.9 fps\n    //shaker_sort();      // 12.3 fps\n    quick_sort();       // 60.0 fps (maxed out, the real FPS may be higher)\n\n    frag_col = vec4(arr[0]);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "DtSfzR",
    "date": "1693654314",
    "viewed": 270,
    "name": "Beach (Volume Absorption)",
    "description": "More or less: [code]col *= pow(absorption_col, depth)[/code]",
    "likes": 6,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "volume",
     "gradient",
     "exponential",
     "beach",
     "absorption"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "float remap_clamp(float inp, float inp_start, float inp_end, float out_start, float out_end)\n{\n    float t = clamp((inp - inp_start) / (inp_end - inp_start), 0.0, 1.0);\n    return out_start + t * (out_end - out_start);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Coordinates\n    vec2 uv = fragCoord / iResolution.xy;\n    uv.y += -.05 * iTime;\n    float x = uv.x + .01 * cos(10. * uv.y) + .002 * cos(40. * uv.y);\n    \n    // Base color\n    vec3 col = vec3(.98, .82, .62);\n    \n    // Absorption color\n    const vec3 sea = vec3(.45, .83, .945);\n    \n    // Absorb\n    float depth = remap_clamp(x, 0.2, 1., 0.0001, 30.);\n    col *= pow(sea, vec3(depth));\n    \n    // Desaturate\n    col = mix(col, vec3(.2, 1, 1), .01);\n    \n    // Output\n    col = pow(col, vec3(1. / 2.4));\n    fragColor = vec4(col, 1.0);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "ctjfDc",
    "date": "1694574459",
    "viewed": 369,
    "name": "Fork Discoteq 3 (+ flim)",
    "description": "Discoteq 3\nadded flim ( https://www.shadertoy.com/view/dd2yDz )",
    "likes": 8,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "blur",
     "lines",
     "smoothstep",
     "sinusoidal",
     "beautiful",
     "discoteque"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "#define S smoothstep\n#define R iResolution.xy\n#define T iTime\n\nfloat c(vec2 u) { return  S( 5./R.y, 0., abs(length(u) - .25)); }\nfloat t (float s) { return .5 + sin(T * s) * .5; }\nmat2 r (float a) { return mat2(cos(a), sin(-a), sin(a), cos(a)); }\n\nvec3 render(vec2 I)\n{\n    vec2 u =(I-.5*R)/R.y*r(T*.3);\n    vec4 O = vec4(0);\n    for (float i = 0.; i < 1.; i += 1./50.) {\n        float n = cnoise(vec3(u * 2.5  + i * .3, .9 * T + i * 1.2));\n        float l = c(u + n * .14);\n        vec3 c = mix(vec3(t(.4), t(.8), t(3.)), vec3(t(.8), t(1.2), t(.5)), i);\n        O += vec4(l * c * .3, i);\n    }\n    return O.rgb;\n}\n\nvoid mainImage( out vec4 O, in vec2 I )\n{\n    // Linear RGB\n    vec3 col = pow(render(I), vec3(2.2));\n\n    // Saturation\n    col = mix(vec3(dot(col, vec3(1. / 3.))), col, 1.2);\n\n    // flim\n    col = flim_transform(col, -.5, iChannel0);\n\n    // Output\n    O = vec4(col, 1);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "\n//\tClassic Perlin 3D Noise \n//\tby Stefan Gustavson\n//\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\nvec3 fade(vec3 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\n\nfloat cnoise(vec3 P){\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod(Pi0, 289.0);\n  Pi1 = mod(Pi1, 289.0);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 / 7.0;\n  vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 / 7.0;\n  vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \n  return 2.2 * n_xyz;\n}\n\n/***********************************\n\nflim - Filmic Color Transform\n\nInput Color Space:   Linear BT.709 I-D65\nOutput Color Space:  sRGB 2.2\n\nShadertoy Unit:\n  Common\n\nDescription:\n  Experimental port of flim for GLSL/Shadertoy\n  matching flim v1.1.0.\n  The common unit contains most of the code, and\n  receives gamut extension matrices from a buffer.\n\nAuthor:\n  Bean (beans_please on Shadertoy)\n\nOriginal Repo:\n  https://github.com/bean-mhm/flim\n\nOriginal Shader:\n  https://www.shadertoy.com/view/dd2yDz\n\n***********************************/\n\n// Parameters\n\nconst float flim_pre_exposure = 4.3;\nconst vec3 flim_pre_formation_filter = vec3(1.0);\nconst float flim_pre_formation_filter_strength = 0.0;\n\nconst float flim_extended_gamut_red_scale = 1.05;\nconst float flim_extended_gamut_green_scale = 1.12;\nconst float flim_extended_gamut_blue_scale = 1.045;\nconst float flim_extended_gamut_red_rot = 0.5;\nconst float flim_extended_gamut_green_rot = 2.0;\nconst float flim_extended_gamut_blue_rot = 0.1;\nconst float flim_extended_gamut_red_mul = 1.0;\nconst float flim_extended_gamut_green_mul = 1.0;\nconst float flim_extended_gamut_blue_mul = 1.0;\n\nconst float flim_sigmoid_log2_min = -10.0;\nconst float flim_sigmoid_log2_max = 22.0;\nconst float flim_sigmoid_toe_x = 0.44;\nconst float flim_sigmoid_toe_y = 0.28;\nconst float flim_sigmoid_shoulder_x = 0.591;\nconst float flim_sigmoid_shoulder_y = 0.779;\n\nconst float flim_negative_film_exposure = 6.0;\nconst float flim_negative_film_density = 5.0;\n\nconst vec3 flim_print_backlight = vec3(1.0);\nconst float flim_print_film_exposure = 6.0;\nconst float flim_print_film_density = 27.5;\n\nconst float flim_black_point = -1.0; // -1 = auto\nconst vec3 flim_post_formation_filter = vec3(1.0);\nconst float flim_post_formation_filter_strength = 0.0;\nconst float flim_midtone_saturation = 1.02;\n\n// -------------------------------\n\nfloat wrap(float inp, float start, float end)\n{\n    return start + mod(inp - start, end - start);\n}\n\nfloat lerp(float a, float b, float t)\n{\n    return a + t * (b - a);\n}\n\nvec3 lerp(vec3 a, vec3 b, float t)\n{\n    return a + t * (b - a);\n}\n\nfloat map_range(float inp, float inp_start, float inp_end, float out_start, float out_end)\n{\n    return out_start + ((out_end - out_start) / (inp_end - inp_start)) * (inp - inp_start);\n}\n\nfloat map_range_clamp(float inp, float inp_start, float inp_end, float out_start, float out_end)\n{\n    float t = clamp((inp - inp_start) / (inp_end - inp_start), 0.0, 1.0);\n    float v = out_start + t * (out_end - out_start);\n    return v;\n}\n\nvec3 blender_rgb_to_hsv(vec3 rgb)\n{\n    float cmax, cmin, h, s, v, cdelta;\n    vec3 c;\n\n    cmax = max(rgb[0], max(rgb[1], rgb[2]));\n    cmin = min(rgb[0], min(rgb[1], rgb[2]));\n    cdelta = cmax - cmin;\n\n    v = cmax;\n    if (cmax != 0.0)\n    {\n        s = cdelta / cmax;\n    }\n    else\n    {\n        s = 0.0;\n        h = 0.0;\n    }\n\n    if (s == 0.0)\n    {\n        h = 0.0;\n    }\n    else\n    {\n        c = (vec3(cmax) - rgb.xyz) / cdelta;\n\n        if (rgb.x == cmax)\n        {\n            h = c[2] - c[1];\n        }\n        else if (rgb.y == cmax)\n        {\n            h = 2.0 + c[0] - c[2];\n        }\n        else\n        {\n            h = 4.0 + c[1] - c[0];\n        }\n\n        h /= 6.0;\n\n        if (h < 0.0)\n        {\n            h += 1.0;\n        }\n    }\n\n    return vec3(h, s, v);\n}\n\nvec3 blender_hsv_to_rgb(vec3 hsv)\n{\n    float i, f, p, q, t, h, s, v;\n    vec3 rgb;\n\n    h = hsv[0];\n    s = hsv[1];\n    v = hsv[2];\n\n    if (s == 0.0)\n    {\n        rgb = vec3(v, v, v);\n    }\n    else\n    {\n        if (h == 1.0)\n        {\n            h = 0.0;\n        }\n\n        h *= 6.0;\n        i = floor(h);\n        f = h - i;\n        rgb = vec3(f, f, f);\n        p = v * (1.0 - s);\n        q = v * (1.0 - (s * f));\n        t = v * (1.0 - (s * (1.0 - f)));\n\n        if (i == 0.0)\n        {\n            rgb = vec3(v, t, p);\n        }\n        else if (i == 1.0)\n        {\n            rgb = vec3(q, v, p);\n        }\n        else if (i == 2.0)\n        {\n            rgb = vec3(p, v, t);\n        }\n        else if (i == 3.0)\n        {\n            rgb = vec3(p, q, v);\n        }\n        else if (i == 4.0)\n        {\n            rgb = vec3(t, p, v);\n        }\n        else\n        {\n            rgb = vec3(v, p, q);\n        }\n    }\n\n    return rgb;\n}\n\nvec3 blender_hue_sat(vec3 col, float hue, float sat, float value)\n{\n    vec3 hsv = blender_rgb_to_hsv(col);\n\n    hsv[0] = fract(hsv[0] + hue + 0.5);\n    hsv[1] = clamp(hsv[1] * sat, 0.0, 1.0);\n    hsv[2] = hsv[2] * value;\n\n    return blender_hsv_to_rgb(hsv);\n}\n\nfloat rgb_avg(vec3 inp)\n{\n    return (inp.x + inp.y + inp.z) / 3.0;\n}\n\nfloat rgb_sum(vec3 inp)\n{\n    return inp.x + inp.y + inp.z;\n}\n\nfloat rgb_max(vec3 inp)\n{\n    return max(max(inp.x, inp.y), inp.z);\n}\n\nfloat rgb_min(vec3 inp)\n{\n    return min(min(inp.x, inp.y), inp.z);\n}\n\nvec3 rgb_uniform_offset(vec3 inp, float black_point, float white_point)\n{\n    float mono = rgb_avg(inp);\n    float mono2 = map_range_clamp(mono, black_point / 1000.0, 1.0 - (white_point / 1000.0), 0.0, 1.0);\n    return inp * (mono2 / mono);\n}\n\nvec3 rgb_sweep(float hue)\n{\n    hue = wrap(hue * 360.0, 0.0, 360.0);\n\n    vec3 col = vec3(1, 0, 0);\n    col = mix(col, vec3(1, 1, 0), map_range_clamp(hue, 0.0, 60.0, 0.0, 1.0));\n    col = mix(col, vec3(0, 1, 0), map_range_clamp(hue, 60.0, 120.0, 0.0, 1.0));\n    col = mix(col, vec3(0, 1, 1), map_range_clamp(hue, 120.0, 180.0, 0.0, 1.0));\n    col = mix(col, vec3(0, 0, 1), map_range_clamp(hue, 180.0, 240.0, 0.0, 1.0));\n    col = mix(col, vec3(1, 0, 1), map_range_clamp(hue, 240.0, 300.0, 0.0, 1.0));\n    col = mix(col, vec3(1, 0, 0), map_range_clamp(hue, 300.0, 360.0, 0.0, 1.0));\n    \n    return col;\n}\n\n// -------------------------------\n\nvec3 flim_rgb_sweep(vec2 uv0to1)\n{\n    float hue = 1.0 - uv0to1.y;\n    float exposure = map_range(uv0to1.x, 0.0, 1.0, -5.0, 10.0);\n    return rgb_sweep(hue) * pow(2.0, exposure);\n}\n\n// https://www.desmos.com/calculator/khkztixyeu\nfloat flim_super_sigmoid(float inp, float toe_x, float toe_y, float shoulder_x, float shoulder_y)\n{\n    // Clip\n    inp = clamp(inp, 0.0, 1.0);\n    toe_x = clamp(toe_x, 0.0, 1.0);\n    toe_y = clamp(toe_y, 0.0, 1.0);\n    shoulder_x = clamp(shoulder_x, 0.0, 1.0);\n    shoulder_y = clamp(shoulder_y, 0.0, 1.0);\n\n    // Calculate straight line slope\n    float slope = (shoulder_y - toe_y) / (shoulder_x - toe_x);\n\n    // Toe\n    if (inp < toe_x)\n    {\n        float toe_pow = slope * toe_x / toe_y;\n        return toe_y * pow(inp / toe_x, toe_pow);\n    }\n\n    // Straight line\n    if (inp < shoulder_x)\n    {\n        float intercept = toe_y - (slope * toe_x);\n        return slope * inp + intercept;\n    }\n\n    // Shoulder\n    float shoulder_pow = -slope / (((shoulder_x - 1.0) / pow(1.0 - shoulder_x, 2.0)) * (1.0 - shoulder_y));\n    return (1.0 - pow(1.0 - (inp - shoulder_x) / (1.0 - shoulder_x), shoulder_pow)) * (1.0 - shoulder_y) + shoulder_y;\n}\n\nfloat flim_dye_mix_factor(float mono, float max_density)\n{\n    // log2 and map range\n    float offset = pow(2.0, flim_sigmoid_log2_min);\n    float fac = map_range_clamp(log2(mono + offset), flim_sigmoid_log2_min, flim_sigmoid_log2_max, 0.0, 1.0);\n\n    // Calculate amount of exposure from 0 to 1\n    fac = flim_super_sigmoid(fac, flim_sigmoid_toe_x, flim_sigmoid_toe_y, flim_sigmoid_shoulder_x, flim_sigmoid_shoulder_y);\n\n    // Calculate dye density\n    fac *= max_density;\n\n    // Mix factor\n    fac = pow(2.0, -fac);\n\n    // Clip and return\n    return clamp(fac, 0.0, 1.0);\n}\n\nvec3 flim_rgb_color_layer(vec3 inp, vec3 sensitivity_tone, vec3 dye_tone, float max_density)\n{\n    // Normalize\n    vec3 sensitivity_tone_norm = sensitivity_tone / rgb_sum(sensitivity_tone);\n    vec3 dye_tone_norm = dye_tone / rgb_max(dye_tone);\n\n    // Dye mix factor\n    float mono = dot(inp, sensitivity_tone_norm);\n    float mixFac = flim_dye_mix_factor(mono, max_density);\n\n    // Dye mixing\n    return lerp(dye_tone_norm, vec3(1.0), mixFac);\n}\n\nvec3 flim_rgb_develop(vec3 inp, float exposure, float max_density)\n{\n    // Exposure\n    inp *= pow(2.0, exposure);\n\n    // Blue-sensitive layer\n    vec3 result = flim_rgb_color_layer(inp, vec3(0, 0, 1), vec3(1, 1, 0), max_density);\n\n    // Green-sensitive layer\n    result *= flim_rgb_color_layer(inp, vec3(0, 1, 0), vec3(1, 0, 1), max_density);\n\n    // Red-sensitive layer\n    result *= flim_rgb_color_layer(inp, vec3(1, 0, 0), vec3(0, 1, 1), max_density);\n\n    return result;\n}\n\nvec3 flim_gamut_extension_mat_row(float primary_hue, float scale, float rotate, float mul)\n{\n    vec3 result = blender_hsv_to_rgb(vec3(wrap(primary_hue + (rotate / 360.0), 0.0, 1.0), 1.0 / scale, 1.0));\n    result /= rgb_sum(result);\n    result *= mul;\n    return result;\n}\n\nmat3 flim_gamut_extension_mat(\n    float red_scale,\n    float green_scale,\n    float blue_scale,\n    float red_rot,\n    float green_rot,\n    float blue_rot,\n    float red_mul,\n    float green_mul,\n    float blue_mul\n)\n{\n    mat3 m;\n    m[0] = flim_gamut_extension_mat_row(0.0, red_scale, red_rot, red_mul);\n    m[1] = flim_gamut_extension_mat_row(1.0 / 3.0, green_scale, green_rot, green_mul);\n    m[2] = flim_gamut_extension_mat_row(2.0 / 3.0, blue_scale, blue_rot, blue_mul);\n    return m;\n}\n\nvec3 negative_and_print(vec3 inp, vec3 backlight_ext)\n{\n    // Develop Negative\n    inp = flim_rgb_develop(inp, flim_negative_film_exposure, flim_negative_film_density);\n\n    // Backlight\n    inp *= backlight_ext;\n\n    // Develop Print\n    inp = flim_rgb_develop(inp, flim_print_film_exposure, flim_print_film_density);\n\n    return inp;\n}\n\nbool flim_load_matrices(sampler2D matrix_ch, out mat3 extend_mat, out mat3 extend_mat_inv)\n{\n    // W == valid_w means the matrices have been calculated\n    // in the source buffer.\n    const float valid_w = 2.0;\n\n    vec4 row;\n\n    // extend_mat\n    {\n        row = texelFetch(matrix_ch, ivec2(0, 0), 0);\n        if (row.w != valid_w)\n            return false;\n        extend_mat[0] = row.xyz;\n\n        row = texelFetch(matrix_ch, ivec2(1, 0), 0);\n        if (row.w != valid_w)\n            return false;\n        extend_mat[1] = row.xyz;\n\n        row = texelFetch(matrix_ch, ivec2(2, 0), 0);\n        if (row.w != valid_w)\n            return false;\n        extend_mat[2] = row.xyz;\n    }\n\n    // extend_mat_inv\n    {\n        row = texelFetch(matrix_ch, ivec2(3, 0), 0);\n        if (row.w != valid_w)\n            return false;\n        extend_mat_inv[0] = row.xyz;\n\n        row = texelFetch(matrix_ch, ivec2(4, 0), 0);\n        if (row.w != valid_w)\n            return false;\n        extend_mat_inv[1] = row.xyz;\n\n        row = texelFetch(matrix_ch, ivec2(5, 0), 0);\n        if (row.w != valid_w)\n            return false;\n        extend_mat_inv[2] = row.xyz;\n    }\n\n    return true;\n}\n\n// -------------------------------\n\n// matrix_ch: Which channel provides the buffer\n// containing gamut extension matrices?\nvec3 flim_transform(vec3 inp, float exposure, sampler2D matrix_ch)\n{\n    // Eliminate negative values\n    inp = max(inp, 0.0);\n\n    // Pre-Exposure\n    inp *= pow(2.0, flim_pre_exposure + exposure);\n\n    // Clip very large values for float precision reasons\n    inp = min(inp, 5000.0);\n\n    // Gamut Extension Matrix (Linear BT.709)\n    mat3 extend_mat, extend_mat_inv;\n    if (!flim_load_matrices(matrix_ch, extend_mat, extend_mat_inv))\n    {\n        return vec3(1, 0, 1);\n    }\n\n    // Backlight (extended gamut)\n    vec3 backlight_ext = flim_print_backlight * extend_mat;\n\n    // Upper limit in the print (highlight cap)\n    const float big = 10000000.0;\n    vec3 white_cap = negative_and_print(vec3(big, big, big), backlight_ext);\n\n    // Pre-Formation Filter\n    inp = lerp(inp, inp * flim_pre_formation_filter, flim_pre_formation_filter_strength);\n\n    // Convert to extended gamut\n    inp *= extend_mat;\n\n    // Negative & Print\n    inp = negative_and_print(inp, backlight_ext);\n\n    // Convert from extended gamut\n    inp *= extend_mat_inv;\n\n    // Eliminate negative values\n    inp = max(inp, 0.0);\n\n    // White cap\n    inp /= white_cap;\n\n    // Black cap\n    if (flim_black_point == -1.0) // -1 = auto\n    {\n        vec3 black_cap = negative_and_print(vec3(0.0), backlight_ext);\n        black_cap /= white_cap;\n        inp = rgb_uniform_offset(inp, rgb_avg(black_cap) * 1000.0, 0.0);\n    }\n    else\n    {\n        inp = rgb_uniform_offset(inp, flim_black_point, 0.0);\n    }\n\n    // Post-Formation Filter\n    inp = lerp(inp, inp * flim_post_formation_filter, flim_post_formation_filter_strength);\n\n    // Clip\n    inp = clamp(inp, 0.0, 1.0);\n\n    // Midtone Saturation\n    float mono = rgb_avg(inp);\n    float mixFac = (mono < 0.5) ? map_range_clamp(mono, 0.05, 0.5, 0.0, 1.0) : map_range_clamp(mono, 0.5, 0.95, 1.0, 0.0);\n    inp = lerp(inp, blender_hue_sat(inp, 0.5, flim_midtone_saturation, 1.0), mixFac);\n\n    // Clip\n    inp = clamp(inp, 0.0, 1.0);\n\n    // OETF (Gamma 2.2)\n    inp = pow(inp, vec3(1.0 / 2.2));\n\n    return inp;\n}\n\n/***********************************\n\nEnd of flim's implementation for Shadertoy Unit: Common\n\n***********************************/\n",
     "name": "Common",
     "description": "",
     "type": "common"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "/***********************************\n\nflim - Filmic Color Transform\n\nInput Color Space:   Linear BT.709 I-D65\nOutput Color Space:  sRGB 2.2\n\nShadertoy Unit:\n  Buffer X\n\nDescription:\n  Experimental port of flim for GLSL/Shadertoy\n  matching flim v1.1.0.\n  The buffer unit performs a one-time calculation\n  of flim's gamut extension matrices.\n\nAuthor:\n  Bean (beans_please on Shadertoy)\n\nOriginal Repo:\n  https://github.com/bean-mhm/flim\n\nOriginal Shader:\n  https://www.shadertoy.com/view/dd2yDz\n\n***********************************/\n\n// NOTE:\n// iChannel0 must be set to this buffer (self-feeding).\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // W == valid_w means the matrices have already been calculated.\n    const float valid_w = 2.0;\n\n    // We only care about the first 6 pixels\n    if (ivec2(fragCoord).x > 5 || ivec2(fragCoord).y > 0)\n        return;\n\n    // Previous frame's value\n    vec4 prev = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    fragColor = prev;\n\n    // Do we need to recalculate the matrices?\n    bool needToCalc = (prev.w != valid_w) || (iTime == 0.0) || (iFrame < 1);\n    if (!needToCalc)\n        return;\n\n    // (Re)calculate the matrices\n    mat3 extend_mat = flim_gamut_extension_mat(flim_extended_gamut_red_scale, flim_extended_gamut_green_scale, flim_extended_gamut_blue_scale, flim_extended_gamut_red_rot, flim_extended_gamut_green_rot, flim_extended_gamut_blue_rot, flim_extended_gamut_red_mul, flim_extended_gamut_green_mul, flim_extended_gamut_blue_mul);\n    mat3 extend_mat_inv = inverse(extend_mat);\n\n    // extend_mat\n    {\n        if (ivec2(fragCoord) == ivec2(0, 0))\n        {\n            fragColor = vec4(extend_mat[0], valid_w);\n        }\n        if (ivec2(fragCoord) == ivec2(1, 0))\n        {\n            fragColor = vec4(extend_mat[1], valid_w);\n        }\n        if (ivec2(fragCoord) == ivec2(2, 0))\n        {\n            fragColor = vec4(extend_mat[2], valid_w);\n        }\n    }\n\n    // extend_mat_inv\n    {\n        if (ivec2(fragCoord) == ivec2(3, 0))\n        {\n            fragColor = vec4(extend_mat_inv[0], valid_w);\n        }\n        if (ivec2(fragCoord) == ivec2(4, 0))\n        {\n            fragColor = vec4(extend_mat_inv[1], valid_w);\n        }\n        if (ivec2(fragCoord) == ivec2(5, 0))\n        {\n            fragColor = vec4(extend_mat_inv[2], valid_w);\n        }\n    }\n}\n\n/***********************************\n\nEnd of flim's implementation for Shadertoy Unit: Buffer X\n\n***********************************/\n",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "DdcyRf",
    "date": "1695281747",
    "viewed": 198,
    "name": "Exponential Colormap",
    "description": "See the Desmos graphs, play with v",
    "likes": 6,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "colormap",
     "exponential"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// https://www.desmos.com/calculator/n4mfhffj1n\nfloat f(float x, float v)\n{\n    if (abs(v) < .0001) v = .0001;\n    float p = pow(2., v);\n    return (1. - pow(p, -x)) / (1. - 1. / p);\n}\n\nvec3 colormap(float x)\n{\n    //float t = .1 * iTime;\n    //float t = .75 - 1.1 * x;\n    //float t = .25 * x;\n    float t = .6 + .8 * x;\n    \n    // https://www.desmos.com/calculator/sdqk904uu9\n    vec3 tone = 10. * vec3(\n        cos(6.283 * t),\n        cos(6.283 * (t - .3333)),\n        cos(6.283 * (t - .6667))\n    );\n    \n    x = smoothstep(-.04, 1., x);\n    vec3 c = vec3(\n        f(x, tone.r),\n        f(x, tone.g),\n        f(x, tone.b)\n    );\n    \n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = colormap(uv.x);\n    col = pow(col, vec3(.45));\n    fragColor = vec4(col,1.0);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "ds3fDM",
    "date": "1697312887",
    "viewed": 340,
    "name": "XPBD Rope",
    "description": "Finally implemented XPBD!\nWatch this amazing video: https://youtube.com/watch?v=jrociOAYqxA\n\n* Drag to move the tail\n\n* Long ish compile time (22 seconds for me), so be patient\n\n* Does not work well on my phone, presumably because of 16-bit floats.",
    "likes": 16,
    "published": "Public API",
    "usePreview": 1,
    "tags": [
     "2d",
     "simulation",
     "solver",
     "physics",
     "rope",
     "xpbd"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "nearest",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "void mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    // Don't display the bottom row\n    if (frag_coord.y < 1.)\n    {\n        frag_col = vec4(0);\n        return;\n    }\n\n    // Output buffer A\n    vec3 col = texelFetch(iChannel0, ivec2(frag_coord), 0).xyz;\n    col = pow(col, vec3(1. / 2.2));\n    frag_col = vec4(col, 1.);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "nearest",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "// Particle\nstruct particle_t\n{\n    vec2 pos;\n    vec2 pos_prev;\n    vec2 vel;\n    float inv_mass;\n    bool no_gravity;\n};\n\n// Constants\nconst float eps = .0001;\nconst float damp = .4;\nconst float rest_dist = .11;\n\n// Particles\nconst int n_particles = 10;\nparticle_t p[n_particles];\n\n// UV stuff\nfloat px2uv;\nvec2 screen_to_uv(vec2 coord)\n{\n    return px2uv * (coord - .5 * iResolution.xy);\n}\n\nbool is_initializing()\n{\n    return iFrame < 2 || iTime < .02;\n}\n\nvoid load_particles()\n{\n    for (int i = 0; i < n_particles; i++)\n    {\n        vec4 data = texelFetch(iChannel0, ivec2(i, 0), 0);\n        p[i].pos = data.xy;\n        p[i].vel = data.zw;\n        p[i].inv_mass = (i == 0 ? 0. : 1.);\n        p[i].no_gravity = (i == 0);\n    }\n}\n\nvoid output_particle(in particle_t p, out vec4 frag_col)\n{\n    frag_col = vec4(p.pos, p.vel);\n}\n\nconst int n_constraints = n_particles;\nfloat constraint_err(int constraint_idx, out float inv_stiffness)\n{\n    // Distance constraints\n    if (constraint_idx < (n_particles - 1))\n    {\n        inv_stiffness = 1. / 1000.;\n        return distance(\n            p[constraint_idx].pos,\n            p[constraint_idx + 1].pos\n        ) - rest_dist;\n    }\n    // Mouse constraint\n    else if (constraint_idx == (n_particles - 1))\n    {\n        inv_stiffness = 1. / 100.;\n        \n        if (iMouse.z < .5)\n            return 0.;\n        \n        vec2 uv_mouse = screen_to_uv(iMouse.xy);\n        return distance(uv_mouse, p[n_particles - 1].pos);\n    }\n    return 0.;\n}\n\nfloat constraint_err(int constraint_idx)\n{\n    float useless;\n    return constraint_err(constraint_idx, useless);\n}\n\nvec2 constraint_err_grad(int constraint_idx, int particle_idx)\n{\n    // Base constraint error without any modifications\n    float base_err = constraint_err(constraint_idx);\n    \n    // Make a copy of the particle's position\n    vec2 base_pos = p[particle_idx].pos;\n    \n    // Nudge the particle slightly in the X axis, then,\n    // re-evaluate the constraint error, and take the\n    // difference of the new error and the base error.\n    p[particle_idx].pos = base_pos + vec2(eps, 0);\n    float grad_x = constraint_err(constraint_idx) - base_err;\n    \n    // Same as above, with the Y axis\n    p[particle_idx].pos = base_pos + vec2(0, eps);\n    float grad_y = constraint_err(constraint_idx) - base_err;\n    \n    // Reset the particle's position\n    p[particle_idx].pos = base_pos;\n    \n    // Return the gradient\n    return vec2(grad_x, grad_y) / eps;\n}\n\nvoid solve_constraints(float dt)\n{\n    for (int constraint_idx = 0; constraint_idx < n_constraints; constraint_idx++)\n    {\n        // Calculate lambda\n        float inv_stiffness;\n        float numer = -constraint_err(constraint_idx, inv_stiffness);\n        float denom = inv_stiffness / (dt * dt);\n        for (int i = 0; i < n_particles; i++)\n        {\n            denom += p[i].inv_mass * len_sqr(\n                constraint_err_grad(constraint_idx, i)\n            );\n        }\n        if (denom == 0.) continue;\n        float lambda = numer / denom;\n        \n        // Update the particles\n        for (int i = 0; i < n_particles; i++)\n        {\n            p[i].pos +=\n                lambda\n                * p[i].inv_mass\n                * constraint_err_grad(constraint_idx, i);\n        }\n    }\n}\n\nfloat sd_segment(vec2 p, vec2 a, vec2 b)\n{\n    // Slope and intercept\n    float temp = b.x - a.x;\n    if (temp == 0.) temp = 1e-9;\n    float slope = (b.y - a.y) / temp;\n    float intercept = a.y - slope * a.x;\n    \n    // Should we use the endpoints or the line?\n    if (min(dot(p - a, b - a), dot(p - b, a - b)) < 0.)\n    {\n        // Distance from the endpoints\n        return min(distance(p, a), distance(p, b));\n    }\n    else\n    {\n        // Distance from the line\n        return abs(slope * p.x - p.y + intercept) / sqrt(slope * slope + 1.);\n    }\n}\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    // UV (2D world position of the current pixel)\n    px2uv = 2. / min(iResolution.x, iResolution.y);\n    vec2 uv = screen_to_uv(frag_coord);\n    \n    // Get the current values from the last frame\n    load_particles();\n    \n    // Use the bottom row for data and simulation\n    if (frag_coord.y < 1.)\n    {\n        int curr_idx = int(floor(frag_coord.x));\n        \n        if (curr_idx >= n_particles)\n            return;\n\n        // Initial values\n        if (is_initializing())\n        {\n            particle_t p;\n            p.pos = vec2(\n                float(curr_idx) * rest_dist,\n                .72\n            );\n            p.vel = vec2(0);\n            output_particle(p, frag_col);\n            \n            return;\n        }\n\n        // Delta time\n        float actual_dt = min(iTimeDelta, .02);\n\n        // Substeps\n        const int n_steps = 50;\n        float dt = actual_dt / float(n_steps);\n\n        // Step forward\n        for (int i = 0; i < n_steps; i++)\n        {\n            // Iterate through the particles\n            for (int j = 0; j < n_particles; j++)\n            {\n                // Gravity\n                const vec2 gravity = vec2(0, -9.81);\n                if (!p[j].no_gravity)\n                    p[j].vel += dt * gravity;\n                \n                // Dampen velocity\n                p[j].vel *= exp(-damp * dt);\n                \n                // Make a backup of the position\n                p[j].pos_prev = p[j].pos;\n                \n                // Position\n                p[j].pos += dt * p[j].vel;\n            }\n            \n            // Solve constraints\n            solve_constraints(dt);\n            \n            // Update the velocities\n            for (int j = 0; j < n_particles; j++)\n            {\n                p[j].vel = (p[j].pos - p[j].pos_prev) / dt;\n            }\n        }\n\n        // Output\n        output_particle(p[curr_idx], frag_col);\n\n        return;\n    }\n    \n    // Background color\n    vec3 col = vec3(0, .02, .07);\n    \n    // Don't render anything while initializing\n    if (is_initializing())\n    {\n        frag_col = vec4(col, 1);\n        return;\n    }\n\n    // Draw line segments connecting the particles\n    {\n        float min_dist = 1e9;\n        for (int i = 0; i < (n_particles - 1); i++)\n        {\n            min_dist = min(min_dist, sd_segment(uv, p[i].pos, p[i + 1].pos));\n        }\n        \n        const float thickness = .01;\n        col = mix(\n            col,\n            vec3(1),\n            .25 * remap01(min_dist, thickness, thickness - px2uv)\n        );\n    }\n\n    // Draw dots on the particles\n    {\n        float min_dist = 1e9;\n        for (int i = 0; i < n_particles; i++)\n        {\n            min_dist = min(min_dist, dist_sqr(uv, p[i].pos));\n        }\n        min_dist = sqrt(min_dist);\n        \n        const float radius = .03;\n        col = mix(\n            col,\n            vec3(1, .75, .1),\n            remap01(min_dist, radius, radius - px2uv)\n        );\n    }\n\n    frag_col = vec4(col, 1);\n}\n",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "/*_________________ Math Utils ________________*/\n\n#define PI 3.1415926535897932384626433832\n#define TAU 6.283185307179586476925286766\n#define PI_OVER_2 1.57079632679489661923132169163\n\n#define FUNC_LERP(T) \\\nT lerp(T a, T b, float t) \\\n{ \\\n    return a + t*(b-a); \\\n}\n\n#define FUNC_WRAP(T) \\\nT wrap(T inp, float start, float end) \\\n{ \\\n    return start + mod(inp - start, end - start); \\\n}\n\n#define FUNC_REMAP(T) \\\nT remap(T inp, float inp_start, float inp_end, float out_start, float out_end) \\\n{ \\\n    return out_start + ((out_end - out_start) / (inp_end - inp_start)) * (inp - inp_start); \\\n}\n\n#define FUNC_REMAP_CLAMP(T) \\\nT remap_clamp(T inp, float inp_start, float inp_end, float out_start, float out_end) \\\n{ \\\n    T t = clamp((inp - inp_start) / (inp_end - inp_start), 0.0, 1.0); \\\n    return out_start + t * (out_end - out_start); \\\n}\n\n#define FUNC_REMAP01(T) \\\nT remap01(T inp, float inp_start, float inp_end) \\\n{ \\\n    return clamp((inp - inp_start) / (inp_end - inp_start), 0.0, 1.0); \\\n}\n\n#define FUNC_LEN_SQR(T) \\\nfloat len_sqr(T inp) \\\n{ \\\n    return dot(inp, inp); \\\n}\n\n#define FUNC_DIST_SQR(T) \\\nfloat dist_sqr(T a, T b) \\\n{ \\\n    a -= b; \\\n    return dot(a, a); \\\n}\n\nFUNC_LERP(float)\nFUNC_LERP(vec2)\nFUNC_LERP(vec3)\nFUNC_LERP(vec4)\n\nFUNC_WRAP(float)\nFUNC_WRAP(vec2)\nFUNC_WRAP(vec3)\nFUNC_WRAP(vec4)\n\nFUNC_REMAP(float)\nFUNC_REMAP(vec2)\nFUNC_REMAP(vec3)\nFUNC_REMAP(vec4)\n\nFUNC_REMAP_CLAMP(float)\nFUNC_REMAP_CLAMP(vec2)\nFUNC_REMAP_CLAMP(vec3)\nFUNC_REMAP_CLAMP(vec4)\n\nFUNC_REMAP01(float)\nFUNC_REMAP01(vec2)\nFUNC_REMAP01(vec3)\nFUNC_REMAP01(vec4)\n\nFUNC_LEN_SQR(vec2)\nFUNC_LEN_SQR(vec3)\nFUNC_LEN_SQR(vec4)\n\nFUNC_DIST_SQR(vec2)\nFUNC_DIST_SQR(vec3)\nFUNC_DIST_SQR(vec4)\n\n/*____________________ End ____________________*/\n",
     "name": "Common",
     "description": "",
     "type": "common"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "DsGBDy",
    "date": "1698577359",
    "viewed": 138,
    "name": "angle in [0, 2pi)",
    "description": "the",
    "likes": 3,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "atan",
     "angle"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (2. * fragCoord - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    vec3 col = .5 + .5 * cos(iTime+uv.xyx+vec3(0, 2, 4));\n    \n    float a = atan(uv.y, uv.x);\n    if (a < 0.)\n        a += 6.2831853;\n    \n    col *= a / 6.2831853;\n    \n    col = pow(col, vec3(1. / 2.2));\n    fragColor = vec4(col, 1);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "Mcf3Dj",
    "date": "1703544197",
    "viewed": 214,
    "name": "FBM Voronoi",
    "description": "i like voronoi",
    "likes": 2,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "voronoi",
     "noise",
     "random",
     "worley",
     "cellular",
     "prng",
     "rng"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "vec2 screen_to_uv(vec2 coord)\n{\n    return 2. * (coord - .5 * iResolution.xy) / min(iResolution.x, iResolution.y);\n}\n\nfloat dist_sq(vec2 a, vec2 b)\n{\n    a -= b;\n    return dot(a, a);\n}\n\n// random offset for a sample point inside a cell\nvec2 cell_corner_offs(ivec2 icell, float cell_size)\n{\n    prng_init(uvec2(icell));\n    return cell_size * (vec2(random(), random()) - .5);\n}\n\nfloat voronoi(vec2 coord)\n{\n    const float cell_size = 1.;\n\n    // cell indices\n    ivec2 icell = ivec2(floor(coord / cell_size));\n    \n    // sample positions (bottom left, top left, etc.)\n    // p0 = center point of the current cell\n    vec2 p0 = (vec2(icell) + .5) * cell_size;\n    vec2 p1 = p0 + vec2(-cell_size, 0);\n    vec2 p2 = p0 + vec2(-cell_size, cell_size);\n    vec2 p3 = p0 + vec2(0, cell_size);\n    vec2 p4 = p0 + vec2(cell_size, cell_size);\n    vec2 p5 = p0 + vec2(cell_size, 0);\n    vec2 p6 = p0 + vec2(cell_size, -cell_size);\n    vec2 p7 = p0 + vec2(0, -cell_size);\n    vec2 p8 = p0 + vec2(-cell_size, -cell_size);\n    \n    // randomly offset the sample points\n    p0 += cell_corner_offs(icell, cell_size);\n    p1 += cell_corner_offs(icell + ivec2(-1, 0), cell_size);\n    p2 += cell_corner_offs(icell + ivec2(-1, 1), cell_size);\n    p3 += cell_corner_offs(icell + ivec2(0, 1), cell_size);\n    p4 += cell_corner_offs(icell + ivec2(1, 1), cell_size);\n    p5 += cell_corner_offs(icell + ivec2(1, 0), cell_size);\n    p6 += cell_corner_offs(icell + ivec2(1, -1), cell_size);\n    p7 += cell_corner_offs(icell + ivec2(0, -1), cell_size);\n    p8 += cell_corner_offs(icell + ivec2(-1, -1), cell_size);\n    \n    // smallest distance between coord and any of the sample points\n    float dist = 1e9;\n    dist = min(dist, dist_sq(coord, p0));\n    dist = min(dist, dist_sq(coord, p1));\n    dist = min(dist, dist_sq(coord, p2));\n    dist = min(dist, dist_sq(coord, p3));\n    dist = min(dist, dist_sq(coord, p4));\n    dist = min(dist, dist_sq(coord, p5));\n    dist = min(dist, dist_sq(coord, p6));\n    dist = min(dist, dist_sq(coord, p7));\n    dist = min(dist, dist_sq(coord, p8));\n    dist = sqrt(dist);\n    \n    // normalize the output in [0, 1] and return.\n    const float max_dist = 1.4142135624 * cell_size;\n    const float fac = 1. / max_dist;\n    return dist * fac;\n}\n\nfloat voronoi_fractal(\n    vec2 coord,\n    int depth,\n    float roughness,\n    float lacunarity\n)\n{\n    float v = 0.;\n    float sum_fac = 0.;\n    \n    for (int i = 0; i < depth; i++)\n    {\n        // factor (impact of the current layer)\n        float fac = 0.;\n        roughness = clamp(roughness, -1., 1.);\n        if (roughness < 0.)\n        {\n            // roughness [-1, 0) will go from fully smooth to normal\n            fac = pow(\n                lacunarity / max(roughness + 1., .0001),\n                float(-i)\n            );\n        }\n        else\n        {\n            // roughness [0, 1] will go from normal to fully rough\n            fac = pow(\n                mix(lacunarity, 1., roughness),\n                float(-i)\n            );\n        }\n        sum_fac += fac;\n        \n        // scale of the current layer\n        float scale = pow(lacunarity, float(i));\n        \n        // add sample\n        v += fac * voronoi(coord * scale);\n        \n        // translate the next layer\n        coord += 100.;\n    }\n    \n    return v / sum_fac;\n}\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    vec2 uv = screen_to_uv(frag_coord) + .2 * iTime;\n    \n    vec2 coord = 3. * uv;\n    int depth = 6;\n    float roughness = -cos(TAU * .08 *  iTime);\n    float lacunarity = 2.;\n    \n    vec3 col = vec3(voronoi_fractal(\n        coord,\n        depth,\n        roughness,\n        lacunarity\n    ));\n    \n    // Output\n    col = pow(col, vec3(1. / 2.2));\n    frag_col = vec4(col, 1.);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "/*_________________ Math Utils ________________*/\n\n#define PI 3.1415926535897932384626433832\n#define TAU 6.283185307179586476925286766\n#define PI_OVER_2 1.57079632679489661923132169163\n\n#define FUNC_LERP(T) \\\nT lerp(T a, T b, float t) \\\n{ \\\n    return a + t*(b-a); \\\n}\n\n#define FUNC_WRAP(T) \\\nT wrap(T inp, float start, float end) \\\n{ \\\n    return start + mod(inp - start, end - start); \\\n}\n\n#define FUNC_REMAP(T) \\\nT remap(T inp, float inp_start, float inp_end, float out_start, float out_end) \\\n{ \\\n    return out_start + ((out_end - out_start) / (inp_end - inp_start)) * (inp - inp_start); \\\n}\n\n#define FUNC_REMAP_CLAMP(T) \\\nT remap_clamp(T inp, float inp_start, float inp_end, float out_start, float out_end) \\\n{ \\\n    T t = clamp((inp - inp_start) / (inp_end - inp_start), 0.0, 1.0); \\\n    return out_start + t * (out_end - out_start); \\\n}\n\n#define FUNC_REMAP01(T) \\\nT remap01(T inp, float inp_start, float inp_end) \\\n{ \\\n    return clamp((inp - inp_start) / (inp_end - inp_start), 0.0, 1.0); \\\n}\n\nFUNC_LERP(float)\nFUNC_LERP(vec2)\nFUNC_LERP(vec3)\nFUNC_LERP(vec4)\n\nFUNC_WRAP(float)\nFUNC_WRAP(vec2)\nFUNC_WRAP(vec3)\nFUNC_WRAP(vec4)\n\nFUNC_REMAP(float)\nFUNC_REMAP(vec2)\nFUNC_REMAP(vec3)\nFUNC_REMAP(vec4)\n\nFUNC_REMAP_CLAMP(float)\nFUNC_REMAP_CLAMP(vec2)\nFUNC_REMAP_CLAMP(vec3)\nFUNC_REMAP_CLAMP(vec4)\n\nFUNC_REMAP01(float)\nFUNC_REMAP01(vec2)\nFUNC_REMAP01(vec3)\nFUNC_REMAP01(vec4)\n\nmat2 rotate_2d(float angle)\n{\n    return mat2(cos(angle), sin(angle), cos(angle + PI_OVER_2), sin(angle + PI_OVER_2));\n}\n\n/*____________________ End ____________________*/\n\n\n\n/*_______ Pseudo-Random Number Generator ______*/\n// Source: https://www.shadertoy.com/view/WdSSRt\n\n/* Usage Example:\n    void mainImage(out vec4 frag_col, in vec2 frag_coord)\n    {\n        // Initialize PRNG\n        prng_init(vec3(frag_coord / iResolution.y, iTime));\n    \n        // Using the function\n        float a = random();\n        vec3 b = vec3(random(), random(), random());\n        \n        ...\n    }\n*/\n\nuint prng_state[2];\n\nuint prng_rot(uint x, int k)\n{\n    return (x << k) | (x >> (32 - k));\n}\n\n// Random uint from 0 to 2^32-1\nuint randomui()\n{\n    uint s0 = prng_state[0];\n    uint s1 = prng_state[1];\n    uint result = prng_rot(s0 * 0x9e3779bbu, 5) * 5u;\n    s1 ^= s0;\n    prng_state[0] = prng_rot(s0, 26) ^ s1 ^ (s1 << 9);\n    prng_state[1] = prng_rot(s1, 13);\n    return result;\n}\n\n// Random int from 0 to 2^31-1\nint randomi()\n{\n    return int(randomui() % 0x7FFFFFFFu);\n}\n\n// Random float from 0 to 1\nfloat random()\n{\n    return float(randomui()) / float(0xffffffffu);\n}\n\n// Generate two normally distributed random numbers using the\n// Box-Muller Transform.\n// https://www.baeldung.com/cs/uniform-to-normal-distribution\nvec2 random_gauss()\n{\n    float u1 = random();\n    float u2 = random() * TAU;\n    float temp = sqrt(-2. * log(u1));\n    return temp * vec2(cos(u2), sin(u2));\n    \n    // Unoptimized version\n    //float u1 = random();\n    //float u2 = random();\n    //return vec2(cos(TAU * u2), sin(TAU * u2)) * sqrt(-2. * log(u1));\n}\n\nvec2 random_unit_vec2()\n{\n    vec2 v = vec2(1);\n    float lensqr;\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec2(2. * random() - 1., 2. * random() - 1.);\n        lensqr = dot(v, v);\n        if (lensqr == 0.)\n            i--;\n        else if (lensqr <= 1.)\n            break;\n    }\n    return v / sqrt(lensqr);\n}\n\nvec3 random_unit_vec3()\n{\n    vec3 v = vec3(1);\n    float lensqr;\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec3(2. * random() - 1., 2. * random() - 1., 2. * random() - 1.);\n        lensqr = dot(v, v);\n        if (lensqr == 0.)\n            i--;\n        else if (lensqr <= 1.)\n            break;\n    }\n    return v / sqrt(lensqr);\n}\n\nvec2 random_in_circle()\n{\n    vec2 v = vec2(1);\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec2(2. * random() - 1., 2. * random() - 1.);\n        if (dot(v, v) <= 1.)\n            return v;\n    }\n    return v;\n}\n\nvec3 random_in_sphere()\n{\n    vec3 v = vec3(1);\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec3(2. * random() - 1., 2. * random() - 1., 2. * random() - 1.);\n        if (dot(v, v) <= 1.)\n            return v;\n    }\n    return v;\n}\n\n// Initialize with uvec2\nvoid prng_init(uvec2 seed)\n{\n    seed += uvec2(1317, 944573125);\n    seed *= 464973573u;\n    prng_state[0] = seed.x;\n    prng_state[1] = seed.y;\n    randomi();\n}\n\n// Initialize with uint\nvoid prng_init(uint seed)\n{\n    prng_init(uvec2(seed, 1));\n}\n\n// Initialize with vec3\nvoid prng_init(vec3 seed)\n{\n    seed += 3.49276101561702;\n    seed.xy *= (seed.z + 10.258);\n    prng_state[0] = floatBitsToUint(seed.x);\n    prng_state[1] = floatBitsToUint(seed.y);\n    randomui();\n}\n\n// Initialize with vec2\nvoid prng_init(vec2 seed)\n{\n    prng_init(vec3(seed, 1));\n}\n\n// Initialize with float\nvoid prng_init(float seed)\n{\n    prng_init(vec3(seed, 1, 1));\n}\n\n/*____________________ End ____________________*/\n",
     "name": "Common",
     "description": "",
     "type": "common"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "4fSGzR",
    "date": "1705547653",
    "viewed": 71,
    "name": "FBM Perlin",
    "description": "i like perlin noise",
    "likes": 0,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "noise",
     "perlin",
     "random",
     "worley",
     "prng",
     "rng"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "vec2 screen_to_uv(vec2 coord)\n{\n    return 2. * (coord - .5 * iResolution.xy) / min(iResolution.x, iResolution.y);\n}\n\nfloat bilinear(\n    float val_bl,\n    float val_tl,\n    float val_tr,\n    float val_br,\n    vec2 offs\n)\n{\n    return mix(\n        mix(val_bl, val_br, offs.x),\n        mix(val_tl, val_tr, offs.x),\n        offs.y\n    );\n}\n\nfloat perlin(vec2 coord)\n{\n    // Cell indices\n    ivec2 icell = ivec2(floor(coord));\n    \n    // Cell corners\n    vec2 cell_bl = vec2(icell);\n    vec2 cell_tl = cell_bl + vec2(0, 1);\n    vec2 cell_tr = cell_bl + vec2(1, 1);\n    vec2 cell_br = cell_bl + vec2(1, 0);\n    \n    // Cell offset in [0, 1) range (vector pointing from the bottom\n    // left corner to coord)\n    vec2 cell_offs = coord - cell_bl;\n    \n    // Generate a random unit vector at each cell corner and take\n    // the distance that coord has traveled along that line\n    \n    prng_init(uvec2(icell));\n    vec2 grad_bl = random_unit_vec2();\n    \n    prng_init(uvec2(icell) + uvec2(0, 1));\n    vec2 grad_tl = random_unit_vec2();\n    \n    prng_init(uvec2(icell) + uvec2(1, 1));\n    vec2 grad_tr = random_unit_vec2();\n    \n    prng_init(uvec2(icell) + uvec2(1, 0));\n    vec2 grad_br = random_unit_vec2();\n    \n    float dist_bl = relative_dist_along_line(coord, cell_bl, cell_bl + grad_bl);\n    float dist_tl = relative_dist_along_line(coord, cell_tl, cell_tl + grad_tl);\n    float dist_tr = relative_dist_along_line(coord, cell_tr, cell_tr + grad_tr);\n    float dist_br = relative_dist_along_line(coord, cell_br, cell_br + grad_br);\n    \n    // Smoothstep the cell offset vector\n    cell_offs = smoothstep(0., 1., cell_offs);\n    \n    // Bilinear interpolation between the four distances\n    float val = bilinear(\n        dist_bl,\n        dist_tl,\n        dist_tr,\n        dist_br,\n        cell_offs\n    );\n    \n    return val;\n}\n\nfloat perlin_fractal(\n    vec2 coord,\n    int depth,\n    float roughness,\n    float lacunarity\n)\n{\n    float v = 0.;\n    float sum_fac = 0.;\n    \n    for (int i = 0; i < depth; i++)\n    {\n        // Factor (impact of the current layer)\n        float fac = 0.;\n        roughness = clamp(roughness, -1., 1.);\n        if (roughness < 0.)\n        {\n            // Roughness [-1, 0) will go from fully smooth to normal\n            fac = pow(\n                lacunarity / max(roughness + 1., .0001),\n                float(-i)\n            );\n        }\n        else\n        {\n            // Roughness [0, 1] will go from normal to fully rough\n            fac = pow(\n                mix(lacunarity, 1., roughness),\n                float(-i)\n            );\n        }\n        sum_fac += fac;\n        \n        // Scale of the current layer\n        float scale = pow(lacunarity, float(i));\n        \n        // Add sample\n        v += fac * perlin(coord * scale);\n        \n        // Move and rotate the next layer\n        coord += 100.;\n        coord *= rotate_2d(1.09956);\n    }\n    \n    return v / sum_fac;\n}\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    vec2 uv = screen_to_uv(frag_coord) + .2 * iTime;\n    \n    vec2 coord = 4. * uv;\n    int depth = 7;\n    float roughness = -cos(TAU * .1 *  iTime);\n    float lacunarity = 2.;\n    \n    float v = perlin_fractal(\n        coord,\n        depth,\n        roughness,\n        lacunarity\n    );\n    \n    // Remap to [0, 1]\n    v = remap(v, -1., 1., 0., 1.);\n    \n    vec3 col = vec3(v);\n    \n    // Output\n    col = pow(col, vec3(1. / 1.5));\n    frag_col = vec4(col, 1.);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "/*_________________ Math Utils ________________*/\n\n#define PI 3.1415926535897932384626433832\n#define TAU 6.283185307179586476925286766\n#define PI_OVER_2 1.57079632679489661923132169163\n\n#define FUNC_LERP(T) \\\nT lerp(T a, T b, float t) \\\n{ \\\n    return a + t*(b-a); \\\n}\n\n#define FUNC_WRAP(T) \\\nT wrap(T inp, float start, float end) \\\n{ \\\n    return start + mod(inp - start, end - start); \\\n}\n\n#define FUNC_REMAP(T) \\\nT remap(T inp, float inp_start, float inp_end, float out_start, float out_end) \\\n{ \\\n    return out_start + ((out_end - out_start) / (inp_end - inp_start)) * (inp - inp_start); \\\n}\n\n#define FUNC_REMAP_CLAMP(T) \\\nT remap_clamp(T inp, float inp_start, float inp_end, float out_start, float out_end) \\\n{ \\\n    T t = clamp((inp - inp_start) / (inp_end - inp_start), 0.0, 1.0); \\\n    return out_start + t * (out_end - out_start); \\\n}\n\n#define FUNC_REMAP01(T) \\\nT remap01(T inp, float inp_start, float inp_end) \\\n{ \\\n    return clamp((inp - inp_start) / (inp_end - inp_start), 0.0, 1.0); \\\n}\n\nFUNC_LERP(float)\nFUNC_LERP(vec2)\nFUNC_LERP(vec3)\nFUNC_LERP(vec4)\n\nFUNC_WRAP(float)\nFUNC_WRAP(vec2)\nFUNC_WRAP(vec3)\nFUNC_WRAP(vec4)\n\nFUNC_REMAP(float)\nFUNC_REMAP(vec2)\nFUNC_REMAP(vec3)\nFUNC_REMAP(vec4)\n\nFUNC_REMAP_CLAMP(float)\nFUNC_REMAP_CLAMP(vec2)\nFUNC_REMAP_CLAMP(vec3)\nFUNC_REMAP_CLAMP(vec4)\n\nFUNC_REMAP01(float)\nFUNC_REMAP01(vec2)\nFUNC_REMAP01(vec3)\nFUNC_REMAP01(vec4)\n\nmat2 rotate_2d(float angle)\n{\n    return mat2(cos(angle), sin(angle), cos(angle + PI_OVER_2), sin(angle + PI_OVER_2));\n}\n\n/*____________________ End ____________________*/\n\n\n\n/*_______ Pseudo-Random Number Generator ______*/\n// Source: https://www.shadertoy.com/view/WdSSRt\n\n/* Usage Example:\n    void mainImage(out vec4 frag_col, in vec2 frag_coord)\n    {\n        // Initialize PRNG\n        prng_init(vec3(frag_coord / iResolution.y, iTime));\n    \n        // Using the function\n        float a = random();\n        vec3 b = vec3(random(), random(), random());\n        \n        ...\n    }\n*/\n\nuint prng_state[2];\n\nuint prng_rot(uint x, int k)\n{\n    return (x << k) | (x >> (32 - k));\n}\n\n// Random uint from 0 to 2^32-1\nuint randomui()\n{\n    uint s0 = prng_state[0];\n    uint s1 = prng_state[1];\n    uint result = prng_rot(s0 * 0x9e3779bbu, 5) * 5u;\n    s1 ^= s0;\n    prng_state[0] = prng_rot(s0, 26) ^ s1 ^ (s1 << 9);\n    prng_state[1] = prng_rot(s1, 13);\n    return result;\n}\n\n// Random int from 0 to 2^31-1\nint randomi()\n{\n    return int(randomui() % 0x7FFFFFFFu);\n}\n\n// Random float from 0 to 1\nfloat random()\n{\n    return float(randomui()) / float(0xffffffffu);\n}\n\n// Generate two normally distributed random numbers using the\n// Box-Muller Transform.\n// https://www.baeldung.com/cs/uniform-to-normal-distribution\nvec2 random_gauss()\n{\n    float u1 = random();\n    float u2 = random() * TAU;\n    float temp = sqrt(-2. * log(u1));\n    return temp * vec2(cos(u2), sin(u2));\n    \n    // Unoptimized version\n    //float u1 = random();\n    //float u2 = random();\n    //return vec2(cos(TAU * u2), sin(TAU * u2)) * sqrt(-2. * log(u1));\n}\n\nvec2 random_unit_vec2()\n{\n    vec2 v = vec2(1);\n    float lensqr;\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec2(2. * random() - 1., 2. * random() - 1.);\n        lensqr = dot(v, v);\n        if (lensqr == 0.)\n            i--;\n        else if (lensqr <= 1.)\n            break;\n    }\n    return v / sqrt(lensqr);\n}\n\nvec3 random_unit_vec3()\n{\n    vec3 v = vec3(1);\n    float lensqr;\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec3(2. * random() - 1., 2. * random() - 1., 2. * random() - 1.);\n        lensqr = dot(v, v);\n        if (lensqr == 0.)\n            i--;\n        else if (lensqr <= 1.)\n            break;\n    }\n    return v / sqrt(lensqr);\n}\n\nvec2 random_in_circle()\n{\n    vec2 v = vec2(1);\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec2(2. * random() - 1., 2. * random() - 1.);\n        if (dot(v, v) <= 1.)\n            return v;\n    }\n    return v;\n}\n\nvec3 random_in_sphere()\n{\n    vec3 v = vec3(1);\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec3(2. * random() - 1., 2. * random() - 1., 2. * random() - 1.);\n        if (dot(v, v) <= 1.)\n            return v;\n    }\n    return v;\n}\n\n// Initialize with uvec2\nvoid prng_init(uvec2 seed)\n{\n    seed += uvec2(1317, 944573125);\n    seed *= 464973573u;\n    prng_state[0] = seed.x;\n    prng_state[1] = seed.y;\n    randomi();\n}\n\n// Initialize with uint\nvoid prng_init(uint seed)\n{\n    prng_init(uvec2(seed, 1));\n}\n\n// Initialize with vec3\nvoid prng_init(vec3 seed)\n{\n    seed += 3.49276101561702;\n    seed.xy *= (seed.z + 10.258);\n    prng_state[0] = floatBitsToUint(seed.x);\n    prng_state[1] = floatBitsToUint(seed.y);\n    randomui();\n}\n\n// Initialize with vec2\nvoid prng_init(vec2 seed)\n{\n    prng_init(vec3(seed, 1));\n}\n\n// Initialize with float\nvoid prng_init(float seed)\n{\n    prng_init(vec3(seed, 1, 1));\n}\n\n/*____________________ End ____________________*/\n\n// https://www.shadertoy.com/view/Ml3Gz8\nfloat smoothmin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n    return mix(a, b, h) - k*h*(1.0-h);\n}\n\nvec2 perpendicular(vec2 dir)\n{\n    return vec2(-dir.y, dir.x);\n}\n\nfloat dist_sqr(vec2 a, vec2 b)\n{\n    vec2 temp = a - b;\n    return dot(temp, temp);\n}\n\nfloat dist_along_line(vec2 p, vec2 line_start, vec2 line_end)\n{\n    vec2 dir = line_end - line_start;\n    \n    // Normalize\n    float len_sqr = dot(dir, dir);\n    if (len_sqr < .0001)\n        return 1e9;\n    dir /= sqrt(len_sqr);\n    \n    return dot(\n        dir,\n        p - line_start\n    );\n}\n\nfloat relative_dist_along_line(vec2 p, vec2 line_start, vec2 line_end)\n{\n    vec2 dir = line_end - line_start;\n    return dot(\n        dir,\n        p - line_start\n    );\n}\n\nfloat fractional_dist_along_line(vec2 p, vec2 line_start, vec2 line_end)\n{\n    vec2 dir = line_end - line_start;\n    \n    // Divide by its length twice, once for normalizing, once for the fraction\n    float len_sqr = dot(dir, dir);\n    if (len_sqr < .0001)\n        return 1e9;\n    dir /= len_sqr;\n    \n    return dot(\n        dir,\n        p - line_start\n    );\n}\n",
     "name": "Common",
     "description": "",
     "type": "common"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "lf23zW",
    "date": "1736235885",
    "viewed": 78,
    "name": "NOISE SHOW",
    "description": "procedural noise",
    "likes": 4,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "procedural",
     "voronoi",
     "noise",
     "texture",
     "random",
     "worley",
     "cellular"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "vec2 screen_to_uv(vec2 coord)\n{\n    return 2. * (coord - .5 * iResolution.xy) / min(iResolution.x, iResolution.y);\n}\n\nfloat bilinear(\n    float val_bl,\n    float val_tl,\n    float val_tr,\n    float val_br,\n    vec2 offs\n)\n{\n    return mix(\n        mix(val_bl, val_br, offs.x),\n        mix(val_tl, val_tr, offs.x),\n        offs.y\n    );\n}\n\nfloat perlin(vec2 coord)\n{\n    // Cell indices\n    ivec2 icell = ivec2(floor(coord));\n    \n    // Cell corners\n    vec2 cell_bl = vec2(icell);\n    vec2 cell_tl = cell_bl + vec2(0, 1);\n    vec2 cell_tr = cell_bl + vec2(1, 1);\n    vec2 cell_br = cell_bl + vec2(1, 0);\n    \n    // Cell offset in [0, 1) range (vector pointing from the bottom\n    // left corner to coord)\n    vec2 cell_offs = coord - cell_bl;\n    \n    // Generate a random unit vector at each cell corner and take\n    // the distance that coord has traveled along that line\n    \n    prng_init(uvec2(icell));\n    vec2 grad_bl = random_unit_vec2();\n    \n    prng_init(uvec2(icell) + uvec2(0, 1));\n    vec2 grad_tl = random_unit_vec2();\n    \n    prng_init(uvec2(icell) + uvec2(1, 1));\n    vec2 grad_tr = random_unit_vec2();\n    \n    prng_init(uvec2(icell) + uvec2(1, 0));\n    vec2 grad_br = random_unit_vec2();\n    \n    float dist_bl = relative_dist_along_line(coord, cell_bl, cell_bl + grad_bl);\n    float dist_tl = relative_dist_along_line(coord, cell_tl, cell_tl + grad_tl);\n    float dist_tr = relative_dist_along_line(coord, cell_tr, cell_tr + grad_tr);\n    float dist_br = relative_dist_along_line(coord, cell_br, cell_br + grad_br);\n    \n    // Smoothstep the cell offset vector\n    cell_offs = smoothstep(0., 1., cell_offs);\n    \n    // Bilinear interpolation between the four distances\n    float val = bilinear(\n        dist_bl,\n        dist_tl,\n        dist_tr,\n        dist_br,\n        cell_offs\n    );\n    \n    return val;\n}\n\n// Random offset for a sample point inside a cell\nvec2 cell_corner_offs(ivec2 icell)\n{\n    prng_init(uvec2(icell));\n    return 1. *  (vec2(random(), random()) - .5);\n}\n\nfloat voronoi(vec2 coord, bool dist_to_edge)\n{\n    // Cell indices\n    ivec2 icell = ivec2(floor(coord));\n    \n    // Cell center\n    vec2 cell_center = (vec2(icell) + .5);\n    \n    if (dist_to_edge)\n    {\n        // Find the closest sample point\n        vec2 closest = vec2(0);\n        float dist = 1e9;\n        for (int yoffs = -1; yoffs <= 1; yoffs++)\n        {\n            for (int xoffs = -1; xoffs <= 1; xoffs++)\n            {\n                vec2 p = cell_center + vec2(xoffs, yoffs);\n                p += cell_corner_offs(icell + ivec2(xoffs, yoffs));\n                \n                float d = dist_sqr(coord, p);\n                if (d < dist)\n                {\n                    dist = d;\n                    closest = p;\n                }\n            }\n        }\n        \n        float dist2edge = 1e9;\n        for (int yoffs = -1; yoffs <= 1; yoffs++)\n        {\n            for (int xoffs = -1; xoffs <= 1; xoffs++)\n            {\n                vec2 p = cell_center + vec2(xoffs, yoffs);\n                p += cell_corner_offs(icell + ivec2(xoffs, yoffs));\n                \n                float d = dist_along_line(\n                    mix(closest, p, .5),\n                    coord,\n                    coord + p - closest\n                );\n                dist2edge = min(dist2edge, d);\n            }\n        }\n        \n        return dist2edge / 0.7071;\n    }\n    else\n    {\n        // Smallest distance between coord and any of the sample points\n        float dist = 1e9;\n        for (int yoffs = -1; yoffs <= 1; yoffs++)\n        {\n            for (int xoffs = -1; xoffs <= 1; xoffs++)\n            {\n                vec2 p = cell_center + vec2(xoffs, yoffs);\n                p += cell_corner_offs(icell + ivec2(xoffs, yoffs));\n                dist = min(dist, dist_sqr(coord, p));\n            }\n        }\n        dist = sqrt(dist);\n        \n        // Normalize the output in [0, 1] and return\n        const float max_dist = 1.4142135624;\n        const float fac = 1. / max_dist;\n        return dist * fac;\n    }\n}\n\nfloat perlin_fractal(\n    vec2 coord,\n    int depth,\n    float roughness,\n    float lacunarity\n)\n{\n    float v = 0.;\n    float sum_fac = 0.;\n    \n    for (int i = 0; i < depth; i++)\n    {\n        // Factor (impact of the current layer)\n        float fac = 0.;\n        roughness = clamp(roughness, -1., 1.);\n        if (roughness < 0.)\n        {\n            // Roughness [-1, 0) will go from fully smooth to normal\n            fac = pow(\n                lacunarity / max(roughness + 1., .0001),\n                float(-i)\n            );\n        }\n        else\n        {\n            // Roughness [0, 1] will go from normal to fully rough\n            fac = pow(\n                mix(lacunarity, 1., roughness),\n                float(-i)\n            );\n        }\n        sum_fac += fac;\n        \n        // Scale of the current layer\n        float scale = pow(lacunarity, float(i));\n        \n        // Add sample\n        v += fac * perlin(coord * scale);\n        \n        // Move and rotate the next layer\n        coord += 100.;\n        coord *= rotate_2d(1.09956);\n    }\n    \n    return v / sum_fac;\n}\n\nfloat voronoi_fractal(\n    vec2 coord,\n    int depth,\n    float roughness,\n    float lacunarity,\n    bool dist_to_edge\n)\n{\n    float v = 0.;\n    float sum_fac = 0.;\n    \n    for (int i = 0; i < depth; i++)\n    {\n        // Factor (impact of the current layer)\n        float fac = 0.;\n        roughness = clamp(roughness, -1., 1.);\n        if (roughness < 0.)\n        {\n            // Roughness [-1, 0) will go from fully smooth to normal\n            fac = pow(\n                lacunarity / max(roughness + 1., .0001),\n                float(-i)\n            );\n        }\n        else\n        {\n            // Roughness [0, 1] will go from normal to fully rough\n            fac = pow(\n                mix(lacunarity, 1., roughness),\n                float(-i)\n            );\n        }\n        sum_fac += fac;\n        \n        // Scale of the current layer\n        float scale = pow(lacunarity, float(i));\n        \n        // Add sample\n        v += fac * voronoi(coord * scale, dist_to_edge);\n        \n        // Move and rotate the next layer\n        coord += 100.;\n        coord *= rotate_2d(1.09956);\n    }\n    \n    return v / sum_fac;\n}\n\nvec3 render(vec2 uv)\n{\n    vec3 col = vec3(0);\n    float t = fract(iTime / 8.);\n    if (t < .25)\n    {\n        vec2 coord = 2. * uv;\n        const int depth = 6;\n        const float roughness = .2;\n        const float lacunarity = 3.;\n        \n        float v = voronoi_fractal(\n            coord,\n            depth,\n            roughness,\n            lacunarity,\n            false\n        );\n        \n        v = smoothstep(.08, .8, v);\n        \n        col = mix(vec3(.02, .18, .0), vec3(.3, .6, .05), remap(v, .45, .7, 0., 1.));\n        \n        float sand_mix = remap01(v, .43, .37);\n        col = mix(col, vec3(.7, .5, .2), sand_mix);\n        \n        float water_mix = remap01(v, .37, .25);\n        vec3 water_col = mix(vec3(.0, .05, .16), vec3(.0, .0, .05), remap(v, .4, 0., 0., 1.));\n        col = mix(col, water_col, water_mix);\n    }\n    else if (t < .5)\n    {\n        float v = smoothstep(-.4, .4, perlin_fractal(2.1 * uv, 5, .1, 3.));\n        col = vec3(1. * exp(-4. * v * v), .3 * exp(-8. * v), 1. * exp(-2.5 * v * v));\n    }\n    else if (t < .75)\n    {\n        float v = perlin_fractal(2.5 * uv, 2, .2, 2.);\n        v = remap(v, -1., 1., 0., 1.);\n        v -= .007 * sin(1. * TAU * iTime);\n        v -= .05 * iTime;\n        col = mix(\n            vec3(.7, .6, .3),\n            vec3(.3, .02, .02),\n            smoothstep(.057, .06, mod(v, .1))\n        );\n        col = mix(col, vec3(.7, .6, .3), smoothstep(.097, .1, mod(v, .1)));\n    }\n    else\n    {\n        float v = smoothstep(-.4, .22, perlin_fractal(1.8 * (uv + 20.), 4, .8, 4.));\n        col = vec3(0., exp(-10. * v), exp(-3. * v));\n    }\n    return col;\n}\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    // UV\n    vec2 uv = screen_to_uv(frag_coord) + .2 * iTime;\n    \n    // render\n    vec3 col = render(uv);\n    \n    // output\n    col = pow(col, vec3(1. / 2.2));\n    frag_col = vec4(col, 1.);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "/*_________________ Math Utils ________________*/\n\n#define PI 3.1415926535897932384626433832\n#define TAU 6.283185307179586476925286766\n#define PI_OVER_2 1.57079632679489661923132169163\n\n#define FUNC_LERP(T) \\\nT lerp(T a, T b, float t) \\\n{ \\\n    return a + t*(b-a); \\\n}\n\n#define FUNC_WRAP(T) \\\nT wrap(T inp, float start, float end) \\\n{ \\\n    return start + mod(inp - start, end - start); \\\n}\n\n#define FUNC_REMAP(T) \\\nT remap(T inp, float inp_start, float inp_end, float out_start, float out_end) \\\n{ \\\n    return out_start + ((out_end - out_start) / (inp_end - inp_start)) * (inp - inp_start); \\\n}\n\n#define FUNC_REMAP_CLAMP(T) \\\nT remap_clamp(T inp, float inp_start, float inp_end, float out_start, float out_end) \\\n{ \\\n    T t = clamp((inp - inp_start) / (inp_end - inp_start), 0.0, 1.0); \\\n    return out_start + t * (out_end - out_start); \\\n}\n\n#define FUNC_REMAP01(T) \\\nT remap01(T inp, float inp_start, float inp_end) \\\n{ \\\n    return clamp((inp - inp_start) / (inp_end - inp_start), 0.0, 1.0); \\\n}\n\nFUNC_LERP(float)\nFUNC_LERP(vec2)\nFUNC_LERP(vec3)\nFUNC_LERP(vec4)\n\nFUNC_WRAP(float)\nFUNC_WRAP(vec2)\nFUNC_WRAP(vec3)\nFUNC_WRAP(vec4)\n\nFUNC_REMAP(float)\nFUNC_REMAP(vec2)\nFUNC_REMAP(vec3)\nFUNC_REMAP(vec4)\n\nFUNC_REMAP_CLAMP(float)\nFUNC_REMAP_CLAMP(vec2)\nFUNC_REMAP_CLAMP(vec3)\nFUNC_REMAP_CLAMP(vec4)\n\nFUNC_REMAP01(float)\nFUNC_REMAP01(vec2)\nFUNC_REMAP01(vec3)\nFUNC_REMAP01(vec4)\n\nmat2 rotate_2d(float angle)\n{\n    return mat2(cos(angle), sin(angle), cos(angle + PI_OVER_2), sin(angle + PI_OVER_2));\n}\n\n/*____________________ End ____________________*/\n\n\n\n/*_______ Pseudo-Random Number Generator ______*/\n// Source: https://www.shadertoy.com/view/WdSSRt\n\n/* Usage Example:\n    void mainImage(out vec4 frag_col, in vec2 frag_coord)\n    {\n        // Initialize PRNG\n        prng_init(vec3(frag_coord / iResolution.y, iTime));\n    \n        // Using the function\n        float a = random();\n        vec3 b = vec3(random(), random(), random());\n        \n        ...\n    }\n*/\n\nuint prng_state[2];\n\nuint prng_rot(uint x, int k)\n{\n    return (x << k) | (x >> (32 - k));\n}\n\n// Random uint from 0 to 2^32-1\nuint randomui()\n{\n    uint s0 = prng_state[0];\n    uint s1 = prng_state[1];\n    uint result = prng_rot(s0 * 0x9e3779bbu, 5) * 5u;\n    s1 ^= s0;\n    prng_state[0] = prng_rot(s0, 26) ^ s1 ^ (s1 << 9);\n    prng_state[1] = prng_rot(s1, 13);\n    return result;\n}\n\n// Random int from 0 to 2^31-1\nint randomi()\n{\n    return int(randomui() % 0x7FFFFFFFu);\n}\n\n// Random float from 0 to 1\nfloat random()\n{\n    return float(randomui()) / float(0xffffffffu);\n}\n\n// Generate two normally distributed random numbers using the\n// Box-Muller Transform.\n// https://www.baeldung.com/cs/uniform-to-normal-distribution\nvec2 random_gauss()\n{\n    float u1 = random();\n    float u2 = random() * TAU;\n    float temp = sqrt(-2. * log(u1));\n    return temp * vec2(cos(u2), sin(u2));\n    \n    // Unoptimized version\n    //float u1 = random();\n    //float u2 = random();\n    //return vec2(cos(TAU * u2), sin(TAU * u2)) * sqrt(-2. * log(u1));\n}\n\nvec2 random_unit_vec2()\n{\n    vec2 v = vec2(1);\n    float lensqr;\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec2(2. * random() - 1., 2. * random() - 1.);\n        lensqr = dot(v, v);\n        if (lensqr == 0.)\n            i--;\n        else if (lensqr <= 1.)\n            break;\n    }\n    return v / sqrt(lensqr);\n}\n\nvec3 random_unit_vec3()\n{\n    vec3 v = vec3(1);\n    float lensqr;\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec3(2. * random() - 1., 2. * random() - 1., 2. * random() - 1.);\n        lensqr = dot(v, v);\n        if (lensqr == 0.)\n            i--;\n        else if (lensqr <= 1.)\n            break;\n    }\n    return v / sqrt(lensqr);\n}\n\nvec2 random_in_circle()\n{\n    vec2 v = vec2(1);\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec2(2. * random() - 1., 2. * random() - 1.);\n        if (dot(v, v) <= 1.)\n            return v;\n    }\n    return v;\n}\n\nvec3 random_in_sphere()\n{\n    vec3 v = vec3(1);\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec3(2. * random() - 1., 2. * random() - 1., 2. * random() - 1.);\n        if (dot(v, v) <= 1.)\n            return v;\n    }\n    return v;\n}\n\n// Initialize with uvec2\nvoid prng_init(uvec2 seed)\n{\n    seed += uvec2(1317, 944573125);\n    seed *= 464973573u;\n    prng_state[0] = seed.x;\n    prng_state[1] = seed.y;\n    randomi();\n}\n\n// Initialize with uint\nvoid prng_init(uint seed)\n{\n    prng_init(uvec2(seed, 1));\n}\n\n// Initialize with vec3\nvoid prng_init(vec3 seed)\n{\n    seed += 3.49276101561702;\n    seed.xy *= (seed.z + 10.258);\n    prng_state[0] = floatBitsToUint(seed.x);\n    prng_state[1] = floatBitsToUint(seed.y);\n    randomui();\n}\n\n// Initialize with vec2\nvoid prng_init(vec2 seed)\n{\n    prng_init(vec3(seed, 1));\n}\n\n// Initialize with float\nvoid prng_init(float seed)\n{\n    prng_init(vec3(seed, 1, 1));\n}\n\n/*____________________ End ____________________*/\n\n\n// https://www.shadertoy.com/view/Ml3Gz8\nfloat smoothmin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n    return mix(a, b, h) - k*h*(1.0-h);\n}\n\nvec2 perpendicular(vec2 dir)\n{\n    return vec2(-dir.y, dir.x);\n}\n\nfloat dist_sqr(vec2 a, vec2 b)\n{\n    vec2 temp = a - b;\n    return dot(temp, temp);\n}\n\nfloat dist_along_line(vec2 p, vec2 line_start, vec2 line_end)\n{\n    vec2 dir = line_end - line_start;\n    \n    // Normalize\n    float len_sqr = dot(dir, dir);\n    if (len_sqr < .0001)\n        return 1e9;\n    dir /= sqrt(len_sqr);\n    \n    return dot(\n        dir,\n        p - line_start\n    );\n}\n\nfloat relative_dist_along_line(vec2 p, vec2 line_start, vec2 line_end)\n{\n    vec2 dir = line_end - line_start;\n    return dot(\n        dir,\n        p - line_start\n    );\n}\n\nfloat fractional_dist_along_line(vec2 p, vec2 line_start, vec2 line_end)\n{\n    vec2 dir = line_end - line_start;\n    \n    // Divide by its length twice, once for normalizing, once for the fraction\n    float len_sqr = dot(dir, dir);\n    if (len_sqr < .0001)\n        return 1e9;\n    dir /= len_sqr;\n    \n    return dot(\n        dir,\n        p - line_start\n    );\n}\n\nfloat sd_segment(vec2 p, vec2 a, vec2 b)\n{\n    // Slope and intercept\n    float temp = b.x - a.x;\n    if (temp == 0.) temp = 1e-9;\n    float slope = (b.y - a.y) / temp;\n    float intercept = a.y - slope * a.x;\n    \n    // Should we use the endpoints or the line?\n    if (min(dot(p - a, b - a), dot(p - b, a - b)) < 0.)\n    {\n        // Distance from the endpoints\n        return min(distance(p, a), distance(p, b));\n    }\n    else\n    {\n        // Distance from the line\n        return abs(slope * p.x - p.y + intercept) / sqrt(slope * slope + 1.);\n    }\n}\n",
     "name": "Common",
     "description": "",
     "type": "common"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "lclXWs",
    "date": "1705932695",
    "viewed": 172,
    "name": "Quantum physics or something",
    "description": "Extremely slow, use shadertoy browser extension to increase the number of iters/frame (paint calls) to 512 ish with inspect element!\n\nHelp: How do I calculate max dt (before it breaks) based on the parameters?\n\nhttps://www.desmos.com/calculator/ery45h4dzl",
    "likes": 1,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "2d",
     "simulation",
     "solver",
     "physics",
     "quantum",
     "equation",
     "pde",
     "schrodinger"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "vec2 screen_to_uv(vec2 coord)\n{\n    return (2. * coord - iResolution.xy) / min(iResolution.x, iResolution.y);\n}\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    vec2 uv = screen_to_uv(frag_coord);\n    \n    vec3 col = vec3(.04, 0., .02);\n    if (max(abs(uv.x), abs(uv.y)) < 1.)\n    {\n        ivec2 icoord = ivec2(remap(uv, -1., 1., 0., float(grid_res)));\n        vec4 data = texelFetch(iChannel0, icoord, 0);\n        \n        complex val = 2. * READ(data);\n        col += abs(val.x) * vec3(2., .65, 0) + abs(val.y) * vec3(0, .7, 2.);\n    }\n    \n    // Output\n    col = pow(col, vec3(1. / 2.2));\n    frag_col = vec4(col, 1.);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "#define complex vec2\n#define READ(DATA) complex(DATA.x, DATA.y)\n#define WRITE(VAR) frag_col = vec4(VAR.xy, iResolution.xy)\n#define RES_CHANGED(DATA) (max(abs(DATA.z - iResolution.x), abs(DATA.w - iResolution.y)) > .1)\n\nconst int grid_res = 100;\n\nconst float dx = 1. / float(grid_res);\nconst float dx2 = dx * dx;\n\n// reduced planck's constant\n// 1.054571817 * 10^34 joule seconds\nconst float h = 1.054571817e-4;\nconst float h2 = h * h;\n\nconst float mass = 20.;\n\nconst float h2_2mass = h2 / (2. * mass);\n\nconst float dt = .005;\n\ncomplex complex_mul(complex a, complex b)\n{\n    return complex(\n        a.x * b.x - a.y * b.y,\n        a.x * b.y + a.y * b.x\n    );\n}\n\ncomplex complex_mul_by_i(complex c)\n{\n    return complex(-c.y, c.x);\n}\n\n\n\n/*_________________ Math Utils ________________*/\n\n#define PI 3.1415926535897932384626433832\n#define TAU 6.283185307179586476925286766\n#define PI_OVER_2 1.57079632679489661923132169163\n\n#define FUNC_LERP(T) \\\nT lerp(T a, T b, float t) \\\n{ \\\n    return a + t*(b-a); \\\n}\n\n#define FUNC_WRAP(T) \\\nT wrap(T inp, float start, float end) \\\n{ \\\n    return start + mod(inp - start, end - start); \\\n}\n\n#define FUNC_REMAP(T) \\\nT remap(T inp, float inp_start, float inp_end, float out_start, float out_end) \\\n{ \\\n    return out_start + ((out_end - out_start) / (inp_end - inp_start)) * (inp - inp_start); \\\n}\n\n#define FUNC_REMAP_CLAMP(T) \\\nT remap_clamp(T inp, float inp_start, float inp_end, float out_start, float out_end) \\\n{ \\\n    T t = clamp((inp - inp_start) / (inp_end - inp_start), 0.0, 1.0); \\\n    return out_start + t * (out_end - out_start); \\\n}\n\n#define FUNC_REMAP01(T) \\\nT remap01(T inp, float inp_start, float inp_end) \\\n{ \\\n    return clamp((inp - inp_start) / (inp_end - inp_start), 0.0, 1.0); \\\n}\n\nFUNC_LERP(float)\nFUNC_LERP(vec2)\nFUNC_LERP(vec3)\nFUNC_LERP(vec4)\n\nFUNC_WRAP(float)\nFUNC_WRAP(vec2)\nFUNC_WRAP(vec3)\nFUNC_WRAP(vec4)\n\nFUNC_REMAP(float)\nFUNC_REMAP(vec2)\nFUNC_REMAP(vec3)\nFUNC_REMAP(vec4)\n\nFUNC_REMAP_CLAMP(float)\nFUNC_REMAP_CLAMP(vec2)\nFUNC_REMAP_CLAMP(vec3)\nFUNC_REMAP_CLAMP(vec4)\n\nFUNC_REMAP01(float)\nFUNC_REMAP01(vec2)\nFUNC_REMAP01(vec3)\nFUNC_REMAP01(vec4)\n\nmat2 rotate_2d(float angle)\n{\n    return mat2(cos(angle), sin(angle), cos(angle + PI_OVER_2), sin(angle + PI_OVER_2));\n}\n\n/*____________________ End ____________________*/\n\n\n\n/*_______ Pseudo-Random Number Generator ______*/\n// Source: https://www.shadertoy.com/view/WdSSRt\n\n/* Usage Example:\n    void mainImage(out vec4 frag_col, in vec2 frag_coord)\n    {\n        // Initialize PRNG\n        prng_init(vec3(frag_coord / iResolution.y, iTime));\n    \n        // Using the function\n        float a = random();\n        vec3 b = vec3(random(), random(), random());\n        \n        ...\n    }\n*/\n\nuint prng_state[2];\n\nuint prng_rot(uint x, int k)\n{\n    return (x << k) | (x >> (32 - k));\n}\n\n// Random uint from 0 to 2^32-1\nuint randomui()\n{\n    uint s0 = prng_state[0];\n    uint s1 = prng_state[1];\n    uint result = prng_rot(s0 * 0x9e3779bbu, 5) * 5u;\n    s1 ^= s0;\n    prng_state[0] = prng_rot(s0, 26) ^ s1 ^ (s1 << 9);\n    prng_state[1] = prng_rot(s1, 13);\n    return result;\n}\n\n// Random int from 0 to 2^31-1\nint randomi()\n{\n    return int(randomui() % 0x7FFFFFFFu);\n}\n\n// Random float from 0 to 1\nfloat random()\n{\n    return float(randomui()) / float(0xffffffffu);\n}\n\n// Generate two normally distributed random numbers using the\n// Box-Muller Transform.\n// https://www.baeldung.com/cs/uniform-to-normal-distribution\nvec2 random_gauss()\n{\n    float u1 = random();\n    float u2 = random() * TAU;\n    float temp = sqrt(-2. * log(u1));\n    return temp * vec2(cos(u2), sin(u2));\n    \n    // Unoptimized version\n    //float u1 = random();\n    //float u2 = random();\n    //return vec2(cos(TAU * u2), sin(TAU * u2)) * sqrt(-2. * log(u1));\n}\n\nvec2 random_unit_vec2()\n{\n    vec2 v = vec2(1);\n    float lensqr;\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec2(2. * random() - 1., 2. * random() - 1.);\n        lensqr = dot(v, v);\n        if (lensqr == 0.)\n            i--;\n        else if (lensqr <= 1.)\n            break;\n    }\n    return v / sqrt(lensqr);\n}\n\nvec3 random_unit_vec3()\n{\n    vec3 v = vec3(1);\n    float lensqr;\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec3(2. * random() - 1., 2. * random() - 1., 2. * random() - 1.);\n        lensqr = dot(v, v);\n        if (lensqr == 0.)\n            i--;\n        else if (lensqr <= 1.)\n            break;\n    }\n    return v / sqrt(lensqr);\n}\n\nvec2 random_in_circle()\n{\n    vec2 v = vec2(1);\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec2(2. * random() - 1., 2. * random() - 1.);\n        if (dot(v, v) <= 1.)\n            return v;\n    }\n    return v;\n}\n\nvec3 random_in_sphere()\n{\n    vec3 v = vec3(1);\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec3(2. * random() - 1., 2. * random() - 1., 2. * random() - 1.);\n        if (dot(v, v) <= 1.)\n            return v;\n    }\n    return v;\n}\n\n// Initialize with uvec2\nvoid prng_init(uvec2 seed)\n{\n    seed += uvec2(1317, 944573125);\n    seed *= 464973573u;\n    prng_state[0] = seed.x;\n    prng_state[1] = seed.y;\n    randomi();\n}\n\n// Initialize with uint\nvoid prng_init(uint seed)\n{\n    prng_init(uvec2(seed, 1));\n}\n\n// Initialize with vec3\nvoid prng_init(vec3 seed)\n{\n    seed += 3.49276101561702;\n    seed.xy *= (seed.z + 10.258);\n    prng_state[0] = floatBitsToUint(seed.x);\n    prng_state[1] = floatBitsToUint(seed.y);\n    randomui();\n}\n\n// Initialize with vec2\nvoid prng_init(vec2 seed)\n{\n    prng_init(vec3(seed, 1));\n}\n\n// Initialize with float\nvoid prng_init(float seed)\n{\n    prng_init(vec3(seed, 1, 1));\n}\n\n/*____________________ End ____________________*/\n\n\n\n// ...\n",
     "name": "Common",
     "description": "",
     "type": "common"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "complex value_at(ivec2 icoord)\n{\n    if (icoord.x < 0\n        || icoord.y < 0\n        || icoord.x >= grid_res\n        || icoord.y >= grid_res)\n    {\n        return complex(0);\n    }\n\n    vec4 data = texelFetch(iChannel0, icoord, 0);\n    return READ(data);\n}\n\ncomplex potential(vec2 uv)\n{\n    return complex(2. * sin(uv.x * 10.), 0.);\n}\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    // ignore out-of-bounds\n    ivec2 icoord = ivec2(frag_coord);\n    if (max(icoord.x, icoord.y) >= grid_res)\n    {\n        return;\n    }\n    \n    // UV\n    vec2 uv = (2. * vec2(icoord) / float(grid_res)) - 1.;\n    \n    // read the current value\n    vec4 data = texelFetch(iChannel0, icoord, 0);\n    complex curr = READ(data);\n    \n    // initial values\n    if (iFrame < 1 || iTime < .01 || RES_CHANGED(data))\n    {\n        float real = 1. - min(dot(10. * uv, 10. * uv), 1.);\n        real *= real;\n        float imag = 0.;\n        WRITE(complex(real, imag));\n        return;\n    }\n    \n    complex prev_in_x = value_at(icoord + ivec2(-1, 0));\n    complex prev_in_y = value_at(icoord + ivec2(0, -1));\n    complex next_in_x = value_at(icoord + ivec2(1, 0));\n    complex next_in_y = value_at(icoord + ivec2(0, 1));\n    \n    complex grad_sum = (\n        (next_in_x - curr - curr + prev_in_x)\n        + (next_in_y - curr - curr + prev_in_y)\n    ) / dx2;\n    \n    complex du_dt =\n        (grad_sum * h2_2mass);\n        - complex_mul(potential(uv), curr);\n    du_dt /= h;\n    du_dt = complex_mul_by_i(du_dt);\n    \n    curr += dt * du_dt;\n    \n    WRITE(curr);\n}\n",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "MXSXRm",
    "date": "1710373949",
    "viewed": 237,
    "name": "3D Function/Volume Visualizer",
    "description": "just raymarching through a box and averaging the values we sampled along the way\n",
    "likes": 11,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "3d",
     "raymarching",
     "math",
     "volume",
     "sdf",
     "visualization",
     "map",
     "functions",
     "fields"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// iChannel0 = Buffer A\n\n// min/max XYZ range for the input point\nconst vec2 domain = 3. * vec2(-1., 1.);\n\n// use a colormap (see end of Common)\nconst bool use_cmap = false;\n\n// your 3D function\nfloat volume(vec3 p)\n{\n    //return log(p.y * p.y + .05) * sin(safe_pow(p.x, p.z));\n    //return abs(sin(p.x * p.x + p.y * p.y) - p.z * p.z) < .2 ? 1. : 0.;\n    //return abs(sin(p.x * p.z - p.y) - sin(2. * p.y)) < .2 ? 1. : 0.;\n    return abs(\n        remap01(cos(p.z + 1.7 * iTime), -1., 1.)\n        * p.x * p.x + p.y * p.y\n        - sin(p.x) * p.z * p.z * sin(3. * p.z * p.z)\n    ) < .2 ? 2. : 0.;\n}\n\nvec3 tint()\n{\n    return rgb_saturate(\n        flim_rgb_sweep(iTime * .05 + .6),\n        .95\n    );\n}\n\nvec3 negative_tint()\n{\n    return .8 * rgb_saturate(\n        flim_rgb_sweep(iTime * .05 + .27),\n        .95\n    );\n}\n\nvec2 screen_to_uv(vec2 coord)\n{\n    return (2. * coord - iResolution.xy) / min(iResolution.x, iResolution.y);\n}\n\nvec3 render(vec2 frag_coord)\n{\n    // UV\n    vec2 uv = screen_to_uv(frag_coord);\n    \n    // setup camera\n    \n    vec3 cam_pos_spherical = vec3(\n        /* r     */ 1.25,\n        /* theta */ PI_OVER_2,\n        /* phi   */ TAU * iTime * .08 - PI_OVER_2\n    );\n    if (iMouse.z > .1)\n    {\n        vec2 mouse_uv = screen_to_uv(iMouse.xy);\n        cam_pos_spherical.y = PI_OVER_2 + 1.5 * mouse_uv.y;\n        cam_pos_spherical.z = -PI_OVER_2 - 1.5 * mouse_uv.x;\n    }\n    vec3 cam_pos = spherical2cart(cam_pos_spherical);\n    cam_pos += vec3(0, 0, .1);\n\n    float cam_fov = 80.;\n    float cam_zoom = 90. / cam_fov;\n    \n    vec3 target_pos = vec3(0);\n    vec3 cam_forward = normalize(target_pos - cam_pos);\n    vec3 cam_right = normalize(cross(cam_forward, vec3(0, 0, 1)));\n    vec3 cam_up = cross(cam_right, cam_forward);\n\n    // generate ray\n    Ray ray;\n    ray.orig = cam_pos;\n    ray.dir = normalize(\n        cam_forward\n        + cam_right * (uv.x / cam_zoom)\n        + cam_up * (uv.y / cam_zoom)\n    );\n    \n    // check intersection with the container box which\n    // goes from (-.5, -.5, -.5) to (.5, .5, .5)\n    Hit hit;\n    ray_aabb(vec3(-.5), vec3(.5), ray, hit);\n    \n    // shade\n    vec3 col = vec3(0);\n    if (hit.hit)\n    {\n        // constant or randomized step sizes?\n        const bool use_random_stepping = true;\n        \n        // raymarch through the box\n        if (use_random_stepping)\n        {\n            // step size range\n            float min_step = .005;\n            float max_step = .02;\n            \n            // initial t along the ray\n            float step_size = remap(random(), 0., 1., min_step, max_step);\n            float t = hit.tmin + step_size;\n            \n            // keep stepping forward until we reach hit.tmax\n            int n_samples = 0;\n            while (t < hit.tmax)\n            {\n                // point along the ray inside the volume\n                vec3 p = ray.orig + t * ray.dir;\n                \n                // step forward\n                step_size = remap(random(), 0., 1., min_step, max_step);\n                t += step_size;\n                \n                // sample the input 3D function\n                vec3 p_mapped = remap(\n                    p,\n                    -.5, .5,\n                    domain.x, domain.y\n                );\n                float v = volume(p_mapped);\n                \n                // collect sample\n                if (use_cmap)\n                {\n                    col += colormap(.3 * v);\n                }\n                else\n                {\n                    // use another tint for negative values\n                    vec3 final_tint = tint();\n                    if (v < 0.)\n                    {\n                        v = -v;\n                        final_tint = negative_tint();\n                    }\n                    \n                    col += .9 * v * final_tint;\n                }\n                n_samples++;\n            }\n            \n            // average out the samples\n            if (n_samples > 0)\n            {\n                col /= float(n_samples);\n            }\n        }\n        else\n        {\n            // number of volume samples\n            int n_samples = 20;\n            \n            // collect samples\n            for (int i = 0; i < n_samples; i++)\n            {\n                // point along the ray inside the volume\n                float t = mix(\n                    hit.tmin,\n                    hit.tmax,\n                    (float(i) + .5) / float(n_samples)\n                );\n                vec3 p = ray.orig + t * ray.dir;\n                \n                // sample the input 3D function\n                vec3 p_mapped = remap(\n                    p,\n                    -.5, .5,\n                    domain.x, domain.y\n                );\n                float v = volume(p_mapped);\n                \n                // collect sample\n                if (use_cmap)\n                {\n                    col += colormap(.3 * v);\n                }\n                else\n                {\n                    // use another tint for negative values\n                    vec3 final_tint = tint();\n                    if (v < 0.)\n                    {\n                        v = -v;\n                        final_tint = negative_tint();\n                    }\n                    \n                    col += .9 * v * final_tint;\n                }\n            }\n            \n            // average out the samples\n            col /= float(n_samples);\n        }\n        \n        // slightly brigthen the box\n        col += vec3(.01);\n    }\n    \n    // glow\n    col += tint() * 0.12 * pow(max(0.0, dot(ray.dir, normalize(-cam_pos))), 6.0);\n    \n    return col;\n}\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    // initialize PRNG\n    prng_init(vec3(frag_coord / iResolution.y, iTime));\n\n    // box jitter sampling\n    const int num_samples = 8;\n    vec3 col = vec3(0);\n    for (int i = 0; i < num_samples; i++)\n    {\n        col += render(frag_coord + vec2(random() - .5, random() - .5));\n    }\n    col /= float(num_samples);\n    \n    // color grading\n    col = pow(col, vec3(1.2));\n    col += .015 * pow(tint(), vec3(6.));\n    \n    // noise\n    col += remap(random(), 0., 1., -.007, .005);\n    \n    // flim\n    col = flim_transform(col, 0.);\n    \n    // output\n    frag_col = vec4(col, 1);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "/*_________________ Math Utils ________________*/\n\n#define PI 3.1415926535897932384626433832\n#define TAU 6.283185307179586476925286766\n#define PI_OVER_2 1.57079632679489661923132169163\n\n#define FUNC_LERP(T) \\\nT lerp(T a, T b, float t) \\\n{ \\\n    return a + t*(b-a); \\\n}\n\n#define FUNC_WRAP(T) \\\nT wrap(T inp, float start, float end) \\\n{ \\\n    return start + mod(inp - start, end - start); \\\n}\n\n#define FUNC_REMAP(T) \\\nT remap(T inp, float inp_start, float inp_end, float out_start, float out_end) \\\n{ \\\n    return out_start + ((out_end - out_start) / (inp_end - inp_start)) * (inp - inp_start); \\\n}\n\n#define FUNC_REMAP_CLAMP(T) \\\nT remap_clamp(T inp, float inp_start, float inp_end, float out_start, float out_end) \\\n{ \\\n    T t = clamp((inp - inp_start) / (inp_end - inp_start), 0.0, 1.0); \\\n    return out_start + t * (out_end - out_start); \\\n}\n\n#define FUNC_REMAP01(T) \\\nT remap01(T inp, float inp_start, float inp_end) \\\n{ \\\n    return clamp((inp - inp_start) / (inp_end - inp_start), 0.0, 1.0); \\\n}\n\nFUNC_LERP(float)\nFUNC_LERP(vec2)\nFUNC_LERP(vec3)\nFUNC_LERP(vec4)\n\nFUNC_WRAP(float)\nFUNC_WRAP(vec2)\nFUNC_WRAP(vec3)\nFUNC_WRAP(vec4)\n\nFUNC_REMAP(float)\nFUNC_REMAP(vec2)\nFUNC_REMAP(vec3)\nFUNC_REMAP(vec4)\n\nFUNC_REMAP_CLAMP(float)\nFUNC_REMAP_CLAMP(vec2)\nFUNC_REMAP_CLAMP(vec3)\nFUNC_REMAP_CLAMP(vec4)\n\nFUNC_REMAP01(float)\nFUNC_REMAP01(vec2)\nFUNC_REMAP01(vec3)\nFUNC_REMAP01(vec4)\n\nmat2 rotate_2d(float angle)\n{\n    return mat2(cos(angle), sin(angle), cos(angle + PI_OVER_2), sin(angle + PI_OVER_2));\n}\n\n/*____________________ End ____________________*/\n\n\n\n/*_______ Pseudo-Random Number Generator ______*/\n// Source: https://www.shadertoy.com/view/WdSSRt\n\n/* Usage Example:\n    void mainImage(out vec4 frag_col, in vec2 frag_coord)\n    {\n        // Initialize PRNG\n        prng_init(vec3(frag_coord / iResolution.y, iTime));\n    \n        // Using the function\n        float a = random();\n        vec3 b = vec3(random(), random(), random());\n        \n        ...\n    }\n*/\n\nuint prng_state[2];\n\nuint prng_rot(uint x, int k)\n{\n    return (x << k) | (x >> (32 - k));\n}\n\n// Random uint from 0 to 2^32-1\nuint randomui()\n{\n    uint s0 = prng_state[0];\n    uint s1 = prng_state[1];\n    uint result = prng_rot(s0 * 0x9e3779bbu, 5) * 5u;\n    s1 ^= s0;\n    prng_state[0] = prng_rot(s0, 26) ^ s1 ^ (s1 << 9);\n    prng_state[1] = prng_rot(s1, 13);\n    return result;\n}\n\n// Random int from 0 to 2^31-1\nint randomi()\n{\n    return int(randomui() % 0x7FFFFFFFu);\n}\n\n// Random float from 0 to 1\nfloat random()\n{\n    return float(randomui()) / float(0xffffffffu);\n}\n\n// Generate two normally distributed random numbers using the\n// Box-Muller Transform.\n// https://www.baeldung.com/cs/uniform-to-normal-distribution\nvec2 random_gauss()\n{\n    float u1 = random();\n    float u2 = random() * TAU;\n    float temp = sqrt(-2. * log(u1));\n    return temp * vec2(cos(u2), sin(u2));\n    \n    // Unoptimized version\n    //float u1 = random();\n    //float u2 = random();\n    //return vec2(cos(TAU * u2), sin(TAU * u2)) * sqrt(-2. * log(u1));\n}\n\nvec2 random_unit_vec2()\n{\n    vec2 v = vec2(1);\n    float lensqr;\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec2(2. * random() - 1., 2. * random() - 1.);\n        lensqr = dot(v, v);\n        if (lensqr == 0.)\n            i--;\n        else if (lensqr <= 1.)\n            break;\n    }\n    return v / sqrt(lensqr);\n}\n\nvec3 random_unit_vec3()\n{\n    vec3 v = vec3(1);\n    float lensqr;\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec3(2. * random() - 1., 2. * random() - 1., 2. * random() - 1.);\n        lensqr = dot(v, v);\n        if (lensqr == 0.)\n            i--;\n        else if (lensqr <= 1.)\n            break;\n    }\n    return v / sqrt(lensqr);\n}\n\nvec2 random_in_circle()\n{\n    vec2 v = vec2(1);\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec2(2. * random() - 1., 2. * random() - 1.);\n        if (dot(v, v) <= 1.)\n            return v;\n    }\n    return v;\n}\n\nvec3 random_in_sphere()\n{\n    vec3 v = vec3(1);\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec3(2. * random() - 1., 2. * random() - 1., 2. * random() - 1.);\n        if (dot(v, v) <= 1.)\n            return v;\n    }\n    return v;\n}\n\n// Initialize with uvec2\nvoid prng_init(uvec2 seed)\n{\n    seed += uvec2(1317, 944573125);\n    seed *= 464973573u;\n    prng_state[0] = seed.x;\n    prng_state[1] = seed.y;\n    randomi();\n}\n\n// Initialize with uint\nvoid prng_init(uint seed)\n{\n    prng_init(uvec2(seed, 1));\n}\n\n// Initialize with vec3\nvoid prng_init(vec3 seed)\n{\n    seed += 3.49276101561702;\n    seed.xy *= (seed.z + 10.258);\n    prng_state[0] = floatBitsToUint(seed.x);\n    prng_state[1] = floatBitsToUint(seed.y);\n    randomui();\n}\n\n// Initialize with vec2\nvoid prng_init(vec2 seed)\n{\n    prng_init(vec3(seed, 1));\n}\n\n// Initialize with float\nvoid prng_init(float seed)\n{\n    prng_init(vec3(seed, 1, 1));\n}\n\n/*____________________ End ____________________*/\n\n\n\n\n/*-----------------------------------------------\n\nflim - Filmic Color Transform\n\nInput Color Space:   Linear BT.709 I-D65\nOutput Color Space:  sRGB 2.2\n\nDescription:\n  Experimental port of flim for GLSL/Shadertoy\n  matching flim v1.1.0.\n\nAuthor:\n  Bean (beans_please on Shadertoy)\n\nOriginal Repo:\n  https://github.com/bean-mhm/flim\n\nOriginal Shader:\n  https://www.shadertoy.com/view/dd2yDz\n\n-----------------------------------------------*/\n\n// parameters\n\nconst float flim_pre_exposure = 4.3;\nconst vec3 flim_pre_formation_filter = vec3(1.);\nconst float flim_pre_formation_filter_strength = 0.;\n\nconst float flim_extended_gamut_red_scale = 1.05;\nconst float flim_extended_gamut_green_scale = 1.12;\nconst float flim_extended_gamut_blue_scale = 1.045;\nconst float flim_extended_gamut_red_rot = .5;\nconst float flim_extended_gamut_green_rot = 2.;\nconst float flim_extended_gamut_blue_rot = .1;\nconst float flim_extended_gamut_red_mul = 1.;\nconst float flim_extended_gamut_green_mul = 1.;\nconst float flim_extended_gamut_blue_mul = 1.;\n\nconst float flim_sigmoid_log2_min = -10.;\nconst float flim_sigmoid_log2_max = 22.;\nconst float flim_sigmoid_toe_x = .44;\nconst float flim_sigmoid_toe_y = .28;\nconst float flim_sigmoid_shoulder_x = .591;\nconst float flim_sigmoid_shoulder_y = .779;\n\nconst float flim_negative_film_exposure = 6.;\nconst float flim_negative_film_density = 5.;\n\nconst vec3 flim_print_backlight = vec3(1);\nconst float flim_print_film_exposure = 6.;\nconst float flim_print_film_density = 27.5;\n\nconst float flim_black_point = -1.; // -1 = auto\nconst vec3 flim_post_formation_filter = vec3(1);\nconst float flim_post_formation_filter_strength = 0.;\nconst float flim_midtone_saturation = 1.02;\n\n//-----------------------------------------------\n\nfloat flim_wrap(float inp, float start, float end)\n{\n    return start + mod(inp - start, end - start);\n}\n\nfloat flim_remap(\n    float inp,\n    float inp_start,\n    float inp_end,\n    float out_start,\n    float out_end\n)\n{\n    return out_start\n        + ((out_end - out_start) / (inp_end - inp_start)) * (inp - inp_start);\n}\n\nfloat flim_remap_clamp(\n    float inp,\n    float inp_start,\n    float inp_end,\n    float out_start,\n    float out_end\n)\n{\n    float t = clamp((inp - inp_start) / (inp_end - inp_start), 0., 1.);\n    float v = out_start + t * (out_end - out_start);\n    return v;\n}\n\nfloat flim_remap01(\n    float inp,\n    float inp_start,\n    float inp_end\n)\n{\n    return clamp((inp - inp_start) / (inp_end - inp_start), 0., 1.);\n}\n\nvec3 flim_blender_rgb_to_hsv(vec3 rgb)\n{\n    float cmax, cmin, h, s, v, cdelta;\n    vec3 c;\n\n    cmax = max(rgb[0], max(rgb[1], rgb[2]));\n    cmin = min(rgb[0], min(rgb[1], rgb[2]));\n    cdelta = cmax - cmin;\n\n    v = cmax;\n    if (cmax != 0.)\n    {\n        s = cdelta / cmax;\n    }\n    else\n    {\n        s = 0.;\n        h = 0.;\n    }\n\n    if (s == 0.)\n    {\n        h = 0.;\n    }\n    else\n    {\n        c = (vec3(cmax) - rgb.xyz) / cdelta;\n\n        if (rgb.x == cmax)\n        {\n            h = c[2] - c[1];\n        }\n        else if (rgb.y == cmax)\n        {\n            h = 2. + c[0] - c[2];\n        }\n        else\n        {\n            h = 4. + c[1] - c[0];\n        }\n\n        h /= 6.;\n\n        if (h < 0.)\n        {\n            h += 1.;\n        }\n    }\n\n    return vec3(h, s, v);\n}\n\nvec3 flim_blender_hsv_to_rgb(vec3 hsv)\n{\n    float f, p, q, t, h, s, v;\n    vec3 rgb;\n\n    h = hsv[0];\n    s = hsv[1];\n    v = hsv[2];\n\n    if (s == 0.)\n    {\n        rgb = vec3(v, v, v);\n    }\n    else\n    {\n        if (h == 1.)\n        {\n            h = 0.;\n        }\n\n        h *= 6.;\n        int i = int(floor(h));\n        f = h - float(i);\n        rgb = vec3(f, f, f);\n        p = v * (1. - s);\n        q = v * (1. - (s * f));\n        t = v * (1. - (s * (1. - f)));\n\n        if (i == 0)\n        {\n            rgb = vec3(v, t, p);\n        }\n        else if (i == 1)\n        {\n            rgb = vec3(q, v, p);\n        }\n        else if (i == 2)\n        {\n            rgb = vec3(p, v, t);\n        }\n        else if (i == 3)\n        {\n            rgb = vec3(p, q, v);\n        }\n        else if (i == 4)\n        {\n            rgb = vec3(t, p, v);\n        }\n        else\n        {\n            rgb = vec3(v, p, q);\n        }\n    }\n\n    return rgb;\n}\n\nvec3 flim_blender_hue_sat(vec3 col, float hue, float sat, float value)\n{\n    vec3 hsv = flim_blender_rgb_to_hsv(col);\n\n    hsv[0] = fract(hsv[0] + hue + .5);\n    hsv[1] = clamp(hsv[1] * sat, 0., 1.);\n    hsv[2] = hsv[2] * value;\n\n    return flim_blender_hsv_to_rgb(hsv);\n}\n\nfloat flim_rgb_avg(vec3 inp)\n{\n    return (inp.x + inp.y + inp.z) / 3.;\n}\n\nfloat flim_rgb_sum(vec3 inp)\n{\n    return inp.x + inp.y + inp.z;\n}\n\nfloat flim_rgb_max(vec3 inp)\n{\n    return max(max(inp.x, inp.y), inp.z);\n}\n\nfloat flim_rgb_min(vec3 inp)\n{\n    return min(min(inp.x, inp.y), inp.z);\n}\n\nvec3 flim_rgb_uniform_offset(vec3 inp, float black_point, float white_point)\n{\n    float mono = flim_rgb_avg(inp);\n    float mono2 = flim_remap01(\n        mono, black_point / 1000.,\n        1. - (white_point / 1000.)\n    );\n    return inp * (mono2 / mono);\n}\n\nvec3 flim_rgb_sweep(float hue)\n{\n    hue = flim_wrap(hue * 360., 0., 360.);\n\n    vec3 col = vec3(1, 0, 0);\n    col = mix(col, vec3(1, 1, 0), flim_remap01(hue, 0., 60.));\n    col = mix(col, vec3(0, 1, 0), flim_remap01(hue, 60., 120.));\n    col = mix(col, vec3(0, 1, 1), flim_remap01(hue, 120., 180.));\n    col = mix(col, vec3(0, 0, 1), flim_remap01(hue, 180., 240.));\n    col = mix(col, vec3(1, 0, 1), flim_remap01(hue, 240., 300.));\n    col = mix(col, vec3(1, 0, 0), flim_remap01(hue, 300., 360.));\n    \n    return col;\n}\n\nvec3 flim_rgb_exposure_sweep_test(vec2 uv0to1)\n{\n    float hue = 1. - uv0to1.y;\n    float exposure = flim_remap(uv0to1.x, 0., 1., -5., 10.);\n    return flim_rgb_sweep(hue) * pow(2., exposure);\n}\n\n// https://www.desmos.com/calculator/khkztixyeu\nfloat flim_super_sigmoid(\n    float inp,\n    float toe_x,\n    float toe_y,\n    float shoulder_x,\n    float shoulder_y\n)\n{\n    // clip\n    inp = clamp(inp, 0., 1.);\n    toe_x = clamp(toe_x, 0., 1.);\n    toe_y = clamp(toe_y, 0., 1.);\n    shoulder_x = clamp(shoulder_x, 0., 1.);\n    shoulder_y = clamp(shoulder_y, 0., 1.);\n\n    // calculate straight line slope\n    float slope = (shoulder_y - toe_y) / (shoulder_x - toe_x);\n\n    // toe\n    if (inp < toe_x)\n    {\n        float toe_pow = slope * toe_x / toe_y;\n        return toe_y * pow(inp / toe_x, toe_pow);\n    }\n\n    // straight line\n    if (inp < shoulder_x)\n    {\n        float intercept = toe_y - (slope * toe_x);\n        return slope * inp + intercept;\n    }\n\n    // shoulder\n    float shoulder_pow =\n        -slope / (\n            ((shoulder_x - 1.) / pow(1. - shoulder_x, 2.))\n            * (1. - shoulder_y)\n        );\n    return\n        (1. - pow(1. - (inp - shoulder_x) / (1. - shoulder_x), shoulder_pow))\n        * (1. - shoulder_y)\n        + shoulder_y;\n}\n\nfloat flim_dye_mix_factor(float mono, float max_density)\n{\n    // log2 and map range\n    float offset = pow(2., flim_sigmoid_log2_min);\n    float fac = flim_remap01(\n        log2(mono + offset),\n        flim_sigmoid_log2_min,\n        flim_sigmoid_log2_max\n    );\n\n    // calculate amount of exposure from 0 to 1\n    fac = flim_super_sigmoid(\n        fac,\n        flim_sigmoid_toe_x,\n        flim_sigmoid_toe_y,\n        flim_sigmoid_shoulder_x,\n        flim_sigmoid_shoulder_y\n    );\n\n    // calculate dye density\n    fac *= max_density;\n\n    // mix factor\n    fac = pow(2., -fac);\n\n    // clip and return\n    return clamp(fac, 0., 1.);\n}\n\nvec3 flim_rgb_color_layer(\n    vec3 inp,\n    vec3 sensitivity_tone,\n    vec3 dye_tone,\n    float max_density\n)\n{\n    // normalize\n    vec3 sensitivity_tone_norm =\n        sensitivity_tone / flim_rgb_sum(sensitivity_tone);\n    vec3 dye_tone_norm = dye_tone / flim_rgb_max(dye_tone);\n\n    // dye mix factor\n    float mono = dot(inp, sensitivity_tone_norm);\n    float mix_fac = flim_dye_mix_factor(mono, max_density);\n\n    // dye mixing\n    return mix(dye_tone_norm, vec3(1), mix_fac);\n}\n\nvec3 flim_rgb_develop(vec3 inp, float exposure, float max_density)\n{\n    // exposure\n    inp *= pow(2., exposure);\n\n    // blue-sensitive layer\n    vec3 result = flim_rgb_color_layer(\n        inp,\n        vec3(0, 0, 1),\n        vec3(1, 1, 0),\n        max_density\n    );\n\n    // green-sensitive layer\n    result *= flim_rgb_color_layer(\n        inp,\n        vec3(0, 1, 0),\n        vec3(1, 0, 1),\n        max_density\n    );\n\n    // red-sensitive layer\n    result *= flim_rgb_color_layer(\n        inp,\n        vec3(1, 0, 0),\n        vec3(0, 1, 1),\n        max_density\n    );\n\n    return result;\n}\n\nvec3 flim_gamut_extension_mat_row(\n    float primary_hue,\n    float scale,\n    float rotate,\n    float mul\n)\n{\n    vec3 result = flim_blender_hsv_to_rgb(vec3(\n        flim_wrap(primary_hue + (rotate / 360.), 0., 1.),\n        1. / scale,\n        1.\n    ));\n    result /= flim_rgb_sum(result);\n    result *= mul;\n    return result;\n}\n\nmat3 flim_gamut_extension_mat(\n    float red_scale,\n    float green_scale,\n    float blue_scale,\n    float red_rot,\n    float green_rot,\n    float blue_rot,\n    float red_mul,\n    float green_mul,\n    float blue_mul\n)\n{\n    mat3 m;\n    m[0] = flim_gamut_extension_mat_row(\n        0.,\n        red_scale,\n        red_rot,\n        red_mul\n    );\n    m[1] = flim_gamut_extension_mat_row(\n        1. / 3.,\n        green_scale,\n        green_rot,\n        green_mul\n    );\n    m[2] = flim_gamut_extension_mat_row(\n        2. / 3.,\n        blue_scale,\n        blue_rot,\n        blue_mul\n    );\n    return m;\n}\n\nvec3 negative_and_print(vec3 inp, vec3 backlight_ext)\n{\n    // develop negative\n    inp = flim_rgb_develop(\n        inp,\n        flim_negative_film_exposure,\n        flim_negative_film_density\n    );\n\n    // backlight\n    inp *= backlight_ext;\n\n    // develop print\n    inp = flim_rgb_develop(\n        inp,\n        flim_print_film_exposure,\n        flim_print_film_density\n    );\n\n    return inp;\n}\n\n// -------------------------------\n\nvec3 flim_transform(vec3 inp, float exposure)\n{\n    // eliminate negative values\n    inp = max(inp, 0.);\n\n    // pre-Exposure\n    inp *= pow(2., flim_pre_exposure + exposure);\n\n    // clip very large values for float precision issues\n    inp = min(inp, 5000.);\n\n    // gamut extension matrix (Linear BT.709)\n    mat3 extend_mat = flim_gamut_extension_mat(\n        flim_extended_gamut_red_scale,\n        flim_extended_gamut_green_scale,\n        flim_extended_gamut_blue_scale,\n        flim_extended_gamut_red_rot,\n        flim_extended_gamut_green_rot,\n        flim_extended_gamut_blue_rot,\n        flim_extended_gamut_red_mul,\n        flim_extended_gamut_green_mul,\n        flim_extended_gamut_blue_mul\n    );\n    mat3 extend_mat_inv = inverse(extend_mat);\n\n    // backlight in the extended gamut\n    vec3 backlight_ext = flim_print_backlight * extend_mat;\n\n    // upper limit in the print (highlight cap)\n    const float big = 10000000.;\n    vec3 white_cap = negative_and_print(vec3(big, big, big), backlight_ext);\n\n    // pre-formation filter\n    inp = mix(\n        inp,\n        inp * flim_pre_formation_filter,\n        flim_pre_formation_filter_strength\n    );\n\n    // convert to the extended gamut\n    inp *= extend_mat;\n\n    // negative & print\n    inp = negative_and_print(inp, backlight_ext);\n\n    // convert from the extended gamut\n    inp *= extend_mat_inv;\n\n    // eliminate negative values\n    inp = max(inp, 0.);\n\n    // white cap\n    inp /= white_cap;\n\n    // black cap (-1 = auto)\n    if (flim_black_point == -1.)\n    {\n        vec3 black_cap = negative_and_print(vec3(0.), backlight_ext);\n        black_cap /= white_cap;\n        inp = flim_rgb_uniform_offset(\n            inp,\n            flim_rgb_avg(black_cap) * 1000.,\n            0.\n        );\n    }\n    else\n    {\n        inp = flim_rgb_uniform_offset(inp, flim_black_point, 0.);\n    }\n\n    // post-formation filter\n    inp = mix(\n        inp,\n        inp * flim_post_formation_filter,\n        flim_post_formation_filter_strength\n    );\n\n    // clip\n    inp = clamp(inp, 0., 1.);\n\n    // midtone saturation\n    float mono = flim_rgb_avg(inp);\n    float mix_fac =\n        (mono < .5)\n        ? flim_remap01(mono, .05, .5)\n        : flim_remap01(mono, .95, .5);\n    inp = mix(\n        inp,\n        flim_blender_hue_sat(inp, .5, flim_midtone_saturation, 1.),\n        mix_fac\n    );\n\n    // clip\n    inp = clamp(inp, 0., 1.);\n\n    // OETF\n    inp = pow(inp, vec3(1. / 2.2));\n\n    return inp;\n}\n\n/*____________________ end ____________________*/\n\n\n\nstruct Ray\n{\n    vec3 orig;\n    vec3 dir;\n};\n\nstruct Hit\n{\n    bool hit;\n    float tmin;\n    float tmax;\n};\n\n// https://www.reddit.com/r/opengl/comments/8ntzz5/comment/dzyqwgr\nvoid ray_aabb(const vec3 box_min, const vec3 box_max, const Ray r, out Hit hit) {\n    vec3 inv_dir = 1.0 / r.dir;\n    vec3 tbot = inv_dir * (box_min - r.orig);\n    vec3 ttop = inv_dir * (box_max - r.orig);\n    vec3 tmin = min(ttop, tbot);\n    vec3 tmax = max(ttop, tbot);\n    vec2 t = max(tmin.xx, tmin.yz);\n    float t0 = max(t.x, t.y);\n    t = min(tmax.xx, tmax.yz);\n    float t1 = min(t.x, t.y);\n    hit.tmin = t0;\n    hit.tmax = t1;\n    hit.hit = t1 > max(t0, 0.0);\n}\n\nvec3 spherical2cart(vec3 s)\n{\n    float sin_theta = sin(s.y);\n    return s.x * vec3(\n        sin_theta * cos(s.z),\n        sin_theta * sin(s.z),\n        cos(s.y)\n    );\n}\n\n// https://www.desmos.com/calculator/n4mfhffj1n\nfloat f_cmap(float x, float v)\n{\n    if (abs(v) < .0001) v = .0001;\n    float p = pow(2., v);\n    return (1. - pow(p, -x)) / (1. - 1. / p);\n}\n\n// https://www.shadertoy.com/view/DdcyRf\nvec3 colormap(float x)\n{\n    //float t = .1 * iTime;\n    //float t = .75 - 1.1 * x;\n    //float t = .25 * x;\n    float t = .6 + .8 * x;\n    \n    // https://www.desmos.com/calculator/sdqk904uu9\n    vec3 tone = 10. * vec3(\n        cos(6.283 * t),\n        cos(6.283 * (t - .3333)),\n        cos(6.283 * (t - .6667))\n    );\n    \n    x = smoothstep(-.04, 1., x);\n    vec3 c = vec3(\n        f_cmap(x, tone.r),\n        f_cmap(x, tone.g),\n        f_cmap(x, tone.b)\n    );\n    \n    return c;\n}\n\nfloat safe_pow(float a, float b)\n{\n    if (abs(a) < .00001)\n        return a;\n    if (a < 0.)\n        return pow(-a, b);\n    return pow(a, b);\n}\n\nvec3 rgb_saturate(vec3 c, float sat)\n{\n    return mix(vec3(dot(c, vec3(.3, .58, .12))), c, sat);\n}\n",
     "name": "Common",
     "description": "",
     "type": "common"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "M3jSRm",
    "date": "1710413384",
    "viewed": 16,
    "name": "3D SDF Visualization",
    "description": "just raymarching through a box and averaging the values we sampled along the way\n",
    "likes": 0,
    "published": "Unlisted",
    "usePreview": 0,
    "tags": [
     "3d",
     "raymarching",
     "math",
     "volume",
     "sdf",
     "visualization",
     "map",
     "functions",
     "fields"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "/*_________________ Scene SDF _________________*/\n// Source: https://www.shadertoy.com/view/lcsXRl\n\n#define LIGHT_POS vec3(-1002.3, 0.0, 0.0)\n#define LIGHT_RADIUS 1000.0\n\nfloat sdSphere(in vec3 p, in vec3 c, in float r) {\n    return length(p-c)-r;\n}\n\n// r = sphere's radius\n// h = cutting's plane's position\n// t = thickness\nfloat sdCutHollowSphere( vec3 p, float r, float h, float t )\n{\n  // sampling independent computations (only depend on shape)\n  float w = sqrt(r*r-h*h);\n  \n  // sampling dependant computations\n  vec2 q = vec2( length(p.xz), p.y );\n  return ((h*q.x<w*q.y) ? length(q-vec2(w,h)) : \n                          abs(length(q)-r) ) - t;\n}\n\nfloat sdBox( vec3 p, vec3 b ) {\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdBoxFrame( vec3 p, vec3 b, float e)\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nvec3 rotateY(in vec3 p, in float t) {\n    float cosT = cos(t), sinT = sin(t);\n    return vec3(p.x * cosT - p.z * sinT, p.y, p.x * sinT + p.z * cosT);\n}\nvec3 translate(in vec3 p, in vec3 t) {\n    return p-t;\n}\nvec3 repeatX(in vec3 p, in float size) {\n    return vec3(p.x - size*round(p.x/size), p.yz);\n}\nvec3 repeatY(in vec3 p, in float size) {\n    return vec3(p.x, p.y - size*round(p.y/size), p.z);\n}\nvec3 repeatZ(in vec3 p, in float size) {\n    return vec3(p.xy, p.z- size*round(p.z/size));\n}\n\nfloat smin(float a, float b, float k) {\n    return 0.5 * ((a + b) - sqrt((a-b)*(a-b)+k));\n}\n\nfloat map(vec3 p) {\n    float dist = sdSphere(p, LIGHT_POS, LIGHT_RADIUS); // Point light source\n    \n    vec3 wallColor = vec3(0.4, 0.4, 0.9);\n    \n    float room = max(0.0, -sdBox(translate(p, vec3(1.0, 0.0, 0.0)), vec3(3, 2, 2)));\n    room = max(room, -sdBox(translate(p, vec3(-1.5,-0.24,1.5)), vec3(1.0, 1.7, 0.3))); // cut out a hole in the wall\n    if (room < dist) {\n        dist = room;\n    }\n    \n    if (p.y + 1.99 < dist) {\n        dist = p.y + 1.99;\n    }\n    \n                                // Open door\n                                \n    float doorAng = radians(65.0);\n    vec3 doorP = rotateY(p, doorAng);\n    float door = sdBox(doorP - rotateY(vec3(-2.1, -0.24, 2.0), doorAng), vec3(1.0, 1.69, 0.05));\n    float doorDisplacement = 0.0;\n    \n        // Funky pattern on the door\n    doorDisplacement += min(0.2, pow(4.0 * distance(fract(doorP.x*2.0), 1.0) * distance(fract(doorP.x*2.0), 0.0), 10.0));\n    door += doorDisplacement * 0.05;\n    if (door < dist) {\n        dist = door;\n    }\n    /*\n    float doorKnob = sdSphere(p, vec3(-0.7, -0.3, 1.35), 0.1);\n    if (doorKnob < dist) {\n        dist = doorKnob;\n    }*/\n    \n    vec3 lampPos = vec3(1.7, 0.1, 1.5);\n    float lampRadius = 0.15;\n    \n    float lampBulb = sdSphere(p, lampPos, lampRadius * 0.7);\n    if (lampBulb < dist) {\n        dist = lampBulb;\n    }\n    \n    float lampCover = sdCutHollowSphere(translate(rotateY(p.xzy, -0.8 * 3.14159).xzy, rotateY(lampPos.xzy, -0.8 * 3.14159).xzy), lampRadius, lampRadius * 0.5, 0.02);\n    if (lampCover < dist) {\n        dist = lampCover;\n    }\n    \n    float lampStand = sdBox(p - lampPos - vec3(0.1, -0.25, -0.05), vec3(0.04, 0.3, 0.04));\n    lampStand = smin(lampStand, sdSphere(p, lampPos - vec3(-0.1, 0.4, 0.05), 0.04), 0.01);\n    if (lampStand < dist) {\n        dist = lampStand;\n    }\n    \n    float tableFrame = sdBoxFrame(p - vec3(1.2, -1.5, 1.5), vec3(1.0, 1.0, 0.3), 0.05);\n    if (tableFrame < dist) {\n        dist = tableFrame;\n    }\n    \n    float tableTop = sdBox(p - vec3(1.2, -0.5, 1.5), vec3(1.05, 0.1, 0.35)) - 0.02;\n    if (tableTop < dist) {\n        dist = tableTop;\n    }\n    \n    if (p.z + 1.99 < dist) { // light up the room a little\n        dist = p.z + 1.99;\n    }\n    \n    return dist;\n}\n\n/*______________ End of Scene SDF _____________*/\n\n\n\n\n\n\n\n\n// iChannel0 = Buffer A\n\n// min/max XYZ range for the input point\nconst vec2 domain = vec2(-1., 1.);\n\n// use a colormap (see end of Common)\nconst bool use_cmap = false;\n\n// your 3D function\nfloat volume(vec3 p)\n{\n    float v = map(2.15 * (p.xzy + vec3(0, 0, .02))) < .02 ? 1. : 0.;\n    \n    v *= remap(sin(100. * (p.z - .25 * iTime)), -1., 1., .9, 1.);\n    \n    if (mod(p.z + .22 * iTime, .4) < .15)\n    {\n        v *= .8;\n    }\n    \n    uint prng_state_backup[2];\n    prng_state_backup[0] = prng_state[0];\n    prng_state_backup[1] = prng_state[1];\n    prng_init(floor(iTime * 10.) / 10.);\n    if (random() < .3)\n    {\n        float glitch_mid = remap(random(), 0., 1., domain.x, domain.y);\n        float glitch_size = remap(random(), 0., 1., .05, .25);\n        vec2 glitch_range = vec2(glitch_mid - glitch_size, glitch_mid + glitch_size);\n        if (p.z > glitch_range.x && p.z < glitch_range.y)\n        {\n            v *= .7;\n        }\n    }\n    prng_state[0] = prng_state_backup[0];\n    prng_state[1] = prng_state_backup[1];\n    \n    v *= remap_clamp(dot(p, p), .5, 4., 1., .1);\n    \n    return v;\n}\n\nvec3 tint()\n{\n    return rgb_saturate(\n        rgb_sweep(iTime * .05 + .6),\n        .95\n    );\n}\n\nvec3 negative_tint()\n{\n    return .8 * rgb_saturate(\n        rgb_sweep(iTime * .05 + .27),\n        .95\n    );\n}\n\nvec2 screen_to_uv(vec2 coord)\n{\n    return (2. * coord - iResolution.xy) / min(iResolution.x, iResolution.y);\n}\n\nvec3 render(vec2 frag_coord)\n{\n    // UV\n    vec2 uv = screen_to_uv(frag_coord);\n    \n    // setup camera\n    \n    vec3 cam_pos_spherical = vec3(\n        /* r     */ 1.25,\n        /* theta */ PI_OVER_2,\n        /* phi   */ TAU * iTime * .08 - PI_OVER_2\n    );\n    if (iMouse.z > .1)\n    {\n        vec2 mouse_uv = screen_to_uv(iMouse.xy);\n        cam_pos_spherical.y = PI_OVER_2 + 1.5 * mouse_uv.y;\n        cam_pos_spherical.z = -PI_OVER_2 - 1.5 * mouse_uv.x;\n    }\n    vec3 cam_pos = spherical2cart(cam_pos_spherical);\n    cam_pos += vec3(0, 0, .1);\n\n    float cam_fov = 80.;\n    float cam_zoom = 90. / cam_fov;\n    \n    vec3 target_pos = vec3(0);\n    vec3 cam_forward = normalize(target_pos - cam_pos);\n    vec3 cam_right = normalize(cross(cam_forward, vec3(0, 0, 1)));\n    vec3 cam_up = cross(cam_right, cam_forward);\n\n    // generate ray\n    Ray ray;\n    ray.orig = cam_pos;\n    ray.dir = normalize(\n        cam_forward\n        + cam_right * (uv.x / cam_zoom)\n        + cam_up * (uv.y / cam_zoom)\n    );\n    \n    // check intersection with the container box which\n    // goes from (-.5, -.5, -.5) to (.5, .5, .5)\n    Hit hit;\n    ray_aabb(vec3(-.5), vec3(.5), ray, hit);\n    \n    // shade\n    vec3 col = vec3(0);\n    if (hit.hit)\n    {\n        // constant or randomized step sizes?\n        const bool use_random_stepping = true;\n        \n        // raymarch through the box\n        if (use_random_stepping)\n        {\n            // step size range\n            float min_step = .01;\n            float max_step = .025;\n            \n            // initial t along the ray\n            float step_size = remap(random(), 0., 1., min_step, max_step);\n            float t = hit.tmin + step_size;\n            \n            // keep stepping forward until we reach hit.tmax\n            int n_samples = 0;\n            while (t < hit.tmax)\n            {\n                // point along the ray inside the volume\n                vec3 p = ray.orig + t * ray.dir;\n                \n                // step forward\n                step_size = remap(random(), 0., 1., min_step, max_step);\n                t += step_size;\n                \n                // sample the input 3D function\n                vec3 p_mapped = remap(\n                    p,\n                    -.5, .5,\n                    domain.x, domain.y\n                );\n                float v = volume(p_mapped);\n                \n                // collect sample\n                if (use_cmap)\n                {\n                    col += colormap(.3 * v);\n                }\n                else\n                {\n                    // use another tint for negative values\n                    vec3 final_tint = tint();\n                    if (v < 0.)\n                    {\n                        v = -v;\n                        final_tint = negative_tint();\n                    }\n                    \n                    col += .9 * v * final_tint;\n                }\n                n_samples++;\n            }\n            \n            // average out the samples\n            if (n_samples > 0)\n            {\n                col /= float(n_samples);\n            }\n        }\n        else\n        {\n            // number of volume samples\n            int n_samples = 20;\n            \n            // collect samples\n            for (int i = 0; i < n_samples; i++)\n            {\n                // point along the ray inside the volume\n                float t = mix(\n                    hit.tmin,\n                    hit.tmax,\n                    (float(i) + .5) / float(n_samples)\n                );\n                vec3 p = ray.orig + t * ray.dir;\n                \n                // sample the input 3D function\n                vec3 p_mapped = remap(\n                    p,\n                    -.5, .5,\n                    domain.x, domain.y\n                );\n                float v = volume(p_mapped);\n                \n                // collect sample\n                if (use_cmap)\n                {\n                    col += colormap(.3 * v);\n                }\n                else\n                {\n                    // use another tint for negative values\n                    vec3 final_tint = tint();\n                    if (v < 0.)\n                    {\n                        v = -v;\n                        final_tint = negative_tint();\n                    }\n                    \n                    col += .9 * v * final_tint;\n                }\n            }\n            \n            // average out the samples\n            col /= float(n_samples);\n        }\n        \n        // slightly brigthen the box\n        col += vec3(.01);\n    }\n    \n    // glow\n    col += tint() * 0.12 * pow(max(0.0, dot(ray.dir, normalize(-cam_pos))), 6.0);\n    \n    return col;\n}\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    // initialize PRNG\n    prng_init(vec3(frag_coord / iResolution.y, iTime));\n\n    // box jitter sampling\n    const int num_samples = 8;\n    vec3 col = vec3(0);\n    for (int i = 0; i < num_samples; i++)\n    {\n        col += render(frag_coord + vec2(random() - .5, random() - .5));\n    }\n    col /= float(num_samples);\n    \n    // color grading\n    col = pow(col, vec3(1.2));\n    col += .015 * pow(tint(), vec3(6.));\n    \n    // noise\n    col += remap(random(), 0., 1., -.007, .005);\n    \n    // flim\n    col = flim_transform(col, 0., iChannel0);\n    \n    // output\n    frag_col = vec4(col, 1);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "/*_________________ Math Utils ________________*/\n\n#define PI 3.1415926535897932384626433832\n#define TAU 6.283185307179586476925286766\n#define PI_OVER_2 1.57079632679489661923132169163\n\n#define FUNC_LERP(T) \\\nT lerp(T a, T b, float t) \\\n{ \\\n    return a + t*(b-a); \\\n}\n\n#define FUNC_WRAP(T) \\\nT wrap(T inp, float start, float end) \\\n{ \\\n    return start + mod(inp - start, end - start); \\\n}\n\n#define FUNC_REMAP(T) \\\nT remap(T inp, float inp_start, float inp_end, float out_start, float out_end) \\\n{ \\\n    return out_start + ((out_end - out_start) / (inp_end - inp_start)) * (inp - inp_start); \\\n}\n\n#define FUNC_REMAP_CLAMP(T) \\\nT remap_clamp(T inp, float inp_start, float inp_end, float out_start, float out_end) \\\n{ \\\n    T t = clamp((inp - inp_start) / (inp_end - inp_start), 0.0, 1.0); \\\n    return out_start + t * (out_end - out_start); \\\n}\n\n#define FUNC_REMAP01(T) \\\nT remap01(T inp, float inp_start, float inp_end) \\\n{ \\\n    return clamp((inp - inp_start) / (inp_end - inp_start), 0.0, 1.0); \\\n}\n\nFUNC_LERP(float)\nFUNC_LERP(vec2)\nFUNC_LERP(vec3)\nFUNC_LERP(vec4)\n\nFUNC_WRAP(float)\nFUNC_WRAP(vec2)\nFUNC_WRAP(vec3)\nFUNC_WRAP(vec4)\n\nFUNC_REMAP(float)\nFUNC_REMAP(vec2)\nFUNC_REMAP(vec3)\nFUNC_REMAP(vec4)\n\nFUNC_REMAP_CLAMP(float)\nFUNC_REMAP_CLAMP(vec2)\nFUNC_REMAP_CLAMP(vec3)\nFUNC_REMAP_CLAMP(vec4)\n\nFUNC_REMAP01(float)\nFUNC_REMAP01(vec2)\nFUNC_REMAP01(vec3)\nFUNC_REMAP01(vec4)\n\nmat2 rotate_2d(float angle)\n{\n    return mat2(cos(angle), sin(angle), cos(angle + PI_OVER_2), sin(angle + PI_OVER_2));\n}\n\n/*____________________ End ____________________*/\n\n\n\n/*_______ Pseudo-Random Number Generator ______*/\n// Source: https://www.shadertoy.com/view/WdSSRt\n\n/* Usage Example:\n    void mainImage(out vec4 frag_col, in vec2 frag_coord)\n    {\n        // Initialize PRNG\n        prng_init(vec3(frag_coord / iResolution.y, iTime));\n    \n        // Using the function\n        float a = random();\n        vec3 b = vec3(random(), random(), random());\n        \n        ...\n    }\n*/\n\nuint prng_state[2];\n\nuint prng_rot(uint x, int k)\n{\n    return (x << k) | (x >> (32 - k));\n}\n\n// Random uint from 0 to 2^32-1\nuint randomui()\n{\n    uint s0 = prng_state[0];\n    uint s1 = prng_state[1];\n    uint result = prng_rot(s0 * 0x9e3779bbu, 5) * 5u;\n    s1 ^= s0;\n    prng_state[0] = prng_rot(s0, 26) ^ s1 ^ (s1 << 9);\n    prng_state[1] = prng_rot(s1, 13);\n    return result;\n}\n\n// Random int from 0 to 2^31-1\nint randomi()\n{\n    return int(randomui() % 0x7FFFFFFFu);\n}\n\n// Random float from 0 to 1\nfloat random()\n{\n    return float(randomui()) / float(0xffffffffu);\n}\n\n// Generate two normally distributed random numbers using the\n// Box-Muller Transform.\n// https://www.baeldung.com/cs/uniform-to-normal-distribution\nvec2 random_gauss()\n{\n    float u1 = random();\n    float u2 = random() * TAU;\n    float temp = sqrt(-2. * log(u1));\n    return temp * vec2(cos(u2), sin(u2));\n    \n    // Unoptimized version\n    //float u1 = random();\n    //float u2 = random();\n    //return vec2(cos(TAU * u2), sin(TAU * u2)) * sqrt(-2. * log(u1));\n}\n\nvec2 random_unit_vec2()\n{\n    vec2 v = vec2(1);\n    float lensqr;\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec2(2. * random() - 1., 2. * random() - 1.);\n        lensqr = dot(v, v);\n        if (lensqr == 0.)\n            i--;\n        else if (lensqr <= 1.)\n            break;\n    }\n    return v / sqrt(lensqr);\n}\n\nvec3 random_unit_vec3()\n{\n    vec3 v = vec3(1);\n    float lensqr;\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec3(2. * random() - 1., 2. * random() - 1., 2. * random() - 1.);\n        lensqr = dot(v, v);\n        if (lensqr == 0.)\n            i--;\n        else if (lensqr <= 1.)\n            break;\n    }\n    return v / sqrt(lensqr);\n}\n\nvec2 random_in_circle()\n{\n    vec2 v = vec2(1);\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec2(2. * random() - 1., 2. * random() - 1.);\n        if (dot(v, v) <= 1.)\n            return v;\n    }\n    return v;\n}\n\nvec3 random_in_sphere()\n{\n    vec3 v = vec3(1);\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec3(2. * random() - 1., 2. * random() - 1., 2. * random() - 1.);\n        if (dot(v, v) <= 1.)\n            return v;\n    }\n    return v;\n}\n\n// Initialize with uvec2\nvoid prng_init(uvec2 seed)\n{\n    seed += uvec2(1317, 944573125);\n    seed *= 464973573u;\n    prng_state[0] = seed.x;\n    prng_state[1] = seed.y;\n    randomi();\n}\n\n// Initialize with uint\nvoid prng_init(uint seed)\n{\n    prng_init(uvec2(seed, 1));\n}\n\n// Initialize with vec3\nvoid prng_init(vec3 seed)\n{\n    seed += 3.49276101561702;\n    seed.xy *= (seed.z + 10.258);\n    prng_state[0] = floatBitsToUint(seed.x);\n    prng_state[1] = floatBitsToUint(seed.y);\n    randomui();\n}\n\n// Initialize with vec2\nvoid prng_init(vec2 seed)\n{\n    prng_init(vec3(seed, 1));\n}\n\n// Initialize with float\nvoid prng_init(float seed)\n{\n    prng_init(vec3(seed, 1, 1));\n}\n\n/*____________________ End ____________________*/\n\n\n\n\n/***********************************\n\nflim - Filmic Color Transform\n\nInput Color Space:   Linear BT.709 I-D65\nOutput Color Space:  sRGB 2.2\n\nShadertoy Unit:\n  Common\n\nDescription:\n  Experimental port of flim for GLSL/Shadertoy\n  matching flim v1.1.0.\n  The common unit contains most of the code, and\n  receives gamut extension matrices from a buffer.\n\nAuthor:\n  Bean (beans_please on Shadertoy)\n\nOriginal Repo:\n  https://github.com/bean-mhm/flim\n\nOriginal Shader:\n  https://www.shadertoy.com/view/dd2yDz\n\n***********************************/\n\n// Parameters\n\nconst float flim_pre_exposure = 4.3;\nconst vec3 flim_pre_formation_filter = vec3(1.0);\nconst float flim_pre_formation_filter_strength = 0.0;\n\nconst float flim_extended_gamut_red_scale = 1.05;\nconst float flim_extended_gamut_green_scale = 1.12;\nconst float flim_extended_gamut_blue_scale = 1.045;\nconst float flim_extended_gamut_red_rot = 0.5;\nconst float flim_extended_gamut_green_rot = 2.0;\nconst float flim_extended_gamut_blue_rot = 0.1;\nconst float flim_extended_gamut_red_mul = 1.0;\nconst float flim_extended_gamut_green_mul = 1.0;\nconst float flim_extended_gamut_blue_mul = 1.0;\n\nconst float flim_sigmoid_log2_min = -10.0;\nconst float flim_sigmoid_log2_max = 22.0;\nconst float flim_sigmoid_toe_x = 0.44;\nconst float flim_sigmoid_toe_y = 0.28;\nconst float flim_sigmoid_shoulder_x = 0.591;\nconst float flim_sigmoid_shoulder_y = 0.779;\n\nconst float flim_negative_film_exposure = 6.0;\nconst float flim_negative_film_density = 5.0;\n\nconst vec3 flim_print_backlight = vec3(1.0);\nconst float flim_print_film_exposure = 6.0;\nconst float flim_print_film_density = 27.5;\n\nconst float flim_black_point = -1.0; // -1 = auto\nconst vec3 flim_post_formation_filter = vec3(1.0);\nconst float flim_post_formation_filter_strength = 0.0;\nconst float flim_midtone_saturation = 1.02;\n\n// -------------------------------\n\nfloat map_range(float inp, float inp_start, float inp_end, float out_start, float out_end)\n{\n    return out_start + ((out_end - out_start) / (inp_end - inp_start)) * (inp - inp_start);\n}\n\nfloat map_range_clamp(float inp, float inp_start, float inp_end, float out_start, float out_end)\n{\n    float t = clamp((inp - inp_start) / (inp_end - inp_start), 0.0, 1.0);\n    float v = out_start + t * (out_end - out_start);\n    return v;\n}\n\nvec3 blender_rgb_to_hsv(vec3 rgb)\n{\n    float cmax, cmin, h, s, v, cdelta;\n    vec3 c;\n\n    cmax = max(rgb[0], max(rgb[1], rgb[2]));\n    cmin = min(rgb[0], min(rgb[1], rgb[2]));\n    cdelta = cmax - cmin;\n\n    v = cmax;\n    if (cmax != 0.0)\n    {\n        s = cdelta / cmax;\n    }\n    else\n    {\n        s = 0.0;\n        h = 0.0;\n    }\n\n    if (s == 0.0)\n    {\n        h = 0.0;\n    }\n    else\n    {\n        c = (vec3(cmax) - rgb.xyz) / cdelta;\n\n        if (rgb.x == cmax)\n        {\n            h = c[2] - c[1];\n        }\n        else if (rgb.y == cmax)\n        {\n            h = 2.0 + c[0] - c[2];\n        }\n        else\n        {\n            h = 4.0 + c[1] - c[0];\n        }\n\n        h /= 6.0;\n\n        if (h < 0.0)\n        {\n            h += 1.0;\n        }\n    }\n\n    return vec3(h, s, v);\n}\n\nvec3 blender_hsv_to_rgb(vec3 hsv)\n{\n    float i, f, p, q, t, h, s, v;\n    vec3 rgb;\n\n    h = hsv[0];\n    s = hsv[1];\n    v = hsv[2];\n\n    if (s == 0.0)\n    {\n        rgb = vec3(v, v, v);\n    }\n    else\n    {\n        if (h == 1.0)\n        {\n            h = 0.0;\n        }\n\n        h *= 6.0;\n        i = floor(h);\n        f = h - i;\n        rgb = vec3(f, f, f);\n        p = v * (1.0 - s);\n        q = v * (1.0 - (s * f));\n        t = v * (1.0 - (s * (1.0 - f)));\n\n        if (i == 0.0)\n        {\n            rgb = vec3(v, t, p);\n        }\n        else if (i == 1.0)\n        {\n            rgb = vec3(q, v, p);\n        }\n        else if (i == 2.0)\n        {\n            rgb = vec3(p, v, t);\n        }\n        else if (i == 3.0)\n        {\n            rgb = vec3(p, q, v);\n        }\n        else if (i == 4.0)\n        {\n            rgb = vec3(t, p, v);\n        }\n        else\n        {\n            rgb = vec3(v, p, q);\n        }\n    }\n\n    return rgb;\n}\n\nvec3 blender_hue_sat(vec3 col, float hue, float sat, float value)\n{\n    vec3 hsv = blender_rgb_to_hsv(col);\n\n    hsv[0] = fract(hsv[0] + hue + 0.5);\n    hsv[1] = clamp(hsv[1] * sat, 0.0, 1.0);\n    hsv[2] = hsv[2] * value;\n\n    return blender_hsv_to_rgb(hsv);\n}\n\nfloat rgb_avg(vec3 inp)\n{\n    return (inp.x + inp.y + inp.z) / 3.0;\n}\n\nfloat rgb_sum(vec3 inp)\n{\n    return inp.x + inp.y + inp.z;\n}\n\nfloat rgb_max(vec3 inp)\n{\n    return max(max(inp.x, inp.y), inp.z);\n}\n\nfloat rgb_min(vec3 inp)\n{\n    return min(min(inp.x, inp.y), inp.z);\n}\n\nvec3 rgb_uniform_offset(vec3 inp, float black_point, float white_point)\n{\n    float mono = rgb_avg(inp);\n    float mono2 = map_range_clamp(mono, black_point / 1000.0, 1.0 - (white_point / 1000.0), 0.0, 1.0);\n    return inp * (mono2 / mono);\n}\n\nvec3 rgb_sweep(float hue)\n{\n    hue = wrap(hue * 360.0, 0.0, 360.0);\n\n    vec3 col = vec3(1, 0, 0);\n    col = mix(col, vec3(1, 1, 0), map_range_clamp(hue, 0.0, 60.0, 0.0, 1.0));\n    col = mix(col, vec3(0, 1, 0), map_range_clamp(hue, 60.0, 120.0, 0.0, 1.0));\n    col = mix(col, vec3(0, 1, 1), map_range_clamp(hue, 120.0, 180.0, 0.0, 1.0));\n    col = mix(col, vec3(0, 0, 1), map_range_clamp(hue, 180.0, 240.0, 0.0, 1.0));\n    col = mix(col, vec3(1, 0, 1), map_range_clamp(hue, 240.0, 300.0, 0.0, 1.0));\n    col = mix(col, vec3(1, 0, 0), map_range_clamp(hue, 300.0, 360.0, 0.0, 1.0));\n    \n    return col;\n}\n\n// -------------------------------\n\nvec3 flim_rgb_sweep(vec2 uv0to1)\n{\n    float hue = 1.0 - uv0to1.y;\n    float exposure = map_range(uv0to1.x, 0.0, 1.0, -5.0, 10.0);\n    return rgb_sweep(hue) * pow(2.0, exposure);\n}\n\n// https://www.desmos.com/calculator/khkztixyeu\nfloat flim_super_sigmoid(float inp, float toe_x, float toe_y, float shoulder_x, float shoulder_y)\n{\n    // Clip\n    inp = clamp(inp, 0.0, 1.0);\n    toe_x = clamp(toe_x, 0.0, 1.0);\n    toe_y = clamp(toe_y, 0.0, 1.0);\n    shoulder_x = clamp(shoulder_x, 0.0, 1.0);\n    shoulder_y = clamp(shoulder_y, 0.0, 1.0);\n\n    // Calculate straight line slope\n    float slope = (shoulder_y - toe_y) / (shoulder_x - toe_x);\n\n    // Toe\n    if (inp < toe_x)\n    {\n        float toe_pow = slope * toe_x / toe_y;\n        return toe_y * pow(inp / toe_x, toe_pow);\n    }\n\n    // Straight line\n    if (inp < shoulder_x)\n    {\n        float intercept = toe_y - (slope * toe_x);\n        return slope * inp + intercept;\n    }\n\n    // Shoulder\n    float shoulder_pow = -slope / (((shoulder_x - 1.0) / pow(1.0 - shoulder_x, 2.0)) * (1.0 - shoulder_y));\n    return (1.0 - pow(1.0 - (inp - shoulder_x) / (1.0 - shoulder_x), shoulder_pow)) * (1.0 - shoulder_y) + shoulder_y;\n}\n\nfloat flim_dye_mix_factor(float mono, float max_density)\n{\n    // log2 and map range\n    float offset = pow(2.0, flim_sigmoid_log2_min);\n    float fac = map_range_clamp(log2(mono + offset), flim_sigmoid_log2_min, flim_sigmoid_log2_max, 0.0, 1.0);\n\n    // Calculate amount of exposure from 0 to 1\n    fac = flim_super_sigmoid(fac, flim_sigmoid_toe_x, flim_sigmoid_toe_y, flim_sigmoid_shoulder_x, flim_sigmoid_shoulder_y);\n\n    // Calculate dye density\n    fac *= max_density;\n\n    // Mix factor\n    fac = pow(2.0, -fac);\n\n    // Clip and return\n    return clamp(fac, 0.0, 1.0);\n}\n\nvec3 flim_rgb_color_layer(vec3 inp, vec3 sensitivity_tone, vec3 dye_tone, float max_density)\n{\n    // Normalize\n    vec3 sensitivity_tone_norm = sensitivity_tone / rgb_sum(sensitivity_tone);\n    vec3 dye_tone_norm = dye_tone / rgb_max(dye_tone);\n\n    // Dye mix factor\n    float mono = dot(inp, sensitivity_tone_norm);\n    float mixFac = flim_dye_mix_factor(mono, max_density);\n\n    // Dye mixing\n    return lerp(dye_tone_norm, vec3(1.0), mixFac);\n}\n\nvec3 flim_rgb_develop(vec3 inp, float exposure, float max_density)\n{\n    // Exposure\n    inp *= pow(2.0, exposure);\n\n    // Blue-sensitive layer\n    vec3 result = flim_rgb_color_layer(inp, vec3(0, 0, 1), vec3(1, 1, 0), max_density);\n\n    // Green-sensitive layer\n    result *= flim_rgb_color_layer(inp, vec3(0, 1, 0), vec3(1, 0, 1), max_density);\n\n    // Red-sensitive layer\n    result *= flim_rgb_color_layer(inp, vec3(1, 0, 0), vec3(0, 1, 1), max_density);\n\n    return result;\n}\n\nvec3 flim_gamut_extension_mat_row(float primary_hue, float scale, float rotate, float mul)\n{\n    vec3 result = blender_hsv_to_rgb(vec3(wrap(primary_hue + (rotate / 360.0), 0.0, 1.0), 1.0 / scale, 1.0));\n    result /= rgb_sum(result);\n    result *= mul;\n    return result;\n}\n\nmat3 flim_gamut_extension_mat(\n    float red_scale,\n    float green_scale,\n    float blue_scale,\n    float red_rot,\n    float green_rot,\n    float blue_rot,\n    float red_mul,\n    float green_mul,\n    float blue_mul\n)\n{\n    mat3 m;\n    m[0] = flim_gamut_extension_mat_row(0.0, red_scale, red_rot, red_mul);\n    m[1] = flim_gamut_extension_mat_row(1.0 / 3.0, green_scale, green_rot, green_mul);\n    m[2] = flim_gamut_extension_mat_row(2.0 / 3.0, blue_scale, blue_rot, blue_mul);\n    return m;\n}\n\nvec3 negative_and_print(vec3 inp, vec3 backlight_ext)\n{\n    // Develop Negative\n    inp = flim_rgb_develop(inp, flim_negative_film_exposure, flim_negative_film_density);\n\n    // Backlight\n    inp *= backlight_ext;\n\n    // Develop Print\n    inp = flim_rgb_develop(inp, flim_print_film_exposure, flim_print_film_density);\n\n    return inp;\n}\n\nbool flim_load_matrices(sampler2D matrix_ch, out mat3 extend_mat, out mat3 extend_mat_inv)\n{\n    // W == valid_w means the matrices have been calculated\n    // in the source buffer.\n    const float valid_w = 2.0;\n\n    vec4 row;\n\n    // extend_mat\n    {\n        row = texelFetch(matrix_ch, ivec2(0, 0), 0);\n        if (row.w != valid_w)\n            return false;\n        extend_mat[0] = row.xyz;\n\n        row = texelFetch(matrix_ch, ivec2(1, 0), 0);\n        if (row.w != valid_w)\n            return false;\n        extend_mat[1] = row.xyz;\n\n        row = texelFetch(matrix_ch, ivec2(2, 0), 0);\n        if (row.w != valid_w)\n            return false;\n        extend_mat[2] = row.xyz;\n    }\n\n    // extend_mat_inv\n    {\n        row = texelFetch(matrix_ch, ivec2(3, 0), 0);\n        if (row.w != valid_w)\n            return false;\n        extend_mat_inv[0] = row.xyz;\n\n        row = texelFetch(matrix_ch, ivec2(4, 0), 0);\n        if (row.w != valid_w)\n            return false;\n        extend_mat_inv[1] = row.xyz;\n\n        row = texelFetch(matrix_ch, ivec2(5, 0), 0);\n        if (row.w != valid_w)\n            return false;\n        extend_mat_inv[2] = row.xyz;\n    }\n\n    return true;\n}\n\n// -------------------------------\n\n// matrix_ch: Which channel provides the buffer\n// containing gamut extension matrices?\nvec3 flim_transform(vec3 inp, float exposure, sampler2D matrix_ch)\n{\n    // Eliminate negative values\n    inp = max(inp, 0.0);\n\n    // Pre-Exposure\n    inp *= pow(2.0, flim_pre_exposure + exposure);\n\n    // Clip very large values for float precision reasons\n    inp = min(inp, 5000.0);\n\n    // Gamut Extension Matrix (Linear BT.709)\n    mat3 extend_mat, extend_mat_inv;\n    if (!flim_load_matrices(matrix_ch, extend_mat, extend_mat_inv))\n    {\n        return vec3(1, 0, 1);\n    }\n\n    // Backlight (extended gamut)\n    vec3 backlight_ext = flim_print_backlight * extend_mat;\n\n    // Upper limit in the print (highlight cap)\n    const float big = 10000000.0;\n    vec3 white_cap = negative_and_print(vec3(big, big, big), backlight_ext);\n\n    // Pre-Formation Filter\n    inp = lerp(inp, inp * flim_pre_formation_filter, flim_pre_formation_filter_strength);\n\n    // Convert to extended gamut\n    inp *= extend_mat;\n\n    // Negative & Print\n    inp = negative_and_print(inp, backlight_ext);\n\n    // Convert from extended gamut\n    inp *= extend_mat_inv;\n\n    // Eliminate negative values\n    inp = max(inp, 0.0);\n\n    // White cap\n    inp /= white_cap;\n\n    // Black cap\n    if (flim_black_point == -1.0) // -1 = auto\n    {\n        vec3 black_cap = negative_and_print(vec3(0.0), backlight_ext);\n        black_cap /= white_cap;\n        inp = rgb_uniform_offset(inp, rgb_avg(black_cap) * 1000.0, 0.0);\n    }\n    else\n    {\n        inp = rgb_uniform_offset(inp, flim_black_point, 0.0);\n    }\n\n    // Post-Formation Filter\n    inp = lerp(inp, inp * flim_post_formation_filter, flim_post_formation_filter_strength);\n\n    // Clip\n    inp = clamp(inp, 0.0, 1.0);\n\n    // Midtone Saturation\n    float mono = rgb_avg(inp);\n    float mixFac = (mono < 0.5) ? map_range_clamp(mono, 0.05, 0.5, 0.0, 1.0) : map_range_clamp(mono, 0.5, 0.95, 1.0, 0.0);\n    inp = lerp(inp, blender_hue_sat(inp, 0.5, flim_midtone_saturation, 1.0), mixFac);\n\n    // Clip\n    inp = clamp(inp, 0.0, 1.0);\n\n    // OETF (Gamma 2.2)\n    inp = pow(inp, vec3(1.0 / 2.2));\n\n    return inp;\n}\n\n/***********************************\n\nEnd of flim's implementation for Shadertoy Unit: Common\n\n***********************************/\n\n\n\nstruct Ray\n{\n    vec3 orig;\n    vec3 dir;\n};\n\nstruct Hit\n{\n    bool hit;\n    float tmin;\n    float tmax;\n};\n\n// https://www.reddit.com/r/opengl/comments/8ntzz5/comment/dzyqwgr\nvoid ray_aabb(const vec3 box_min, const vec3 box_max, const Ray r, out Hit hit) {\n    vec3 inv_dir = 1.0 / r.dir;\n    vec3 tbot = inv_dir * (box_min - r.orig);\n    vec3 ttop = inv_dir * (box_max - r.orig);\n    vec3 tmin = min(ttop, tbot);\n    vec3 tmax = max(ttop, tbot);\n    vec2 t = max(tmin.xx, tmin.yz);\n    float t0 = max(t.x, t.y);\n    t = min(tmax.xx, tmax.yz);\n    float t1 = min(t.x, t.y);\n    hit.tmin = t0;\n    hit.tmax = t1;\n    hit.hit = t1 > max(t0, 0.0);\n}\n\nvec3 spherical2cart(vec3 s)\n{\n    float sin_theta = sin(s.y);\n    return s.x * vec3(\n        sin_theta * cos(s.z),\n        sin_theta * sin(s.z),\n        cos(s.y)\n    );\n}\n\n// https://www.desmos.com/calculator/n4mfhffj1n\nfloat f_cmap(float x, float v)\n{\n    if (abs(v) < .0001) v = .0001;\n    float p = pow(2., v);\n    return (1. - pow(p, -x)) / (1. - 1. / p);\n}\n\n// https://www.shadertoy.com/view/DdcyRf\nvec3 colormap(float x)\n{\n    //float t = .1 * iTime;\n    //float t = .75 - 1.1 * x;\n    //float t = .25 * x;\n    float t = .6 + .8 * x;\n    \n    // https://www.desmos.com/calculator/sdqk904uu9\n    vec3 tone = 10. * vec3(\n        cos(6.283 * t),\n        cos(6.283 * (t - .3333)),\n        cos(6.283 * (t - .6667))\n    );\n    \n    x = smoothstep(-.04, 1., x);\n    vec3 c = vec3(\n        f_cmap(x, tone.r),\n        f_cmap(x, tone.g),\n        f_cmap(x, tone.b)\n    );\n    \n    return c;\n}\n\nfloat safe_pow(float a, float b)\n{\n    if (abs(a) < .00001)\n        return a;\n    if (a < 0.)\n        return pow(-a, b);\n    return pow(a, b);\n}\n\nvec3 rgb_saturate(vec3 c, float sat)\n{\n    return mix(vec3(dot(c, vec3(.3, .58, .12))), c, sat);\n}\n",
     "name": "Common",
     "description": "",
     "type": "common"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "/***********************************\n\nflim - Filmic Color Transform\n\nInput Color Space:   Linear BT.709 I-D65\nOutput Color Space:  sRGB 2.2\n\nShadertoy Unit:\n  Buffer X\n\nDescription:\n  Experimental port of flim for GLSL/Shadertoy\n  matching flim v1.1.0.\n  The buffer unit performs a one-time calculation\n  of flim's gamut extension matrices.\n\nAuthor:\n  Bean (beans_please on Shadertoy)\n\nOriginal Repo:\n  https://github.com/bean-mhm/flim\n\nOriginal Shader:\n  https://www.shadertoy.com/view/dd2yDz\n\n***********************************/\n\n// NOTE:\n// iChannel0 must be set to this buffer (self-feeding).\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // W == valid_w means the matrices have already been calculated.\n    const float valid_w = 2.0;\n\n    // We only care about the first 6 pixels\n    if (ivec2(fragCoord).x > 5 || ivec2(fragCoord).y > 0)\n        return;\n\n    // Previous frame's value\n    vec4 prev = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    fragColor = prev;\n\n    // Do we need to recalculate the matrices?\n    bool needToCalc = (prev.w != valid_w) || (iTime == 0.0) || (iFrame < 1);\n    if (!needToCalc)\n        return;\n\n    // (Re)calculate the matrices\n    mat3 extend_mat = flim_gamut_extension_mat(flim_extended_gamut_red_scale, flim_extended_gamut_green_scale, flim_extended_gamut_blue_scale, flim_extended_gamut_red_rot, flim_extended_gamut_green_rot, flim_extended_gamut_blue_rot, flim_extended_gamut_red_mul, flim_extended_gamut_green_mul, flim_extended_gamut_blue_mul);\n    mat3 extend_mat_inv = inverse(extend_mat);\n\n    // extend_mat\n    {\n        if (ivec2(fragCoord) == ivec2(0, 0))\n        {\n            fragColor = vec4(extend_mat[0], valid_w);\n        }\n        if (ivec2(fragCoord) == ivec2(1, 0))\n        {\n            fragColor = vec4(extend_mat[1], valid_w);\n        }\n        if (ivec2(fragCoord) == ivec2(2, 0))\n        {\n            fragColor = vec4(extend_mat[2], valid_w);\n        }\n    }\n\n    // extend_mat_inv\n    {\n        if (ivec2(fragCoord) == ivec2(3, 0))\n        {\n            fragColor = vec4(extend_mat_inv[0], valid_w);\n        }\n        if (ivec2(fragCoord) == ivec2(4, 0))\n        {\n            fragColor = vec4(extend_mat_inv[1], valid_w);\n        }\n        if (ivec2(fragCoord) == ivec2(5, 0))\n        {\n            fragColor = vec4(extend_mat_inv[2], valid_w);\n        }\n    }\n}\n\n/***********************************\n\nEnd of flim's implementation for Shadertoy Unit: Buffer X\n\n***********************************/\n",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "lXBXWz",
    "date": "1710447505",
    "viewed": 199,
    "name": "8-bit Blue Noise Dithering",
    "description": "dithering",
    "likes": 3,
    "published": "Public API",
    "usePreview": 1,
    "tags": [
     "noise",
     "dither",
     "gamma",
     "dithering",
     "bluenoise",
     "srgb",
     "oetf"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "XsBSR3",
       "filepath": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png",
       "type": "texture",
       "channel": 0,
       "sampler": {
        "filter": "nearest",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "void mainImage(out vec4 fragcol, in vec2 fragcoord)\n{\n    // UV (0 to 1 stretched)\n    vec2 uv = fragcoord / iResolution.xy;\n\n    // linear gradient\n    vec3 col = vec3(uv.x * .3 + .05);\n\n    // OETF (Linear BT.709 I-D65 --> sRGB 2.2)\n    col = pow(col, vec3(1. / 2.2));\n    \n    // alternate dither mode\n    bool dither = mod(iTime, 2.) < 1.;\n    \n    // dither\n    if (dither)\n    {\n        float bn = texelFetch(\n            iChannel0,\n            ivec2(fragcoord) % textureSize(iChannel0, 0),\n            0\n        ).x;\n        col += 2. * (bn - .5) / 254.9;\n    }\n    \n    // indicator at the corner\n    if (uv.x > .97 && uv.y < .05)\n    {\n        col = dither ? vec3(0, 1, 0) : vec3(1, 0, 0);\n    }\n    \n    // output\n    fragcol = vec4(col, 1);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "XX2XDd",
    "date": "1711246176",
    "viewed": 171,
    "name": "Run at 120+ Hz if possible",
    "description": "Alternating between red and cyan, which looks gray. Try moving your eyes across the screen really quickly to see the pattern (in full screen).",
    "likes": 1,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "color",
     "blending",
     "blend",
     "mixing",
     "alternating"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "void mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    // uv\n    vec2 uv = frag_coord / iResolution.xy;\n\n    // render\n    const vec3 a = vec3(1, 0, 0);\n    const vec3 b = vec3(0, 1, 1);\n    vec3 col = iFrame % 2 == 0 ? a : b;\n    \n    // output\n    col = pow(col, vec3(1. / 2.2));\n    frag_col = vec4(col, 1);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "Xcd3zN",
    "date": "0",
    "viewed": 0,
    "name": "Low Quality Digital Camera",
    "description": "Applying a bayer filter to a render and then demosaicing it.",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "3d",
     "raymarching",
     "noise",
     "filter",
     "color",
     "camera",
     "effect",
     "old",
     "digital",
     "bayer",
     "tape",
     "artifacts",
     "demosaic",
     "demosaicing",
     "rcd"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XsBSR3",
       "filepath": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png",
       "type": "texture",
       "channel": 1,
       "sampler": {
        "filter": "nearest",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// ASC CDL color grading\n// https://en.wikipedia.org/wiki/ASC_CDL\nvec3 asc_cdl(vec3 col, vec3 slope, vec3 offset, vec3 power)\n{\n    return pow(col * slope + offset, power);\n}\n\nvec3 view_transform(vec3 col)\n{\n    col = asc_cdl(\n        col,\n        1.1 * vec3(1, .903, .94),\n        vec3(0, 0, .007),\n        1.05 * vec3(1, .95, 1)\n    );\n\n    if (1 == 1)\n    {\n        col = flim_transform(col, 0.);\n    }\n    else\n    {\n        col = clamp(col, 0., 1.);\n\n        // OETF (Linear BT.709 I-D65 to sRGB 2.2)\n        col = pow(col, vec3(1. / 2.2));\n    }\n    \n    return col;\n}\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    ivec2 icoord = ivec2(frag_coord);\n\n    // demosaic\n    ivec2 icoord_bl = 2 * ivec2(floor(.5 * frag_coord));\n    vec3 bl_g = vec3(0, texelFetch(iChannel0, icoord_bl, 0).x, 0);\n    vec3 br_r = vec3(texelFetch(iChannel0, icoord_bl + ivec2(1, 0), 0).x, 0, 0);\n    vec3 tr_g = vec3(0, texelFetch(iChannel0, icoord_bl + ivec2(1), 0).x, 0);\n    vec3 tl_b = vec3(0, 0, texelFetch(iChannel0, icoord_bl + ivec2(0, 1), 0).x);\n    vec3 col = .5 * (bl_g + tr_g) + br_r + tl_b;\n\n/*\nG\n0       0.25    0\n0.25    1.00    0.25\n0       0.25    0\n\n\nR B\n0.25    0.50    0.25\n0.50    1.00    0.50\n0.25    0.50    0.25\n*/\n\n    //col = texelFetch(iChannel0, icoord, 0).rgb;\n\n    // view transform\n    col = view_transform(col);\n\n    // dither\n    float bn = texelFetch(\n        iChannel1,\n        icoord % textureSize(iChannel1, 0),\n        0\n    ).x;\n    col = clamp(col + (2. * bn - .5) / 254., 0., 1.);\n\n    // output\n    frag_col = vec4(col, 1.);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "#define SHADERTOY 1\n\nprecision highp float;\nprecision highp int;\n\n\n\n/*_________________ math utils ________________*/\n\nconst float PI = 3.141592653589793238462643383;\nconst float TAU = 6.283185307179586476925286767;\nconst float PI_OVER_2 = 1.570796326794896619231321692;\nconst float INV_PI = .318309886183790671537767527;\n\n#define FUNC_LERP(T) \\\nT lerp(T a, T b, float t) \\\n{ \\\n    return a + t * (b - a); \\\n}\n\n#define FUNC_WRAP(T) \\\nT wrap(T inp, float start, float end) \\\n{ \\\n    return start + mod(inp - start, end - start); \\\n}\n\n#define FUNC_REMAP(T) \\\nT remap(T inp, float inp_start, float inp_end, float out_start, float out_end) \\\n{ \\\n    return out_start \\\n        + ((out_end - out_start) / (inp_end - inp_start)) * (inp - inp_start); \\\n}\n\n#define FUNC_REMAP_CLAMP(T) \\\nT remap_clamp( \\\n    T inp, \\\n    float inp_start, \\\n    float inp_end, \\\n    float out_start, \\\n    float out_end \\\n) \\\n{ \\\n    T t = clamp((inp - inp_start) / (inp_end - inp_start), 0.0, 1.0); \\\n    return out_start + t * (out_end - out_start); \\\n}\n\n#define FUNC_REMAP01(T) \\\nT remap01(T inp, float inp_start, float inp_end) \\\n{ \\\n    return clamp((inp - inp_start) / (inp_end - inp_start), 0.0, 1.0); \\\n}\n\nFUNC_LERP(float)\nFUNC_LERP(vec2)\nFUNC_LERP(vec3)\nFUNC_LERP(vec4)\n\nFUNC_WRAP(float)\nFUNC_WRAP(vec2)\nFUNC_WRAP(vec3)\nFUNC_WRAP(vec4)\n\nFUNC_REMAP(float)\nFUNC_REMAP(vec2)\nFUNC_REMAP(vec3)\nFUNC_REMAP(vec4)\n\nFUNC_REMAP_CLAMP(float)\nFUNC_REMAP_CLAMP(vec2)\nFUNC_REMAP_CLAMP(vec3)\nFUNC_REMAP_CLAMP(vec4)\n\nFUNC_REMAP01(float)\nFUNC_REMAP01(vec2)\nFUNC_REMAP01(vec3)\nFUNC_REMAP01(vec4)\n\nfloat min_component(vec2 inp)\n{\n    return min(inp.x, inp.y);\n}\n\nfloat min_component(vec3 inp)\n{\n    return min(min(inp.x, inp.y), inp.z);\n}\n\nfloat min_component(vec4 inp)\n{\n    return min(min(min(inp.x, inp.y), inp.z), inp.w);\n}\n\nfloat max_component(vec2 inp)\n{\n    return max(inp.x, inp.y);\n}\n\nfloat max_component(vec3 inp)\n{\n    return max(max(inp.x, inp.y), inp.z);\n}\n\nfloat max_component(vec4 inp)\n{\n    return max(max(max(inp.x, inp.y), inp.z), inp.w);\n}\n\n// |a| * |b| * sin(theta)\nfloat cross2d(vec2 a, vec2 b)\n{\n    return a.x * b.y - a.y * b.x;\n}\n\n// references for barycentric coordinates\n// https://www.desmos.com/calculator/8g8xjejuox\n// https://www.shadertoy.com/view/mdjBWK\n\nvec3 cartesian_to_barycentric(\n    vec2 p,\n    vec2 v0,\n    vec2 v1,\n    vec2 v2,\n    bool clamp_,\n    out bool p_is_outside\n)\n{\n    vec3 b = vec3(\n        cross2d(v1 - p, v2 - p),\n        cross2d(v2 - p, v0 - p),\n        cross2d(v0 - p, v1 - p)\n    ) / cross2d(v1 - v0, v2 - v0);\n    p_is_outside = min(min(b.x, b.y), b.z) < 0.;\n    if (clamp_)\n    {\n        b = max(b, 0.);\n        b /= (b.x + b.y + b.z);\n    }\n    return b;\n}\n\nvec3 cartesian_to_barycentric(\n    vec3 p,\n    vec3 v0,\n    vec3 v1,\n    vec3 v2,\n    bool clamp_,\n    out bool p_is_outside\n)\n{\n    vec3 b = vec3(\n        length(cross(v1 - p, v2 - p)),\n        length(cross(v2 - p, v0 - p)),\n        length(cross(v0 - p, v1 - p))\n    ) / length(cross(v1 - v0, v2 - v0));\n    p_is_outside = min(min(b.x, b.y), b.z) < 0.;\n    if (clamp_)\n    {\n        b = max(b, 0.);\n        b /= (b.x + b.y + b.z);\n    }\n    return b;\n}\n\nfloat barycentric_interpolate(vec3 b, float v0, float v1, float v2)\n{\n    return dot(b, vec3(v0, v1, v2));\n}\n\nvec2 barycentric_interpolate(vec3 b, vec2 v0, vec2 v1, vec2 v2)\n{\n    return b.x * v0 + b.y * v1 + b.z * v2;\n}\n\nvec3 barycentric_interpolate(vec3 b, vec3 v0, vec3 v1, vec3 v2)\n{\n    return b.x * v0 + b.y * v1 + b.z * v2;\n}\n\nvec4 barycentric_interpolate(vec3 b, vec4 v0, vec4 v1, vec4 v2)\n{\n    return b.x * v0 + b.y * v1 + b.z * v2;\n}\n\nfloat barycentric_interpolate(vec2 b, float v0, float v1, float v2)\n{\n    return barycentric_interpolate(\n        vec3(b.x, b.y, 1. - b.x - b.y),\n        v0, v1, v2\n    );\n}\n\nvec2 barycentric_interpolate(vec2 b, vec2 v0, vec2 v1, vec2 v2)\n{\n    return barycentric_interpolate(\n        vec3(b.x, b.y, 1. - b.x - b.y),\n        v0, v1, v2\n    );\n}\n\nvec3 barycentric_interpolate(vec2 b, vec3 v0, vec3 v1, vec3 v2)\n{\n    return barycentric_interpolate(\n        vec3(b.x, b.y, 1. - b.x - b.y),\n        v0, v1, v2\n    );\n}\n\nvec4 barycentric_interpolate(vec2 b, vec4 v0, vec4 v1, vec4 v2)\n{\n    return barycentric_interpolate(\n        vec3(b.x, b.y, 1. - b.x - b.y),\n        v0, v1, v2\n    );\n}\n\nmat2 rotate_2d(float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(\n        c, s,\n        -s, c\n    );\n}\n\nvec3 spherical_to_cartesian(vec2 s)\n{\n    float sin_theta = sin(s.x);\n    return vec3(\n        sin_theta * cos(s.y),\n        sin_theta * sin(s.y),\n        cos(s.x)\n    );\n}\n\nvec2 screen_to_uv01(vec2 coord, vec2 res)\n{\n    return coord / res;\n}\n\nvec2 screen_to_uv_horizontal(vec2 coord, vec2 res)\n{\n    return (2. * coord - res) / res.x;\n}\n\nvec2 screen_to_uv_vertical(vec2 coord, vec2 res)\n{\n    return (2. * coord - res) / res.y;\n}\n\nvec2 screen_to_uv_fit(vec2 coord, vec2 res)\n{\n    return (2. * coord - res) / min_component(res);\n}\n\nvec2 screen_to_uv_fill(vec2 coord, vec2 res)\n{\n    return (2. * coord - res) / max_component(res);\n}\n\n#define idiv_ceil(x, y) ((x + y - 1) / y)\n\n// for some reason we can't use intBitsToFloat() or floatBitsToInt() to store\n// integers below this value in a buffer.\nconst int BUFFER_MIN_INTEGER = 8388608;\n\n// * x must not be higher than 4,286,578,688 (see BUFFER_MIN_INTEGER above)\n// * for your sanity, don't use negative values\nfloat encode_int_for_buffer(int x)\n{\n    return intBitsToFloat(x + BUFFER_MIN_INTEGER);\n}\n\nint decode_int_from_buffer(float x)\n{\n    return floatBitsToInt(x) - BUFFER_MIN_INTEGER;\n}\n\n// pack two 16-bit integers in a single 32-bit integer\n// * both arguments should be in the 0-65535 range\n// * a must be less than 65279 (see the functions above)\nint pack_i16(int a, int b)\n{\n    return (a << 16) | b;\n}\n\n// unpack two 16-bit integers from a single 32-bit integer\nvoid unpack_i16(int x, out int a, out int b)\n{\n    a = (x >> 16) & 65535;\n    b = x & 65535;\n}\n\n// unpack the first 16-bit integer from a 32-bit integer\nint unpack_i16_a(int x)\n{\n    return (x >> 16) & 65535;\n}\n\n// unpack the second 16-bit integer from a 32-bit integer\nint unpack_i16_b(int x)\n{\n    return x & 65535;\n}\n\n\n\n/*_______ pseudo-random number generator ______*/\n// source: https://www.shadertoy.com/view/WdSSRt\n// (heavily modified)\n\n/* usage example:\n    void mainImage(out vec4 frag_col, in vec2 frag_coord)\n    {\n        // initialize PRNG\n        prng_init(vec3(frag_coord / iResolution.y, iTime));\n    \n        // use the function\n        float a = random();\n        vec3 b = vec3(random(), random(), random());\n        \n        ...\n    }\n*/\n\nuint prng_state[2];\n\nuint prng_rot(uint x, int k)\n{\n    return (x << k) | (x >> (32 - k));\n}\n\n// random uint from 0 to 2^32-1\nuint randomui()\n{\n    uint s0 = prng_state[0];\n    uint s1 = prng_state[1];\n    uint result = prng_rot(s0 * 2654435771u, 5) * 5u;\n    s1 ^= s0;\n    prng_state[0] = prng_rot(s0, 26) ^ s1 ^ (s1 << 9);\n    prng_state[1] = prng_rot(s1, 13);\n    return result;\n}\n\n// random int from 0 to 2^31-1\nint randomi()\n{\n    return int(randomui() % 0x7FFFFFFFu);\n}\n\n// random float from 0 to 1\nfloat random()\n{\n    return float(randomui()) / float(0xffffffffu);\n}\n\n// generate two normally distributed random numbers using the\n// Box-Muller transform\n// https://www.baeldung.com/cs/uniform-to-normal-distribution\nvec2 random_gauss()\n{\n    float u1 = random();\n    float u2 = random() * TAU;\n    float temp = sqrt(-2. * log(u1));\n    return temp * vec2(cos(u2), sin(u2));\n    \n    // unoptimized version\n    //float u1 = random();\n    //float u2 = random();\n    //return vec2(cos(TAU * u2), sin(TAU * u2)) * sqrt(-2. * log(u1));\n}\n\nvec2 random_unit_vec2()\n{\n    vec2 v = vec2(1);\n    float lensqr;\n\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec2(2. * random() - 1., 2. * random() - 1.);\n        lensqr = dot(v, v);\n        if (lensqr == 0.)\n            i--;\n        else if (lensqr <= 1.)\n            break;\n    }\n    return v / sqrt(lensqr);\n}\n\nvec3 random_unit_vec3()\n{\n    vec3 v = vec3(1);\n    float lensqr;\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec3(2. * random() - 1., 2. * random() - 1., 2. * random() - 1.);\n        lensqr = dot(v, v);\n        if (lensqr == 0.)\n            i--;\n        else if (lensqr <= 1.)\n            break;\n    }\n    return v / sqrt(lensqr);\n}\n\nvec2 random_in_circle()\n{\n    vec2 v = vec2(1);\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec2(2. * random() - 1., 2. * random() - 1.);\n        if (dot(v, v) <= 1.)\n            return v;\n    }\n    return v;\n}\n\nvec3 random_in_sphere()\n{\n    vec3 v = vec3(1);\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec3(2. * random() - 1., 2. * random() - 1., 2. * random() - 1.);\n        if (dot(v, v) <= 1.)\n            return v;\n    }\n    return v;\n}\n\nvec3 random_in_hemisphere(vec3 normal)\n{\n    vec3 v = random_in_sphere();\n    return v * sign(dot(v, normal));\n}\n\n// initialize with uvec2\nvoid prng_init(uvec2 seed)\n{\n    seed += uvec2(1317, 944573125);\n    seed *= 464973573u;\n    prng_state[0] = seed.x;\n    prng_state[1] = seed.y;\n    randomi();\n}\n\n// initialize with uint\nvoid prng_init(uint seed)\n{\n    prng_init(uvec2(seed, 1));\n}\n\n// initialize with vec3\nvoid prng_init(vec3 seed)\n{\n    seed += 3.49276101561702;\n    seed.xy *= (seed.z + 10.258);\n    prng_state[0] = floatBitsToUint(seed.x);\n    prng_state[1] = floatBitsToUint(seed.y);\n    randomui();\n}\n\n// initialize with vec2\nvoid prng_init(vec2 seed)\n{\n    prng_init(vec3(seed, 1));\n}\n\n// initialize with float\nvoid prng_init(float seed)\n{\n    prng_init(vec3(seed, 1, 1));\n}\n\n\n\n/*______________ halton sequence ______________*/\n\n// * idx starts at 1\nfloat halton(int base, int idx)\n{\n    float result = 0.;\n    float digit_weight = 1.;\n    while (idx > 0)\n    {\n        digit_weight /= float(base);\n        result += float(idx % base) * digit_weight;\n        idx /= base;\n    }\n    return result;\n}\n\n// * idx starts at 1\nvec2 halton_2d(int idx)\n{\n    return vec2(halton(2, idx), halton(3, idx));\n}\n\n// * idx starts at 1\nvec3 halton_3d(int idx)\n{\n    return vec3(halton(2, idx), halton(3, idx), halton(5, idx));\n}\n\n// * idx starts at 1\nvec4 halton_4d(int idx)\n{\n    return vec4(\n        halton(2, idx),\n        halton(3, idx),\n        halton(5, idx),\n        halton(7, idx)\n    );\n}\n\n\n\n/*__________________ keyboard _________________*/\n\n// put this code in every buffer that uses the keyboard input:\n/*\n#if SHADERTOY\n// iChannelX must be set to Keyboard in Shadertoy\n#define SHADERTOY_KEYBOARD_CH iChannelX\n#else\n#iKeyboard\n#endif\n\ndefine_keyboard_utils\n*/\n\n#if SHADERTOY\n\n#define define_keyboard_utils \\\n \\\n/* https://github.com/stevensona/shader-toy/blob/c4833b972649d78a2ee090af60b79a3907e8e091/src/extensions/keyboard/keyboard_shader_extension.ts#L11 */ \\\nconst int \\\n    Key_Backspace = 8, Key_Tab = 9, Key_Enter = 13, Key_Shift = 16, \\\n    Key_Ctrl = 17, Key_Alt = 18, Key_Pause = 19, Key_Caps = 20, \\\n    Key_Escape = 27, Key_PageUp = 33, Key_PageDown = 34, Key_End = 35, \\\n    Key_Home = 36, Key_LeftArrow = 37, Key_UpArrow = 38, Key_RightArrow = 39, \\\n    Key_DownArrow = 40, Key_Insert = 45, Key_Delete = 46, Key_0 = 48, \\\n    Key_1 = 49, Key_2 = 50, Key_3 = 51, Key_4 = 52, Key_5 = 53, Key_6 = 54, \\\n    Key_7 = 55, Key_8 = 56, Key_9 = 57, Key_A = 65, Key_B = 66, Key_C = 67, \\\n    Key_D = 68, Key_E = 69, Key_F = 70, Key_G = 71, Key_H = 72, \\\n    Key_I = 73, Key_J = 74, Key_K = 75, Key_L = 76, Key_M = 77, Key_N = 78, \\\n    Key_O = 79, Key_P = 80, Key_Q = 81, Key_R = 82, Key_S = 83, Key_T = 84, \\\n    Key_U = 85, Key_V = 86, Key_W = 87, Key_X = 88, Key_Y = 89, Key_Z = 90, \\\n    Key_LeftWindow = 91, Key_RightWindows = 92, Key_Select = 93, \\\n    Key_Numpad0 = 96, Key_Numpad1 = 97, Key_Numpad2 = 98, Key_Numpad3 = 99, \\\n    Key_Numpad4 = 100, Key_Numpad5 = 101, Key_Numpad6 = 102, \\\n    Key_Numpad7 = 103, Key_Numpad8 = 104, Key_Numpad9 = 105, \\\n    Key_NumpadMultiply = 106, Key_NumpadAdd = 107, Key_NumpadSubtract = 109, \\\n    Key_NumpadPeriod = 110, Key_NumpadDivide = 111, Key_F1 = 112, \\\n    Key_F2 = 113, Key_F3 = 114, Key_F4 = 115, Key_F5 = 116, Key_F6 = 117, \\\n    Key_F7 = 118, Key_F8 = 119, Key_F9 = 120, Key_F10 = 121, Key_F11 = 122, \\\n    Key_F12 = 123, Key_NumLock = 144, Key_ScrollLock = 145, \\\n    Key_SemiColon = 186, Key_Equal = 187, Key_Comma = 188, Key_Dash = 189, \\\n    Key_Period = 190, Key_ForwardSlash = 191, Key_GraveAccent = 192, \\\n    Key_OpenBracket = 219, Key_BackSlash = 220, Key_CloseBraket = 221, \\\n    Key_SingleQuote = 222; \\\n \\\nbool is_key_pressed(int key) \\\n{ \\\n    return texelFetch(SHADERTOY_KEYBOARD_CH, ivec2(key, 1), 0).x > .5; \\\n} \\\n \\\nbool is_key_down(int key) \\\n{ \\\n    return texelFetch(SHADERTOY_KEYBOARD_CH, ivec2(key, 0), 0).x > .5; \\\n} \\\n \\\nbool is_key_toggled(int key) \\\n{ \\\n    return texelFetch(SHADERTOY_KEYBOARD_CH, ivec2(key, 2), 0).x > .5; \\\n}\n\n#else\n\n#define define_keyboard_utils \\\n \\\nbool is_key_pressed(int key) \\\n{ \\\n    return isKeyPressed(key); \\\n} \\\n \\\nbool is_key_down(int key) \\\n{ \\\n    return isKeyDown(key); \\\n} \\\n \\\nbool is_key_toggled(int key) \\\n{ \\\n    return isKeyToggled(key); \\\n}\n\n#endif\n\n\n\n/*________________ ray tracing ________________*/\n\nstruct Ray\n{\n    vec3 orig;\n    vec3 dir;\n};\n\nstruct OrthonormalBasis\n{\n    vec3 right;\n    vec3 forward;\n    vec3 up;\n};\n\n// * all three arguments must be normalized and perpendicular to each other\nOrthonormalBasis OrthonormalBasis_new(vec3 right, vec3 forward, vec3 up)\n{\n    OrthonormalBasis onb;\n    onb.right = right;\n    onb.forward = forward;\n    onb.up = up;\n    return onb;\n}\n\n// * forward must be normalized\nOrthonormalBasis OrthonormalBasis_from_forward_and_world_up(\n    vec3 forward,\n    vec3 world_up\n)\n{\n    OrthonormalBasis onb;\n    onb.forward = forward;\n    onb.right = normalize(cross(onb.forward, world_up));\n    onb.up = cross(onb.right, onb.forward);\n    return onb;\n}\n\nvec3 OrthonormalBasis_localize(in OrthonormalBasis self, vec3 p)\n{\n    return vec3(\n        dot(p, self.right),\n        dot(p, self.forward),\n        dot(p, self.up)\n    );\n}\n\nvec3 OrthonormalBasis_delocalize(in OrthonormalBasis self, vec3 p)\n{\n    return (p.x * self.right) + (p.y * self.forward) + (p.z * self.up);\n}\n\n// basic perspective camera\nstruct Camera\n{\n    vec3 pos;\n    float sensor_width;\n    float sensor_height;\n    float focal_length;\n\n    OrthonormalBasis _onb;\n};\n\n// Camera: adjust focal length based on horizontal FOV and sensor width\nvoid Camera_set_fov_horizontal(inout Camera self, float fov)\n{\n    self.focal_length = .5 * self.sensor_width / tan(.5 * fov);\n}\n\n// Camera: calculate the horizontal FOV\nfloat Camera_get_fov_horizontal(in Camera self)\n{\n    return 2. * atan(.5 * self.sensor_width / self.focal_length);\n}\n\n// Camera: adjust focal length based on vertical FOV and sensor height\nvoid Camera_set_fov_vertical(inout Camera self, float fov)\n{\n    self.focal_length = .5 * self.sensor_height / tan(.5 * fov);\n}\n\n// Camera: calculate the vertical FOV\nfloat Camera_get_fov_vertical(in Camera self)\n{\n    return 2. * atan(.5 * self.sensor_height / self.focal_length);\n}\n\n// Camera: adjust focal length based on diagonal FOV and sensor size\nvoid Camera_set_fov_diagonal(inout Camera self, float fov)\n{\n    float sensor_size = length(vec2(self.sensor_width, self.sensor_height));\n    self.focal_length = .5 * sensor_size / tan(.5 * fov);\n}\n\n// Camera: calculate the diagonal FOV\nfloat Camera_get_fov_diagonal(in Camera self)\n{\n    float sensor_size = length(vec2(self.sensor_width, self.sensor_height));\n    return 2. * atan(.5 * sensor_size / self.focal_length);\n}\n\n// Camera: look at a point\nvoid Camera_look_at(inout Camera self, vec3 target, vec3 world_up)\n{\n    self._onb = OrthonormalBasis_from_forward_and_world_up(\n        normalize(target - self.pos),\n        world_up\n    );\n}\n\n// Camera: look along a direction\n// * dir must be normalized\nvoid Camera_look_along(inout Camera self, vec3 dir, vec3 world_up)\n{\n    self._onb = OrthonormalBasis_from_forward_and_world_up(\n        dir,\n        world_up\n    );\n}\n\n// Camera: generate a camera ray for given UV coordinates\nRay Camera_gen_ray(in Camera self, vec2 uv01)\n{\n    Ray r;\n    r.orig = self.pos + OrthonormalBasis_delocalize(self._onb, vec3(\n        (uv01.x - .5) * self.sensor_width,\n        self.focal_length,\n        (uv01.y - .5) * self.sensor_height\n    ));\n    r.dir = normalize(r.orig - self.pos);\n    return r;\n}\n\n\n\n/*___________________ SDFs ____________________*/\n\nfloat sd_sphere(vec3 p, vec3 center, float radius)\n{\n    return distance(p, center) - radius;\n}\n\nfloat sd_box(vec3 p, vec3 center, vec3 bounds)\n{\n  vec3 q = abs(p - center) - bounds;\n  return length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.);\n}\n\n\n\n/*_______________ bayer filter ________________*/\n\nconst int BAYER_RED = 0;\nconst int BAYER_GREEN = 1;\nconst int BAYER_BLUE = 2;\n\nint get_bayer(ivec2 icoord)\n{\n    bool even_col = (icoord.x % 2 == 0);\n    bool even_row = (icoord.y % 2 == 0);\n    return even_row\n        ? (even_col ? BAYER_GREEN : BAYER_RED)\n        : (even_col ? BAYER_BLUE : BAYER_GREEN);\n}\n\n\n\n/*-----------------------------------------------\n\nflim - Filmic Color Transform\n\nInput Color Space:   Linear BT.709 I-D65\nOutput Color Space:  sRGB 2.2\n\nDescription:\n  Experimental port of flim for GLSL/Shadertoy\n  matching flim v1.1.0.\n\nAuthor:\n  Bean (beans_please on Shadertoy)\n\nOriginal Repo:\n  https://github.com/bean-mhm/flim\n\nOriginal Shader:\n  https://www.shadertoy.com/view/dd2yDz\n\n-----------------------------------------------*/\n\n// parameters\n\nconst float flim_pre_exposure = 4.3;\nconst vec3 flim_pre_formation_filter = vec3(1.);\nconst float flim_pre_formation_filter_strength = 0.;\n\nconst float flim_extended_gamut_red_scale = 1.05;\nconst float flim_extended_gamut_green_scale = 1.12;\nconst float flim_extended_gamut_blue_scale = 1.045;\nconst float flim_extended_gamut_red_rot = .5;\nconst float flim_extended_gamut_green_rot = 2.;\nconst float flim_extended_gamut_blue_rot = .1;\nconst float flim_extended_gamut_red_mul = 1.;\nconst float flim_extended_gamut_green_mul = 1.;\nconst float flim_extended_gamut_blue_mul = 1.;\n\nconst float flim_sigmoid_log2_min = -10.;\nconst float flim_sigmoid_log2_max = 22.;\nconst float flim_sigmoid_toe_x = .44;\nconst float flim_sigmoid_toe_y = .28;\nconst float flim_sigmoid_shoulder_x = .591;\nconst float flim_sigmoid_shoulder_y = .779;\n\nconst float flim_negative_film_exposure = 6.;\nconst float flim_negative_film_density = 5.;\n\nconst vec3 flim_print_backlight = vec3(1);\nconst float flim_print_film_exposure = 6.;\nconst float flim_print_film_density = 27.5;\n\nconst float flim_black_point = -1.; // -1 = auto\nconst vec3 flim_post_formation_filter = vec3(1);\nconst float flim_post_formation_filter_strength = 0.;\nconst float flim_midtone_saturation = 1.02;\n\n//-----------------------------------------------\n\nfloat flim_wrap(float inp, float start, float end)\n{\n    return start + mod(inp - start, end - start);\n}\n\nfloat flim_remap(\n    float inp,\n    float inp_start,\n    float inp_end,\n    float out_start,\n    float out_end\n)\n{\n    return out_start\n        + ((out_end - out_start) / (inp_end - inp_start)) * (inp - inp_start);\n}\n\nfloat flim_remap_clamp(\n    float inp,\n    float inp_start,\n    float inp_end,\n    float out_start,\n    float out_end\n)\n{\n    float t = clamp((inp - inp_start) / (inp_end - inp_start), 0., 1.);\n    float v = out_start + t * (out_end - out_start);\n    return v;\n}\n\nfloat flim_remap01(\n    float inp,\n    float inp_start,\n    float inp_end\n)\n{\n    return clamp((inp - inp_start) / (inp_end - inp_start), 0., 1.);\n}\n\nvec3 flim_blender_rgb_to_hsv(vec3 rgb)\n{\n    float cmax, cmin, h, s, v, cdelta;\n    vec3 c;\n\n    cmax = max(rgb[0], max(rgb[1], rgb[2]));\n    cmin = min(rgb[0], min(rgb[1], rgb[2]));\n    cdelta = cmax - cmin;\n\n    v = cmax;\n    if (cmax != 0.)\n    {\n        s = cdelta / cmax;\n    }\n    else\n    {\n        s = 0.;\n        h = 0.;\n    }\n\n    if (s == 0.)\n    {\n        h = 0.;\n    }\n    else\n    {\n        c = (vec3(cmax) - rgb.xyz) / cdelta;\n\n        if (rgb.x == cmax)\n        {\n            h = c[2] - c[1];\n        }\n        else if (rgb.y == cmax)\n        {\n            h = 2. + c[0] - c[2];\n        }\n        else\n        {\n            h = 4. + c[1] - c[0];\n        }\n\n        h /= 6.;\n\n        if (h < 0.)\n        {\n            h += 1.;\n        }\n    }\n\n    return vec3(h, s, v);\n}\n\nvec3 flim_blender_hsv_to_rgb(vec3 hsv)\n{\n    float f, p, q, t, h, s, v;\n    vec3 rgb;\n\n    h = hsv[0];\n    s = hsv[1];\n    v = hsv[2];\n\n    if (s == 0.)\n    {\n        rgb = vec3(v, v, v);\n    }\n    else\n    {\n        if (h == 1.)\n        {\n            h = 0.;\n        }\n\n        h *= 6.;\n        int i = int(floor(h));\n        f = h - float(i);\n        rgb = vec3(f, f, f);\n        p = v * (1. - s);\n        q = v * (1. - (s * f));\n        t = v * (1. - (s * (1. - f)));\n\n        if (i == 0)\n        {\n            rgb = vec3(v, t, p);\n        }\n        else if (i == 1)\n        {\n            rgb = vec3(q, v, p);\n        }\n        else if (i == 2)\n        {\n            rgb = vec3(p, v, t);\n        }\n        else if (i == 3)\n        {\n            rgb = vec3(p, q, v);\n        }\n        else if (i == 4)\n        {\n            rgb = vec3(t, p, v);\n        }\n        else\n        {\n            rgb = vec3(v, p, q);\n        }\n    }\n\n    return rgb;\n}\n\nvec3 flim_blender_hue_sat(vec3 col, float hue, float sat, float value)\n{\n    vec3 hsv = flim_blender_rgb_to_hsv(col);\n\n    hsv[0] = fract(hsv[0] + hue + .5);\n    hsv[1] = clamp(hsv[1] * sat, 0., 1.);\n    hsv[2] = hsv[2] * value;\n\n    return flim_blender_hsv_to_rgb(hsv);\n}\n\nfloat flim_rgb_avg(vec3 inp)\n{\n    return (inp.x + inp.y + inp.z) / 3.;\n}\n\nfloat flim_rgb_sum(vec3 inp)\n{\n    return inp.x + inp.y + inp.z;\n}\n\nfloat flim_rgb_max(vec3 inp)\n{\n    return max(max(inp.x, inp.y), inp.z);\n}\n\nfloat flim_rgb_min(vec3 inp)\n{\n    return min(min(inp.x, inp.y), inp.z);\n}\n\nvec3 flim_rgb_uniform_offset(vec3 inp, float black_point, float white_point)\n{\n    float mono = flim_rgb_avg(inp);\n    float mono2 = flim_remap01(\n        mono, black_point / 1000.,\n        1. - (white_point / 1000.)\n    );\n    return inp * (mono2 / mono);\n}\n\nvec3 flim_rgb_sweep(float hue)\n{\n    hue = flim_wrap(hue * 360., 0., 360.);\n\n    vec3 col = vec3(1, 0, 0);\n    col = mix(col, vec3(1, 1, 0), flim_remap01(hue, 0., 60.));\n    col = mix(col, vec3(0, 1, 0), flim_remap01(hue, 60., 120.));\n    col = mix(col, vec3(0, 1, 1), flim_remap01(hue, 120., 180.));\n    col = mix(col, vec3(0, 0, 1), flim_remap01(hue, 180., 240.));\n    col = mix(col, vec3(1, 0, 1), flim_remap01(hue, 240., 300.));\n    col = mix(col, vec3(1, 0, 0), flim_remap01(hue, 300., 360.));\n    \n    return col;\n}\n\nvec3 flim_rgb_exposure_sweep_test(vec2 uv0to1)\n{\n    float hue = 1. - uv0to1.y;\n    float exposure = flim_remap(uv0to1.x, 0., 1., -5., 10.);\n    return flim_rgb_sweep(hue) * pow(2., exposure);\n}\n\n// https://www.desmos.com/calculator/khkztixyeu\nfloat flim_super_sigmoid(\n    float inp,\n    float toe_x,\n    float toe_y,\n    float shoulder_x,\n    float shoulder_y\n)\n{\n    // clip\n    inp = clamp(inp, 0., 1.);\n    toe_x = clamp(toe_x, 0., 1.);\n    toe_y = clamp(toe_y, 0., 1.);\n    shoulder_x = clamp(shoulder_x, 0., 1.);\n    shoulder_y = clamp(shoulder_y, 0., 1.);\n\n    // calculate straight line slope\n    float slope = (shoulder_y - toe_y) / (shoulder_x - toe_x);\n\n    // toe\n    if (inp < toe_x)\n    {\n        float toe_pow = slope * toe_x / toe_y;\n        return toe_y * pow(inp / toe_x, toe_pow);\n    }\n\n    // straight line\n    if (inp < shoulder_x)\n    {\n        float intercept = toe_y - (slope * toe_x);\n        return slope * inp + intercept;\n    }\n\n    // shoulder\n    float shoulder_pow =\n        -slope / (\n            ((shoulder_x - 1.) / pow(1. - shoulder_x, 2.))\n            * (1. - shoulder_y)\n        );\n    return\n        (1. - pow(1. - (inp - shoulder_x) / (1. - shoulder_x), shoulder_pow))\n        * (1. - shoulder_y)\n        + shoulder_y;\n}\n\nfloat flim_dye_mix_factor(float mono, float max_density)\n{\n    // log2 and map range\n    float offset = pow(2., flim_sigmoid_log2_min);\n    float fac = flim_remap01(\n        log2(mono + offset),\n        flim_sigmoid_log2_min,\n        flim_sigmoid_log2_max\n    );\n\n    // calculate amount of exposure from 0 to 1\n    fac = flim_super_sigmoid(\n        fac,\n        flim_sigmoid_toe_x,\n        flim_sigmoid_toe_y,\n        flim_sigmoid_shoulder_x,\n        flim_sigmoid_shoulder_y\n    );\n\n    // calculate dye density\n    fac *= max_density;\n\n    // mix factor\n    fac = pow(2., -fac);\n\n    // clip and return\n    return clamp(fac, 0., 1.);\n}\n\nvec3 flim_rgb_color_layer(\n    vec3 inp,\n    vec3 sensitivity_tone,\n    vec3 dye_tone,\n    float max_density\n)\n{\n    // normalize\n    vec3 sensitivity_tone_norm =\n        sensitivity_tone / flim_rgb_sum(sensitivity_tone);\n    vec3 dye_tone_norm = dye_tone / flim_rgb_max(dye_tone);\n\n    // dye mix factor\n    float mono = dot(inp, sensitivity_tone_norm);\n    float mix_fac = flim_dye_mix_factor(mono, max_density);\n\n    // dye mixing\n    return mix(dye_tone_norm, vec3(1), mix_fac);\n}\n\nvec3 flim_rgb_develop(vec3 inp, float exposure, float max_density)\n{\n    // exposure\n    inp *= pow(2., exposure);\n\n    // blue-sensitive layer\n    vec3 result = flim_rgb_color_layer(\n        inp,\n        vec3(0, 0, 1),\n        vec3(1, 1, 0),\n        max_density\n    );\n\n    // green-sensitive layer\n    result *= flim_rgb_color_layer(\n        inp,\n        vec3(0, 1, 0),\n        vec3(1, 0, 1),\n        max_density\n    );\n\n    // red-sensitive layer\n    result *= flim_rgb_color_layer(\n        inp,\n        vec3(1, 0, 0),\n        vec3(0, 1, 1),\n        max_density\n    );\n\n    return result;\n}\n\nvec3 flim_gamut_extension_mat_row(\n    float primary_hue,\n    float scale,\n    float rotate,\n    float mul\n)\n{\n    vec3 result = flim_blender_hsv_to_rgb(vec3(\n        flim_wrap(primary_hue + (rotate / 360.), 0., 1.),\n        1. / scale,\n        1.\n    ));\n    result /= flim_rgb_sum(result);\n    result *= mul;\n    return result;\n}\n\nmat3 flim_gamut_extension_mat(\n    float red_scale,\n    float green_scale,\n    float blue_scale,\n    float red_rot,\n    float green_rot,\n    float blue_rot,\n    float red_mul,\n    float green_mul,\n    float blue_mul\n)\n{\n    mat3 m;\n    m[0] = flim_gamut_extension_mat_row(\n        0.,\n        red_scale,\n        red_rot,\n        red_mul\n    );\n    m[1] = flim_gamut_extension_mat_row(\n        1. / 3.,\n        green_scale,\n        green_rot,\n        green_mul\n    );\n    m[2] = flim_gamut_extension_mat_row(\n        2. / 3.,\n        blue_scale,\n        blue_rot,\n        blue_mul\n    );\n    return m;\n}\n\nvec3 negative_and_print(vec3 inp, vec3 backlight_ext)\n{\n    // develop negative\n    inp = flim_rgb_develop(\n        inp,\n        flim_negative_film_exposure,\n        flim_negative_film_density\n    );\n\n    // backlight\n    inp *= backlight_ext;\n\n    // develop print\n    inp = flim_rgb_develop(\n        inp,\n        flim_print_film_exposure,\n        flim_print_film_density\n    );\n\n    return inp;\n}\n\n// -------------------------------\n\nvec3 flim_transform(vec3 inp, float exposure)\n{\n    // eliminate negative values\n    inp = max(inp, 0.);\n\n    // pre-Exposure\n    inp *= pow(2., flim_pre_exposure + exposure);\n\n    // clip very large values for float precision issues\n    inp = min(inp, 5000.);\n\n    // gamut extension matrix (Linear BT.709)\n    mat3 extend_mat = flim_gamut_extension_mat(\n        flim_extended_gamut_red_scale,\n        flim_extended_gamut_green_scale,\n        flim_extended_gamut_blue_scale,\n        flim_extended_gamut_red_rot,\n        flim_extended_gamut_green_rot,\n        flim_extended_gamut_blue_rot,\n        flim_extended_gamut_red_mul,\n        flim_extended_gamut_green_mul,\n        flim_extended_gamut_blue_mul\n    );\n    mat3 extend_mat_inv = inverse(extend_mat);\n\n    // backlight in the extended gamut\n    vec3 backlight_ext = flim_print_backlight * extend_mat;\n\n    // upper limit in the print (highlight cap)\n    const float big = 10000000.;\n    vec3 white_cap = negative_and_print(vec3(big, big, big), backlight_ext);\n\n    // pre-formation filter\n    inp = mix(\n        inp,\n        inp * flim_pre_formation_filter,\n        flim_pre_formation_filter_strength\n    );\n\n    // convert to the extended gamut\n    inp *= extend_mat;\n\n    // negative & print\n    inp = negative_and_print(inp, backlight_ext);\n\n    // convert from the extended gamut\n    inp *= extend_mat_inv;\n\n    // eliminate negative values\n    inp = max(inp, 0.);\n\n    // white cap\n    inp /= white_cap;\n\n    // black cap (-1 = auto)\n    if (flim_black_point == -1.)\n    {\n        vec3 black_cap = negative_and_print(vec3(0.), backlight_ext);\n        black_cap /= white_cap;\n        inp = flim_rgb_uniform_offset(\n            inp,\n            flim_rgb_avg(black_cap) * 1000.,\n            0.\n        );\n    }\n    else\n    {\n        inp = flim_rgb_uniform_offset(inp, flim_black_point, 0.);\n    }\n\n    // post-formation filter\n    inp = mix(\n        inp,\n        inp * flim_post_formation_filter,\n        flim_post_formation_filter_strength\n    );\n\n    // clip\n    inp = clamp(inp, 0., 1.);\n\n    // midtone saturation\n    float mono = flim_rgb_avg(inp);\n    float mix_fac =\n        (mono < .5)\n        ? flim_remap01(mono, .05, .5)\n        : flim_remap01(mono, .95, .5);\n    inp = mix(\n        inp,\n        flim_blender_hue_sat(inp, .5, flim_midtone_saturation, 1.),\n        mix_fac\n    );\n\n    // clip\n    inp = clamp(inp, 0., 1.);\n\n    // OETF\n    inp = pow(inp, vec3(1. / 2.2));\n\n    return inp;\n}\n\n/*____________________ end ____________________*/\n",
     "name": "Common",
     "description": "",
     "type": "common"
    },
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "const int MAX_STEPS = 128;\nconst float MAX_DIST = 100.;\nconst float HIT_THRESHOLD = .001;\n\n// https://www.shadertoy.com/view/3sfyRB\nvec3 sky_gradient(float height01)\n{\n    const vec3 color = vec3(.0005, .015, .05);\n\n    vec3 blue = pow(color, vec3(height01 * 2.));\n    vec3 orange = 1. - blue;\n    vec3 sky = 16. * blue * pow(orange, vec3(8.));\n\n    sky = mix(\n        sky + vec3(.015, .01, .003),\n        sky,\n        min(1., 10. * height01)\n    );\n\n    return sky;\n}\n\n// sample the environment color\nvec3 get_env(vec3 dir)\n{\n    float vertical_angle = acos(.9999 * dir.z) * INV_PI;\n    float height01 = smoothstep(.51, .07, vertical_angle);\n    return sky_gradient(height01);\n}\n\nconst int OBJ_NONE = 0;\nconst int OBJ_FLOOR = 1;\nconst int OBJ_SPHERE = 2;\n\nfloat sd_scene(vec3 p, float time, out int obj_id)\n{\n    float min_dist = 1e9;\n    obj_id = OBJ_NONE;\n    \n    float d = sd_box(p, vec3(0, 0, -.051), vec3(1.5, 1.5, .05));\n    if (d < min_dist)\n    {\n        min_dist = d;\n        obj_id = OBJ_FLOOR;\n    }\n    \n    d = sd_sphere(p, vec3(0, 0, .5), .5);\n    if (d < min_dist)\n    {\n        min_dist = d;\n        obj_id = OBJ_SPHERE;\n    }\n    \n    return min_dist;\n}\n\nvec3 render(vec2 coord, in Camera cam, float time)\n{\n    vec2 uv01 = screen_to_uv01(coord, iResolution.xy);\n    Ray r = Camera_gen_ray(cam, uv01);\n    \n    float total_dist = 0.;\n    float dist;\n    int obj_id;\n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        dist = sd_scene(r.orig, time, obj_id);\n        if (dist < HIT_THRESHOLD || total_dist > MAX_DIST)\n        {\n            break;\n        }\n        r.orig += dist * r.dir;\n        total_dist += dist;\n    }\n    \n    if (dist > HIT_THRESHOLD)\n    {\n        return get_env(r.dir);\n    }\n    \n    const float eps = .0001;\n    int _;\n    vec3 normal = normalize(vec3(\n        sd_scene(r.orig + vec3(eps, 0, 0), time, _) - dist,\n        sd_scene(r.orig + vec3(0, eps, 0), time, _) - dist,\n        sd_scene(r.orig + vec3(0, 0, eps), time, _) - dist\n    ));\n\n    vec3 base_color = vec3(0);\n    if (obj_id == OBJ_FLOOR)\n    {\n        base_color = vec3(.6);\n    }\n    else if (obj_id == OBJ_SPHERE)\n    {\n        base_color = vec3(.1, .8, .05);\n    }\n    \n    vec3 light_dir = normalize(vec3(\n        1.3 * cos(-1.5 * time),\n        1.3 * sin(-1.5 * time),\n        1.\n    ));\n    float light_mul = pow(1. - acos(dot(normal, light_dir)) * INV_PI, 3.);\n    light_mul *= 3.;\n    light_mul += .05;\n    return light_mul * base_color;\n}\n\nCamera make_camera()\n{\n    Camera cam;\n    cam.pos = vec3(0, -3, .8);\n\n    // https://www.desmos.com/calculator/unhormazaq\n    cam.sensor_height = .035;\n    cam.sensor_width = cam.sensor_height * (iResolution.x / iResolution.y);\n    cam.focal_length = .025;\n\n    vec2 cam_dir_spherical = vec2(PI_OVER_2 + radians(7.), PI_OVER_2);\n    if (iMouse.z > .1)\n    {\n        vec2 mouse_uv = screen_to_uv_fit(iMouse.xy, iResolution.xy);\n        cam_dir_spherical -= .6 * mouse_uv.yx;\n    }\n    \n    vec3 cam_dir = spherical_to_cartesian(cam_dir_spherical);\n    Camera_look_along(cam, cam_dir, vec3(0, 0, 1));\n    \n    return cam;\n}\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    // time\n    const float shutter_time = .06;\n    float time = floor(iTime / shutter_time) * shutter_time;\n    \n    // initialize PRNG\n    prng_init(vec3(frag_coord / iResolution.y, time));\n    \n    // camera\n    Camera cam = make_camera();\n\n    // render with jitter sampling\n    vec3 col = vec3(0);\n    const int n_samples = 23;\n    for (int i = 0; i < n_samples; i++)\n    {\n        vec2 offs = 2.5 * (halton_2d(i + 1) - .5);\n        col += render(frag_coord + offs, cam, time);\n    }\n    col /= float(n_samples);\n    \n    // bayer filter\n    col = vec3(col[get_bayer(ivec2(frag_coord))]);\n    \n    // add noise on top of bayer for color noise\n    col = max(vec3(0.), col + .03 * (random() - .5));\n    \n    // sensor clipping\n    col = clamp(col, 0., 1.5);\n    \n    frag_col = vec4(col, 1);\n}\n",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "nearest",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "XsXGR8",
       "channel": 0
      }
     ],
     "code": "void mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    ivec2 icoord = ivec2(frag_coord);\n    float val = texture(iChannel0, frag_coord).x;\n    float val_e = texture(iChannel0, frag_coord + vec2(1, 0)).x;\n    float val_n = texture(iChannel0, frag_coord + vec2(0, 1)).x;\n    float val_w = texture(iChannel0, frag_coord + vec2(-1, 0)).x;\n    float val_s = texture(iChannel0, frag_coord + vec2(0, -1)).x;\n    frag_col = vec4(0, 0, 1, 1);\n}\n",
     "name": "Buffer B",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "4cVGRD",
    "date": "1712491395",
    "viewed": 2,
    "name": "blue to yellow gradient demo",
    "description": "demo for a tutorial",
    "likes": 0,
    "published": "Unlisted",
    "usePreview": 0,
    "tags": [
     "tutorial",
     "gradient",
     "lerp"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "void mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = frag_coord / iResolution.xy;\n\n    // Pixel color\n    vec3 col = mix(\n        vec3(0, 0, 1),\n        vec3(1, 1, 0),\n        uv.x\n    );\n\n    // Output to screen\n    frag_col = vec4(col, 1);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "McdSzr",
    "date": "1713529681",
    "viewed": 242,
    "name": "Subpixel Anti-Aliasing",
    "description": "looks kinda weird tbh, am I doing something wrong?",
    "likes": 4,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "text",
     "antialiasing",
     "rendering",
     "subpixel",
     "spaa"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "const float render_res = 65.;\n\nvec3 render(vec2 coord)\n{\n    vec2 uv = 4. * screen_to_uv_fit(coord, vec2(render_res));\n    uv.x += .22 * iTime;\n    return vec3(cos(uv.x) * sin(uv.y) < sin(TAU * .03 * iTime));\n}\n\nvec3 discrete_render(ivec2 icoord)\n{\n    vec2 coord = vec2(icoord) + .5;\n    vec3 col = vec3(0);\n    \n    col.r += render(coord + vec2(-.333, -.333)).r;\n    col.r += render(coord + vec2(-.333, 0)).r;\n    col.r += render(coord + vec2(-.333, .333)).r;\n    \n    col.g += render(coord + vec2(0, -.333)).g;\n    col.g += render(coord + vec2(0, 0)).g;\n    col.g += render(coord + vec2(0, .333)).g;\n    \n    col.b += render(coord + vec2(.333, -.333)).b;\n    col.b += render(coord + vec2(.333, 0)).b;\n    col.b += render(coord + vec2(.333, .333)).b;\n    \n    return col * .333;\n}\n\nvec3 view_transform(vec3 col)\n{\n    // avoid any negative values before using power functions\n    col = max(col, 0.);\n\n    // OETF (Linear BT.709 I-D65 to sRGB 2.2)\n    col = pow(col, vec3(1. / 2.2));\n    col = clamp(col, 0., 1.);\n\n    return col;\n}\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    vec2 uv = screen_to_uv_fit(frag_coord, iResolution.xy);\n    vec3 col = discrete_render(ivec2(floor(uv * render_res * .5)));\n\n    // view transform\n    col = view_transform(col);\n\n    // output\n    frag_col = vec4(col, 1.);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "#define SHADERTOY 0\n\nprecision highp float;\nprecision highp int;\n\n\n\n/*_________________ math utils ________________*/\n\nconst float PI = 3.141592653589793238462643383;\nconst float TAU = 6.283185307179586476925286767;\nconst float PI_OVER_2 = 1.570796326794896619231321692;\nconst float INV_PI = .318309886183790671537767527;\nconst float INV_TAU = .159154943091895335768883763;\n\n#define FUNC_LERP(T) \\\nT lerp(T a, T b, float t) \\\n{ \\\n    return a + t * (b - a); \\\n}\n\n#define FUNC_WRAP(T) \\\nT wrap(T v, float start, float end) \\\n{ \\\n    return start + mod(v - start, end - start); \\\n}\n\n#define FUNC_REMAP(T) \\\nT remap(T v, float inp_start, float inp_end, float out_start, float out_end) \\\n{ \\\n    return out_start \\\n        + ((out_end - out_start) / (inp_end - inp_start)) * (v - inp_start); \\\n}\n\n#define FUNC_REMAP_CLAMP(T) \\\nT remap_clamp( \\\n    T v, \\\n    float inp_start, \\\n    float inp_end, \\\n    float out_start, \\\n    float out_end \\\n) \\\n{ \\\n    T t = clamp((v - inp_start) / (inp_end - inp_start), 0., 1.); \\\n    return out_start + t * (out_end - out_start); \\\n}\n\n#define FUNC_REMAP01(T) \\\nT remap01(T v, float inp_start, float inp_end) \\\n{ \\\n    return clamp((v - inp_start) / (inp_end - inp_start), 0., 1.); \\\n}\n\n#define FUNC_LENGTH_SQ(T) \\\nfloat length_sq(T v) \\\n{ \\\n    return dot(v, v); \\\n}\n\n#define FUNC_DIST_SQ(T) \\\nfloat dist_sq(T a, T b) \\\n{ \\\n    a -= b; \\\n    return dot(a, a); \\\n}\n\nFUNC_LERP(float)\nFUNC_LERP(vec2)\nFUNC_LERP(vec3)\nFUNC_LERP(vec4)\n\nFUNC_WRAP(float)\nFUNC_WRAP(vec2)\nFUNC_WRAP(vec3)\nFUNC_WRAP(vec4)\n\nFUNC_REMAP(float)\nFUNC_REMAP(vec2)\nFUNC_REMAP(vec3)\nFUNC_REMAP(vec4)\n\nFUNC_REMAP_CLAMP(float)\nFUNC_REMAP_CLAMP(vec2)\nFUNC_REMAP_CLAMP(vec3)\nFUNC_REMAP_CLAMP(vec4)\n\nFUNC_REMAP01(float)\nFUNC_REMAP01(vec2)\nFUNC_REMAP01(vec3)\nFUNC_REMAP01(vec4)\n\nFUNC_LENGTH_SQ(vec2)\nFUNC_LENGTH_SQ(vec3)\nFUNC_LENGTH_SQ(vec4)\n\nFUNC_DIST_SQ(vec2)\nFUNC_DIST_SQ(vec3)\nFUNC_DIST_SQ(vec4)\n\nint imin(int a, int b)\n{\n    if (a < b)\n    {\n        return a;\n    }\n    return b;\n}\n\nint imax(int a, int b)\n{\n    if (a > b)\n    {\n        return a;\n    }\n    return b;\n}\n\nint iclamp(int v, int start, int end)\n{\n    if (v < start)\n    {\n        v = start;\n    }\n    if (v > end)\n    {\n        v = end;\n    }\n    return v;\n}\n\nfloat min_component(vec2 v)\n{\n    return min(v.x, v.y);\n}\n\nfloat min_component(vec3 v)\n{\n    return min(min(v.x, v.y), v.z);\n}\n\nfloat min_component(vec4 v)\n{\n    return min(min(min(v.x, v.y), v.z), v.w);\n}\n\nfloat max_component(vec2 v)\n{\n    return max(v.x, v.y);\n}\n\nfloat max_component(vec3 v)\n{\n    return max(max(v.x, v.y), v.z);\n}\n\nfloat max_component(vec4 v)\n{\n    return max(max(max(v.x, v.y), v.z), v.w);\n}\n\nint min_component(ivec2 v)\n{\n    return imin(v.x, v.y);\n}\n\nint min_component(ivec3 v)\n{\n    return imin(imin(v.x, v.y), v.z);\n}\n\nint min_component(ivec4 v)\n{\n    return imin(imin(imin(v.x, v.y), v.z), v.w);\n}\n\nint max_component(ivec2 v)\n{\n    return imax(v.x, v.y);\n}\n\nint max_component(ivec3 v)\n{\n    return imax(imax(v.x, v.y), v.z);\n}\n\nint max_component(ivec4 v)\n{\n    return imax(imax(imax(v.x, v.y), v.z), v.w);\n}\n\n// |a| * |b| * sin(theta)\nfloat cross2d(vec2 a, vec2 b)\n{\n    return a.x * b.y - a.y * b.x;\n}\n\n// references for barycentric coordinates\n// https://www.desmos.com/calculator/8g8xjejuox\n// https://www.shadertoy.com/view/mdjBWK\n\nvec3 cartesian_to_barycentric(\n    vec2 p,\n    vec2 v0,\n    vec2 v1,\n    vec2 v2,\n    bool clamp_,\n    out bool p_is_outside\n)\n{\n    vec3 b = vec3(\n        cross2d(v1 - p, v2 - p),\n        cross2d(v2 - p, v0 - p),\n        cross2d(v0 - p, v1 - p)\n    ) / cross2d(v1 - v0, v2 - v0);\n    p_is_outside = min(min(b.x, b.y), b.z) < 0.;\n    if (clamp_)\n    {\n        b = max(b, 0.);\n        b /= (b.x + b.y + b.z);\n    }\n    return b;\n}\n\nvec3 cartesian_to_barycentric(\n    vec3 p,\n    vec3 v0,\n    vec3 v1,\n    vec3 v2,\n    bool clamp_,\n    out bool p_is_outside\n)\n{\n    vec3 b = vec3(\n        length(cross(v1 - p, v2 - p)),\n        length(cross(v2 - p, v0 - p)),\n        length(cross(v0 - p, v1 - p))\n    ) / length(cross(v1 - v0, v2 - v0));\n    p_is_outside = min(min(b.x, b.y), b.z) < 0.;\n    if (clamp_)\n    {\n        b = max(b, 0.);\n        b /= (b.x + b.y + b.z);\n    }\n    return b;\n}\n\nfloat barycentric_interpolate(vec3 b, float v0, float v1, float v2)\n{\n    return dot(b, vec3(v0, v1, v2));\n}\n\nvec2 barycentric_interpolate(vec3 b, vec2 v0, vec2 v1, vec2 v2)\n{\n    return b.x * v0 + b.y * v1 + b.z * v2;\n}\n\nvec3 barycentric_interpolate(vec3 b, vec3 v0, vec3 v1, vec3 v2)\n{\n    return b.x * v0 + b.y * v1 + b.z * v2;\n}\n\nvec4 barycentric_interpolate(vec3 b, vec4 v0, vec4 v1, vec4 v2)\n{\n    return b.x * v0 + b.y * v1 + b.z * v2;\n}\n\nfloat barycentric_interpolate(vec2 b, float v0, float v1, float v2)\n{\n    return barycentric_interpolate(\n        vec3(b.x, b.y, 1. - b.x - b.y),\n        v0, v1, v2\n    );\n}\n\nvec2 barycentric_interpolate(vec2 b, vec2 v0, vec2 v1, vec2 v2)\n{\n    return barycentric_interpolate(\n        vec3(b.x, b.y, 1. - b.x - b.y),\n        v0, v1, v2\n    );\n}\n\nvec3 barycentric_interpolate(vec2 b, vec3 v0, vec3 v1, vec3 v2)\n{\n    return barycentric_interpolate(\n        vec3(b.x, b.y, 1. - b.x - b.y),\n        v0, v1, v2\n    );\n}\n\nvec4 barycentric_interpolate(vec2 b, vec4 v0, vec4 v1, vec4 v2)\n{\n    return barycentric_interpolate(\n        vec3(b.x, b.y, 1. - b.x - b.y),\n        v0, v1, v2\n    );\n}\n\n// angle from 0 to TAU\nfloat get_angle(vec2 p)\n{\n    float a = atan(p.y, p.x);\n    if (a < 0.)\n    {\n        return a + TAU;\n    }\n    return a;\n}\n\nmat2 rotate_2d(float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(\n        c, s,\n        -s, c\n    );\n}\n\nvec3 spherical_to_cartesian(vec2 s)\n{\n    float sin_theta = sin(s.x);\n    return vec3(\n        sin_theta * cos(s.y),\n        sin_theta * sin(s.y),\n        cos(s.x)\n    );\n}\n\nvec2 screen_to_uv01(vec2 coord, vec2 res)\n{\n    return coord / res;\n}\n\nvec2 screen_to_uv_horizontal(vec2 coord, vec2 res)\n{\n    return (2. * coord - res) / res.x;\n}\n\nvec2 screen_to_uv_vertical(vec2 coord, vec2 res)\n{\n    return (2. * coord - res) / res.y;\n}\n\nvec2 screen_to_uv_fit(vec2 coord, vec2 res)\n{\n    return (2. * coord - res) / min_component(res);\n}\n\nvec2 screen_to_uv_fill(vec2 coord, vec2 res)\n{\n    return (2. * coord - res) / max_component(res);\n}\n\n#define idiv_ceil(a, b) ((a + b - 1) / b)\n\n// for some reason we can't use intBitsToFloat() or floatBitsToInt() to store\n// integers below this value in a buffer.\nconst int BUFFER_MIN_INTEGER = 8388608;\n\n// * x must not be higher than 4,286,578,688 (see BUFFER_MIN_INTEGER above)\n// * for your sanity, don't use negative values\nfloat encode_int_for_buffer(int v)\n{\n    return intBitsToFloat(v + BUFFER_MIN_INTEGER);\n}\n\nint decode_int_from_buffer(float v)\n{\n    return floatBitsToInt(v) - BUFFER_MIN_INTEGER;\n}\n\n// pack two 16-bit integers in a single 32-bit integer\n// * both arguments should be in the 0-65535 range\n// * a must be less than 65279 (see the functions above)\nint pack_i16(int a, int b)\n{\n    return (a << 16) | b;\n}\n\n// unpack two 16-bit integers from a single 32-bit integer\nvoid unpack_i16(int v, out int a, out int b)\n{\n    a = (v >> 16) & 65535;\n    b = v & 65535;\n}\n\n// unpack the first 16-bit integer from a 32-bit integer\nint unpack_i16_a(int v)\n{\n    return (v >> 16) & 65535;\n}\n\n// unpack the second 16-bit integer from a 32-bit integer\nint unpack_i16_b(int v)\n{\n    return v & 65535;\n}\n\n\n\n/*_______ pseudo-random number generator ______*/\n// source: https://www.shadertoy.com/view/WdSSRt\n// (heavily modified)\n\n/* usage example:\n    void mainImage(out vec4 frag_col, in vec2 frag_coord)\n    {\n        // initialize PRNG\n        prng_init(vec3(frag_coord / iResolution.y, iTime));\n    \n        // use the function\n        float a = random();\n        vec3 b = vec3(random(), random(), random());\n        \n        ...\n    }\n*/\n\nuint prng_state[2];\n\nuint prng_rot(uint x, int k)\n{\n    return (x << k) | (x >> (32 - k));\n}\n\n// random uint from 0 to 2^32-1\nuint randomui()\n{\n    uint s0 = prng_state[0];\n    uint s1 = prng_state[1];\n    uint result = prng_rot(s0 * 2654435771u, 5) * 5u;\n    s1 ^= s0;\n    prng_state[0] = prng_rot(s0, 26) ^ s1 ^ (s1 << 9);\n    prng_state[1] = prng_rot(s1, 13);\n    return result;\n}\n\n// random int from 0 to 2^31-1\nint randomi()\n{\n    return int(randomui() % 0x7FFFFFFFu);\n}\n\n// random float from 0 to 1\nfloat random()\n{\n    return float(randomui()) / float(0xffffffffu);\n}\n\n// generate two normally distributed random numbers using the\n// Box-Muller transform\n// https://www.baeldung.com/cs/uniform-to-normal-distribution\nvec2 random_gauss()\n{\n    float u1 = random();\n    float u2 = random() * TAU;\n    float temp = sqrt(-2. * log(u1));\n    return temp * vec2(cos(u2), sin(u2));\n    \n    // unoptimized version\n    //float u1 = random();\n    //float u2 = random();\n    //return vec2(cos(TAU * u2), sin(TAU * u2)) * sqrt(-2. * log(u1));\n}\n\nvec2 random_on_circle()\n{\n    vec2 v = vec2(1);\n    float lensqr;\n\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec2(2. * random() - 1., 2. * random() - 1.);\n        lensqr = dot(v, v);\n        if (lensqr == 0.)\n            i--;\n        else if (lensqr <= 1.)\n            break;\n    }\n    return v / sqrt(lensqr);\n}\n\nvec3 random_on_sphere()\n{\n    vec3 v = vec3(1);\n    float lensqr;\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec3(2. * random() - 1., 2. * random() - 1., 2. * random() - 1.);\n        lensqr = dot(v, v);\n        if (lensqr == 0.)\n            i--;\n        else if (lensqr <= 1.)\n            break;\n    }\n    return v / sqrt(lensqr);\n}\n\nvec2 random_in_circle()\n{\n    vec2 v = vec2(1);\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec2(2. * random() - 1., 2. * random() - 1.);\n        if (dot(v, v) <= 1.)\n            return v;\n    }\n    return v;\n}\n\nvec3 random_in_sphere()\n{\n    vec3 v = vec3(1);\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec3(2. * random() - 1., 2. * random() - 1., 2. * random() - 1.);\n        if (dot(v, v) <= 1.)\n            return v;\n    }\n    return v;\n}\n\nvec3 random_on_hemisphere(vec3 normal)\n{\n    vec3 v = random_on_sphere();\n    return v * sign(dot(v, normal));\n}\n\nvec3 random_in_hemisphere(vec3 normal)\n{\n    vec3 v = random_in_sphere();\n    return v * sign(dot(v, normal));\n}\n\n// initialize with uvec2\nvoid prng_init(uvec2 seed)\n{\n    seed += uvec2(1317, 944573125);\n    seed *= 464973573u;\n    prng_state[0] = seed.x;\n    prng_state[1] = seed.y;\n    randomi();\n}\n\n// initialize with uint\nvoid prng_init(uint seed)\n{\n    prng_init(uvec2(seed, 1));\n}\n\n// initialize with vec3\nvoid prng_init(vec3 seed)\n{\n    seed += 3.49276101561702;\n    seed.xy *= (seed.z + 10.258);\n    prng_state[0] = floatBitsToUint(seed.x);\n    prng_state[1] = floatBitsToUint(seed.y);\n    randomui();\n}\n\n// initialize with vec2\nvoid prng_init(vec2 seed)\n{\n    prng_init(vec3(seed, 1));\n}\n\n// initialize with float\nvoid prng_init(float seed)\n{\n    prng_init(vec3(seed, 1, 1));\n}\n\n\n\n/*______________ halton sequence ______________*/\n\n// * idx starts at 1\nfloat halton(int base, int idx)\n{\n    float result = 0.;\n    float digit_weight = 1.;\n    while (idx > 0)\n    {\n        digit_weight /= float(base);\n        result += float(idx % base) * digit_weight;\n        idx /= base;\n    }\n    return result;\n}\n\n// * idx starts at 1\nvec2 halton_2d(int idx)\n{\n    return vec2(halton(2, idx), halton(3, idx));\n}\n\n// * idx starts at 1\nvec3 halton_3d(int idx)\n{\n    return vec3(halton(2, idx), halton(3, idx), halton(5, idx));\n}\n\n// * idx starts at 1\nvec4 halton_4d(int idx)\n{\n    return vec4(\n        halton(2, idx),\n        halton(3, idx),\n        halton(5, idx),\n        halton(7, idx)\n    );\n}\n",
     "name": "Common",
     "description": "",
     "type": "common"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "M3dGz8",
    "date": "1716107523",
    "viewed": 77,
    "name": "2x Temporal Upscaling",
    "description": "read my comments, the character limit is too low ..............................................................................................................................................................................................................",
    "likes": 1,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "sampling",
     "halton",
     "frameblending",
     "jitter",
     "accumulation",
     "temporal",
     "taa",
     "upscaling",
     "jittering",
     "fsr"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "void mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    vec3 col = texelFetch(iChannel0, ivec2(frag_coord), 0).rgb;\n    col = flim_transform(col, 0.5, true);\n    frag_col = vec4(col, 1.);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "precision highp float;\nprecision highp int;\n\n\n\n/*_________________ math utils ________________*/\n\nconst float PI = 3.141592653589793238462643383;\nconst float TAU = 6.283185307179586476925286767;\nconst float PI_OVER_2 = 1.570796326794896619231321692;\nconst float INV_PI = .318309886183790671537767527;\nconst float INV_TAU = .159154943091895335768883763;\n\n#define FUNC_LERP(T) \\\nT lerp(T a, T b, float t) \\\n{ \\\n    return a + t * (b - a); \\\n}\n\n#define FUNC_WRAP(T) \\\nT wrap(T v, float start, float end) \\\n{ \\\n    return start + mod(v - start, end - start); \\\n}\n\n#define FUNC_REMAP(T) \\\nT remap(T v, float inp_start, float inp_end, float out_start, float out_end) \\\n{ \\\n    return out_start \\\n        + ((out_end - out_start) / (inp_end - inp_start)) * (v - inp_start); \\\n}\n\n#define FUNC_REMAP_CLAMP(T) \\\nT remap_clamp( \\\n    T v, \\\n    float inp_start, \\\n    float inp_end, \\\n    float out_start, \\\n    float out_end \\\n) \\\n{ \\\n    T t = clamp((v - inp_start) / (inp_end - inp_start), 0., 1.); \\\n    return out_start + t * (out_end - out_start); \\\n}\n\n#define FUNC_REMAP01(T) \\\nT remap01(T v, float inp_start, float inp_end) \\\n{ \\\n    return clamp((v - inp_start) / (inp_end - inp_start), 0., 1.); \\\n}\n\n#define FUNC_LENGTH_SQ(T) \\\nfloat length_sq(T v) \\\n{ \\\n    return dot(v, v); \\\n}\n\n#define FUNC_DIST_SQ(T) \\\nfloat dist_sq(T a, T b) \\\n{ \\\n    a -= b; \\\n    return dot(a, a); \\\n}\n\nFUNC_LERP(float)\nFUNC_LERP(vec2)\nFUNC_LERP(vec3)\nFUNC_LERP(vec4)\n\nFUNC_WRAP(float)\nFUNC_WRAP(vec2)\nFUNC_WRAP(vec3)\nFUNC_WRAP(vec4)\n\nFUNC_REMAP(float)\nFUNC_REMAP(vec2)\nFUNC_REMAP(vec3)\nFUNC_REMAP(vec4)\n\nFUNC_REMAP_CLAMP(float)\nFUNC_REMAP_CLAMP(vec2)\nFUNC_REMAP_CLAMP(vec3)\nFUNC_REMAP_CLAMP(vec4)\n\nFUNC_REMAP01(float)\nFUNC_REMAP01(vec2)\nFUNC_REMAP01(vec3)\nFUNC_REMAP01(vec4)\n\nFUNC_LENGTH_SQ(vec2)\nFUNC_LENGTH_SQ(vec3)\nFUNC_LENGTH_SQ(vec4)\n\nFUNC_DIST_SQ(vec2)\nFUNC_DIST_SQ(vec3)\nFUNC_DIST_SQ(vec4)\n\nint imin(int a, int b)\n{\n    if (a < b)\n    {\n        return a;\n    }\n    return b;\n}\n\nint imax(int a, int b)\n{\n    if (a > b)\n    {\n        return a;\n    }\n    return b;\n}\n\nint iclamp(int v, int start, int end)\n{\n    if (v < start)\n    {\n        v = start;\n    }\n    if (v > end)\n    {\n        v = end;\n    }\n    return v;\n}\n\nfloat min_component(vec2 v)\n{\n    return min(v.x, v.y);\n}\n\nfloat min_component(vec3 v)\n{\n    return min(min(v.x, v.y), v.z);\n}\n\nfloat min_component(vec4 v)\n{\n    return min(min(min(v.x, v.y), v.z), v.w);\n}\n\nfloat max_component(vec2 v)\n{\n    return max(v.x, v.y);\n}\n\nfloat max_component(vec3 v)\n{\n    return max(max(v.x, v.y), v.z);\n}\n\nfloat max_component(vec4 v)\n{\n    return max(max(max(v.x, v.y), v.z), v.w);\n}\n\nint min_component(ivec2 v)\n{\n    return imin(v.x, v.y);\n}\n\nint min_component(ivec3 v)\n{\n    return imin(imin(v.x, v.y), v.z);\n}\n\nint min_component(ivec4 v)\n{\n    return imin(imin(imin(v.x, v.y), v.z), v.w);\n}\n\nint max_component(ivec2 v)\n{\n    return imax(v.x, v.y);\n}\n\nint max_component(ivec3 v)\n{\n    return imax(imax(v.x, v.y), v.z);\n}\n\nint max_component(ivec4 v)\n{\n    return imax(imax(imax(v.x, v.y), v.z), v.w);\n}\n\n// |a| * |b| * sin(theta)\nfloat cross2d(vec2 a, vec2 b)\n{\n    return a.x * b.y - a.y * b.x;\n}\n\n// references for barycentric coordinates\n// https://www.desmos.com/calculator/8g8xjejuox\n// https://www.shadertoy.com/view/mdjBWK\n\nvec3 cartesian_to_barycentric(\n    vec2 p,\n    vec2 v0,\n    vec2 v1,\n    vec2 v2,\n    bool clamp_,\n    out bool p_is_outside\n)\n{\n    vec3 b = vec3(\n        cross2d(v1 - p, v2 - p),\n        cross2d(v2 - p, v0 - p),\n        cross2d(v0 - p, v1 - p)\n    ) / cross2d(v1 - v0, v2 - v0);\n    p_is_outside = min(min(b.x, b.y), b.z) < 0.;\n    if (clamp_)\n    {\n        b = max(b, 0.);\n        b /= (b.x + b.y + b.z);\n    }\n    return b;\n}\n\nvec3 cartesian_to_barycentric(\n    vec3 p,\n    vec3 v0,\n    vec3 v1,\n    vec3 v2,\n    bool clamp_,\n    out bool p_is_outside\n)\n{\n    vec3 b = vec3(\n        length(cross(v1 - p, v2 - p)),\n        length(cross(v2 - p, v0 - p)),\n        length(cross(v0 - p, v1 - p))\n    ) / length(cross(v1 - v0, v2 - v0));\n    p_is_outside = min(min(b.x, b.y), b.z) < 0.;\n    if (clamp_)\n    {\n        b = max(b, 0.);\n        b /= (b.x + b.y + b.z);\n    }\n    return b;\n}\n\nfloat barycentric_interpolate(vec3 b, float v0, float v1, float v2)\n{\n    return dot(b, vec3(v0, v1, v2));\n}\n\nvec2 barycentric_interpolate(vec3 b, vec2 v0, vec2 v1, vec2 v2)\n{\n    return b.x * v0 + b.y * v1 + b.z * v2;\n}\n\nvec3 barycentric_interpolate(vec3 b, vec3 v0, vec3 v1, vec3 v2)\n{\n    return b.x * v0 + b.y * v1 + b.z * v2;\n}\n\nvec4 barycentric_interpolate(vec3 b, vec4 v0, vec4 v1, vec4 v2)\n{\n    return b.x * v0 + b.y * v1 + b.z * v2;\n}\n\nfloat barycentric_interpolate(vec2 b, float v0, float v1, float v2)\n{\n    return barycentric_interpolate(\n        vec3(b.x, b.y, 1. - b.x - b.y),\n        v0, v1, v2\n    );\n}\n\nvec2 barycentric_interpolate(vec2 b, vec2 v0, vec2 v1, vec2 v2)\n{\n    return barycentric_interpolate(\n        vec3(b.x, b.y, 1. - b.x - b.y),\n        v0, v1, v2\n    );\n}\n\nvec3 barycentric_interpolate(vec2 b, vec3 v0, vec3 v1, vec3 v2)\n{\n    return barycentric_interpolate(\n        vec3(b.x, b.y, 1. - b.x - b.y),\n        v0, v1, v2\n    );\n}\n\nvec4 barycentric_interpolate(vec2 b, vec4 v0, vec4 v1, vec4 v2)\n{\n    return barycentric_interpolate(\n        vec3(b.x, b.y, 1. - b.x - b.y),\n        v0, v1, v2\n    );\n}\n\n// angle from 0 to TAU\nfloat get_angle(vec2 p)\n{\n    float a = atan(p.y, p.x);\n    if (a < 0.)\n    {\n        return a + TAU;\n    }\n    return a;\n}\n\nmat2 rotate_2d(float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(\n        c, s,\n        -s, c\n    );\n}\n\nvec3 spherical_to_cartesian(vec2 s)\n{\n    float sin_theta = sin(s.x);\n    return vec3(\n        sin_theta * cos(s.y),\n        sin_theta * sin(s.y),\n        cos(s.x)\n    );\n}\n\nvec2 screen_to_uv01(vec2 coord, vec2 res)\n{\n    return coord / res;\n}\n\nvec2 screen_to_uv_horizontal(vec2 coord, vec2 res)\n{\n    return (2. * coord - res) / res.x;\n}\n\nvec2 screen_to_uv_vertical(vec2 coord, vec2 res)\n{\n    return (2. * coord - res) / res.y;\n}\n\nvec2 screen_to_uv_fit(vec2 coord, vec2 res)\n{\n    return (2. * coord - res) / min_component(res);\n}\n\nvec2 screen_to_uv_fill(vec2 coord, vec2 res)\n{\n    return (2. * coord - res) / max_component(res);\n}\n\n#define idiv_ceil(a, b) ((a + b - 1) / b)\n\n// for some reason we can't use intBitsToFloat() or floatBitsToInt() to store\n// integers below this value in a buffer.\nconst int BUFFER_MIN_INTEGER = 8388608;\n\n// * x must not be higher than 4,286,578,688 (see BUFFER_MIN_INTEGER above)\n// * for your sanity, don't use negative values\nfloat encode_int_for_buffer(int v)\n{\n    return intBitsToFloat(v + BUFFER_MIN_INTEGER);\n}\n\nint decode_int_from_buffer(float v)\n{\n    return floatBitsToInt(v) - BUFFER_MIN_INTEGER;\n}\n\n// pack two 16-bit integers in a single 32-bit integer\n// * both arguments should be in the 0-65535 range\n// * a must be less than 65279 (see the functions above)\nint pack_i16(int a, int b)\n{\n    return (a << 16) | b;\n}\n\n// unpack two 16-bit integers from a single 32-bit integer\nvoid unpack_i16(int v, out int a, out int b)\n{\n    a = (v >> 16) & 65535;\n    b = v & 65535;\n}\n\n// unpack the first 16-bit integer from a 32-bit integer\nint unpack_i16_a(int v)\n{\n    return (v >> 16) & 65535;\n}\n\n// unpack the second 16-bit integer from a 32-bit integer\nint unpack_i16_b(int v)\n{\n    return v & 65535;\n}\n\nbool icoord_in_bounds(ivec2 icoord, ivec2 ires)\n{\n    return\n        icoord.x >= 0 &&\n        icoord.y >= 0 &&\n        icoord.x < ires.x &&\n        icoord.y < ires.y;\n}\n\nbool icoord_in_bounds(ivec3 icoord, ivec3 ires)\n{\n    return\n        icoord.x >= 0 &&\n        icoord.y >= 0 &&\n        icoord.z >= 0 &&\n        icoord.x < ires.x &&\n        icoord.y < ires.y &&\n        icoord.z < ires.z;\n}\n\nint icoord_to_idx(ivec2 icoord, ivec2 ires)\n{\n    return icoord.x + (icoord.y * ires.x);\n}\n\nint icoord_to_idx(ivec3 icoord, ivec3 ires)\n{\n    return icoord.x + (icoord.y * ires.x) + (icoord.z * ires.x * ires.y);\n}\n\nivec2 idx_to_icoord(int idx, ivec2 ires)\n{\n    return ivec2(idx % ires.x, idx / ires.x);\n}\n\nivec3 idx_to_icoord(int idx, ivec3 ires)\n{\n    return ivec3(\n        idx % ires.x,\n        (idx % (ires.x * ires.y)) / ires.x,\n        idx / (ires.x * ires.y)\n    );\n}\n\n\n\n/*______________ halton sequence ______________*/\n\n// * idx starts at 1\nfloat halton(int base, int idx)\n{\n    float result = 0.;\n    float digit_weight = 1.;\n    while (idx > 0)\n    {\n        digit_weight /= float(base);\n        result += float(idx % base) * digit_weight;\n        idx /= base;\n    }\n    return result;\n}\n\n// * idx starts at 1\nvec2 halton_2d(int idx)\n{\n    return vec2(halton(2, idx), halton(3, idx));\n}\n\n// * idx starts at 1\nvec3 halton_3d(int idx)\n{\n    return vec3(halton(2, idx), halton(3, idx), halton(5, idx));\n}\n\n// * idx starts at 1\nvec4 halton_4d(int idx)\n{\n    return vec4(\n        halton(2, idx),\n        halton(3, idx),\n        halton(5, idx),\n        halton(7, idx)\n    );\n}\n\n\n\n/*__________________ custom ___________________*/\n\nvec2 jitter_offset(int frame_idx)\n{\n    const vec2 offsets[4] = vec2[4](\n        vec2(-.25, -.25),\n        vec2(.25, -.25),\n        vec2(.25, .25),\n        vec2(-.25, .25)\n    );\n    return offsets[frame_idx % 4];\n}\n\n// because every pixel in the render buffer turns into a 2x2\n// block of pixels when upscaled, we can do a tinier jitter in\n// the render buffer for AA\nvec2 subsubjitter_offset(int frame_idx)\n{\n    return .5 * (halton_2d((frame_idx % 17) + 1) - .5);\n}\n\n\n\n/*-----------------------------------------------\n\nflim - Filmic Color Transform\n\nInput Color Space:   Linear BT.709 I-D65\nOutput Color Space:  Linear BT.709 I-D65 / sRGB 2.2 (depends on arguments)\n\nDescription:\n  Experimental port of flim for GLSL/Shadertoy\n  matching flim v1.1.0.\n\nAuthor:\n  Bean (beans_please on Shadertoy)\n\nOriginal Repo:\n  https://github.com/bean-mhm/flim\n\nOriginal Shader:\n  https://www.shadertoy.com/view/dd2yDz\n\n-----------------------------------------------*/\n\n// parameters\n\nconst float flim_pre_exposure = 4.3;\nconst vec3 flim_pre_formation_filter = vec3(1.);\nconst float flim_pre_formation_filter_strength = 0.;\n\nconst float flim_extended_gamut_red_scale = 1.05;\nconst float flim_extended_gamut_green_scale = 1.12;\nconst float flim_extended_gamut_blue_scale = 1.045;\nconst float flim_extended_gamut_red_rot = .5;\nconst float flim_extended_gamut_green_rot = 2.;\nconst float flim_extended_gamut_blue_rot = .1;\nconst float flim_extended_gamut_red_mul = 1.;\nconst float flim_extended_gamut_green_mul = 1.;\nconst float flim_extended_gamut_blue_mul = 1.;\n\nconst float flim_sigmoid_log2_min = -10.;\nconst float flim_sigmoid_log2_max = 22.;\nconst float flim_sigmoid_toe_x = .44;\nconst float flim_sigmoid_toe_y = .28;\nconst float flim_sigmoid_shoulder_x = .591;\nconst float flim_sigmoid_shoulder_y = .779;\n\nconst float flim_negative_film_exposure = 6.;\nconst float flim_negative_film_density = 5.;\n\nconst vec3 flim_print_backlight = vec3(1);\nconst float flim_print_film_exposure = 6.;\nconst float flim_print_film_density = 27.5;\n\nconst float flim_black_point = -1.; // -1 = auto\nconst vec3 flim_post_formation_filter = vec3(1);\nconst float flim_post_formation_filter_strength = 0.;\nconst float flim_midtone_saturation = 1.02;\n\n// color space conversions\n// the matrices below represent data in row-major, but GLSL matrices are in\n// column-major, so we need to multiply a vec3 by a matrix rather than\n// multiplying a matrix by a vec3.\n\nconst mat3 mat_bt2020_to_xyz = mat3(\n     0.6369580483,  0.1446169036,  0.1688809752,\n     0.2627002120,  0.6779980715,  0.0593017165,\n     0.0000000000,  0.0280726930,  1.0609850577\n);\n\nconst mat3 mat_xyz_to_bt2020 = mat3(\n     1.7166511880, -0.3556707838, -0.2533662814,\n    -0.6666843518,  1.6164812366,  0.0157685458,\n     0.0176398574, -0.0427706133,  0.9421031212\n);\n\nconst mat3 mat_bt709_to_xyz = mat3(\n     0.4123907993,  0.3575843394,  0.1804807884,\n     0.2126390059,  0.7151686788,  0.0721923154,\n     0.0193308187,  0.1191947798,  0.9505321522\n);\n\nconst mat3 mat_xyz_to_bt709 = mat3(\n     3.2409699419, -1.5373831776, -0.4986107603,\n    -0.9692436363,  1.8759675015,  0.0415550574,\n     0.0556300797, -0.2039769589,  1.0569715142\n);\n\nconst mat3 mat_dcip3_to_xyz = mat3(\n     0.4451698156,  0.2771344092,  0.1722826698,\n     0.2094916779,  0.7215952542,  0.0689130679,\n     0.0000000000,  0.0470605601,  0.9073553944\n);\n\nconst mat3 mat_xyz_to_dcip3 = mat3(\n     2.7253940305, -1.0180030062, -0.4401631952,\n    -0.7951680258,  1.6897320548,  0.0226471906,\n     0.0412418914, -0.0876390192,  1.1009293786\n);\n\nvec3 oetf_pow(vec3 col, float power)\n{\n    return pow(col, vec3(1. / power));\n}\n\nvec3 eotf_pow(vec3 col, float power)\n{\n    return pow(col, vec3(power));\n}\n\n// flim's utility functions\n\nfloat flim_wrap(float v, float start, float end)\n{\n    return start + mod(v - start, end - start);\n}\n\nfloat flim_remap(\n    float v,\n    float inp_start,\n    float inp_end,\n    float out_start,\n    float out_end\n)\n{\n    return out_start\n        + ((out_end - out_start) / (inp_end - inp_start)) * (v - inp_start);\n}\n\nfloat flim_remap_clamp(\n    float v,\n    float inp_start,\n    float inp_end,\n    float out_start,\n    float out_end\n)\n{\n    float t = clamp((v - inp_start) / (inp_end - inp_start), 0., 1.);\n    return out_start + t * (out_end - out_start);\n}\n\nfloat flim_remap01(\n    float v,\n    float inp_start,\n    float inp_end\n)\n{\n    return clamp((v - inp_start) / (inp_end - inp_start), 0., 1.);\n}\n\nvec3 flim_blender_rgb_to_hsv(vec3 rgb)\n{\n    float cmax, cmin, h, s, v, cdelta;\n    vec3 c;\n\n    cmax = max(rgb[0], max(rgb[1], rgb[2]));\n    cmin = min(rgb[0], min(rgb[1], rgb[2]));\n    cdelta = cmax - cmin;\n\n    v = cmax;\n    if (cmax != 0.)\n    {\n        s = cdelta / cmax;\n    }\n    else\n    {\n        s = 0.;\n        h = 0.;\n    }\n\n    if (s == 0.)\n    {\n        h = 0.;\n    }\n    else\n    {\n        c = (vec3(cmax) - rgb.xyz) / cdelta;\n\n        if (rgb.x == cmax)\n        {\n            h = c[2] - c[1];\n        }\n        else if (rgb.y == cmax)\n        {\n            h = 2. + c[0] - c[2];\n        }\n        else\n        {\n            h = 4. + c[1] - c[0];\n        }\n\n        h /= 6.;\n\n        if (h < 0.)\n        {\n            h += 1.;\n        }\n    }\n\n    return vec3(h, s, v);\n}\n\nvec3 flim_blender_hsv_to_rgb(vec3 hsv)\n{\n    float f, p, q, t, h, s, v;\n    vec3 rgb;\n\n    h = hsv[0];\n    s = hsv[1];\n    v = hsv[2];\n\n    if (s == 0.)\n    {\n        rgb = vec3(v, v, v);\n    }\n    else\n    {\n        if (h == 1.)\n        {\n            h = 0.;\n        }\n\n        h *= 6.;\n        int i = int(floor(h));\n        f = h - float(i);\n        rgb = vec3(f, f, f);\n        p = v * (1. - s);\n        q = v * (1. - (s * f));\n        t = v * (1. - (s * (1. - f)));\n\n        if (i == 0)\n        {\n            rgb = vec3(v, t, p);\n        }\n        else if (i == 1)\n        {\n            rgb = vec3(q, v, p);\n        }\n        else if (i == 2)\n        {\n            rgb = vec3(p, v, t);\n        }\n        else if (i == 3)\n        {\n            rgb = vec3(p, q, v);\n        }\n        else if (i == 4)\n        {\n            rgb = vec3(t, p, v);\n        }\n        else\n        {\n            rgb = vec3(v, p, q);\n        }\n    }\n\n    return rgb;\n}\n\nvec3 flim_blender_hue_sat(vec3 col, float hue, float sat, float value)\n{\n    vec3 hsv = flim_blender_rgb_to_hsv(col);\n\n    hsv[0] = fract(hsv[0] + hue + .5);\n    hsv[1] = clamp(hsv[1] * sat, 0., 1.);\n    hsv[2] = hsv[2] * value;\n\n    return flim_blender_hsv_to_rgb(hsv);\n}\n\nfloat flim_rgb_avg(vec3 col)\n{\n    return (col.x + col.y + col.z) / 3.;\n}\n\nfloat flim_rgb_sum(vec3 col)\n{\n    return col.x + col.y + col.z;\n}\n\nfloat flim_rgb_max(vec3 col)\n{\n    return max(max(col.x, col.y), col.z);\n}\n\nfloat flim_rgb_min(vec3 col)\n{\n    return min(min(col.x, col.y), col.z);\n}\n\nvec3 flim_rgb_uniform_offset(vec3 col, float black_point, float white_point)\n{\n    float mono = flim_rgb_avg(col);\n    float mono2 = flim_remap01(\n        mono, black_point / 1000.,\n        1. - (white_point / 1000.)\n    );\n    return col * (mono2 / mono);\n}\n\nvec3 flim_rgb_sweep(float hue)\n{\n    hue = flim_wrap(hue * 360., 0., 360.);\n\n    vec3 col = vec3(1, 0, 0);\n    col = mix(col, vec3(1, 1, 0), flim_remap01(hue, 0., 60.));\n    col = mix(col, vec3(0, 1, 0), flim_remap01(hue, 60., 120.));\n    col = mix(col, vec3(0, 1, 1), flim_remap01(hue, 120., 180.));\n    col = mix(col, vec3(0, 0, 1), flim_remap01(hue, 180., 240.));\n    col = mix(col, vec3(1, 0, 1), flim_remap01(hue, 240., 300.));\n    col = mix(col, vec3(1, 0, 0), flim_remap01(hue, 300., 360.));\n    \n    return col;\n}\n\nvec3 flim_rgb_exposure_sweep_test(vec2 uv0to1)\n{\n    float hue = 1. - uv0to1.y;\n    float exposure = flim_remap(uv0to1.x, 0., 1., -5., 10.);\n    return flim_rgb_sweep(hue) * pow(2., exposure);\n}\n\n// https://www.desmos.com/calculator/khkztixyeu\nfloat flim_super_sigmoid(\n    float v,\n    float toe_x,\n    float toe_y,\n    float shoulder_x,\n    float shoulder_y\n)\n{\n    // clip\n    v = clamp(v, 0., 1.);\n    toe_x = clamp(toe_x, 0., 1.);\n    toe_y = clamp(toe_y, 0., 1.);\n    shoulder_x = clamp(shoulder_x, 0., 1.);\n    shoulder_y = clamp(shoulder_y, 0., 1.);\n\n    // calculate straight line slope\n    float slope = (shoulder_y - toe_y) / (shoulder_x - toe_x);\n\n    // toe\n    if (v < toe_x)\n    {\n        float toe_pow = slope * toe_x / toe_y;\n        return toe_y * pow(v / toe_x, toe_pow);\n    }\n\n    // straight line\n    if (v < shoulder_x)\n    {\n        float intercept = toe_y - (slope * toe_x);\n        return slope * v + intercept;\n    }\n\n    // shoulder\n    float shoulder_pow =\n        -slope / (\n            ((shoulder_x - 1.) / pow(1. - shoulder_x, 2.))\n            * (1. - shoulder_y)\n        );\n    return\n        (1. - pow(1. - (v - shoulder_x) / (1. - shoulder_x), shoulder_pow))\n        * (1. - shoulder_y)\n        + shoulder_y;\n}\n\nfloat flim_dye_mix_factor(float mono, float max_density)\n{\n    // log2 and map range\n    float offset = pow(2., flim_sigmoid_log2_min);\n    float fac = flim_remap01(\n        log2(mono + offset),\n        flim_sigmoid_log2_min,\n        flim_sigmoid_log2_max\n    );\n\n    // calculate amount of exposure from 0 to 1\n    fac = flim_super_sigmoid(\n        fac,\n        flim_sigmoid_toe_x,\n        flim_sigmoid_toe_y,\n        flim_sigmoid_shoulder_x,\n        flim_sigmoid_shoulder_y\n    );\n\n    // calculate dye density\n    fac *= max_density;\n\n    // mix factor\n    fac = pow(2., -fac);\n\n    // clip and return\n    return clamp(fac, 0., 1.);\n}\n\nvec3 flim_rgb_color_layer(\n    vec3 col,\n    vec3 sensitivity_tone,\n    vec3 dye_tone,\n    float max_density\n)\n{\n    // normalize\n    vec3 sensitivity_tone_norm =\n        sensitivity_tone / flim_rgb_sum(sensitivity_tone);\n    vec3 dye_tone_norm = dye_tone / flim_rgb_max(dye_tone);\n\n    // dye mix factor\n    float mono = dot(col, sensitivity_tone_norm);\n    float mix_fac = flim_dye_mix_factor(mono, max_density);\n\n    // dye mixing\n    return mix(dye_tone_norm, vec3(1), mix_fac);\n}\n\nvec3 flim_rgb_develop(vec3 col, float exposure, float max_density)\n{\n    // exposure\n    col *= pow(2., exposure);\n\n    // blue-sensitive layer\n    vec3 result = flim_rgb_color_layer(\n        col,\n        vec3(0, 0, 1),\n        vec3(1, 1, 0),\n        max_density\n    );\n\n    // green-sensitive layer\n    result *= flim_rgb_color_layer(\n        col,\n        vec3(0, 1, 0),\n        vec3(1, 0, 1),\n        max_density\n    );\n\n    // red-sensitive layer\n    result *= flim_rgb_color_layer(\n        col,\n        vec3(1, 0, 0),\n        vec3(0, 1, 1),\n        max_density\n    );\n\n    return result;\n}\n\nvec3 flim_gamut_extension_mat_row(\n    float primary_hue,\n    float scale,\n    float rotate,\n    float mul\n)\n{\n    vec3 result = flim_blender_hsv_to_rgb(vec3(\n        flim_wrap(primary_hue + (rotate / 360.), 0., 1.),\n        1. / scale,\n        1.\n    ));\n    result /= flim_rgb_sum(result);\n    result *= mul;\n    return result;\n}\n\nmat3 flim_gamut_extension_mat(\n    float red_scale,\n    float green_scale,\n    float blue_scale,\n    float red_rot,\n    float green_rot,\n    float blue_rot,\n    float red_mul,\n    float green_mul,\n    float blue_mul\n)\n{\n    mat3 m;\n    m[0] = flim_gamut_extension_mat_row(\n        0.,\n        red_scale,\n        red_rot,\n        red_mul\n    );\n    m[1] = flim_gamut_extension_mat_row(\n        1. / 3.,\n        green_scale,\n        green_rot,\n        green_mul\n    );\n    m[2] = flim_gamut_extension_mat_row(\n        2. / 3.,\n        blue_scale,\n        blue_rot,\n        blue_mul\n    );\n    return m;\n}\n\nvec3 negative_and_print(vec3 col, vec3 backlight_ext)\n{\n    // develop negative\n    col = flim_rgb_develop(\n        col,\n        flim_negative_film_exposure,\n        flim_negative_film_density\n    );\n\n    // backlight\n    col *= backlight_ext;\n\n    // develop print\n    col = flim_rgb_develop(\n        col,\n        flim_print_film_exposure,\n        flim_print_film_density\n    );\n\n    return col;\n}\n\n// the flim transform\n\nvec3 flim_transform(vec3 col, float exposure, bool convert_to_srgb)\n{\n    // eliminate negative values\n    col = max(col, 0.);\n\n    // pre-Exposure\n    col *= pow(2., flim_pre_exposure + exposure);\n\n    // clip very large values for float precision issues\n    col = min(col, 5000.);\n\n    // gamut extension matrix (Linear BT.709)\n    mat3 extend_mat = flim_gamut_extension_mat(\n        flim_extended_gamut_red_scale,\n        flim_extended_gamut_green_scale,\n        flim_extended_gamut_blue_scale,\n        flim_extended_gamut_red_rot,\n        flim_extended_gamut_green_rot,\n        flim_extended_gamut_blue_rot,\n        flim_extended_gamut_red_mul,\n        flim_extended_gamut_green_mul,\n        flim_extended_gamut_blue_mul\n    );\n    mat3 extend_mat_inv = inverse(extend_mat);\n\n    // backlight in the extended gamut\n    vec3 backlight_ext = flim_print_backlight * extend_mat;\n\n    // upper limit in the print (highlight cap)\n    const float big = 10000000.;\n    vec3 white_cap = negative_and_print(vec3(big, big, big), backlight_ext);\n\n    // pre-formation filter\n    col = mix(\n        col,\n        col * flim_pre_formation_filter,\n        flim_pre_formation_filter_strength\n    );\n\n    // convert to the extended gamut\n    col *= extend_mat;\n\n    // negative & print\n    col = negative_and_print(col, backlight_ext);\n\n    // convert from the extended gamut\n    col *= extend_mat_inv;\n\n    // eliminate negative values\n    col = max(col, 0.);\n\n    // white cap\n    col /= white_cap;\n\n    // black cap (-1 = auto)\n    if (flim_black_point == -1.)\n    {\n        vec3 black_cap = negative_and_print(vec3(0.), backlight_ext);\n        black_cap /= white_cap;\n        col = flim_rgb_uniform_offset(\n            col,\n            flim_rgb_avg(black_cap) * 1000.,\n            0.\n        );\n    }\n    else\n    {\n        col = flim_rgb_uniform_offset(col, flim_black_point, 0.);\n    }\n\n    // post-formation filter\n    col = mix(\n        col,\n        col * flim_post_formation_filter,\n        flim_post_formation_filter_strength\n    );\n\n    // clip\n    col = clamp(col, 0., 1.);\n\n    // midtone saturation\n    float mono = flim_rgb_avg(col);\n    float mix_fac =\n        (mono < .5)\n        ? flim_remap01(mono, .05, .5)\n        : flim_remap01(mono, .95, .5);\n    col = mix(\n        col,\n        flim_blender_hue_sat(col, .5, flim_midtone_saturation, 1.),\n        mix_fac\n    );\n\n    // clip\n    col = clamp(col, 0., 1.);\n\n    // OETF\n    if (convert_to_srgb)\n    {\n        col = oetf_pow(col, 2.2);\n    }\n\n    return col;\n}\n\n/*____________________ end ____________________*/\n",
     "name": "Common",
     "description": "",
     "type": "common"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "/*_______________ render stuff ________________*/\n// source: https://www.shadertoy.com/view/DljyDG\n// (heavily modified)\n\nvec3 colormap(float x)\n{\n    vec3 c = vec3(1.0);\n    c = mix(c, 1.2 * vec3(0.3, 0.5, 0.8), remap_clamp(x, -1.0, -0.6, 0.0, 1.0));\n    c = mix(c, 1.2 * vec3(0.1, 0.02, 0.4), remap_clamp(x, -0.6, -0.25, 0.0, 1.0));\n    c = mix(c, vec3(0.0), remap_clamp(x, -0.25, 0.0, 0.0, 1.0));\n    c = mix(c, 1.2 * vec3(0.4, 0.1, 0.02), remap_clamp(x, 0.0, 0.25, 0.0, 1.0));\n    c = mix(c, 1.2 * vec3(0.8, 0.5, 0.3), remap_clamp(x, 0.25, 0.6, 0.0, 1.0));\n    c = mix(c, vec3(1.0), remap_clamp(x, 0.6, 1.0, 0.0, 1.0));\n    \n    c = pow(c, vec3(1.8));\n    c += vec3(0.03, 0.0, 0.02);\n    \n    return c;\n}\n\nvec2 fractal_screen_to_uv(vec2 coord, vec2 render_res)\n{\n    return 2. * (coord - .5 * render_res) / min(render_res.x, render_res.y);\n}\n\n// Returns a value in [0, 1] which will be fed to the color map\nfloat fractal(vec2 coord, vec2 render_res)\n{\n    vec2 uv = fractal_screen_to_uv(coord, render_res);\n    \n    // Number of iterations\n    const int max_iters = 120;\n    int iters;\n    \n    // Starting complex number\n    vec2 a = uv;\n    \n    // Constant to add in each iteration\n    vec2 c;\n    if (iMouse.z > .5)\n    {\n        vec2 m = .5 * fractal_screen_to_uv(iMouse.xy, render_res);\n        m /= sqrt(length(m));\n        c = m;\n    }\n    else\n    {\n        c = vec2(-0.756924804733, 0.210445461405);\n    }\n    \n    while (iters++ < max_iters)\n    {\n        // a = a^2\n        a = vec2(a.x * a.x - a.y * a.y, 2. * a.x * a.y);\n        \n        // Add constant\n        a += c;\n        \n        // Break if a is too large\n        if (dot(a, a) > 2.5)\n            break;\n    }\n    \n    // Return a value based on the number of iterations \n    // done before becoming too large.\n    return remap(\n        exp(-float(iters) / float(max_iters)),\n        1., exp(-1.),\n        0., 1.15\n    );\n}\n\nvec3 render(vec2 coord, vec2 render_res)\n{\n    vec3 col = colormap(fractal(coord, render_res));\n    col = mix(vec3(dot(col, vec3(1. / 3.))), col, 1.1);\n    col = max(col, 0.);\n    return col;\n}\n\n/*___________________ end _____________________*/\n\n\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    ivec2 icoord = ivec2(frag_coord);\n    vec2 render_res = ceil(.5 * iResolution.xy);\n\n    if (!icoord_in_bounds(\n        icoord,\n        ivec2(render_res)\n    ))\n    {\n        frag_col = vec4(0);\n        return;\n    }\n\n    vec2 offs = jitter_offset(iFrame) + subsubjitter_offset(iFrame);\n    \n    vec3 col = render(\n        frag_coord + offs,\n        render_res\n    );\n\n    frag_col = vec4(col, 1);\n}\n",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "XsXGR8",
       "channel": 0
      }
     ],
     "code": "void mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    ivec2 icoord = ivec2(frag_coord);\n    vec2 render_res = ceil(.5 * iResolution.xy);\n\n    vec2 buf_coord = clamp(\n        (frag_coord / iResolution.xy) * render_res,\n        vec2(.501),\n        render_res - .501\n    );\n    ivec2 buf_icoord = ivec2(buf_coord);\n    \n    vec2 sample_coord = vec2(buf_icoord) + .5 + jitter_offset(iFrame);\n    vec2 sample_coord_upscaled = (sample_coord / render_res) * iResolution.xy;\n    \n    // whether the jittered sample point falls inside the boundaries\n    // of the current pixel when upscaled\n    bool sample_inside_this_pixel =\n        sample_coord_upscaled.x >= float(icoord.x)\n        && sample_coord_upscaled.y >= float(icoord.y)\n        && sample_coord_upscaled.x < float(icoord.x + 1)\n        && sample_coord_upscaled.y < float(icoord.y + 1);\n    \n    // in real TAA, this would also make sure that the previous\n    // history (reprojected and accumulated color from the\n    // previous frame) is valid, for example, by checking the\n    // depth of the neighbors and whether the pixel has just\n    // entered the frame, and other factors. here, we always use\n    // the previous frame's value unless we're on the first frame.\n    // we also don't do any reprojection in this demo.\n    bool valid_history = iFrame > 0;\n    \n    // find the previous best candidate (the starting color)\n    vec3 col = vec3(0);\n    if (valid_history)\n    {\n        // we can use the (potentially reprojected)\n        // values from the previous frame\n        col = texelFetch(iChannel1, icoord, 0).rgb;\n    }\n    else\n    {\n        // we have nothing but the low res render buffer, so we'll\n        // just use bilinear interpolation over it\n        col = texture(iChannel0, buf_coord / iResolution.xy).rgb;\n    }\n    \n    // if the new offset falls in this pixel, blend toward the new\n    // sample\n    if (sample_inside_this_pixel)\n    {\n        // we have an exact sample to use\n        vec3 sample_col = texelFetch(iChannel0, buf_icoord, 0).rgb;\n        \n        // blend for accumulation (you could use more complex algorithms\n        // for the blend weight)\n        // NOTE: this blending would be useless if we didn't have the\n        // sub-sub-jitter.\n        col = mix(col, sample_col, .2);\n    }\n\n    frag_col = vec4(col, 1.);\n}\n",
     "name": "Buffer B",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "XXG3zW",
    "date": "1717502615",
    "viewed": 19,
    "name": "Digital Log Sim (didnt publish)",
    "description": "See the first comment for tutorial and description.\nSee the first comment for tutorial and description.\nSee the first comment for tutorial and description.\nSee the first comment for tutorial and description.\n",
    "likes": 0,
    "published": "Unlisted",
    "usePreview": 0,
    "tags": [
     "2d",
     "binary",
     "simulation",
     "digital",
     "wires",
     "physics",
     "chip",
     "logic",
     "turing",
     "sim",
     "wire",
     "gates",
     "complete",
     "dls",
     "voltage",
     "computers"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4sXGR8",
       "filepath": "/media/previz/buffer02.png",
       "type": "buffer",
       "channel": 2,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// the image tab finally takes the wire state info from the\n// simulation buffer and displays them with different colors.\n// it also shows a panel at the top left showing the available\n// draw modes with their icons, and highlighting the selected\n// one. it also shows a circle outline around the cursor when\n// the mouse button is down and draw mode is set to erase.\n// it iterates through the gate buffer and renders the logic\n// gates.\n\n#define ICHANNEL_SIM_BUF iChannel0\n#define ICHANNEL_GATE_BUF iChannel1\n#define ICHANNEL_DATA_BUF iChannel2\n\nvoid dls_fetch(\n    ivec2 icoord,\n    out int wire_state,\n    out int last_updated\n)\n{\n    if (!icoord_in_bounds(\n        icoord,\n        ivec2(iResolution.xy)\n    ))\n    {\n        wire_state = WIRE_STATE_NOT_WIRE;\n        last_updated = -1;\n        return;\n    }\n    \n    vec4 data = texelFetch(ICHANNEL_SIM_BUF, icoord, 0);\n    dls_decode(data, wire_state, last_updated);\n}\n\nvoid gate_fetch(\n    int idx,\n    out int gate_type,\n    out ivec2 icoord_bl\n)\n{\n    if (idx < 0 || idx >= N_GATES)\n    {\n        gate_type = GATE_TYPE_NONE;\n        icoord_bl = ivec2(0);\n        return;\n    }\n    \n    ivec2 icoord = idx_to_icoord(idx, GATE_BUF_SIZE);\n    vec4 data = texelFetch(ICHANNEL_GATE_BUF, icoord, 0);\n    gate_buf_decode(data, gate_type, icoord_bl);\n}\n\nvec3 render_gate(\n    vec3 col,\n    int gate_type,\n    vec2 block_uv,\n    float block_uv_1px\n)\n{\n    if (gate_type == GATE_TYPE_AND)\n    {\n        if (point_inside_and_gate(block_uv))\n        {\n            col = COL_AND_GATE;\n        }\n        \n        float sd = sd_and_gate(block_uv);\n        col = mix(\n            col,\n            vec3(.7),\n            remap01(sd, .4 * block_uv_1px, -.4 * block_uv_1px)\n        );\n    }\n    else if (gate_type == GATE_TYPE_OR)\n    {\n        if (point_inside_or_gate(block_uv))\n        {\n            col = COL_OR_GATE;\n        }\n        \n        float sd = sd_or_gate(block_uv);\n        col = mix(\n            col,\n            vec3(.7),\n            remap01(sd, .4 * block_uv_1px, -.4 * block_uv_1px)\n        );\n    }\n    else if (gate_type == GATE_TYPE_XOR)\n    {\n        if (point_inside_xor_gate(block_uv))\n        {\n            col = COL_XOR_GATE;\n        }\n        \n        float sd = sd_xor_gate(block_uv);\n        col = mix(\n            col,\n            vec3(.7),\n            remap01(sd, .4 * block_uv_1px, -.4 * block_uv_1px)\n        );\n    }\n    else if (gate_type == GATE_TYPE_NOT)\n    {\n        if (point_inside_not_gate(block_uv))\n        {\n            col = COL_NOT_GATE;\n        }\n        \n        float sd = sd_not_gate(block_uv);\n        col = mix(\n            col,\n            vec3(.7),\n            remap01(sd, .4 * block_uv_1px, -.4 * block_uv_1px)\n        );\n    }\n    else if (gate_type == GATE_TYPE_NAND)\n    {\n        if (point_inside_nand_gate(block_uv))\n        {\n            col = COL_NAND_GATE;\n        }\n        \n        float sd = sd_nand_gate(block_uv);\n        col = mix(\n            col,\n            vec3(.7),\n            remap01(sd, .4 * block_uv_1px, -.4 * block_uv_1px)\n        );\n    }\n    else if (gate_type == GATE_TYPE_NOR)\n    {\n        if (point_inside_nor_gate(block_uv))\n        {\n            col = COL_NOR_GATE;\n        }\n        \n        float sd = sd_nor_gate(block_uv);\n        col = mix(\n            col,\n            vec3(.7),\n            remap01(sd, .4 * block_uv_1px, -.4 * block_uv_1px)\n        );\n    }\n    else if (gate_type == GATE_TYPE_XNOR)\n    {\n        if (point_inside_xnor_gate(block_uv))\n        {\n            col = COL_XNOR_GATE;\n        }\n        \n        float sd = sd_xnor_gate(block_uv);\n        col = mix(\n            col,\n            vec3(.7),\n            remap01(sd, .4 * block_uv_1px, -.4 * block_uv_1px)\n        );\n    }\n    else if (gate_type == GATE_TYPE_SWC)\n    {\n        if (point_inside_swc_gate(block_uv))\n        {\n            col = COL_SWC_GATE;\n        }\n        \n        float sd = sd_swc_gate(block_uv);\n        col = mix(\n            col,\n            vec3(.7),\n            remap01(sd, .4 * block_uv_1px, -.4 * block_uv_1px)\n        );\n    }\n    return col;\n}\n\nvec3 render_gates(\n    vec3 col,\n    vec2 coord\n)\n{\n    ivec2 icoord = ivec2(coord);\n    for (int i = 0; i < N_GATES; i++)\n    {\n        int gate_type;\n        ivec2 gate_icoord_bl;\n        gate_fetch(i, gate_type, gate_icoord_bl);\n        if (gate_type == GATE_TYPE_NONE)\n        {\n            continue;\n        }\n        \n        ivec2 gate_icoord_tr = gate_icoord_bl + GATE_SIZE_PX;\n        if (any(lessThan(icoord, gate_icoord_bl))\n            || any(greaterThanEqual(icoord, gate_icoord_tr)))\n        {\n            continue;\n        }\n        \n        vec2 block_uv = clamp(\n            (coord - vec2(gate_icoord_bl) - .5) / float(GATE_SIZE_PX),\n            0.,\n            1.\n        );\n        float block_uv_1px = 1. / float(GATE_SIZE_PX);\n        \n        col = render_gate(\n            col,\n            gate_type,\n            block_uv,\n            block_uv_1px\n        );\n    }\n    return col;\n}\n\nvec3 render_eraser_size_indicator(\n    vec3 col,\n    vec2 coord,\n    int draw_mode\n)\n{\n    vec2 mouse_toolbar_uv = dls_toolbar_uv(iMouse.xy, iResolution.xy); \n    bool mouse_in_toolbar = point_inside_dls_toolbar(\n        mouse_toolbar_uv,\n        iResolution.xy\n    );\n    \n    if (iMouse.z < .5 || draw_mode != DRAW_MODE_ERASE || mouse_in_toolbar)\n    {\n        return col;\n    }\n\n    float d = distance(coord, iMouse.xy);\n    float sd = max(\n        -(d - ERASER_THICKNESS_PX),\n        d - ERASER_THICKNESS_PX - 3.\n    );\n    col = mix(\n        col,\n        vec3(.7),\n        remap01(sd, .4, -.4)\n    );\n    return col;\n}\n\nvec3 render_draw_mode_block(\n    vec3 col,\n    int block_idx,\n    vec2 block_uv,\n    float block_uv_1px\n)\n{\n    if (block_idx == DRAW_MODE_WIRE)\n    {\n        float sd = sd_oriented_box(block_uv, vec2(.38), vec2(.7), .15);\n        sd = min(\n            sd,\n            sd_oriented_box(block_uv, vec2(.3), vec2(.6), .07)\n        );\n        col = mix(\n            col,\n            vec3(.7),\n            remap01(sd, .4 * block_uv_1px, -.4 * block_uv_1px)\n        );\n    }\n    else if (block_idx == DRAW_MODE_ERASE)\n    {\n        float sd = sd_oriented_box(block_uv, vec2(.45), vec2(.68), .24);\n        sd = min(\n            sd,\n            max(\n                sd_oriented_box(block_uv, vec2(.32), vec2(.6), .24),\n                -sd_oriented_box(block_uv, vec2(.35), vec2(.6), .15)\n            )\n        );\n        \n        col = mix(\n            col,\n            vec3(.7),\n            remap01(sd, .4 * block_uv_1px, -.4 * block_uv_1px)\n        );\n    }\n    else if (block_idx == DRAW_MODE_WIRE_LOW)\n    {\n        float sd = distance(block_uv, vec2(.5)) - .24;\n        col = mix(\n            col,\n            vec3(.7),\n            remap01(sd, .4 * block_uv_1px, -.4 * block_uv_1px)\n        );\n        \n        sd = distance(block_uv, vec2(.5)) - .18;\n        col = mix(\n            col,\n            vec3(.68, .05, .02),\n            remap01(sd, .4 * block_uv_1px, -.4 * block_uv_1px)\n        );\n    }\n    else if (block_idx == DRAW_MODE_WIRE_HIGH)\n    {\n        float sd = distance(block_uv, vec2(.5)) - .24;\n        col = mix(\n            col,\n            vec3(.7),\n            remap01(sd, .4 * block_uv_1px, -.4 * block_uv_1px)\n        );\n        \n        sd = distance(block_uv, vec2(.5)) - .18;\n        col = mix(\n            col,\n            vec3(.02, .45, .01),\n            remap01(sd, .4 * block_uv_1px, -.4 * block_uv_1px)\n        );\n    }\n    else if (block_idx == DRAW_MODE_GATE_AND)\n    {\n        block_uv = remap(block_uv, .08, .92, 0., 1.);\n        col = render_gate(col, GATE_TYPE_AND, block_uv, block_uv_1px);\n    }\n    else if (block_idx == DRAW_MODE_GATE_OR)\n    {\n        block_uv = remap(block_uv, .08, .92, 0., 1.);\n        col = render_gate(col, GATE_TYPE_OR, block_uv, block_uv_1px);\n    }\n    else if (block_idx == DRAW_MODE_GATE_XOR)\n    {\n        block_uv = remap(block_uv, .08, .92, 0., 1.);\n        col = render_gate(col, GATE_TYPE_XOR, block_uv, block_uv_1px);\n    }\n    else if (block_idx == DRAW_MODE_GATE_NOT)\n    {\n        block_uv = remap(block_uv, .08, .92, 0., 1.);\n        col = render_gate(col, GATE_TYPE_NOT, block_uv, block_uv_1px);\n    }\n    else if (block_idx == DRAW_MODE_GATE_NAND)\n    {\n        block_uv = remap(block_uv, .08, .92, 0., 1.);\n        col = render_gate(col, GATE_TYPE_NAND, block_uv, block_uv_1px);\n    }\n    else if (block_idx == DRAW_MODE_GATE_NOR)\n    {\n        block_uv = remap(block_uv, .08, .92, 0., 1.);\n        col = render_gate(col, GATE_TYPE_NOR, block_uv, block_uv_1px);\n    }\n    else if (block_idx == DRAW_MODE_GATE_XNOR)\n    {\n        block_uv = remap(block_uv, .08, .92, 0., 1.);\n        col = render_gate(col, GATE_TYPE_XNOR, block_uv, block_uv_1px);\n    }\n    else if (block_idx == DRAW_MODE_GATE_SWC)\n    {\n        block_uv = remap(block_uv, .08, .92, 0., 1.);\n        col = render_gate(col, GATE_TYPE_SWC, block_uv, block_uv_1px);\n    }\n    \n    return col;\n}\n\nvec3 render_draw_mode_toolbar(\n    vec3 col,\n    vec2 coord,\n    int draw_mode\n)\n{\n    vec2 toolbar_uv = dls_toolbar_uv(coord, iResolution.xy);\n    \n    if (!point_inside_dls_toolbar(toolbar_uv, iResolution.xy))\n    {\n        return col;\n    }\n    \n    int block_idx = dls_toolbar_block_idx(toolbar_uv);\n    vec2 block_uv = dls_toolbar_block_uv(toolbar_uv, iResolution.xy);\n    \n    float block_uv_1px = (1. / iResolution.x) / TOOLBAR_BLOCK_SIZE;\n\n    // highlight selected\n    if (block_idx == draw_mode)\n    {\n        col = mix(col, vec3(.3), .4);\n    }\n    else\n    {\n        col = mix(col, vec3(.1), .4);\n    }\n\n    // draw mode icon\n    col = render_draw_mode_block(\n        col,\n        block_idx,\n        block_uv,\n        block_uv_1px\n    );\n    \n    // separator line\n    float sd = 1e9;\n    if (block_idx > 0)\n    {\n        sd = min(sd, abs(block_uv.x - 0.) - .008);\n    }\n    if (block_idx < (N_TOOLBAR_BLOCKS - 1))\n    {\n        sd = min(sd, abs(block_uv.x - 1.) - .008);\n    }\n    col = mix(\n        col,\n        vec3(.03),\n        remap01(sd, .4 * block_uv_1px, -.4 * block_uv_1px)\n    );\n    \n    return col;\n}\n\nvec3 view_transform(vec3 col)\n{\n    col = max(col, 0.);\n    col = pow(col, vec3(1. / 2.2));\n    return col;\n}\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    ivec2 icoord = ivec2(frag_coord);\n\n    // current pixel's values from the DLS buffer\n    int wire_state;\n    int last_updated;\n    dls_fetch(icoord, wire_state, last_updated);\n    \n    // values from the data buffer\n    ivec2 res;\n    int draw_mode;\n    bool prev_mouse_down;\n    ivec2 prev_imouse;\n    data_buf_decode(\n        texelFetch(ICHANNEL_DATA_BUF, ivec2(0), 0),\n        res,\n        draw_mode,\n        prev_mouse_down,\n        prev_imouse\n    );\n\n    // wires and background\n    vec3 col = vec3(0);\n    if (wire_state == WIRE_STATE_NOT_WIRE)\n    {\n        col = COL_BACKGROUND;\n    }\n    else if (wire_state == WIRE_STATE_DISCONNECTED)\n    {\n        col = COL_WIRE_DISCONNECTED;\n    }\n    else if (wire_state == WIRE_STATE_LOW)\n    {\n        col = COL_WIRE_LOW;\n    }\n    else if (wire_state == WIRE_STATE_HIGH)\n    {\n        col = COL_WIRE_HIGH;\n    }\n    \n    // gates\n    col = render_gates(col, frag_coord);\n    \n    // eraser size indicator\n    col = render_eraser_size_indicator(\n        col,\n        frag_coord,\n        draw_mode\n    );\n    \n    // draw mode toolbar\n    col = render_draw_mode_toolbar(\n        col,\n        frag_coord,\n        draw_mode\n    );\n\n    // output\n    col = view_transform(col);\n    frag_col = vec4(col, 1);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "#define SHADERTOY 1\n\nprecision highp float;\nprecision highp int;\n\n\n\n/*_________________ math utils ________________*/\n\nconst float PI = 3.141592653589793238462643383;\nconst float TAU = 6.283185307179586476925286767;\nconst float PI_OVER_2 = 1.570796326794896619231321692;\nconst float INV_PI = .318309886183790671537767527;\nconst float INV_TAU = .159154943091895335768883763;\n\n#define FUNC_LERP(T) \\\nT lerp(T a, T b, float t) \\\n{ \\\n    return a + t * (b - a); \\\n}\n\n#define FUNC_WRAP(T) \\\nT wrap(T v, float start, float end) \\\n{ \\\n    return start + mod(v - start, end - start); \\\n}\n\n#define FUNC_REMAP(T) \\\nT remap(T v, float inp_start, float inp_end, float out_start, float out_end) \\\n{ \\\n    return out_start \\\n        + ((out_end - out_start) / (inp_end - inp_start)) * (v - inp_start); \\\n}\n\n#define FUNC_REMAP_CLAMP(T) \\\nT remap_clamp( \\\n    T v, \\\n    float inp_start, \\\n    float inp_end, \\\n    float out_start, \\\n    float out_end \\\n) \\\n{ \\\n    T t = clamp((v - inp_start) / (inp_end - inp_start), 0., 1.); \\\n    return out_start + t * (out_end - out_start); \\\n}\n\n#define FUNC_REMAP01(T) \\\nT remap01(T v, float inp_start, float inp_end) \\\n{ \\\n    return clamp((v - inp_start) / (inp_end - inp_start), 0., 1.); \\\n}\n\n#define FUNC_LENGTH_SQ(T) \\\nfloat length_sq(T v) \\\n{ \\\n    return dot(v, v); \\\n}\n\n#define FUNC_DIST_SQ(T) \\\nfloat dist_sq(T a, T b) \\\n{ \\\n    a -= b; \\\n    return dot(a, a); \\\n}\n\nFUNC_LERP(float)\nFUNC_LERP(vec2)\nFUNC_LERP(vec3)\nFUNC_LERP(vec4)\n\nFUNC_WRAP(float)\nFUNC_WRAP(vec2)\nFUNC_WRAP(vec3)\nFUNC_WRAP(vec4)\n\nFUNC_REMAP(float)\nFUNC_REMAP(vec2)\nFUNC_REMAP(vec3)\nFUNC_REMAP(vec4)\n\nFUNC_REMAP_CLAMP(float)\nFUNC_REMAP_CLAMP(vec2)\nFUNC_REMAP_CLAMP(vec3)\nFUNC_REMAP_CLAMP(vec4)\n\nFUNC_REMAP01(float)\nFUNC_REMAP01(vec2)\nFUNC_REMAP01(vec3)\nFUNC_REMAP01(vec4)\n\nFUNC_LENGTH_SQ(vec2)\nFUNC_LENGTH_SQ(vec3)\nFUNC_LENGTH_SQ(vec4)\n\nFUNC_DIST_SQ(vec2)\nFUNC_DIST_SQ(vec3)\nFUNC_DIST_SQ(vec4)\n\nfloat chebyshev_dist(vec2 a, vec2 b)\n{\n    return max(abs(a.x - b.x), abs(a.y - b.y));\n}\n\nfloat chebyshev_dist(vec3 a, vec3 b)\n{\n    return max(\n        max(abs(a.x - b.x), abs(a.y - b.y)),\n        abs(a.z - b.z)\n    );\n}\n\nfloat chebyshev_dist(vec4 a, vec4 b)\n{\n    return max(\n        max(\n            max(abs(a.x - b.x), abs(a.y - b.y)),\n            abs(a.z - b.z)\n        ),\n        abs(a.w - b.w)\n    );\n}\n\n#define idiv_ceil(a, b) ((a + b - 1) / b)\n\nint iabs(int v)\n{\n    if (v < 0)\n    {\n        return -v;\n    }\n    return v;\n}\n\nint imin(int a, int b)\n{\n    if (a < b)\n    {\n        return a;\n    }\n    return b;\n}\n\nint imax(int a, int b)\n{\n    if (a > b)\n    {\n        return a;\n    }\n    return b;\n}\n\nint iclamp(int v, int start, int end)\n{\n    if (v < start)\n    {\n        v = start;\n    }\n    if (v > end)\n    {\n        v = end;\n    }\n    return v;\n}\n\nfloat min_component(vec2 v)\n{\n    return min(v.x, v.y);\n}\n\nfloat min_component(vec3 v)\n{\n    return min(min(v.x, v.y), v.z);\n}\n\nfloat min_component(vec4 v)\n{\n    return min(min(min(v.x, v.y), v.z), v.w);\n}\n\nfloat max_component(vec2 v)\n{\n    return max(v.x, v.y);\n}\n\nfloat max_component(vec3 v)\n{\n    return max(max(v.x, v.y), v.z);\n}\n\nfloat max_component(vec4 v)\n{\n    return max(max(max(v.x, v.y), v.z), v.w);\n}\n\nint min_component(ivec2 v)\n{\n    return imin(v.x, v.y);\n}\n\nint min_component(ivec3 v)\n{\n    return imin(imin(v.x, v.y), v.z);\n}\n\nint min_component(ivec4 v)\n{\n    return imin(imin(imin(v.x, v.y), v.z), v.w);\n}\n\nint max_component(ivec2 v)\n{\n    return imax(v.x, v.y);\n}\n\nint max_component(ivec3 v)\n{\n    return imax(imax(v.x, v.y), v.z);\n}\n\nint max_component(ivec4 v)\n{\n    return imax(imax(imax(v.x, v.y), v.z), v.w);\n}\n\n// credits to AHSEN (https://www.shadertoy.com/user/01000001)\n// https://www.desmos.com/calculator/5d6ph151vi interactive :D\nfloat bicubic(float a, float b, float c, float d, float t)\n{\n    float one = t - 1.;\n    float two = t - 2.;\n    float three = t - 3.;\n    return (\n        (-one * two * three * a)\n        + (t * one * two * d)\n        + (3. * t * two * three * b)\n        - (3. * t * one * three * c)\n    ) / 6.;\n}\n\n// |a| * |b| * sin(theta)\nfloat cross2d(vec2 a, vec2 b)\n{\n    return a.x * b.y - a.y * b.x;\n}\n\n// references for barycentric coordinates\n// https://www.desmos.com/calculator/8g8xjejuox\n// https://www.shadertoy.com/view/mdjBWK\n\nvec3 cartesian_to_barycentric(\n    vec2 p,\n    vec2 v0,\n    vec2 v1,\n    vec2 v2,\n    bool clamp_,\n    out bool p_is_outside\n)\n{\n    vec3 b = vec3(\n        cross2d(v1 - p, v2 - p),\n        cross2d(v2 - p, v0 - p),\n        cross2d(v0 - p, v1 - p)\n    ) / cross2d(v1 - v0, v2 - v0);\n    p_is_outside = min(min(b.x, b.y), b.z) < 0.;\n    if (clamp_)\n    {\n        b = max(b, 0.);\n        b /= (b.x + b.y + b.z);\n    }\n    return b;\n}\n\nvec3 cartesian_to_barycentric(\n    vec3 p,\n    vec3 v0,\n    vec3 v1,\n    vec3 v2,\n    bool clamp_,\n    out bool p_is_outside\n)\n{\n    vec3 b = vec3(\n        length(cross(v1 - p, v2 - p)),\n        length(cross(v2 - p, v0 - p)),\n        length(cross(v0 - p, v1 - p))\n    ) / length(cross(v1 - v0, v2 - v0));\n    p_is_outside = min(min(b.x, b.y), b.z) < 0.;\n    if (clamp_)\n    {\n        b = max(b, 0.);\n        b /= (b.x + b.y + b.z);\n    }\n    return b;\n}\n\nfloat barycentric_interpolate(vec3 b, float v0, float v1, float v2)\n{\n    return dot(b, vec3(v0, v1, v2));\n}\n\nvec2 barycentric_interpolate(vec3 b, vec2 v0, vec2 v1, vec2 v2)\n{\n    return b.x * v0 + b.y * v1 + b.z * v2;\n}\n\nvec3 barycentric_interpolate(vec3 b, vec3 v0, vec3 v1, vec3 v2)\n{\n    return b.x * v0 + b.y * v1 + b.z * v2;\n}\n\nvec4 barycentric_interpolate(vec3 b, vec4 v0, vec4 v1, vec4 v2)\n{\n    return b.x * v0 + b.y * v1 + b.z * v2;\n}\n\nfloat barycentric_interpolate(vec2 b, float v0, float v1, float v2)\n{\n    return barycentric_interpolate(\n        vec3(b.x, b.y, 1. - b.x - b.y),\n        v0, v1, v2\n    );\n}\n\nvec2 barycentric_interpolate(vec2 b, vec2 v0, vec2 v1, vec2 v2)\n{\n    return barycentric_interpolate(\n        vec3(b.x, b.y, 1. - b.x - b.y),\n        v0, v1, v2\n    );\n}\n\nvec3 barycentric_interpolate(vec2 b, vec3 v0, vec3 v1, vec3 v2)\n{\n    return barycentric_interpolate(\n        vec3(b.x, b.y, 1. - b.x - b.y),\n        v0, v1, v2\n    );\n}\n\nvec4 barycentric_interpolate(vec2 b, vec4 v0, vec4 v1, vec4 v2)\n{\n    return barycentric_interpolate(\n        vec3(b.x, b.y, 1. - b.x - b.y),\n        v0, v1, v2\n    );\n}\n\n// angle from 0 to TAU\nfloat get_angle(vec2 p)\n{\n    float a = atan(p.y, p.x);\n    if (a < 0.)\n    {\n        return a + TAU;\n    }\n    return a;\n}\n\nmat2 rotate_2d(float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(\n        c, s,\n        -s, c\n    );\n}\n\nvec3 spherical_to_cartesian(vec2 s)\n{\n    float sin_theta = sin(s.x);\n    return vec3(\n        sin_theta * cos(s.y),\n        sin_theta * sin(s.y),\n        cos(s.x)\n    );\n}\n\nvec2 screen_to_uv01(vec2 coord, vec2 res)\n{\n    return coord / res;\n}\n\nvec2 screen_to_uv_horizontal(vec2 coord, vec2 res)\n{\n    return (2. * coord - res) / res.x;\n}\n\nvec2 screen_to_uv_vertical(vec2 coord, vec2 res)\n{\n    return (2. * coord - res) / res.y;\n}\n\nvec2 screen_to_uv_fit(vec2 coord, vec2 res)\n{\n    return (2. * coord - res) / min_component(res);\n}\n\nvec2 screen_to_uv_fill(vec2 coord, vec2 res)\n{\n    return (2. * coord - res) / max_component(res);\n}\n\n// for some reason we can't use intBitsToFloat() or floatBitsToInt() to store\n// integers below this value in a buffer.\nconst int BUFFER_MIN_INTEGER = 8388608;\n\n// * x must not be higher than 4,286,578,688 (see BUFFER_MIN_INTEGER above)\n// * for your sanity, don't use negative values\nfloat encode_int_for_buffer(int v)\n{\n    return intBitsToFloat(v + BUFFER_MIN_INTEGER);\n}\n\nint decode_int_from_buffer(float v)\n{\n    return floatBitsToInt(v) - BUFFER_MIN_INTEGER;\n}\n\n// pack two 16-bit integers in a single 32-bit integer\n// * both arguments should be in the 0-65535 range\n// * a must be less than 65279 (see the functions above)\nint pack_i16(int a, int b)\n{\n    return (a << 16) | b;\n}\n\n// unpack two 16-bit integers from a single 32-bit integer\nvoid unpack_i16(int v, out int a, out int b)\n{\n    a = (v >> 16) & 65535;\n    b = v & 65535;\n}\n\n// unpack the first 16-bit integer from a 32-bit integer\nint unpack_i16_a(int v)\n{\n    return (v >> 16) & 65535;\n}\n\n// unpack the second 16-bit integer from a 32-bit integer\nint unpack_i16_b(int v)\n{\n    return v & 65535;\n}\n\nbool icoord_in_bounds(ivec2 icoord, ivec2 ires)\n{\n    return\n        icoord.x >= 0 &&\n        icoord.y >= 0 &&\n        icoord.x < ires.x &&\n        icoord.y < ires.y;\n}\n\nbool icoord_in_bounds(ivec3 icoord, ivec3 ires)\n{\n    return\n        icoord.x >= 0 &&\n        icoord.y >= 0 &&\n        icoord.z >= 0 &&\n        icoord.x < ires.x &&\n        icoord.y < ires.y &&\n        icoord.z < ires.z;\n}\n\nint icoord_to_idx(ivec2 icoord, ivec2 ires)\n{\n    return icoord.x + (icoord.y * ires.x);\n}\n\nint icoord_to_idx(ivec3 icoord, ivec3 ires)\n{\n    return icoord.x + (icoord.y * ires.x) + (icoord.z * ires.x * ires.y);\n}\n\nivec2 idx_to_icoord(int idx, ivec2 ires)\n{\n    return ivec2(idx % ires.x, idx / ires.x);\n}\n\nivec3 idx_to_icoord(int idx, ivec3 ires)\n{\n    return ivec3(\n        idx % ires.x,\n        (idx % (ires.x * ires.y)) / ires.x,\n        idx / (ires.x * ires.y)\n    );\n}\n\n/*__________________ keyboard _________________*/\n\n// put this code in every buffer that uses the keyboard input:\n/*\n#if SHADERTOY\n// iChannelX must be set to Keyboard in Shadertoy\n#define SHADERTOY_KEYBOARD_CH iChannelX\n#else\n#iKeyboard\n#endif\n\ndefine_keyboard_utils\n*/\n\n#if SHADERTOY\n\n#define define_keyboard_utils \\\n \\\n/* https://github.com/stevensona/shader-toy/blob/c4833b972649d78a2ee090af60b79a3907e8e091/src/extensions/keyboard/keyboard_shader_extension.ts#L11 */ \\\nconst int \\\n    Key_Backspace = 8, Key_Tab = 9, Key_Enter = 13, Key_Shift = 16, \\\n    Key_Ctrl = 17, Key_Alt = 18, Key_Pause = 19, Key_Caps = 20, \\\n    Key_Escape = 27, Key_PageUp = 33, Key_PageDown = 34, Key_End = 35, \\\n    Key_Home = 36, Key_LeftArrow = 37, Key_UpArrow = 38, Key_RightArrow = 39, \\\n    Key_DownArrow = 40, Key_Insert = 45, Key_Delete = 46, Key_0 = 48, \\\n    Key_1 = 49, Key_2 = 50, Key_3 = 51, Key_4 = 52, Key_5 = 53, Key_6 = 54, \\\n    Key_7 = 55, Key_8 = 56, Key_9 = 57, Key_A = 65, Key_B = 66, Key_C = 67, \\\n    Key_D = 68, Key_E = 69, Key_F = 70, Key_G = 71, Key_H = 72, \\\n    Key_I = 73, Key_J = 74, Key_K = 75, Key_L = 76, Key_M = 77, Key_N = 78, \\\n    Key_O = 79, Key_P = 80, Key_Q = 81, Key_R = 82, Key_S = 83, Key_T = 84, \\\n    Key_U = 85, Key_V = 86, Key_W = 87, Key_X = 88, Key_Y = 89, Key_Z = 90, \\\n    Key_LeftWindow = 91, Key_RightWindows = 92, Key_Select = 93, \\\n    Key_Numpad0 = 96, Key_Numpad1 = 97, Key_Numpad2 = 98, Key_Numpad3 = 99, \\\n    Key_Numpad4 = 100, Key_Numpad5 = 101, Key_Numpad6 = 102, \\\n    Key_Numpad7 = 103, Key_Numpad8 = 104, Key_Numpad9 = 105, \\\n    Key_NumpadMultiply = 106, Key_NumpadAdd = 107, Key_NumpadSubtract = 109, \\\n    Key_NumpadPeriod = 110, Key_NumpadDivide = 111, Key_F1 = 112, \\\n    Key_F2 = 113, Key_F3 = 114, Key_F4 = 115, Key_F5 = 116, Key_F6 = 117, \\\n    Key_F7 = 118, Key_F8 = 119, Key_F9 = 120, Key_F10 = 121, Key_F11 = 122, \\\n    Key_F12 = 123, Key_NumLock = 144, Key_ScrollLock = 145, \\\n    Key_SemiColon = 186, Key_Equal = 187, Key_Comma = 188, Key_Dash = 189, \\\n    Key_Period = 190, Key_ForwardSlash = 191, Key_GraveAccent = 192, \\\n    Key_OpenBracket = 219, Key_BackSlash = 220, Key_CloseBraket = 221, \\\n    Key_SingleQuote = 222; \\\nconst int Key_Space = 32; \\\n \\\nbool is_key_pressed(int key) \\\n{ \\\n    return texelFetch(SHADERTOY_KEYBOARD_CH, ivec2(key, 1), 0).x > .5; \\\n} \\\n \\\nbool is_key_down(int key) \\\n{ \\\n    return texelFetch(SHADERTOY_KEYBOARD_CH, ivec2(key, 0), 0).x > .5; \\\n} \\\n \\\nbool is_key_toggled(int key) \\\n{ \\\n    return texelFetch(SHADERTOY_KEYBOARD_CH, ivec2(key, 2), 0).x > .5; \\\n}\n\n#else\n\n#define define_keyboard_utils \\\n \\\nconst int Key_Space = 32; \\\n \\\nbool is_key_pressed(int key) \\\n{ \\\n    return isKeyPressed(key); \\\n} \\\n \\\nbool is_key_down(int key) \\\n{ \\\n    return isKeyDown(key); \\\n} \\\n \\\nbool is_key_toggled(int key) \\\n{ \\\n    return isKeyToggled(key); \\\n}\n\n#endif\n\n\n\n/*___________________ SDF _____________________*/\n\n// most but not all of these are from the following article\n// https://iquilezles.org/articles/distfunctions2d/\n\nfloat sd_segment(vec2 p, vec2 a, vec2 b)\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sd_segment_2sided(vec2 p, vec2 a, vec2 b)\n{\n    vec2 tangent_unnorm = b - a;\n    float tangent_len = length(tangent_unnorm);\n    vec2 tangent = tangent_unnorm / tangent_len;\n    \n    float u = dot(p - a, tangent);\n    if (u < 0. || u > tangent_len)\n    {\n        return min(distance(p, a), distance(p, b));\n    }\n    else\n    {\n        vec2 normal = vec2(-tangent.y, tangent.x);\n        return dot(p - a, normal);\n    }\n}\n\nfloat sd_ring(vec2 p, vec2 n, float r, float thickness)\n{\n    p.x = abs(p.x);\n    \n    p = mat2(n.x,n.y,-n.y,n.x)*p;\n\n    return max( abs(length(p)-r)-thickness*0.5,\n                length(vec2(p.x,max(0.0,abs(r-p.y)-thickness*0.5)))*sign(p.x) );\n}\n\nfloat sd_oriented_box(vec2 p, vec2 a, vec2 b, float thickness)\n{\n    float l = length(b-a);\n    vec2  d = (b-a)/l;\n    vec2  q = (p-(a+b)*0.5);\n          q = mat2(d.x,-d.y,d.y,d.x)*q;\n          q = abs(q)-vec2(l,thickness)*0.5;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0);    \n}\n\nfloat sd_parabola(vec2 pos, float width, float height)\n{\n    pos.x = abs(pos.x);\n\n    float ik = width*width/height;\n    float p = ik*(height-pos.y-0.5*ik)/3.0;\n    float q = pos.x*ik*ik*0.25;\n    float h = q*q - p*p*p;\n    \n    float x;\n    if( h>0.0 ) // 1 root\n    {\n        float r = sqrt(h);\n        x = pow(q+r,1.0/3.0) + pow(abs(q-r),1.0/3.0)*sign(p);\n    }\n    else        // 3 roots\n    {\n        float r = sqrt(p);\n        x = 2.0*r*cos(acos(q/(p*r))/3.0); // see https://www.shadertoy.com/view/WltSD7 for an implementation of cos(acos(x)/3) without trigonometrics\n    }\n    \n    x = min(x,width);\n    \n    return length(pos-vec2(x,height-x*x/ik)) * \n           sign(ik*(pos.y-height)+pos.x*pos.x);\n}\n\nfloat sd_bezier(vec2 pos, vec2 A, vec2 B, vec2 C)\n{    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n    float kk = 1.0/dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);      \n    float res = 0.0;\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx-3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n    if( h >= 0.0) \n    { \n        h = sqrt(h);\n        vec2 x = (vec2(h,-h)-q)/2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = clamp( uv.x+uv.y-kx, 0.0, 1.0 );\n        res = length_sq(d + (c + b*t)*t);\n    }\n    else\n    {\n        float z = sqrt(-p);\n        float v = acos( q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3  t = clamp(vec3(m+m,-n-m,n-m)*z-kx,0.0,1.0);\n        res = min( length_sq(d+(c+b*t.x)*t.x),\n                   length_sq(d+(c+b*t.y)*t.y) );\n        // the third root cannot be the closest\n        // res = min(res,dot2(d+(c+b*t.z)*t.z));\n    }\n    return sqrt(res);\n}\n\n#define DEFINE_SD_POLYGON(n_sides) \\\nfloat sd_polygon(vec2 p, vec2[n_sides] v) \\\n{ \\\n    float d = dot(p-v[0],p-v[0]); \\\n    float s = 1.0; \\\n    for( int i=0, j=n_sides-1; i<n_sides; j=i, i++ ) \\\n    { \\\n        vec2 e = v[j] - v[i]; \\\n        vec2 w =    p - v[i]; \\\n        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 ); \\\n        d = min( d, dot(b,b) ); \\\n        bvec3 c = bvec3(p.y>=v[i].y,p.y<v[j].y,e.x*w.y>e.y*w.x); \\\n        if( all(c) || all(not(c)) ) s*=-1.0;   \\\n    } \\\n    return s*sqrt(d); \\\n}\n\n\n\n/*___________ bezier sdf approx. ______________*/\n\nvec2 bezier(vec2 a, vec2 b, vec2 c, float t)\n{\n    return mix(\n        mix(a, b, t),\n        mix(b, c, t),\n        t\n    );\n}\n\nvec2 bezier(vec2 a, vec2 b, vec2 c, vec2 d, float t)\n{\n    return mix(\n        mix(\n            mix(a, b, t),\n            mix(b, c, t),\n            t\n        ),\n        mix(\n            mix(b, c, t),\n            mix(c, d, t),\n            t\n        ),\n        t\n    );\n}\n\nconst int BEZIER_RES = 6;\n\nfloat sd_bezier_approx(vec2 p, vec2 a, vec2 b, vec2 c)\n{\n    float sd = 1e9;\n    for (int i = 0; i < BEZIER_RES; i++)\n    {\n        sd = min(sd, sd_segment(\n            p,\n            bezier(a, b, c, float(i) / float(BEZIER_RES)),\n            bezier(a, b, c, float(i + 1) / float(BEZIER_RES))\n        ));\n    }\n    return sd;\n}\n\nfloat sd_bezier_approx(vec2 p, vec2 a, vec2 b, vec2 c, vec2 d)\n{\n    float sd = 1e9;\n    for (int i = 0; i < BEZIER_RES; i++)\n    {\n        sd = min(sd, sd_segment(\n            p,\n            bezier(a, b, c, d, float(i) / float(BEZIER_RES)),\n            bezier(a, b, c, d, float(i + 1) / float(BEZIER_RES))\n        ));\n    }\n    return sd;\n}\n\n\n\n/*______________ DLS constants ________________*/\n\nconst int WIRE_STATE_NOT_WIRE = 0;\nconst int WIRE_STATE_DISCONNECTED = 1;\nconst int WIRE_STATE_LOW = 2;\nconst int WIRE_STATE_HIGH = 3;\n\nconst int DRAW_MODE_WIRE = 0;\nconst int DRAW_MODE_ERASE = 1;\nconst int DRAW_MODE_WIRE_LOW = 2;\nconst int DRAW_MODE_WIRE_HIGH = 3;\nconst int DRAW_MODE_GATE_AND = 4;\nconst int DRAW_MODE_GATE_OR = 5;\nconst int DRAW_MODE_GATE_XOR = 6;\nconst int DRAW_MODE_GATE_NOT = 7;\nconst int DRAW_MODE_GATE_NAND = 8;\nconst int DRAW_MODE_GATE_NOR = 9;\nconst int DRAW_MODE_GATE_XNOR = 10;\nconst int DRAW_MODE_GATE_SWC = 11;\nconst int N_DRAW_MODES = 12;\n\nconst float TOOLBAR_BLOCK_SIZE = .05;\nconst int N_TOOLBAR_BLOCKS = N_DRAW_MODES;\n\nconst float BRUSH_THICKNESS_PX = 6.;\nconst float ERASER_THICKNESS_PX = 26.;\n\nconst vec3 COL_BACKGROUND = vec3(.024, .036, .062);\nconst vec3 COL_WIRE_DISCONNECTED = vec3(.013, .013, .024);\nconst vec3 COL_WIRE_LOW = vec3(.680, .074, .028);\nconst vec3 COL_WIRE_HIGH = vec3(.074, .659, .032);\nconst vec3 COL_AND_GATE = vec3(.12, .101, .06);\nconst vec3 COL_OR_GATE = vec3(.077, .12, .06);\nconst vec3 COL_XOR_GATE = vec3(.107, .06, .12);\nconst vec3 COL_NOT_GATE = vec3(.12, .06, .075);\nconst vec3 COL_NAND_GATE = vec3(.06, .12, .066);\nconst vec3 COL_NOR_GATE = vec3(.06, .081, .12);\nconst vec3 COL_XNOR_GATE = vec3(.06, .12, .112);\nconst vec3 COL_SWC_GATE = vec3(.08, .06, .12);\n\nconst float GATE_ICON_THICKNESS = .02;\nconst int GATE_SIZE_PX = 80;\n\n// amount of empty space at the top & bottom,\n// this is there because gates are basically\n// considered squares but the actual shapes\n// are more elongated, so to make the\n// intersection tests more accurate, we account\n// for the vertical empty space at the top and\n// bottom of the gates. intersection tests are\n// used to avoid spawning a gate on top of\n// another one.\n// since the gate SDFs have 20% vertical margins\n// we'll use the same ratio here.\nconst int GATE_VERT_PADDING = int(.2 * float(GATE_SIZE_PX));\n\nconst int GATE_TYPE_NONE = N_DRAW_MODES;\nconst int GATE_TYPE_AND = DRAW_MODE_GATE_AND;\nconst int GATE_TYPE_OR = DRAW_MODE_GATE_OR;\nconst int GATE_TYPE_XOR = DRAW_MODE_GATE_XOR;\nconst int GATE_TYPE_NOT = DRAW_MODE_GATE_NOT;\nconst int GATE_TYPE_NAND = DRAW_MODE_GATE_NAND;\nconst int GATE_TYPE_NOR = DRAW_MODE_GATE_NOR;\nconst int GATE_TYPE_XNOR = DRAW_MODE_GATE_XNOR;\nconst int GATE_TYPE_SWC = DRAW_MODE_GATE_SWC;\n\n// size of the block of pixels at the bottom left corner of\n// the gate buffer to represent gates\nconst ivec2 GATE_BUF_SIZE = ivec2(8);\nconst int N_GATES = GATE_BUF_SIZE.x * GATE_BUF_SIZE.y;\n\n\n\n/*_________ DLS buffer data encoding __________*/\n\nvec4 dls_encode(int wire_state, int last_updated)\n{\n    wire_state = iclamp(wire_state, 0, 3);\n    return vec4(\n        encode_int_for_buffer((last_updated << 2) | wire_state),\n        0, 0, 0\n    );\n}\n\nvoid dls_decode(\n    vec4 data,\n    out int wire_state,\n    out int last_updated\n)\n{\n    int packed = decode_int_from_buffer(data.x);\n    wire_state = packed & 3;\n    last_updated = packed >> 2;\n}\n\nvec4 gate_buf_encode(int gate_type, ivec2 icoord_bl)\n{\n    return vec4(\n        encode_int_for_buffer(gate_type),\n        encode_int_for_buffer(icoord_bl.x),\n        encode_int_for_buffer(icoord_bl.y),\n        0\n    );\n}\n\nvoid gate_buf_decode(\n    vec4 data,\n    out int gate_type,\n    out ivec2 icoord_bl\n)\n{\n    gate_type = decode_int_from_buffer(data.x);\n    icoord_bl = ivec2(\n        decode_int_from_buffer(data.y),\n        decode_int_from_buffer(data.z)\n    );\n}\n\nvec4 data_buf_encode(\n    ivec2 res,\n    int draw_mode,\n    bool prev_mouse_down,\n    ivec2 prev_imouse\n)\n{\n    int prev_mouse_down_01 = (prev_mouse_down ? 1 : 0);\n    return vec4(\n        encode_int_for_buffer(res.x),\n        encode_int_for_buffer(res.y),\n        encode_int_for_buffer((draw_mode << 1) | prev_mouse_down_01),\n        encode_int_for_buffer((prev_imouse.x << 16) | prev_imouse.y)\n    );\n}\n\nvoid data_buf_decode(\n    vec4 data,\n    out ivec2 res,\n    out int draw_mode,\n    out bool prev_mouse_down,\n    out ivec2 prev_imouse\n)\n{\n    res = ivec2(\n        decode_int_from_buffer(data.x),\n        decode_int_from_buffer(data.y)\n    );\n    \n    int packed = decode_int_from_buffer(data.z);\n    draw_mode = packed >> 1;\n    prev_mouse_down = bool(packed & 1);\n    \n    packed = decode_int_from_buffer(data.w);\n    prev_imouse = ivec2(\n        packed >> 16,\n        packed & ((1 << 16) - 1)\n    );\n}\n\n\n\n/*_________________ DLS SDFs __________________*/\n\nconst vec2 GATE_TOP_INPUT_UV = vec2(0., .65);\nconst vec2 GATE_BOTTOM_INPUT_UV = vec2(0., .35);\nconst vec2 GATE_CENTER_INPUT_UV = vec2(0., .5); // for single-input gates\n\n#define N_SIDES_AND_GATE (4 + BEZIER_RES + BEZIER_RES - 1)\nDEFINE_SD_POLYGON(N_SIDES_AND_GATE)\n\nbool point_inside_and_gate(vec2 block_uv)\n{\n    vec2 p[N_SIDES_AND_GATE];\n    p[0] = vec2(.5, .2);\n    p[1] = vec2(.2, .2);\n    p[2] = vec2(.2, .8);\n    p[3] = vec2(.5, .8);\n    for (int i = 1; i <= BEZIER_RES; i++)\n    {\n        p[3 + i] = bezier(\n            vec2(.5, .8),\n            vec2(.5 + .13, .8),\n            vec2(.75, .5 + .13),\n            vec2(.75, .5),\n            float(i) / float(BEZIER_RES)\n        );\n    }\n    for (int i = 1; i < BEZIER_RES; i++)\n    {\n        p[3 + BEZIER_RES + i] = bezier(\n            vec2(.75, .5),\n            vec2(.75, .5 - .13),\n            vec2(.5 + .13, .2),\n            vec2(.5, .2),\n            float(i) / float(BEZIER_RES)\n        );\n    }\n    \n    return sd_polygon(block_uv, p) < 0.;\n}\n\nbool point_inside_nand_gate(vec2 block_uv)\n{\n    return point_inside_and_gate(block_uv);\n}\n\nfloat sd_and_gate_no_output_line(vec2 block_uv)\n{\n    float sd = sd_bezier_approx(\n        block_uv,\n        vec2(.5, .8),\n        vec2(.5 + .13, .8),\n        vec2(.75, .5 + .13),\n        vec2(.75, .5)\n    ) - GATE_ICON_THICKNESS;\n    \n    sd = min(sd, sd_bezier_approx(\n        block_uv,\n        vec2(.75, .5),\n        vec2(.75, .5 - .13),\n        vec2(.5 + .13, .2),\n        vec2(.5, .2)\n    ) - GATE_ICON_THICKNESS);\n    \n    sd = min(sd, sd_segment(\n        block_uv,\n        vec2(.2, .8),\n        vec2(.5, .8)\n    ) - GATE_ICON_THICKNESS);\n    \n    sd = min(sd, sd_segment(\n        block_uv,\n        vec2(.2, .2),\n        vec2(.5, .2)\n    ) - GATE_ICON_THICKNESS);\n    \n    sd = min(sd, sd_segment(\n        block_uv,\n        vec2(.2, .2),\n        vec2(.2, .8)\n    ) - GATE_ICON_THICKNESS);\n    \n    // input line 1\n    sd = min(sd, sd_segment(\n        block_uv,\n        GATE_TOP_INPUT_UV,\n        GATE_TOP_INPUT_UV + vec2(.2, 0)\n    ) - GATE_ICON_THICKNESS);\n    \n    // input line 2\n    sd = min(sd, sd_segment(\n        block_uv,\n        GATE_BOTTOM_INPUT_UV,\n        GATE_BOTTOM_INPUT_UV + vec2(.2, 0)\n    ) - GATE_ICON_THICKNESS);\n    \n    return sd;\n}\n\nfloat sd_and_gate(vec2 block_uv)\n{\n    float sd = sd_and_gate_no_output_line(block_uv);\n    \n    // output line\n    sd = min(sd, sd_segment(\n        block_uv,\n        vec2(.76, .5),\n        vec2(1, .5)\n    ) - GATE_ICON_THICKNESS);\n    \n    return sd;\n}\n\n#define N_SIDES_OR_GATE (3 * BEZIER_RES)\nDEFINE_SD_POLYGON(N_SIDES_OR_GATE)\n\nbool point_inside_or_gate(vec2 block_uv)\n{\n    vec2 p[N_SIDES_OR_GATE];\n    for (int i = 0; i < BEZIER_RES; i++)\n    {\n        p[i] = bezier(\n            vec2(.2, .8),\n            vec2(.5, .8),\n            vec2(.75, .5),\n            float(i) / float(BEZIER_RES)\n        );\n    }\n    for (int i = 0; i < BEZIER_RES; i++)\n    {\n        p[BEZIER_RES + i] = bezier(\n            vec2(.75, .5),\n            vec2(.5, .2),\n            vec2(.2, .2),\n            float(i) / float(BEZIER_RES)\n        );\n    }\n    for (int i = 0; i < BEZIER_RES; i++)\n    {\n        p[2 * BEZIER_RES + i] = bezier(\n            vec2(.2, .2),\n            vec2(.43, .5),\n            vec2(.2, .8),\n            float(i) / float(BEZIER_RES)\n        );\n    }\n    \n    return sd_polygon(block_uv, p) < 0.;\n}\n\nbool point_inside_xor_gate(vec2 block_uv)\n{\n    return point_inside_or_gate(block_uv);\n}\n\nbool point_inside_nor_gate(vec2 block_uv)\n{\n    return point_inside_or_gate(block_uv);\n}\n\nbool point_inside_xnor_gate(vec2 block_uv)\n{\n    return point_inside_or_gate(block_uv);\n}\n\nfloat sd_or_gate_no_output_line(vec2 block_uv)\n{\n    float sd = sd_bezier_approx(\n        block_uv,\n        vec2(.2, .8),\n        vec2(.5, .8),\n        vec2(.75, .5)\n    ) - GATE_ICON_THICKNESS;\n    \n    sd = min(sd, sd_bezier_approx(\n        block_uv,\n        vec2(.75, .5),\n        vec2(.5, .2),\n        vec2(.2, .2)\n    ) - GATE_ICON_THICKNESS);\n    \n    sd = min(sd, sd_bezier_approx(\n        block_uv,\n        vec2(.2, .2),\n        vec2(.43, .5),\n        vec2(.2, .8)\n    ) - GATE_ICON_THICKNESS);\n    \n    // input line 1\n    sd = min(sd, sd_segment(\n        block_uv,\n        GATE_TOP_INPUT_UV,\n        GATE_TOP_INPUT_UV + vec2(.28, 0)\n    ) - GATE_ICON_THICKNESS);\n    \n    // input line 2\n    sd = min(sd, sd_segment(\n        block_uv,\n        GATE_BOTTOM_INPUT_UV,\n        GATE_BOTTOM_INPUT_UV + vec2(.28, 0)\n    ) - GATE_ICON_THICKNESS);\n    \n    return sd;\n}\n\nfloat sd_or_gate(vec2 block_uv)\n{\n    float sd = sd_or_gate_no_output_line(block_uv);\n    \n    // output line\n    sd = min(sd, sd_segment(\n        block_uv,\n        vec2(.76, .5),\n        vec2(1, .5)\n    ) - GATE_ICON_THICKNESS);\n    \n    return sd;\n}\n\nfloat sd_xor_gate_no_output_line(vec2 block_uv)\n{\n    float sd = sd_or_gate_no_output_line(block_uv);\n    \n    sd = min(sd, sd_bezier_approx(\n        block_uv + vec2(.08, 0),\n        vec2(.2, .8),\n        vec2(.43, .5),\n        vec2(.2, .2)\n    ) - GATE_ICON_THICKNESS);\n    \n    return sd;\n}\n\nfloat sd_xor_gate(vec2 block_uv)\n{\n    float sd = sd_xor_gate_no_output_line(block_uv);\n    \n    // output line\n    sd = min(sd, sd_segment(\n        block_uv,\n        vec2(.76, .5),\n        vec2(1, .5)\n    ) - GATE_ICON_THICKNESS);\n    \n    return sd;\n}\n\nfloat sd_gate_dot_and_output_line(vec2 block_uv)\n{\n    // dot (the dot at the end of NOT, NOR, XNOR, etc.)\n    float sd = abs(\n        distance(\n            block_uv,\n            vec2(.84, .5)\n        ) - .05\n    ) - GATE_ICON_THICKNESS;\n    \n    // output line\n    sd = min(sd, sd_segment(\n        block_uv,\n        vec2(.89, .5),\n        vec2(1, .5)\n    ) - GATE_ICON_THICKNESS);\n    \n    return sd;\n}\n\n#define N_SIDES_NOT_GATE 3\nDEFINE_SD_POLYGON(N_SIDES_NOT_GATE)\n\nbool point_inside_not_gate(vec2 block_uv)\n{\n    vec2 p[N_SIDES_NOT_GATE] = vec2[](\n        vec2(.2, .2),\n        vec2(.8, .5),\n        vec2(.2, .8)\n    );\n    return sd_polygon(block_uv, p) < 0.;\n}\n\nfloat sd_not_gate(vec2 block_uv)\n{\n    float sd = sd_segment(\n        block_uv,\n        vec2(.2, .2),\n        vec2(.8, .5)\n    ) - GATE_ICON_THICKNESS;\n    \n    sd = min(sd, sd_segment(\n        block_uv,\n        vec2(.2, .8),\n        vec2(.8, .5)\n    ) - GATE_ICON_THICKNESS);\n    \n    sd = min(sd, sd_segment(\n        block_uv,\n        vec2(.2, .2),\n        vec2(.2, .8)\n    ) - GATE_ICON_THICKNESS);\n    \n    // input line\n    sd = min(sd, sd_segment(\n        block_uv,\n        GATE_CENTER_INPUT_UV,\n        GATE_CENTER_INPUT_UV + vec2(.2, 0)\n    ) - GATE_ICON_THICKNESS);\n    \n    // output line\n    sd = min(sd, sd_segment(\n        block_uv,\n        vec2(.89, .5),\n        vec2(1, .5)\n    ) - GATE_ICON_THICKNESS);\n    \n    sd = min(sd, sd_gate_dot_and_output_line(block_uv));\n    \n    return sd;\n}\n\nfloat sd_nand_gate(vec2 block_uv)\n{\n    float sd = sd_and_gate_no_output_line(block_uv);\n    sd = min(sd, sd_gate_dot_and_output_line(block_uv));\n    return sd;\n}\n\nfloat sd_nor_gate(vec2 block_uv)\n{\n    float sd = sd_or_gate_no_output_line(block_uv);\n    sd = min(sd, sd_gate_dot_and_output_line(block_uv));\n    return sd;\n}\n\nfloat sd_xnor_gate(vec2 block_uv)\n{\n    float sd = sd_xor_gate_no_output_line(block_uv);\n    sd = min(sd, sd_gate_dot_and_output_line(block_uv));\n    return sd;\n}\n\nconst vec2 SWC_GATE_CIRCLE_CENTER = vec2(.46, .5);\nconst float SWC_GATE_CIRCLE_RADIUS = .29;\n\nbool point_inside_swc_gate(vec2 block_uv)\n{\n    return\n        dist_sq(block_uv, SWC_GATE_CIRCLE_CENTER)\n        < (SWC_GATE_CIRCLE_RADIUS * SWC_GATE_CIRCLE_RADIUS);\n}\n\nfloat sd_swc_gate(vec2 block_uv)\n{\n    float sd = abs(\n        distance(\n            block_uv,\n            SWC_GATE_CIRCLE_CENTER\n        ) - SWC_GATE_CIRCLE_RADIUS\n    ) - GATE_ICON_THICKNESS;\n    \n    // input line 1\n    sd = min(sd, sd_segment(\n        block_uv,\n        GATE_TOP_INPUT_UV,\n        GATE_TOP_INPUT_UV + vec2(.2, 0)\n    ) - GATE_ICON_THICKNESS);\n    \n    // input line 2\n    sd = min(sd, sd_segment(\n        block_uv,\n        GATE_BOTTOM_INPUT_UV,\n        GATE_BOTTOM_INPUT_UV + vec2(.2, 0)\n    ) - GATE_ICON_THICKNESS);\n    \n    // output line\n    sd = min(sd, sd_segment(\n        block_uv,\n        vec2(.76, .5),\n        vec2(1, .5)\n    ) - GATE_ICON_THICKNESS);\n    \n    // text\n    {\n        // S\n    \n        sd = min(sd, sd_segment(\n            block_uv,\n            vec2(.38, .62),\n            vec2(.3, .62)\n        ) - .5 * GATE_ICON_THICKNESS);\n        \n        sd = min(sd, sd_segment(\n            block_uv,\n            vec2(.3, .62),\n            vec2(.38, .38)\n        ) - .5 * GATE_ICON_THICKNESS);\n        \n        sd = min(sd, sd_segment(\n            block_uv,\n            vec2(.38, .38),\n            vec2(.3, .38)\n        ) - .5 * GATE_ICON_THICKNESS);\n        \n        // W\n        \n        sd = min(sd, sd_segment(\n            block_uv,\n            vec2(.42, .62),\n            vec2(.42, .38)\n        ) - .5 * GATE_ICON_THICKNESS);\n        \n        sd = min(sd, sd_segment(\n            block_uv,\n            vec2(.42, .38),\n            vec2(.46, .5)\n        ) - .5 * GATE_ICON_THICKNESS);\n        \n        sd = min(sd, sd_segment(\n            block_uv,\n            vec2(.46, .5),\n            vec2(.5, .38)\n        ) - .5 * GATE_ICON_THICKNESS);\n        \n        sd = min(sd, sd_segment(\n            block_uv,\n            vec2(.5, .38),\n            vec2(.5, .62)\n        ) - .5 * GATE_ICON_THICKNESS);\n        \n        // C\n        \n        sd = min(sd, sd_segment(\n            block_uv,\n            vec2(.62, .62),\n            vec2(.54, .62)\n        ) - .5 * GATE_ICON_THICKNESS);\n        \n        sd = min(sd, sd_segment(\n            block_uv,\n            vec2(.54, .62),\n            vec2(.54, .38)\n        ) - .5 * GATE_ICON_THICKNESS);\n        \n        sd = min(sd, sd_segment(\n            block_uv,\n            vec2(.54, .38),\n            vec2(.62, .38)\n        ) - .5 * GATE_ICON_THICKNESS);\n    }\n    \n    return sd;\n}\n\nbool point_inside_gate(vec2 block_uv, int gate_type)\n{\n    if (gate_type == GATE_TYPE_AND)\n    {\n        return point_inside_and_gate(block_uv);\n    }\n    else if (gate_type == GATE_TYPE_OR)\n    {\n        return point_inside_or_gate(block_uv);\n    }\n    else if (gate_type == GATE_TYPE_XOR)\n    {\n        return point_inside_xor_gate(block_uv);\n    }\n    else if (gate_type == GATE_TYPE_NOT)\n    {\n        return point_inside_not_gate(block_uv);\n    }\n    else if (gate_type == GATE_TYPE_NAND)\n    {\n        return point_inside_nand_gate(block_uv);\n    }\n    else if (gate_type == GATE_TYPE_NOR)\n    {\n        return point_inside_nor_gate(block_uv);\n    }\n    else if (gate_type == GATE_TYPE_XNOR)\n    {\n        return point_inside_xnor_gate(block_uv);\n    }\n    else if (gate_type == GATE_TYPE_SWC)\n    {\n        return point_inside_swc_gate(block_uv);\n    }\n    return false;\n}\n\nbool point_inside_gate_output(vec2 block_uv)\n{\n    float sd = sd_segment(\n        block_uv,\n        vec2(.89, .5),\n        vec2(1, .5)\n    ) - GATE_ICON_THICKNESS;\n    return sd < 0.;\n}\n\n\n\n/*_______________ DLS toolbar _________________*/\n\nvec2 dls_toolbar_uv(vec2 coord, vec2 res)\n{\n    return coord / res.x;\n}\n\nbool point_inside_dls_toolbar(vec2 toolbar_uv, vec2 res)\n{\n    vec2 uv_top_left = vec2(0, res.y) / res.x;\n    return\n        toolbar_uv.x <= TOOLBAR_BLOCK_SIZE * float(N_TOOLBAR_BLOCKS)\n        && toolbar_uv.y >= (uv_top_left.y - TOOLBAR_BLOCK_SIZE);\n}\n\nint dls_toolbar_block_idx(vec2 toolbar_uv)\n{\n    return iclamp(\n        int(toolbar_uv.x / TOOLBAR_BLOCK_SIZE),\n        0,\n        N_TOOLBAR_BLOCKS - 1\n    );\n}\n\nvec2 dls_toolbar_block_uv(vec2 toolbar_uv, vec2 res)\n{\n    vec2 uv_top_left = vec2(0, res.y) / res.x;\n    return vec2(\n        mod(toolbar_uv.x, TOOLBAR_BLOCK_SIZE) / TOOLBAR_BLOCK_SIZE,\n        (toolbar_uv.y - (uv_top_left.y - TOOLBAR_BLOCK_SIZE)) / TOOLBAR_BLOCK_SIZE\n    );\n}\n\n\n\n// The following is a copy of the tutorial comment posted by the author\n// under the original shader (https://www.shadertoy.com/view/XXG3zW).\n\n/*\nThis is a digital logic simulation shader for learning and experimenting with logic gates and digital circuits like binary adders, ALUs (arithmetic logic units), and if you're really nerdy, entire basic CPUs. It simulates logic values propagating inside wires, and logic gates that read & manipulate those values at their inputs and outputs.\n\nThis shader is written by bean.\nGitHub: [url]https://github.com/bean-mhm[/url]\n\n[b]DON'T PANIC[/b]\nIf it says \"Compiled in 0.0 secs\" and shows a black screen, it's lying to you. The shader is still being compiled, just wait for 30-60 seconds.\n\n[b]Controls[/b]\n[Hold Mouse] Draw / Erase\n[Click] Select tool\n[C] Clear\n[i]NOTE: Resolution changes will reset everything and cause data loss.[/i]\n\n[b]Toolbar[/b]\nClick on the icons in the toolbar to change the draw mode to one of the following, respectively.\n- Wire brush\n- Eraser\n- Inject 0 in wire\n- Inject 1 in wire\n- AND gate\n- OR gate\n- XOR gate\n- NOT gate\n- NAND gate\n- NOR gate\n- XNOR gate\n- SWC gate\n\n[b]How logic gates work[/b]\n\nThe following terms refer to the same thing: 0, false, low, and off. Same with 1, true, high, and on.\n\n[i]AND[/i] outputs true if both inputs are true.\n[i]OR[/i] outputs true if either input is true.\n[i]XOR[/i] outputs true if the inputs have different values.\n\n[i]NOT[/i] outputs the inverted version of the input ([i]NOT[/i] has only one input).\n\n[i]NAND[/i] outputs true if either input is false.\n[i]NOR[/i] outputs true if both inputs are false.\n[i]XNOR[/i] outputs true if the inputs have equal values.\n\n[i]SWC[/i] outputs the first input only if the second input is true, does nothing otherwise.\n\n[b]Colors in wires[/b]\nThis is kinda obvious, but green means high, and red is low.\n*/\n\n\n\n// The following is a copy of my personal to-do list for this project\n\n/*\ndata buffer\n- new draw modes for the gates\n\nimage\n- icons for the new draw modes\n\ngate buffer\n- contains an array of logic gates\n- struct LogicGate:\n    type: int GATE_TYPE_AND\n    icoord_bottom_left: ivec2\n- [C] should clear the gates too\n- if draw mode is a gate, add it if mouse is down in this frame but wasnt in prev frame\n\nimage\n- iterate through the gate array from the gate buffer and see if we're inside\n  one, and if so, render that gate.\n- fill the interior of the gates\n\ngate buffer\n- if mouse is on a gate already, don't add anything\n- if mouse is on a gate and draw mode is erase, delete it on mouse press\n\nDLS buffer\n- don't run simulation inside a logic gate (ignore wires under gates)\n- if at the output of a logic gate, do the operation based on the inputs\n\nDLS buffer\n- only draw wires if prev_mouse_down is on, use line segments to avoid the nasty cirlce issue (use prev_imouse)\n*/",
     "name": "Common",
     "description": "",
     "type": "common"
    },
    {
     "inputs": [
      {
       "id": "4dXGRr",
       "filepath": "/presets/tex00.jpg",
       "type": "keyboard",
       "channel": 3,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4sXGR8",
       "filepath": "/media/previz/buffer02.png",
       "type": "buffer",
       "channel": 2,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "// simulation buffer. this stores wire states and \"last updated\"\n// values.\n\n#if SHADERTOY\n// iChannel1 must be set to Keyboard in Shadertoy\n#define SHADERTOY_KEYBOARD_CH iChannel3\n#else\n#iKeyboard\n#endif\n\ndefine_keyboard_utils\n\n#define ICHANNEL_SELF iChannel0\n#define ICHANNEL_GATE_BUF iChannel1\n#define ICHANNEL_DATA_BUF iChannel2\n\nvoid dls_fetch(\n    ivec2 icoord,\n    out int wire_state,\n    out int last_updated\n)\n{\n    if (!icoord_in_bounds(\n        icoord,\n        ivec2(iResolution.xy)\n    ))\n    {\n        wire_state = WIRE_STATE_NOT_WIRE;\n        last_updated = -1;\n        return;\n    }\n    \n    vec4 data = texelFetch(ICHANNEL_SELF, icoord, 0);\n    dls_decode(data, wire_state, last_updated);\n}\n\nvoid gate_fetch(\n    int idx,\n    out int gate_type,\n    out ivec2 icoord_bl\n)\n{\n    if (idx < 0 || idx >= N_GATES)\n    {\n        gate_type = GATE_TYPE_NONE;\n        icoord_bl = ivec2(0);\n        return;\n    }\n    \n    ivec2 icoord = idx_to_icoord(idx, GATE_BUF_SIZE);\n    vec4 data = texelFetch(ICHANNEL_GATE_BUF, icoord, 0);\n    gate_buf_decode(data, gate_type, icoord_bl);\n}\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    // values from the data buffer\n    ivec2 res;\n    int draw_mode;\n    bool prev_mouse_down;\n    ivec2 prev_imouse;\n    data_buf_decode(\n        texelFetch(ICHANNEL_DATA_BUF, ivec2(0), 0),\n        res,\n        draw_mode,\n        prev_mouse_down,\n        prev_imouse\n    );\n    \n    // resolution changed since last frame?\n    bool res_changed = imax(\n        iabs(res.x - int(iResolution.x)),\n        iabs(res.y - int(iResolution.y))\n    ) > 0;\n    \n    // are we in the first frame?\n    bool first_frame = (iFrame < 1) || (iTime < .02);\n\n    // set initial values and return on resolution change or\n    // the first frame, or if C is pressed\n    if (res_changed || first_frame || is_key_pressed(Key_C))\n    {\n        frag_col = dls_encode(\n            WIRE_STATE_NOT_WIRE,\n            -1\n        );\n        return;\n    }\n    \n    // see if mouse is in the toolbar\n    vec2 mouse_toolbar_uv = dls_toolbar_uv(iMouse.xy, iResolution.xy); \n    bool mouse_in_toolbar = point_inside_dls_toolbar(\n        mouse_toolbar_uv,\n        iResolution.xy\n    );\n    \n    ivec2 icoord = ivec2(frag_coord);\n    \n    // current pixel's values\n    int wire_state;\n    int last_updated;\n    dls_fetch(icoord, wire_state, last_updated);\n    \n    // see if the current pixel is inside a logic gate\n    bool inside_gate = false;\n    for (int i = 0; i < N_GATES; i++)\n    {\n        int gate_type;\n        ivec2 gate_icoord_bl;\n        gate_fetch(i, gate_type, gate_icoord_bl);\n        \n        if (gate_type == GATE_TYPE_NONE)\n        {\n            continue;\n        }\n        \n        ivec2 gate_icoord_tr = gate_icoord_bl + GATE_SIZE_PX;\n        vec2 block_uv =\n            (frag_coord - vec2(gate_icoord_bl) - .5) / float(GATE_SIZE_PX);\n        \n        if (point_inside_gate_output(block_uv))\n        {\n            // we're on the output of a gate so don't run the\n            // simulation, we'll perform the correct logic\n            // operation instead.\n            inside_gate = true;\n            \n            // read the wire states at the inputs\n            \n            ivec2 icoord_top_input = ivec2(\n                GATE_TOP_INPUT_UV * float(GATE_SIZE_PX)\n                + vec2(gate_icoord_bl) + .5\n            );\n            ivec2 icoord_bottom_input = ivec2(\n                GATE_BOTTOM_INPUT_UV * float(GATE_SIZE_PX)\n                + vec2(gate_icoord_bl) + .5\n            );\n            ivec2 icoord_center_input = ivec2(\n                GATE_CENTER_INPUT_UV * float(GATE_SIZE_PX)\n                + vec2(gate_icoord_bl) + .5\n            );\n            \n            int top_inp_state;\n            int bottom_inp_state;\n            int center_inp_state;\n            int dont_care_about_last_updated;\n            \n            dls_fetch(\n                icoord_top_input,\n                top_inp_state,\n                dont_care_about_last_updated\n            );\n            dls_fetch(\n                icoord_bottom_input,\n                bottom_inp_state,\n                dont_care_about_last_updated\n            );\n            dls_fetch(\n                icoord_center_input,\n                center_inp_state,\n                dont_care_about_last_updated\n            );\n            \n            // perform logic operations\n            if (gate_type == GATE_TYPE_AND)\n            {\n                if (top_inp_state == WIRE_STATE_LOW && bottom_inp_state == WIRE_STATE_LOW)\n                {\n                    wire_state = WIRE_STATE_LOW;\n                    last_updated = iFrame;\n                }\n                else if (top_inp_state == WIRE_STATE_LOW && bottom_inp_state == WIRE_STATE_HIGH)\n                {\n                    wire_state = WIRE_STATE_LOW;\n                    last_updated = iFrame;\n                }\n                else if (top_inp_state == WIRE_STATE_HIGH && bottom_inp_state == WIRE_STATE_LOW)\n                {\n                    wire_state = WIRE_STATE_LOW;\n                    last_updated = iFrame;\n                }\n                else if (top_inp_state == WIRE_STATE_HIGH && bottom_inp_state == WIRE_STATE_HIGH)\n                {\n                    wire_state = WIRE_STATE_HIGH;\n                    last_updated = iFrame;\n                }\n            }\n            else if (gate_type == GATE_TYPE_OR)\n            {\n                if (top_inp_state == WIRE_STATE_LOW && bottom_inp_state == WIRE_STATE_LOW)\n                {\n                    wire_state = WIRE_STATE_LOW;\n                    last_updated = iFrame;\n                }\n                else if (top_inp_state == WIRE_STATE_LOW && bottom_inp_state == WIRE_STATE_HIGH)\n                {\n                    wire_state = WIRE_STATE_HIGH;\n                    last_updated = iFrame;\n                }\n                else if (top_inp_state == WIRE_STATE_HIGH && bottom_inp_state == WIRE_STATE_LOW)\n                {\n                    wire_state = WIRE_STATE_HIGH;\n                    last_updated = iFrame;\n                }\n                else if (top_inp_state == WIRE_STATE_HIGH && bottom_inp_state == WIRE_STATE_HIGH)\n                {\n                    wire_state = WIRE_STATE_HIGH;\n                    last_updated = iFrame;\n                }\n            }\n            else if (gate_type == GATE_TYPE_XOR)\n            {\n                if (top_inp_state == WIRE_STATE_LOW && bottom_inp_state == WIRE_STATE_LOW)\n                {\n                    wire_state = WIRE_STATE_LOW;\n                    last_updated = iFrame;\n                }\n                else if (top_inp_state == WIRE_STATE_LOW && bottom_inp_state == WIRE_STATE_HIGH)\n                {\n                    wire_state = WIRE_STATE_HIGH;\n                    last_updated = iFrame;\n                }\n                else if (top_inp_state == WIRE_STATE_HIGH && bottom_inp_state == WIRE_STATE_LOW)\n                {\n                    wire_state = WIRE_STATE_HIGH;\n                    last_updated = iFrame;\n                }\n                else if (top_inp_state == WIRE_STATE_HIGH && bottom_inp_state == WIRE_STATE_HIGH)\n                {\n                    wire_state = WIRE_STATE_LOW;\n                    last_updated = iFrame;\n                }\n            }\n            else if (gate_type == GATE_TYPE_NOT)\n            {\n                if (center_inp_state == WIRE_STATE_LOW)\n                {\n                    wire_state = WIRE_STATE_HIGH;\n                    last_updated = iFrame;\n                }\n                else if (center_inp_state == WIRE_STATE_HIGH)\n                {\n                    wire_state = WIRE_STATE_LOW;\n                    last_updated = iFrame;\n                }\n            }\n            else if (gate_type == GATE_TYPE_NAND)\n            {\n                if (top_inp_state == WIRE_STATE_LOW && bottom_inp_state == WIRE_STATE_LOW)\n                {\n                    wire_state = WIRE_STATE_HIGH;\n                    last_updated = iFrame;\n                }\n                else if (top_inp_state == WIRE_STATE_LOW && bottom_inp_state == WIRE_STATE_HIGH)\n                {\n                    wire_state = WIRE_STATE_HIGH;\n                    last_updated = iFrame;\n                }\n                else if (top_inp_state == WIRE_STATE_HIGH && bottom_inp_state == WIRE_STATE_LOW)\n                {\n                    wire_state = WIRE_STATE_HIGH;\n                    last_updated = iFrame;\n                }\n                else if (top_inp_state == WIRE_STATE_HIGH && bottom_inp_state == WIRE_STATE_HIGH)\n                {\n                    wire_state = WIRE_STATE_LOW;\n                    last_updated = iFrame;\n                }\n            }\n            else if (gate_type == GATE_TYPE_NOR)\n            {\n                if (top_inp_state == WIRE_STATE_LOW && bottom_inp_state == WIRE_STATE_LOW)\n                {\n                    wire_state = WIRE_STATE_HIGH;\n                    last_updated = iFrame;\n                }\n                else if (top_inp_state == WIRE_STATE_LOW && bottom_inp_state == WIRE_STATE_HIGH)\n                {\n                    wire_state = WIRE_STATE_LOW;\n                    last_updated = iFrame;\n                }\n                else if (top_inp_state == WIRE_STATE_HIGH && bottom_inp_state == WIRE_STATE_LOW)\n                {\n                    wire_state = WIRE_STATE_LOW;\n                    last_updated = iFrame;\n                }\n                else if (top_inp_state == WIRE_STATE_HIGH && bottom_inp_state == WIRE_STATE_HIGH)\n                {\n                    wire_state = WIRE_STATE_LOW;\n                    last_updated = iFrame;\n                }\n            }\n            else if (gate_type == GATE_TYPE_XNOR)\n            {\n                if (top_inp_state == WIRE_STATE_LOW && bottom_inp_state == WIRE_STATE_LOW)\n                {\n                    wire_state = WIRE_STATE_HIGH;\n                    last_updated = iFrame;\n                }\n                else if (top_inp_state == WIRE_STATE_LOW && bottom_inp_state == WIRE_STATE_HIGH)\n                {\n                    wire_state = WIRE_STATE_LOW;\n                    last_updated = iFrame;\n                }\n                else if (top_inp_state == WIRE_STATE_HIGH && bottom_inp_state == WIRE_STATE_LOW)\n                {\n                    wire_state = WIRE_STATE_LOW;\n                    last_updated = iFrame;\n                }\n                else if (top_inp_state == WIRE_STATE_HIGH && bottom_inp_state == WIRE_STATE_HIGH)\n                {\n                    wire_state = WIRE_STATE_HIGH;\n                    last_updated = iFrame;\n                }\n            }\n            else if (gate_type == GATE_TYPE_SWC)\n            {\n                if (top_inp_state == WIRE_STATE_LOW && bottom_inp_state == WIRE_STATE_LOW)\n                {\n                    // do nothing\n                }\n                else if (top_inp_state == WIRE_STATE_LOW && bottom_inp_state == WIRE_STATE_HIGH)\n                {\n                    wire_state = WIRE_STATE_LOW;\n                    last_updated = iFrame;\n                }\n                else if (top_inp_state == WIRE_STATE_HIGH && bottom_inp_state == WIRE_STATE_LOW)\n                {\n                    // do nothing\n                }\n                else if (top_inp_state == WIRE_STATE_HIGH && bottom_inp_state == WIRE_STATE_HIGH)\n                {\n                    wire_state = WIRE_STATE_HIGH;\n                    last_updated = iFrame;\n                }\n            }\n            \n            break;\n        }\n        if (point_inside_gate(block_uv, gate_type))\n        {\n            // we're inside a gate so don't run the simulation\n            inside_gate = true;\n            break;\n        }\n    }\n    \n    // only run the simulation for wire pixels, and not inside gates\n    if (wire_state != WIRE_STATE_NOT_WIRE && !inside_gate)\n    {\n        // check neighbors (5x5 window excluding the center)\n        for (int y_offs = -2; y_offs <= 2; y_offs++)\n        {\n            for (int x_offs = -2; x_offs <= 2; x_offs++)\n            {\n                // skip self (offset=0)\n                ivec2 offs = ivec2(x_offs, y_offs);\n                if (offs == ivec2(0))\n                {\n                    continue;\n                }\n                \n                // fetch neighbor's values\n                int neighbor_wire_state;\n                int neighbor_last_updated;\n                dls_fetch(\n                    icoord + offs,\n                    neighbor_wire_state,\n                    neighbor_last_updated\n                );\n                \n                // skip if neighbor is not a wire\n                if (neighbor_wire_state == WIRE_STATE_NOT_WIRE)\n                {\n                    continue;\n                }\n                \n                // only care about connected neighbors\n                if (neighbor_wire_state == WIRE_STATE_DISCONNECTED)\n                {\n                    continue;\n                }\n                \n                // if we're disconnected\n                if (wire_state == WIRE_STATE_DISCONNECTED)\n                {\n                    // change our values to that of the neighbor\n                    wire_state = neighbor_wire_state;\n                    last_updated = neighbor_last_updated;\n                }\n                \n                // or if we're connected and neighbor has a more recent value\n                if (neighbor_last_updated > last_updated\n                    && wire_state != WIRE_STATE_DISCONNECTED)\n                {\n                    // change our values to that of the neighbor\n                    wire_state = neighbor_wire_state;\n                    last_updated = neighbor_last_updated;\n                }\n            }\n        }\n        \n        // if mouse is down and on this pixel (and it's a wire)\n        if (iMouse.z > .5 && ivec2(iMouse.xy) == icoord && !mouse_in_toolbar)\n        {\n            // draw wire state\n            if (draw_mode == DRAW_MODE_WIRE_LOW)\n            {\n                wire_state = WIRE_STATE_LOW;\n                last_updated = iFrame;\n            }\n            else if (draw_mode == DRAW_MODE_WIRE_HIGH)\n            {\n                wire_state = WIRE_STATE_HIGH;\n                last_updated = iFrame;\n            }\n        }\n    }\n    \n    // on mouse down\n    if (iMouse.z > .5 && prev_mouse_down && !mouse_in_toolbar)\n    {\n        float line_segment_dist = sd_segment(\n            frag_coord,\n            vec2(prev_imouse) + .5,\n            iMouse.xy\n        );\n    \n        // draw wires\n        if (draw_mode == DRAW_MODE_WIRE\n            && line_segment_dist < BRUSH_THICKNESS_PX\n            && wire_state == WIRE_STATE_NOT_WIRE)\n        {\n            wire_state = WIRE_STATE_DISCONNECTED;\n            last_updated = -1;\n        }\n        \n        // erase wires\n        if (draw_mode == DRAW_MODE_ERASE\n            && line_segment_dist < ERASER_THICKNESS_PX)\n        {\n            wire_state = WIRE_STATE_NOT_WIRE;\n            last_updated = -1;\n        }\n    }\n    \n    // output the new values\n    frag_col = dls_encode(wire_state, last_updated);\n}\n",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [
      {
       "id": "4dXGRr",
       "filepath": "/presets/tex00.jpg",
       "type": "keyboard",
       "channel": 3,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4sXGR8",
       "filepath": "/media/previz/buffer02.png",
       "type": "buffer",
       "channel": 2,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "XsXGR8",
       "channel": 0
      }
     ],
     "code": "// gate buffer. this stores a fixed array of logic gates. by\n// default, the elements are initialized to represent no gates,\n// but they can change based on user input.\n\n// this buffer operates in the bottom left GATE_BUF_SIZE block\n// of pixels, so it stores a fixed array of\n// (GATE_BUF_SIZE.x * GATE_BUF_SIZE.y) gates. each pixel stores\n// a gate's type and its bottom left coordinates in pixel space.\n// the simulation buffer uses this info to perform boolean\n// operations at the gate outputs, and the image tab uses this\n// buffer to render the gates.\n\n#if SHADERTOY\n// iChannel1 must be set to Keyboard in Shadertoy\n#define SHADERTOY_KEYBOARD_CH iChannel3\n#else\n#iKeyboard\n#endif\n\ndefine_keyboard_utils\n\n#define ICHANNEL_SIM_BUF iChannel0\n#define ICHANNEL_SELF iChannel1\n#define ICHANNEL_DATA_BUF iChannel2\n\nvoid gate_fetch(\n    int idx,\n    out int gate_type,\n    out ivec2 icoord_bl\n)\n{\n    if (idx < 0 || idx >= N_GATES)\n    {\n        gate_type = GATE_TYPE_NONE;\n        icoord_bl = ivec2(0);\n        return;\n    }\n    \n    ivec2 icoord = idx_to_icoord(idx, GATE_BUF_SIZE);\n    vec4 data = texelFetch(ICHANNEL_SELF, icoord, 0);\n    gate_buf_decode(data, gate_type, icoord_bl);\n}\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    ivec2 icoord = ivec2(frag_coord);\n    \n    // only care about the bottom left block\n    if (!icoord_in_bounds(icoord, GATE_BUF_SIZE))\n    {\n        return;\n    }\n    \n    // 1D index of this pixel in the buffer\n    int my_idx = icoord_to_idx(icoord, GATE_BUF_SIZE);\n    \n    // values from the data buffer\n    ivec2 res;\n    int draw_mode;\n    bool prev_mouse_down;\n    ivec2 prev_imouse;\n    data_buf_decode(\n        texelFetch(ICHANNEL_DATA_BUF, ivec2(0), 0),\n        res,\n        draw_mode,\n        prev_mouse_down,\n        prev_imouse\n    );\n    \n    // resolution changed since last frame?\n    bool res_changed = imax(\n        iabs(res.x - int(iResolution.x)),\n        iabs(res.y - int(iResolution.y))\n    ) > 0;\n    \n    // are we in the first frame?\n    bool first_frame = (iFrame < 1) || (iTime < .02);\n\n    // set initial values and return on resolution change or\n    // the first frame, or if C is pressed\n    if (res_changed || first_frame || is_key_pressed(Key_C))\n    {\n        frag_col = gate_buf_encode(\n            GATE_TYPE_NONE,\n            ivec2(0)\n        );\n        return;\n    }\n    \n    // see if mouse is in the toolbar\n    vec2 mouse_toolbar_uv = dls_toolbar_uv(iMouse.xy, iResolution.xy); \n    bool mouse_in_toolbar = point_inside_dls_toolbar(\n        mouse_toolbar_uv,\n        iResolution.xy\n    );\n    \n    // current values\n    int gate_type;\n    ivec2 icoord_bl;\n    gate_buf_decode(\n        texelFetch(ICHANNEL_SELF, icoord, 0),\n        gate_type,\n        icoord_bl\n    );\n    \n    // on mouse down and in erase mode\n    if (iMouse.z > .5\n        && prev_mouse_down\n        && !mouse_in_toolbar\n        && draw_mode == DRAW_MODE_ERASE)\n    {\n        // find the index of the gate under the mouse\n        int delete_idx = -1;\n        for (int i = 0; i < N_GATES; i++)\n        {\n            int elem_gate_type;\n            ivec2 elem_icoord_bl;\n            gate_fetch(i, elem_gate_type, elem_icoord_bl);\n            \n            // skip empty slots\n            if (elem_gate_type == GATE_TYPE_NONE)\n            {\n                continue;\n            }\n            \n            // is the gate under the mouse?\n            ivec2 elem_icoord_tr = elem_icoord_bl + GATE_SIZE_PX;\n            ivec2 imouse = ivec2(iMouse.xy);\n            bool under_mouse =\n                all(greaterThanEqual(imouse, elem_icoord_bl))\n                && all(lessThan(imouse, elem_icoord_tr));\n            \n            if (!under_mouse)\n            {\n                continue;\n            }\n            \n            // found a gate under the mouse\n            delete_idx = i;\n            break;\n        }\n        \n        // if we found a gate to delete and it's exactly this pixel\n        if (delete_idx != -1 && delete_idx == my_idx)\n        {\n            // reset this pixel to delete the gate\n            gate_type = GATE_TYPE_NONE;\n            icoord_bl = ivec2(0);\n        }\n    }\n    \n    // on mouse press\n    if (iMouse.z > .5\n        && !prev_mouse_down\n        && !mouse_in_toolbar)\n    {\n        // do we need to add a gate? and what type?\n        int gate_to_add = GATE_TYPE_NONE;\n        if (draw_mode == DRAW_MODE_GATE_AND)\n        {\n            gate_to_add = GATE_TYPE_AND;\n        }\n        else if (draw_mode == DRAW_MODE_GATE_OR)\n        {\n            gate_to_add = GATE_TYPE_OR;\n        }\n        else if (draw_mode == DRAW_MODE_GATE_XOR)\n        {\n            gate_to_add = GATE_TYPE_XOR;\n        }\n        else if (draw_mode == DRAW_MODE_GATE_NOT)\n        {\n            gate_to_add = GATE_TYPE_NOT;\n        }\n        else if (draw_mode == DRAW_MODE_GATE_NAND)\n        {\n            gate_to_add = GATE_TYPE_NAND;\n        }\n        else if (draw_mode == DRAW_MODE_GATE_NOR)\n        {\n            gate_to_add = GATE_TYPE_NOR;\n        }\n        else if (draw_mode == DRAW_MODE_GATE_XNOR)\n        {\n            gate_to_add = GATE_TYPE_XNOR;\n        }\n        else if (draw_mode == DRAW_MODE_GATE_SWC)\n        {\n            gate_to_add = GATE_TYPE_SWC;\n        }\n        \n        // if we need to add a gate\n        if (gate_to_add != GATE_TYPE_NONE)\n        {\n            // bounds of the new gate to add\n            ivec2 gate_to_add_bl = ivec2(iMouse.xy) - GATE_SIZE_PX / 2;\n            ivec2 gate_to_add_tr = gate_to_add_bl + GATE_SIZE_PX;\n            \n            // find the index of the first empty slot\n            int empty_idx = -1;\n            for (int i = 0; i < N_GATES; i++)\n            {\n                int elem_gate_type;\n                ivec2 elem_icoord_bl;\n                gate_fetch(i, elem_gate_type, elem_icoord_bl);\n                \n                // if slot already occupied\n                if (elem_gate_type != GATE_TYPE_NONE)\n                {\n                    // does the gate in this slot intersect with the\n                    // bounds of the new gate we wanna add?\n                    ivec2 elem_icoord_tr = elem_icoord_bl + GATE_SIZE_PX;\n                    bool intersects =\n                        elem_icoord_tr.x >= gate_to_add_bl.x\n                        && elem_icoord_bl.x <= gate_to_add_tr.x\n                        && elem_icoord_tr.y - GATE_VERT_PADDING >= gate_to_add_bl.y + GATE_VERT_PADDING\n                        && elem_icoord_bl.y + GATE_VERT_PADDING <= gate_to_add_tr.y - GATE_VERT_PADDING;\n                    \n                    // if so, just don't add the new gate\n                    if (intersects)\n                    {\n                        break;\n                    }\n                    \n                    // otherwise, skip this slot and continue looking\n                    // for an empty slot\n                    continue;\n                }\n                \n                // found an empty slot\n                empty_idx = i;\n                break;\n            }\n            \n            // if we found an empty slot and it's exactly this pixel\n            if (empty_idx != -1 && empty_idx == my_idx)\n            {\n                // update this pixel\n                gate_type = gate_to_add;\n                icoord_bl = gate_to_add_bl;\n            }\n        }\n    }\n    \n    // output the new values\n    frag_col = gate_buf_encode(\n        gate_type,\n        icoord_bl\n    );\n}\n",
     "name": "Buffer B",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [
      {
       "id": "4sXGR8",
       "filepath": "/media/previz/buffer02.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4sXGR8",
       "channel": 0
      }
     ],
     "code": "// data buffer. this stores the last frame's resolution, the\n// current draw mode, whether the mouse button was down in\n// the previous frame, and the mouse coordinates in the\n// previous frame.\n\n#define ICHANNEL_SELF iChannel0\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    ivec2 icoord = ivec2(frag_coord);\n    \n    // only care about pixel (0, 0)\n    if (icoord != ivec2(0))\n    {\n        return;\n    }\n    \n    // current values\n    ivec2 res;\n    int draw_mode;\n    bool prev_mouse_down;\n    ivec2 prev_imouse;\n    data_buf_decode(\n        texelFetch(ICHANNEL_SELF, icoord, 0),\n        res,\n        draw_mode,\n        prev_mouse_down,\n        prev_imouse\n    );\n    \n    // resolution changed since last frame?\n    bool res_changed = imax(\n        iabs(res.x - int(iResolution.x)),\n        iabs(res.y - int(iResolution.y))\n    ) > 0;\n    \n    // set resolution to the current resolution\n    res = ivec2(iResolution.xy);\n\n    // are we in the first frame?\n    bool first_frame = (iFrame < 1) || (iTime < .02);\n    \n    // reset on resolution change or the first frame\n    if (res_changed || first_frame)\n    {\n        draw_mode = DRAW_MODE_WIRE;\n        prev_mouse_down = false;\n        prev_imouse = ivec2(iMouse.xy);\n    }\n    \n    // change draw mode with mouse\n    {\n        vec2 mouse_toolbar_uv = dls_toolbar_uv(iMouse.xy, iResolution.xy);\n        \n        bool mouse_in_toolbar = point_inside_dls_toolbar(\n            mouse_toolbar_uv,\n            iResolution.xy\n        );\n        \n        if (mouse_in_toolbar && iMouse.z > .5 && !prev_mouse_down)\n        {\n            int block_idx = dls_toolbar_block_idx(mouse_toolbar_uv);\n            draw_mode = block_idx;\n        }\n    }\n    \n    // output the new values\n    frag_col = data_buf_encode(\n        res,\n        draw_mode,\n        iMouse.z > .5,\n        ivec2(iMouse.xy)\n    );\n}\n",
     "name": "Buffer C",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "lXy3zK",
    "date": "1717887783",
    "viewed": 579,
    "name": "Daft Punk (Audio Data Packing)",
    "description": "8-bit audio samples packed into ivec4 array(s) using a Python script, with some vinyl pixel art I made",
    "likes": 24,
    "published": "Public API",
    "usePreview": 1,
    "tags": [
     "2d",
     "sound",
     "music",
     "pixel",
     "audio",
     "art",
     "8bit",
     "song",
     "packing",
     "data",
     "script",
     "daft",
     "punk"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "const float bpm = 120.;\nconst float beat_sec = 60. / bpm;\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    vec2 uv = frag_coord / iResolution.xy;\n    uv = uv * 2. - 1.;\n    uv *= iResolution.xy / min(iResolution.x, iResolution.y);\n    \n    // quantize and scale\n    uv = round(uv * 40.) / 40.;\n    uv /= 1.2;\n    \n    vec3 col = mix(\n        vec3(.09, .02, 0),\n        vec3(.1, .05, 0),\n        smoothstep(-.9, 1., uv.x)\n    );\n    \n    float pulse_fac = pow(1. - fract(iTime / beat_sec), 1.5);\n    \n    const vec2 center = vec2(.271, 0);\n    float r = length(uv - center);\n    float grad = remap01(length(uv - vec2(-.33, -.6)), 0., 1.7);\n    if (r < .02)\n    {\n        col = vec3(.6);\n    }\n    else if (r < .04)\n    {\n        col = vec3(.6, .05, .05);\n    }\n    else if (r < .05)\n    {\n        col = mix(vec3(.65, .05, .05), vec3(.8, .1, .1), remap01(grad, .473, .54));\n    }\n    else if (r < .127)\n    {\n        col = mix(vec3(.65, .03, .01), vec3(.8, .05, .02), remap01(grad, .5, .6));\n    }\n    else if (r < .15)\n    {\n        col = mix(vec3(.6, .25, .05), vec3(.7, .4, .05), sqrt(remap01(grad, .4, .55)));\n    }\n    else if (r < .18)\n    {\n        col = mix(vec3(.65, .02, .01), vec3(.75, .05, .02), remap01(grad, .5, .6));\n    }\n    else if (r < .25)\n    {\n        col = vec3(.003, .002, .0005);\n    }\n    else if (r < .6)\n    {\n        col = mix(vec3(.003, .002, .0005), vec3(.008, .006, .004), sqrt(remap01(grad, .14, .9)));\n        \n        float angle = degrees(get_angle(uv - center));\n        vec3 highlight = vec3(0);\n        \n        vec3 prev = highlight;\n        highlight = mix(highlight, vec3(1., .8, .6) * (1. + .1 * pulse_fac), remap_clamp(angle, 0., 100., 0., .015));\n        highlight = mix(highlight, prev, remap01(angle, 100., 200.));\n        \n        prev = highlight;\n        highlight = mix(highlight, 1.1 * vec3(.2, .3, 1.) * (1. - .25 * pulse_fac), remap_clamp(angle, 210., 280., 0., .01));\n        highlight = mix(highlight, prev, remap01(angle, 280., 350.));\n        \n        float moving_angle = angle + .5 * cos(TAU * 2. * iTime);\n        \n        prev = highlight;\n        highlight = mix(highlight, sqrt(remap_clamp(r, .25, .6, .2, .9)) * vec3(.13, .15, .2), remap_clamp(moving_angle, 35., 50., 0., .8));\n        highlight = mix(highlight, prev, remap01(moving_angle, 55., 70.));\n        \n        prev = highlight;\n        highlight = mix(highlight, sqrt(remap_clamp(r, .25, .6, .2, .75)) * vec3(.13, .15, .2), remap_clamp(moving_angle, 218., 232.5, 0., .65));\n        highlight = mix(highlight, prev, remap01(moving_angle, 232.5, 247.));\n        \n        col += highlight;\n        \n        if (abs(r - .5) < .01 || abs(r - .4) < .01 || abs(r - .3) < .01)\n        {\n           col *= remap_clamp(abs(moving_angle - 240.), 0., 10., 1., 1.12);\n        }\n        \n        if (r > .58)\n        {\n            col *= 2.;\n        }\n    }\n    \n    {\n        const vec2 bar_a = center + vec2(.363, -.27);\n        const vec2 bar_b = bar_a + .38;\n        const vec2 bar_dir = normalize(bar_b - bar_a);\n        const vec2 bar_dir_perp = bar_dir.yx * vec2(-1, 1);\n        const float bar_thick = .06;\n        \n        float bar_d = sd_oriented_box(uv, bar_a, bar_b, bar_thick);\n        if (bar_d < 0.)\n        {\n            col = mix(\n                vec3(.03, .03, .05),\n                vec3(.09),\n                remap_clamp(\n                    dot(uv - (bar_a - .5 * bar_thick * bar_dir_perp), bar_dir_perp),\n                    -.01, bar_thick,\n                    0., 1.\n                )\n            );\n        }\n        \n        const vec2 head_a = bar_a - .102 * bar_dir;\n        const vec2 head_b = head_a + .185 * bar_dir;\n        const vec2 head_dir = normalize(head_b - head_a);\n        const vec2 head_dir_perp = head_dir.yx * vec2(-1, 1);\n        const float head_thick = .1;\n        \n        float head_d = sd_oriented_box(uv, head_a, head_b, head_thick);\n        if (head_d < 0.)\n        {\n            col = mix(\n                vec3(.25, .25, .23),\n                vec3(.08, .08, .11),\n                remap_clamp(\n                    dot(uv - (head_a - .5 * head_thick * head_dir_perp), head_dir_perp),\n                    0., head_thick,\n                    0., 1.\n                )\n            );\n        }\n    }\n    \n    col *= 1.4;\n    \n    col = mix(\n        col,\n        pow(col, vec3(1. - .1 * pulse_fac)),\n        smoothstep(.4, 1.2, r)\n    );\n    \n    // dither\n    float bn = texelFetch(\n        iChannel0,\n        ivec2(uv * 40. + 500.) % textureSize(iChannel0, 0),\n        0\n    ).x;\n    col += .2 * (bn - .5) / 255.;\n    \n    col = pow(col, vec3(1. / 2.2));\n    frag_col = vec4(col, 1);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "precision highp float;\nprecision highp int;\n\n\n\n/*_________________ math utils ________________*/\n\nconst float PI = 3.141592653589793238462643383;\nconst float TAU = 6.283185307179586476925286767;\nconst float PI_OVER_2 = 1.570796326794896619231321692;\nconst float INV_PI = .318309886183790671537767527;\nconst float INV_TAU = .159154943091895335768883763;\n\n#define FUNC_LERP(T) \\\nT lerp(T a, T b, float t) \\\n{ \\\n    return a + t * (b - a); \\\n}\n\n#define FUNC_WRAP(T) \\\nT wrap(T v, float start, float end) \\\n{ \\\n    return start + mod(v - start, end - start); \\\n}\n\n#define FUNC_REMAP(T) \\\nT remap(T v, float inp_start, float inp_end, float out_start, float out_end) \\\n{ \\\n    return out_start \\\n        + ((out_end - out_start) / (inp_end - inp_start)) * (v - inp_start); \\\n}\n\n#define FUNC_REMAP_CLAMP(T) \\\nT remap_clamp( \\\n    T v, \\\n    float inp_start, \\\n    float inp_end, \\\n    float out_start, \\\n    float out_end \\\n) \\\n{ \\\n    T t = clamp((v - inp_start) / (inp_end - inp_start), 0., 1.); \\\n    return out_start + t * (out_end - out_start); \\\n}\n\n#define FUNC_REMAP01(T) \\\nT remap01(T v, float inp_start, float inp_end) \\\n{ \\\n    return clamp((v - inp_start) / (inp_end - inp_start), 0., 1.); \\\n}\n\n#define FUNC_LENGTH_SQ(T) \\\nfloat length_sq(T v) \\\n{ \\\n    return dot(v, v); \\\n}\n\n#define FUNC_DIST_SQ(T) \\\nfloat dist_sq(T a, T b) \\\n{ \\\n    a -= b; \\\n    return dot(a, a); \\\n}\n\nFUNC_LERP(float)\nFUNC_LERP(vec2)\nFUNC_LERP(vec3)\nFUNC_LERP(vec4)\n\nFUNC_WRAP(float)\nFUNC_WRAP(vec2)\nFUNC_WRAP(vec3)\nFUNC_WRAP(vec4)\n\nFUNC_REMAP(float)\nFUNC_REMAP(vec2)\nFUNC_REMAP(vec3)\nFUNC_REMAP(vec4)\n\nFUNC_REMAP_CLAMP(float)\nFUNC_REMAP_CLAMP(vec2)\nFUNC_REMAP_CLAMP(vec3)\nFUNC_REMAP_CLAMP(vec4)\n\nFUNC_REMAP01(float)\nFUNC_REMAP01(vec2)\nFUNC_REMAP01(vec3)\nFUNC_REMAP01(vec4)\n\nFUNC_LENGTH_SQ(vec2)\nFUNC_LENGTH_SQ(vec3)\nFUNC_LENGTH_SQ(vec4)\n\nFUNC_DIST_SQ(vec2)\nFUNC_DIST_SQ(vec3)\nFUNC_DIST_SQ(vec4)\n\nfloat chebyshev_dist(vec2 a, vec2 b)\n{\n    return max(abs(a.x - b.x), abs(a.y - b.y));\n}\n\nfloat chebyshev_dist(vec3 a, vec3 b)\n{\n    return max(\n        max(abs(a.x - b.x), abs(a.y - b.y)),\n        abs(a.z - b.z)\n    );\n}\n\nfloat chebyshev_dist(vec4 a, vec4 b)\n{\n    return max(\n        max(\n            max(abs(a.x - b.x), abs(a.y - b.y)),\n            abs(a.z - b.z)\n        ),\n        abs(a.w - b.w)\n    );\n}\n\n#define idiv_ceil(a, b) ((a + b - 1) / b)\n\nint iabs(int v)\n{\n    if (v < 0)\n    {\n        return -v;\n    }\n    return v;\n}\n\nint imin(int a, int b)\n{\n    if (a < b)\n    {\n        return a;\n    }\n    return b;\n}\n\nint imax(int a, int b)\n{\n    if (a > b)\n    {\n        return a;\n    }\n    return b;\n}\n\nint iclamp(int v, int start, int end)\n{\n    if (v < start)\n    {\n        v = start;\n    }\n    if (v > end)\n    {\n        v = end;\n    }\n    return v;\n}\n\nfloat min_component(vec2 v)\n{\n    return min(v.x, v.y);\n}\n\nfloat min_component(vec3 v)\n{\n    return min(min(v.x, v.y), v.z);\n}\n\nfloat min_component(vec4 v)\n{\n    return min(min(min(v.x, v.y), v.z), v.w);\n}\n\nfloat max_component(vec2 v)\n{\n    return max(v.x, v.y);\n}\n\nfloat max_component(vec3 v)\n{\n    return max(max(v.x, v.y), v.z);\n}\n\nfloat max_component(vec4 v)\n{\n    return max(max(max(v.x, v.y), v.z), v.w);\n}\n\nint min_component(ivec2 v)\n{\n    return imin(v.x, v.y);\n}\n\nint min_component(ivec3 v)\n{\n    return imin(imin(v.x, v.y), v.z);\n}\n\nint min_component(ivec4 v)\n{\n    return imin(imin(imin(v.x, v.y), v.z), v.w);\n}\n\nint max_component(ivec2 v)\n{\n    return imax(v.x, v.y);\n}\n\nint max_component(ivec3 v)\n{\n    return imax(imax(v.x, v.y), v.z);\n}\n\nint max_component(ivec4 v)\n{\n    return imax(imax(imax(v.x, v.y), v.z), v.w);\n}\n\n// credits to AHSEN (https://www.shadertoy.com/user/01000001)\n// https://www.desmos.com/calculator/5d6ph151vi interactive :D\nfloat bicubic(float a, float b, float c, float d, float t)\n{\n    float one = t - 1.;\n    float two = t - 2.;\n    float three = t - 3.;\n    return (\n        (-one * two * three * a)\n        + (t * one * two * d)\n        + (3. * t * two * three * b)\n        - (3. * t * one * three * c)\n    ) / 6.;\n}\n\n// |a| * |b| * sin(theta)\nfloat cross2d(vec2 a, vec2 b)\n{\n    return a.x * b.y - a.y * b.x;\n}\n\n// references for barycentric coordinates\n// https://www.desmos.com/calculator/8g8xjejuox\n// https://www.shadertoy.com/view/mdjBWK\n\nvec3 cartesian_to_barycentric(\n    vec2 p,\n    vec2 v0,\n    vec2 v1,\n    vec2 v2,\n    bool clamp_,\n    out bool p_is_outside\n)\n{\n    vec3 b = vec3(\n        cross2d(v1 - p, v2 - p),\n        cross2d(v2 - p, v0 - p),\n        cross2d(v0 - p, v1 - p)\n    ) / cross2d(v1 - v0, v2 - v0);\n    p_is_outside = min(min(b.x, b.y), b.z) < 0.;\n    if (clamp_)\n    {\n        b = max(b, 0.);\n        b /= (b.x + b.y + b.z);\n    }\n    return b;\n}\n\nvec3 cartesian_to_barycentric(\n    vec3 p,\n    vec3 v0,\n    vec3 v1,\n    vec3 v2,\n    bool clamp_,\n    out bool p_is_outside\n)\n{\n    vec3 b = vec3(\n        length(cross(v1 - p, v2 - p)),\n        length(cross(v2 - p, v0 - p)),\n        length(cross(v0 - p, v1 - p))\n    ) / length(cross(v1 - v0, v2 - v0));\n    p_is_outside = min(min(b.x, b.y), b.z) < 0.;\n    if (clamp_)\n    {\n        b = max(b, 0.);\n        b /= (b.x + b.y + b.z);\n    }\n    return b;\n}\n\nfloat barycentric_interpolate(vec3 b, float v0, float v1, float v2)\n{\n    return dot(b, vec3(v0, v1, v2));\n}\n\nvec2 barycentric_interpolate(vec3 b, vec2 v0, vec2 v1, vec2 v2)\n{\n    return b.x * v0 + b.y * v1 + b.z * v2;\n}\n\nvec3 barycentric_interpolate(vec3 b, vec3 v0, vec3 v1, vec3 v2)\n{\n    return b.x * v0 + b.y * v1 + b.z * v2;\n}\n\nvec4 barycentric_interpolate(vec3 b, vec4 v0, vec4 v1, vec4 v2)\n{\n    return b.x * v0 + b.y * v1 + b.z * v2;\n}\n\nfloat barycentric_interpolate(vec2 b, float v0, float v1, float v2)\n{\n    return barycentric_interpolate(\n        vec3(b.x, b.y, 1. - b.x - b.y),\n        v0, v1, v2\n    );\n}\n\nvec2 barycentric_interpolate(vec2 b, vec2 v0, vec2 v1, vec2 v2)\n{\n    return barycentric_interpolate(\n        vec3(b.x, b.y, 1. - b.x - b.y),\n        v0, v1, v2\n    );\n}\n\nvec3 barycentric_interpolate(vec2 b, vec3 v0, vec3 v1, vec3 v2)\n{\n    return barycentric_interpolate(\n        vec3(b.x, b.y, 1. - b.x - b.y),\n        v0, v1, v2\n    );\n}\n\nvec4 barycentric_interpolate(vec2 b, vec4 v0, vec4 v1, vec4 v2)\n{\n    return barycentric_interpolate(\n        vec3(b.x, b.y, 1. - b.x - b.y),\n        v0, v1, v2\n    );\n}\n\n// angle from 0 to TAU\nfloat get_angle(vec2 p)\n{\n    float a = atan(p.y, p.x);\n    if (a < 0.)\n    {\n        return a + TAU;\n    }\n    return a;\n}\n\nmat2 rotate_2d(float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(\n        c, s,\n        -s, c\n    );\n}\n\nvec3 spherical_to_cartesian(vec2 s)\n{\n    float sin_theta = sin(s.x);\n    return vec3(\n        sin_theta * cos(s.y),\n        sin_theta * sin(s.y),\n        cos(s.x)\n    );\n}\n\nvec2 screen_to_uv01(vec2 coord, vec2 res)\n{\n    return coord / res;\n}\n\nvec2 screen_to_uv_horizontal(vec2 coord, vec2 res)\n{\n    return (2. * coord - res) / res.x;\n}\n\nvec2 screen_to_uv_vertical(vec2 coord, vec2 res)\n{\n    return (2. * coord - res) / res.y;\n}\n\nvec2 screen_to_uv_fit(vec2 coord, vec2 res)\n{\n    return (2. * coord - res) / min_component(res);\n}\n\nvec2 screen_to_uv_fill(vec2 coord, vec2 res)\n{\n    return (2. * coord - res) / max_component(res);\n}\n\n// for some reason we can't use intBitsToFloat() or floatBitsToInt() to store\n// integers below this value in a buffer.\nconst int BUFFER_MIN_INTEGER = 8388608;\n\n// * x must not be higher than 4,286,578,688 (see BUFFER_MIN_INTEGER above)\n// * for your sanity, don't use negative values\nfloat encode_int_for_buffer(int v)\n{\n    return intBitsToFloat(v + BUFFER_MIN_INTEGER);\n}\n\nint decode_int_from_buffer(float v)\n{\n    return floatBitsToInt(v) - BUFFER_MIN_INTEGER;\n}\n\n// pack two 16-bit integers in a single 32-bit integer\n// * both arguments should be in the 0-65535 range\n// * a must be less than 65279 (see the functions above)\nint pack_i16(int a, int b)\n{\n    return (a << 16) | b;\n}\n\n// unpack two 16-bit integers from a single 32-bit integer\nvoid unpack_i16(int v, out int a, out int b)\n{\n    a = (v >> 16) & 65535;\n    b = v & 65535;\n}\n\n// unpack the first 16-bit integer from a 32-bit integer\nint unpack_i16_a(int v)\n{\n    return (v >> 16) & 65535;\n}\n\n// unpack the second 16-bit integer from a 32-bit integer\nint unpack_i16_b(int v)\n{\n    return v & 65535;\n}\n\nbool icoord_in_bounds(ivec2 icoord, ivec2 ires)\n{\n    return\n        icoord.x >= 0 &&\n        icoord.y >= 0 &&\n        icoord.x < ires.x &&\n        icoord.y < ires.y;\n}\n\nbool icoord_in_bounds(ivec3 icoord, ivec3 ires)\n{\n    return\n        icoord.x >= 0 &&\n        icoord.y >= 0 &&\n        icoord.z >= 0 &&\n        icoord.x < ires.x &&\n        icoord.y < ires.y &&\n        icoord.z < ires.z;\n}\n\nint icoord_to_idx(ivec2 icoord, ivec2 ires)\n{\n    return icoord.x + (icoord.y * ires.x);\n}\n\nint icoord_to_idx(ivec3 icoord, ivec3 ires)\n{\n    return icoord.x + (icoord.y * ires.x) + (icoord.z * ires.x * ires.y);\n}\n\nivec2 idx_to_icoord(int idx, ivec2 ires)\n{\n    return ivec2(idx % ires.x, idx / ires.x);\n}\n\nivec3 idx_to_icoord(int idx, ivec3 ires)\n{\n    return ivec3(\n        idx % ires.x,\n        (idx % (ires.x * ires.y)) / ires.x,\n        idx / (ires.x * ires.y)\n    );\n}\n\n\n\n/*___________________ SDF _____________________*/\n// source: https://iquilezles.org/articles/distfunctions2d/\n\nfloat sd_oriented_box(vec2 p, vec2 a, vec2 b, float thickness)\n{\n    float l = length(b-a);\n    vec2  d = (b-a)/l;\n    vec2  q = (p-(a+b)*0.5);\n          q = mat2(d.x,-d.y,d.y,d.x)*q;\n          q = abs(q)-vec2(l,thickness)*0.5;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0);    \n}\n",
     "name": "Common",
     "description": "",
     "type": "common"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "/*___________ audio (auto-generated) __________*/\n// the following code contains audio data and utility functions generated by a \n// custom python script and it's supposed to be used in Shadertoy.\n\nprecision highp float;\nprecision highp int;\n\n// the samples are 8-bit signed integers\nconst int audio_sample_rate = 4000;\nconst int audio_n_samples = 64000;\nconst float audio_duration = 16.0;\nconst int audio_n_ivec4_in_part = 4096;\nconst int audio_n_i32_in_part = 16384;\nconst int audio_n_i8_in_part = 65536;\nconst ivec4 audio_data_packed_part0[4000] = ivec4[](ivec4(16973824, 302975749, -150794989, 100528107), ivec4(235736075, 50132480, 487853323, 83887637), ivec4(15926281, 117047307, 992813335, -167242189), ivec4(-170406948, 419168262, 1127756842, 1500543596), ivec4(134684987, -1969826825, -590490695, -353235198), ivec4(-337057300, -404565553, -421798433, -572529171), ivec4(-16645912, -773650153, -742210606, -840565264), ivec4(772993999, 1683247438, 1835035259, 103569773), ivec4(571076332, 1415731775, -49531573, -809246468), ivec4(-840499986, -439241547, 67038962, -994982932), ivec4(-891428655, -740568636, 674502887, -638908646), ivec4(-1144861749, -908204341, 33019590, 1446515977), ivec4(1834905198, 373120624, -604241142, 438306263), ivec4(-168029155, 167046636, -1007545058, -525231707), ivec4(117501171, -237574915, -1059261955, -1110983487), ivec4(638967984, 288238632, -1230785827, -689513526), ivec4(-372519215, 1530534660, 1834572133, 626551918), ivec4(-318766314, 640287708, -420614655, 350938087), ivec4(-132831187, -1061302043, -472130357, -237183250), ivec4(-184875770, -1413228050, 568766363, 590356517), ivec4(-557066234, -807735054, -926954539, 1227360994), ivec4(1903192676, 1179801710, -32170710, 755955697), ivec4(236330026, -338504193, -16180732, -823854332), ivec4(-588254762, -960051767, -34936095, -908529669), ivec4(-136921154, 320215568, -691281653, -218890000), ivec4(-1361972230, 704830649, 2037930040, 1919511158), ivec4(68963428, -1384205, 573188636, -101448425), ivec4(-151059708, -553580043, -336072992, -353969705), ivec4(-472067104, -841552921, -523056693, 557462801), ivec4(-1228937476, -67901740, -857147141, 184474054), ivec4(1766204686, 1936088422, 725838202, -924777702), ivec4(470808543, -335869436, 167701480, -385805551), ivec4(-438252080, -68823077, -152641296, -1177689609), ivec4(-775241039, 1010902003, -369225188, -488779820), ivec4(-319752976, 419292638, 1716795950, 942358871), ivec4(759452248, -857604072, 420869327, -151454714), ivec4(234481385, 404497189, -740690425, -422592304), ivec4(-320344594, -807672848, -1380924980, 284938157), ivec4(84609551, 49145074, -134216434, 520618995), ivec4(1162365504, 539112774, -184084964, -892017421), ivec4(419289539, 388374047, -220600322, 824780567), ivec4(-285204436, -235142665, -370676491, -117835794), ivec4(-723456262, 15261398, 319485954, 335874321), ivec4(252845854, -184282088, 387978490, 387851040), ivec4(487919630, -1176767729, -187581522, 320542479), ivec4(-17499638, 118430987, -167177966, 185927922), ivec4(1182465, -287447827, -134086400, -185864206), ivec4(505420298, -50921451, 252974083, -184020716), ivec4(168822777, 235270641, 588910347, -470348255), ivec4(-842281257, 100791774, 50464010, 639702023), ivec4(-418900448, 268494550, 269683978, -68032005), ivec4(-285734903, -387521049, 471666937, 51517204), ivec4(-185798149, 84608000, 100727292, 352911615), ivec4(83226375, -16115948, -774446097, 129510), ivec4(-17437712, 656411908, 151853350, -84479494), ivec4(83489779, -101715195, 202050054, -824119041), ivec4(521073620, 287055394, -50924548, -202309626), ivec4(32829683, 286198025, 117903382, -84474868), ivec4(-521604616, 33551331, 185140230, 234418172), ivec4(303505437, -101645808, -167770617, -387980562), ivec4(286067192, -555222772, 50392286, 454364680), ivec4(33095954, 185141255, -538180852, 302776558), ivec4(135535388, 50595328, -790759930, 16179924), ivec4(286264068, 151127562, 33557267, 51255312), ivec4(-66317044, -235340806, 117173992, -352449778), ivec4(116516582, 421535511, -236393215, 185470207), ivec4(-285539064, -217709839, 101055470, 235142401), ivec4(-520615661, -556017705, 251719906, 185602837), ivec4(218828296, -285208299, 101251044, 49803764), ivec4(-16775165, -318896890, 351197911, 387199021), ivec4(-132570848, 116711896, -386857975, 319948016), ivec4(689766912, 65598222, 372586535, -253568537), ivec4(-606013960, 51251187, 671805937, -133883093), ivec4(101779453, 503440104, -252376031, -116453370), ivec4(-439498532, 51055104, 321001996, 284353781), ivec4(-554692835, 622460390, 184221458, -252180460), ivec4(252575986, -691217419, -184944147, 404623097), ivec4(233694713, 102314538, 151124215, -102108675), ivec4(-218889984, 488050171, -438769407, -150597632), ivec4(757404149, 15528975, -268364274, 15790056), ivec4(251527427, -201255406, 521406964, -909908730), ivec4(-168168486, 403967220, 15068418, 101850384), ivec4(151127806, -101909756, -352580864, 285274845), ivec4(-471728881, -83952662, 572197364, -35129590), ivec4(-99608051, 32895722, -202374395, 84873214), ivec4(538249464, -723584238, -353571877, 622395367), ivec4(-236321764, 388308487, 50002691, -33551866), ivec4(-251261691, 285339619, -487915503, 195051), ivec4(554761464, -336196574, 168887029, 16775936), ivec4(-134676477, 1313793, 520943345, -470150878), ivec4(-387457570, 218494444, 16778254, 269881871), ivec4(85004298, 33290750, -100399867, 33486323), ivec4(-67108350, -320543502, 639569658, -100527584), ivec4(50199806, -67108608, 235470586, 67174922), ivec4(219022594, 198409, -488576521, 167505640), ivec4(-100595446, 369689086, 51715868, 100858360), ivec4(-168296698, 83357681, -50067447, -454956814), ivec4(302316014, 202841627, -101253372, -33422336), ivec4(33092086, 252513031, 100532233, 396301), ivec4(-555684872, 150729190, 17239311, 151455231), ivec4(336859403, 67373330, -100925436, -168956429), ivec4(134546175, -521208569, 251588834, 85270042), ivec4(117637375, -16447995, -118098696, 100925949), ivec4(218366471, -33222120, -537920768, -68362792), ivec4(253104389, -196602, 219090439, 101057801), ivec4(135007499, -269947652, -50396932, -352845569), ivec4(83620073, 353964298, -16909304, 134414592), ivec4(-201456633, 84213751, 16580867, 320015113), ivec4(-470349295, -404694568, 269353459, 185008388), ivec4(151061772, 133902, 394499, -117637124), ivec4(-84413707, -252182786, -169089049, 623253512), ivec4(16580623, 33356541, -84475899, 592130), ivec4(-50200580, 285933817, -33290994, -589568271), ivec4(134543336, 67109641, 336331521, 200217), ivec4(-67041790, -235012098, 168164078, -117900797), ivec4(-354425871, 403769081, 84941856, -67503108), ivec4(-67372034, 83755006, -32830196, 168098806), ivec4(67700230, -421534216, 83885042, -50461175), ivec4(151520768, 370675978, 34081809, -151454981), ivec4(-84479244, 151651839, -521932799, 285209062), ivec4(17702174, 101451777, -168231425, 33750006), ivec4(134611969, 184811780, -66711020, -370874640), ivec4(251194605, 50662420, -66583045, 252646410), ivec4(-235272950, 252051959, -252776191, 590076), ivec4(-17237514, 185601548, -319158518, 100924143), ivec4(50396417, -453572610, 554105319, 622397212), ivec4(-166852592, -521345297, -455159343, -16842755), ivec4(99675639, 35071792, 304287233, 219607008), ivec4(-99743738, -249425691, -607722261, -251455970), ivec4(52230634, 368169705, 136058419, 1701391136), ivec4(824000329, 525103214, 777205796, -977742337), ivec4(-1903771152, -1112295522, -1332694055, 405029141), ivec4(286005265, -1062818610, -909718328, 318821822), ivec4(-1447899674, -35328046, 1666002702, 942748224), ivec4(1247637304, 1685280044, 591879742, 539316796), ivec4(252257559, -927280137, -1160590923, 284352447), ivec4(-621017334, 691680755, 354955798, -1247420424), ivec4(-1262105650, -52907377, -689778456, -234099793), ivec4(1363419647, 305412413, 894658864, 1414281510), ivec4(-115656645, 522660357, 134740497, -1279140611), ivec4(-1380266557, 149280712, -571339985, -149162537), ivec4(151848942, -1093345022, -1194010430, -641488464), ivec4(-656415240, -66722083, 1025378561, 304757078), ivec4(1028927508, 1329607226, 186857821, 203031817), ivec4(234813441, -840892125, -941895738, -103168829), ivec4(35398948, 202174966, 218431491, -740360167), ivec4(-403381546, -759185201, -571738378, -67772712), ivec4(857343479, 691754065, 976756760, 1093478185), ivec4(523523933, 269617167, -320277510, -403305468), ivec4(-538583333, -523319865, -49999874, 201126132), ivec4(-33751547, -655489531, -606613805, -841952804), ivec4(-319296035, -370810389, 352382953, 1279935278), ivec4(639116086, 573255465, 807937818, 152315696), ivec4(-83556862, -269554964, -471340305, -370877218), ivec4(67040236, -336462075, 302776562, -285998578), ivec4(-605557783, -892678703, -287057715, -100861195), ivec4(150401779, 925706526, 825506621, 589572138), ivec4(169024032, 437521671, 101585687, -67372032), ivec4(-387191308, -590162208, -67374103, -185008899), ivec4(-101124622, 50791166, -235472130, -774184471), ivec4(-674380086, 83948261, 67043590, 892479509), ivec4(590033976, 808661031, 354164779, 218827536), ivec4(84083465, 235669769, 84413968, -589041153), ivec4(16050400, 68095500, -134810374, -134679308), ivec4(16315893, -487523585, -758263591, -252976165), ivec4(-33819150, 774050821, 691353909, 303437854), ivec4(252711184, 33555467, -184877311, -370874128), ivec4(353437942, -453704688, -438248228, -151719443), ivec4(50395897, 16711426, 33554176, 16909317), ivec4(-420546304, -17239576, -252183297, 318894572), ivec4(522594336, 50858515, -403769604, -202643996), ivec4(-167968514, -639637266, -118298148, -50134018), ivec4(-219288590, 65784, 67042559, 505025549), ivec4(235935004, 168891668, -336463358, 168229869), ivec4(-100596215, -152311568, 403506686, 421339168), ivec4(-16512493, -202116361, 403768571, 17766427), ivec4(285736185, 101848596, 184481532, 353834771), ivec4(118230803, 264455, 370149123, 337518365), ivec4(-369819382, -303899681, 151651321, -252840706), ivec4(67174137, 16843783, 168627975, -151717632), ivec4(84212728, -50397696, 66976250, 66566), ivec4(-505287949, 49802727, 34081292, -83951876), ivec4(-134875403, 336396538, -150728940, -505618454), ivec4(-219025686, -33950223, 134875137, 198923), ivec4(-50594050, -84280836, -50989832, -117440000), ivec4(-370742802, 236259834, -521273851, 33552361), ivec4(49806588, 84216075, 303038729, 100465673), ivec4(319622656, -319226620, -320215317, -370610708), ivec4(554498798, 371403309, 134679307, -235601912), ivec4(251985398, 135600407, -320147460, 117504239), ivec4(34213391, -168691715, 185140989, -50198515), ivec4(319817730, 33688080, 336857344, -437322739), ivec4(49407466, -134283005, 32634608, 471734040), ivec4(-133692144, 67243262, -455086077, 572456415), ivec4(-419619028, 217374696, -284420854, 82505188), ivec4(388637216, -302583557, 470748671, 168036628), ivec4(623319303, -689438176, -34874406, 923147), ivec4(-118689550, 219681284, 50526208, 286528012), ivec4(-269551614, 218561776, -235274226, 100924151), ivec4(-167901947, -286725398, 303039735, 67700754), ivec4(67174148, -67633665, 555158270, -335276765), ivec4(-337125149, -168429838, 201259508, 252907789), ivec4(130825, 83951364, 1541, 83951869), ivec4(-201258997, -51123730, 252973575, -269814530), ivec4(67173106, 33619204, 286199309, -84146677), ivec4(151257081, 68096273, -235604738, -151653390), ivec4(-269947666, 504562936, 68033058, -262140), ivec4(-252445441, 302512881, 989465, -303503377), ivec4(67304949, -17039100, -131840, -134611712), ivec4(168034554, 34542608, 50068219, 84873741), ivec4(-353965835, 64243, -353701383, 100595952), ivec4(269751567, 34148625, -235406850, -51056658), ivec4(320081413, -252248054, -101322000, -286264072), ivec4(117570547, 725262, -151586824, 33619192), ivec4(302778372, 135205394, -319752705, -84611348), ivec4(-83951106, -329224, 135270151, -263169), ivec4(235998215, -235932928, 84279287, -269288188), ivec4(-134876175, -286000903, -101453330, 168625152), ivec4(-286067202, -353702932, -573318684, 554960626), ivec4(-50194909, 1665803529, 1416197747, 1179866700), ivec4(-419554249, -708131631, -1111634984, -657865533), ivec4(-622269209, -774454085, -1061372730, -842602029), ivec4(136654088, -287517713, -1128541203, -1111903054), ivec4(672134613, 1213352763, 1786147183, 1987604061), ivec4(1265131120, -66907857, 201117425, -369551581), ivec4(-133496588, -993007104, -1412377898, 454292950), ivec4(-253698818, 253690112, -655431942, -978018355), ivec4(-1850879784, -472927334, 454365964, 1417108556), ivec4(2003987036, 1161773661, 641743691, -857875453), ivec4(-507530544, -200270331, 259817, -1075643379), ivec4(-1262108988, 301521848, -135860213, 472191757), ivec4(-774053369, -1062421553, -924784171, -421738564), ivec4(202772483, 1279603747, 1986485311, 826036846), ivec4(943601981, -640028900, -590619949, -32239115), ivec4(100658414, -520221426, -741353515, -119682883), ivec4(-252248314, 757272573, -656013790, -1414741307), ivec4(-538585410, -85666859, 505946895, 925048598), ivec4(1699888180, 1112828022, 842480185, -622460902), ivec4(-707340332, 370737385, -84542199, -184613630), ivec4(-673850909, -253504813, -201719809, 504495856), ivec4(-487191527, -1111109930, -657209921, -203039272), ivec4(690099973, 757869098, 1009789225, 977686349), ivec4(858860846, -335472343, -572990752, 218298346), ivec4(50464270, -151058681, -657073174, -337322790), ivec4(-67043340, 50067706, -420284160, -875834918), ivec4(-320677680, -286529043, 555355129, 606283045), ivec4(791423272, 506015535, 403902483, 791575), ivec4(-471273738, -34345242, -33552890, -16776960), ivec4(-487787014, -388047907, 117833971, 218563588), ivec4(-184480494, -724576282, 33024733, 84150023), ivec4(404165131, 336926229, 488117525, 471998752), ivec4(-83885300, -134348550, -521602824, 116252382), ivec4(-419624437, 218231267, -487852274, -268304413), ivec4(132966637, -66841832, 521864187, -892276722), ivec4(33615056, 15986682, 68821526, 470481399), ivec4(-353632233, 909517050, -118490342, 102571798), ivec4(-35068948, -33487871, 690625287, -202113260), ivec4(35067144, 98885098, -268102126, 235401703), ivec4(-118094832, 102506253, -103099676, -385607919), ivec4(386065627, -352907745, 84148978, -18290438), ivec4(-184086770, 386461415, -605025765, 268496856), ivec4(235079185, 51715360, 117106412, -723323389), ivec4(454164701, -387516399, 270143488, 184283899), ivec4(-201456120, 387516661, -471532786, 135203838), ivec4(-1250566, -184349436, -84086291, -168888324), ivec4(219946507, -35857163, 203103763, 437386493), ivec4(-251783134, -50265096, -1776913, 85334036), ivec4(554759669, -167043805, 134281965, 184549897), ivec4(1186335, 184347885, -386135539, 572130792), ivec4(-437452008, 327929, 301855991, -302052591), ivec4(572195819, -403567070, 269816061, -101977084), ivec4(-218366467, 67366376, -218891261, 505619974), ivec4(-371529206, 151585536, 319091962, -318436337), ivec4(17431781, -269880070, 236066570, -68886019), ivec4(854276, -117970455, 152112639, 68032527), ivec4(-252577020, -263, -67900173, -117440000), ivec4(-185865487, 219024130, -117372660, -67767564), ivec4(-67239425, 16447482, 16975366, -34279689), ivec4(130814, -101255174, 118031871, -302645501), ivec4(218100202, 269751829, 263177, -235472132), ivec4(-202511124, 185008635, -269288185, 218759413), ivec4(-117372145, 151321845, 264200, -134939389), ivec4(117635834, -33814777, 151388161, -269288960), ivec4(100728054, 51121931, -34344202, 168756739), ivec4(319096582, -352318957, -51253017, -218761988), ivec4(353110010, -335479026, 201654772, -234749943), ivec4(621675254, -452782295, 217312228, -368635626), ivec4(604699366, -603908311, 267247312, -216654306), ivec4(233760992, 35330839, 234223346, -250536936), ivec4(32172255, -301462263, 234024156, -32500458), ivec4(554568180, -470086885, 553578711, -217112791), ivec4(217445090, -419228650, 469232087, -166452441), ivec4(182836698, -149807587, 115991004, 220143384), ivec4(217775096, -116714473, -68491038, 854792), ivec4(49278441, -16316662, 419823602, -251061725), ivec4(200401881, -65921762, 133491941, -150070759), ivec4(15524574, 85269271, -52174103, 85532183), ivec4(-253762584, 337384199, 234881278, 1251867), ivec4(-253565977, 590848, 49606893, -134084338), ivec4(268104427, -116187105, 149873888, -32039398), ivec4(65724639, -82568169, 82700003, -15328490), ivec4(-169810972, 119019790, -118688781, 855043), ivec4(419494386, 35135521, -68358418, -302251518), ivec4(301723618, -285143274, 402913257, -334947552), ivec4(200730590, 1448984, 116451822, -335278832), ivec4(217508322, -99411431, -84940052, -218102784), ivec4(184876534, -251788536, 453967093, -201256679), ivec4(134412536, -504101624, 201189346, -419886320), ivec4(554562280, -419027926, 201123553, -184413675), ivec4(319355383, -487387624, 184412645, -134149103), ivec4(117766905, -437913340, 454559480, -538707184), ivec4(774442740, -421001180, 521602034, -421268205), ivec4(117373684, -470414826, 689894368, 455020046), ivec4(202501085, -66254600, 234679550, -506530293), ivec4(472060416, 401332467, -301323722, -556803360), ivec4(758850564, -893066484, 1128871429, -555620597), ivec4(790756058, -655167189, 856418757, -1024316593), ivec4(-339161939, 658383654, -1699565, 522459419), ivec4(-758064895, 589028546, 352462640, 18022109), ivec4(-603187190, -760101938, 1179531030, -186377213), ivec4(336002835, -790167518, 822792889, 15481915), ivec4(68347107, -317586171, -962021166, 1296314878), ivec4(-100263420, -49540059, -941820658, 468436146), ivec4(201734704, 623375629, -116654306, -1247231782), ivec4(1110709728, -384559589, 1577744, -655425271), ivec4(586139588, -31441350, 234543363, -50397926), ivec4(-1195521052, 1093998822, -233501132, 119805185), ivec4(-604897030, 31310032, -14146794, 335279616), ivec4(167975722, -1346251527, 487058885, 134815033), ivec4(505612798, -402389504, -70139433, 624370963), ivec4(-34014210, -151249897, -1144267531, 537259206), ivec4(270418490, 403898375, -201460741, -355610142), ivec4(656281341, -151389429, 34675725, -739967993), ivec4(-18031929, -15260910, 437188864, 218629137), ivec4(-353963006, 285671414, -134349036, 790787), ivec4(-352912133, -135931682, 607068173, 269094166), ivec4(-17104885, -420743426, 168033263, -67105260), ivec4(135203584, -84083716, -185865486, 252577791), ivec4(-131577, 83820544, 118428431, -67108864), ivec4(-268762624, -17041681, 64764, -269750280), ivec4(285869052, 101124883, 395270, -168165632), ivec4(-33687305, -33357313, 202049280, -117637113), ivec4(-185602573, 134414589, 17107984, 65021), ivec4(134743297, 202180872, -83622135, -168562449), ivec4(-67174920, -34081287, 185272836, 265744), ivec4(67371520, 196866, -33554690, -33818116), ivec4(117702906, 50989578, -269683972, 33290228), ivec4(50859272, 134743299, 16974341, 201786112), ivec4(67570189, -84214785, -134612742, -152047886), ivec4(269157629, 118626583, -33619966, 64763), ivec4(100794623, -50331129, -50660870, 118031616), ivec4(-117899773, -33817863, -50396672, 134677503), ivec4(168429832, 134546181, -16776182, -67437827), ivec4(-50331648, -303172616, 134215665, 269751567), ivec4(329996, -84215300, 16446965, 67372549), ivec4(-84148221, 65788, -185205506, 50396149), ivec4(-67041785, -16974598, 151388672, 302778377), ivec4(-50197999, -252644104, -16778251, -201654275), ivec4(-17173263, 151586820, 101058568, 263944), ivec4(-118295043, 33554173, 16646146, 134874370), ivec4(-184746239, -17108755, 84412161, -84082686), ivec4(16843004, 201721092, 202314513, -285934073), ivec4(-84413457, -50397701, 100727031, 117901064), ivec4(-16908286, 101123585, -33487611, -33685762), ivec4(-134677251, 218562811, 527629, -135140107), ivec4(50396667, 16711681, 101255172, 33751554), ivec4(202180868, -67041783, -117901064, -117769223), ivec4(16249589, 319753224, -83949809, 16908284), ivec4(131329, 134676992, -151388156, 16381172), ivec4(118098438, -117966078, -33883397, -117965826), ivec4(168297214, 118230028, 117768192, -16776956), ivec4(-50726919, -83951616, -236064522, 201654521), ivec4(84479760, 16974596, -50397440, 100727544), ivec4(50726664, -84411906, 50660352, -84214014), ivec4(67305983, -168165630, 33421300, 286264327), ivec4(135138830, -335342078, -525325, 285667572), ivec4(-235343360, 168162295, 67634691, 234816268), ivec4(-302446571, -184155144, 269748216, 1441260), ivec4(623050981, -1582297340, 85603572, -84280577), ivec4(15921137, 1043008746, 165860609, 321662248), ivec4(-219282951, -858264600, 690491620, -222303738), ivec4(-253289686, -237434624, -319876301, 689907718), ivec4(-272499689, 101514731, 571404785, -268959453), ivec4(335603422, -723972825, 102898174, -31196164), ivec4(-301527819, 809106650, -1040837607, -184486425), ivec4(-554567415, -16972801, 539949805, -906549959), ivec4(2815960, 717821, -385542153, 81983735), ivec4(-317976530, 539227600, 386196989, -333377569), ivec4(-100799006, -332980480, 368964570, 184355336), ivec4(-149480198, -1442823, -300147690, -19083322), ivec4(16062995, -33025512, -236588287, 119937275), ivec4(100004837, -234481388, 16646399, -268896776), ivec4(454428920, -119020544, -285341942, 302053368), ivec4(-117571063, 791155714, -589565159, -167509512), ivec4(100730104, -336793089, 672529643, -420673751), ivec4(152177657, -67304709, -168231934, 436994294), ivec4(-487452894, 135202029, -84480015, 132356), ivec4(251853050, -638710505, 319354333, 320014604), ivec4(-32695528, -102243091, -318302708, 133555161), ivec4(167968004, -16380661, 66384630, -48551655), ivec4(150529763, 16515340, 67700224, 66845696), ivec4(-15460081, 15193823, 16780309, 33882627), ivec4(-252577537, 589960959, 83424268, -134213611), ivec4(-67372549, -488510988, 656409840, -135201766), ivec4(-150991609, 168362746, -168165371, 572131323), ivec4(-589828082, 235998449, 67373320, -319488509), ivec4(386136044, -521861866, 185665258, 201916930), ivec4(-16446194, 302053622, -521007592, -218435870), ivec4(100331248, 118626064, 117242365, -486534635), ivec4(218359004, 252315918, -150664689, -85137683), ivec4(-216720109, 133620194, 67594, -235209472), ivec4(-68097813, 270736912, 234615801, -151386867), ivec4(16973821, -404032773, 101582322, 82634734), ivec4(51189268, 151454978, -387452160, 538643187), ivec4(-202706167, 395266, 263681, -320015879), ivec4(656214002, -454559467, -67372816, 302580474), ivec4(17568790, 403768320, -622856946, 17170153), ivec4(16578551, -50067963, 352647157, -335999460), ivec4(151387631, 67436805, -117504504, 251391984), ivec4(-183755234, -50795031, 201456124, 51122704), ivec4(15723767, -133490413, 403372015, 202118428), ivec4(-66975993, -253237264, -66648067, 234746095), ivec4(151720469, -83886075, -84542981, 320673801), ivec4(-50857982, -67568130, 320014597, -235733751), ivec4(202180346, -84675583, -67174143, 201917953), ivec4(-67173624, 421072385, -168493810, -50397959), ivec4(-168626440, -50857738, 437849860, -235470061), ivec4(-117835278, 218497273, -33092593, 16578550), ivec4(-134939904, 16908798, 16645630, -134019065), ivec4(-118296592, -65283, 185337344, 151718923), ivec4(-100990970, 50264824, -269025789, -202379796), ivec4(302909179, 101585427, -50529025, -101058310), ivec4(134480124, 132359, 33685760, -117702654), ivec4(-67504138, 84345856, -100794366, -118098956), ivec4(218694398, 235867919, -151256566, -67635980), ivec4(-50331392, -134809864, 84147961, 117834500), ivec4(67240195, -67174654, 83885050, -184811000), ivec4(-101650959, 336793605, -235536373, -329999), ivec4(352583936, -234479577, -742666781, 856555769), ivec4(674708289, 134678547, 1952136208, 204956022), ivec4(-1079389197, -455884340, -1045049366, -1549424966), ivec4(-321996382, -318635265, -489892648, 958071805), ivec4(539768126, -605614801, -455492164, -724178702), ivec4(-1229868614, -203436602, 1666331662, 1061642084), ivec4(1851872319, 1348758898, 202384704, -303241991), ivec4(706153983, -788853214, -1178881350, -673722167), ivec4(-489894968, 823462649, 1482119235, -418433964), ivec4(-1548966223, -977882193, -572864576, -84479506), ivec4(1211638030, 909985867, 1548564782, 1415410027), ivec4(102377279, -286131206, 336133365, -520024559), ivec4(-1347769670, -741753161, -488777260, 437323763), ivec4(925905959, -267245773, -1297108796, -976962378), ivec4(-808400447, -269621293, 487193841, 1162364983), ivec4(1346384185, 1331258463, 338047551, -33157876), ivec4(50068217, -16117490, -1246050332, -1044858957), ivec4(-236463924, 471272957, 202512155, -151124213), ivec4(-926297882, -741553209, -488316965, -623125027), ivec4(15589595, 1616265761, 876234844, 724447023), ivec4(640100395, 354097179, -117834488, 219089665), ivec4(-1094263042, -371668031, 353306365, 168758801), ivec4(-286001408, 185073650, -606015229, -437919267), ivec4(-236263191, -505026835, 268629222, 1212692770), ivec4(-99865790, 302709748, 403771410, 51254039), ivec4(-235868169, -151981584, -470745601, 150530529), ivec4(303635478, -84016631, 100661239, 386860803), ivec4(-32498146, -353901075, -404427540, -185142290), ivec4(-50726667, 202048766, -32828912, 150728692), ivec4(404363794, 235933974, -605424125, 116975577), ivec4(236723734, -286131968, -396305, 67108865), ivec4(353504266, 504893969, 34676258, -202115848), ivec4(67107829, -117175284, -555883797, -152378143), ivec4(387387138, 151719444, 134678278, 437785870), ivec4(168957979, -252512512, -235539214, -538909462), ivec4(-17569567, 84281349, 218761221, 353373967), ivec4(556345375, -167571430, -656744472, -538977062), ivec4(-387850787, 16380909, 420745227, 707010843), ivec4(775041840, 337257256, -66646767, -437917714), ivec4(-370612250, -202445848, -84479245, -16777216), ivec4(353372674, 219222549, -33355509, -235670281), ivec4(-538712084, -454828066, -387916063, 134413553), ivec4(303107853, 219223059, 134744075, -50330874), ivec4(-218892551, 16710646, -65536, 134545920), ivec4(66310, -16711167, 100860158, 50594822), ivec4(201983749, 235670541, 185536783, 50661128), ivec4(-286066432, -235933972, 16644597, 134678018), ivec4(555487755, 252975648, 168561677, -50331130), ivec4(-134546179, -235801868, -454497297, -236198172), ivec4(235405559, 606083605, 589636900, 463389), ivec4(-454430728, -471736095, -505158172, -152049695), ivec4(84148733, 84149508, 235537926, 235867661), ivec4(-100793590, -303042059, -404296981, -67636243), ivec4(-65538, 100728317, 319884553, 252644624), ivec4(202181645, 50726665, 33685761, 202510343), ivec4(-268959996, -269619989, 134216179, 252909073), ivec4(50990350, -218826241, -17436176, 118033160), ivec4(-100858873, -117901064, -101255432, -185403655), ivec4(-168627467, 50264569, 555092483, 353966109), ivec4(-336793596, 66248929, 286592264, -555750141), ivec4(-304360746, 421006077, 84350232, 117441035), ivec4(219418120, -83357687, 419165175, -369359332), ivec4(-237053478, -99016181, 470677489, -65726194), ivec4(-809054228, 875699701, 52826637, -404093952), ivec4(132769517, -905563084, 723782864, 489038903), ivec4(-152239854, -1498099210, 603708860, 757996063), ivec4(-539765246, 621407963, 1349874781, -148826329), ivec4(-1447581507, -861893999, 1499805947, 644182884), ivec4(352908273, 1968843546, 1852994414, 324034410), ivec4(-1835553325, -1280664945, -1229603647, -1919702600), ivec4(-641689202, 824841970, -790694120, -1314939468), ivec4(-1415535699, 1815211974, 1852662126, 1060584016), ivec4(1614822470, 1769107568, 775372883, -1514679551), ivec4(-827878758, 218696435, -638055153, -406340927), ivec4(167966705, -1430134267, -1937205341, -1247372389), ivec4(973200065, 1852668264, 1599825527, 270351439), ivec4(1800618542, 675042924, -1429737705, -1365465946), ivec4(269152206, 263954, -859120657, 335871468), ivec4(-537192676, -1935559485, -1449814644, -271203397), ivec4(1802852641, 1247967085, -201059017, 487061476), ivec4(894458949, -1025111264, -1633312862, 65654193), ivec4(-235402479, -689640204, 134345689, 219812883), ivec4(-1261640193, -1835362658, -759450971, 1950880491), ivec4(1836411768, 472667231, 117636367, 1617315102), ivec4(-435344311, -1382046263, -422132814, -32303359), ivec4(-268829197, -51191836, 235409158, -907410675), ivec4(-1717589316, -1044994671, 974056917, 2070902374), ivec4(744122230, 134682649, 1816862987, 356211821), ivec4(-1514875414, -674448719, 319879133, -84086530), ivec4(-169086474, 51513848, -116782588, -1548697134), ivec4(-1298100325, 82564029, 1819366183, 1600943986), ivec4(270275884, 1109003278, 810573146, -1194141178), ivec4(-540493398, 66117605, -236456696, -370151698), ivec4(-17635347, 184479985, -975707133, -1533631310), ivec4(-169883720, 1883707906, 1566925672, 437201494), ivec4(622401558, 1550276930, -892204228, -1012031053), ivec4(-337779750, -134280960, -50596101, -404492303), ivec4(-506011922, -521404685, -1414086703, -170277455), ivec4(1059132937, 1297375852, -48808897, 285672196), ivec4(1447243807, -501857710, -1111961635, -437460531), ivec4(-269030174, -438509086, -639441169, -639833893), ivec4(68157931, -538578177, -573454129, 100727792), ivec4(1196182819, 894059336, 454695964, 891559967), ivec4(204292683, -1160916519, -202975549, -236789524), ivec4(-403771145, -269221644, -622601243, 284811733), ivec4(-116910057, -454955528, 370411763, 1179067154), ivec4(623260991, -168296423, 303107583, 910311717), ivec4(-303104476, -219554342, -605356800, -420942364), ivec4(-117313312, -219220487, 217640687, 288042017), ivec4(-470680835, 235205091, 773395217, 253963827), ivec4(-201322484, -33491731, 505218041, -773388270), ivec4(-556676400, -167247637, 50459620, 201389311), ivec4(-268698368, -387519766, 791089401, -16513253), ivec4(234548462, 252909079, 152508949, -403575567), ivec4(-203106085, 553842938, 304555303, -303239178), ivec4(285669874, -135600640, -17367555, 151455758), ivec4(-84150786, 924780540, -49994948, -539500814), ivec4(16710127, 336397824, -34343670, -118557698), ivec4(-33947392, 454695444, -454627574, 83225571), ivec4(-101578732, 202378502, 84809483, -320079355), ivec4(217508587, 220606498, -488114688, 235273453), ivec4(151521549, -353434868, -387386639, -16647441), ivec4(555685121, -33086679, -151850502, -369030403), ivec4(16117479, 218889983, -83687417, 15858173), ivec4(674309910, -521208304, -169353510, 33554434), ivec4(-16315129, -66048, 84082690, 302053119), ivec4(254289950, -269617664, -67374348, -67768081), ivec4(84282380, -201983228, -454037268, 655623410), ivec4(-133751506, -151917330, 236198666, 592396), ivec4(-269225228, -134941972, 33227520, 539172627), ivec4(-234812393, -394514, -235734779, 17237494), ivec4(397833, -67043581, 369817839, -82565855), ivec4(-505487128, 101185253, 117967365, -67372543), ivec4(50659582, -217774336, 269418480, -83620850), ivec4(-202118676, -83884293, 336593144, 51447817), ivec4(-118033166, -85202698, 472127752, -370149625), ivec4(369226220, 67897616, -320080643, -135073556), ivec4(134609913, 419887612, 371137822, -337120503), ivec4(-218896410, -51385876, 218103810, 50395912), ivec4(-67237371, 572264196, -487784939, -270344999), ivec4(201787655, -66910198, 50593018, 117506821), ivec4(-202837757, 319819269, -386595315, 100069100), ivec4(16711684, 330503, -286457850, -117376780), ivec4(369490159, 84942625, -185602824, 168825339), ivec4(-218694393, -118626325, 16710906, -67039733), ivec4(589304577, 1186852, -471997716, -185338124), ivec4(84148217, 17566210, 369623809, 83557390), ivec4(-15788525, -488509192, 235335658, 84216075), ivec4(-34012922, 16975367, -150599936, 268562670), ivec4(286595351, -370347518, 84411378, 151454209), ivec4(16842246, -67636491, -117569015, 454626815), ivec4(-150664947, 167244785, -100662001, -319622414), ivec4(16840941, 302579200, 285212167, 471801116), ivec4(-403700715, -84877606, 16315384, 134218499), ivec4(117507086, 169153547, 201521917, -67502581), ivec4(-202511888, 134876677, 33356803, 100661500), ivec4(16253190, -201982456, 403901696, -133753833), ivec4(-68688658, -16840951, -66976510, -134544899), ivec4(235273466, 16251914, 84415503, -185270004), ivec4(202705913, -303368960, -168955660, -50200067), ivec4(855811, 504628472, 34478883, -555881739), ivec4(-269158677, 134544371, 185599491, 235407879), ivec4(-218428139, 34342137, -302711559, 217903087), ivec4(-83884531, -66976258, 50660353, 50592506), ivec4(150532858, 269753114, -420414969, 151451879), ivec4(-131580, -84542721, -33752069, 18159369), ivec4(201456118, 84542987, -50856705, -134083320), ivec4(-202183699, -50530064, 117111550, 101191440), ivec4(354689297, -336133110, -118826018, -134545153), ivec4(-84083208, 202180609, 471600905, -101321210), ivec4(-33882624, -184878340, 219219190, 16579587), ivec4(16775680, -185074949, 460283, 572130813), ivec4(51187477, -186061319, 50989057, -185273865), ivec4(16380912, 352714496, -33682407, 168561153), ivec4(33884683, 134017528, -303040252, -135203599), ivec4(-33620482, 353239033, 504171025, 33952293), ivec4(-622858503, 83817444, -101386752, 66844408), ivec4(202117133, -83092970, 16643827, -33686018), ivec4(-68093954, 34148108, -66912003, -151520003), ivec4(-34606858, 1288, 253174035, -167902454), ivec4(251917036, -285734895, -353767696, -16778254), ivec4(320277248, 167705348, 168430094, -386727672), ivec4(-33292819, -151850248, -84413453, -33816836), ivec4(320477965, 186061581, -269157889, -85466391), ivec4(659208, -151389191, 218628089, 100729096), ivec4(-353568251, 197880, 101583875, 487719166), ivec4(-319747560, -437982736, -33491223, 269815038), ivec4(369492489, 976761370, 1734171207, 1533830761), ivec4(-1849036515, -1735356513, -1684760677, -876954954), ivec4(-572336689, -50924557, 842207233, -552201472), ivec4(-536650, -48487440, 66265381, -840901645), ivec4(49207743, 1868776225, 1702192480, 1566066534), ivec4(-520612309, -1312240447, -639249992, -507328822), ivec4(165085223, -556267494, -1379474171, -1179535699), ivec4(-120532287, 487131138, -371070438, 49269717), ivec4(890500346, 1701866332, 1600616558, 373707626), ivec4(-638588699, -706692426, -1060189765, 218499820), ivec4(-285198542, 50329348, -1244740384, -977025853), ivec4(-98697003, -469164023, -740960043, -35849742), ivec4(1514284337, 1769365317, 592266314, -772279327), ivec4(-1194339119, -1379219792, 32430004, 35526911), ivec4(-201585936, -875036926, -1178420287, 48614847), ivec4(-32829683, -640026372, 100335353, 1079128587), ivec4(2020701775, 861691758, -571275255, -908337699), ivec4(-875706168, -355350583, 369492228, -252382972), ivec4(-487130381, -1027423021, -539898430, 302122242), ivec4(-504564215, -152050982, 1126632446, 1701667924), ivec4(1465742448, 34415177, -605624336, -876363063), ivec4(-707670837, 117704169, -16510956, 34013693), ivec4(-1010247185, -909721665, -67177514, -66842357), ivec4(49802738, 672270598, 1582583106, 1433562979), ivec4(236730178, -101122038, -774578190, -825042986), ivec4(-236070708, -218498833, 167572208, -419952111), ivec4(-757934630, -185870640, -134219537, -270013454), ivec4(487721471, 1498761264, 1919574111, 439566169), ivec4(-252182779, -639307535, -505357612, -85401634), ivec4(-100927232, -303568657, -285409032, -892546338), ivec4(-321400372, 386728960, -218297837, 168098801), ivec4(791024396, 976367403, 556219207, 202181910), ivec4(185798922, -34015232, -521999626, -286330136), ivec4(-320081936, 252575731, -673123838, -758001966), ivec4(-252711714, -218564104, 83422700, 706417679), ivec4(724249905, 489633069, -134609646, 16315124), ivec4(33488385, 118165517, 202508803, -168034043), ivec4(16117487, -504366075, -589768742, -464416), ivec4(-100729092, -455088656, 50396401, 185405965), ivec4(589238542, 34148634, -196608, -33553148), ivec4(50923264, 16316414, 50331651, 67042817), ivec4(85137424, -572397323, -219684129, -185272583), ivec4(-403966986, 167966699, 404559376, 285805328), ivec4(-83619818, -286265101, 16775409, 403768833), ivec4(84348438, 199434, -67174144, 151848958), ivec4(-403900929, -118428696, 135007492, -150994172), ivec4(-135206163, 100794365, 50331909, 320543503), ivec4(-16776436, -16975365, -17105924, -184811004), ivec4(63729, 319883779, 572068628, -285274339), ivec4(-421273115, 33749228, 33619454, -50857473), ivec4(252578821, 17240082, 286262528, -201850615), ivec4(-135139087, 50594303, 151982087, -461056), ivec4(100728575, 185010697, 791828, -320148493), ivec4(167769839, 33687052, -201719548, 67304949), ivec4(33883139, 352715007, 68097819, -151454721), ivec4(-520, 33684732, -370544132, 100530675), ivec4(370742542, 354361369, -454429434, -253041182), ivec4(-151388679, -16712200, 168033274, 185339151), ivec4(-33816825, 17435653, -353702152, 50000106), ivec4(184944391, -251984628, -117968405, 202114557), ivec4(302777608, -336001265, -84874775, 168757504), ivec4(134611459, -185272576, -16776711, -151322625), ivec4(605883645, -269022951, 83883246, 50333195), ivec4(-168230396, -17502735, 403369970, 135010073), ivec4(-83557626, -438046476, 420019958, 656876326), ivec4(370549031, 639637526, -15985379, 386400254), ivec4(-487258089, -774844461, -370678053, -420615191), ivec4(-758132519, -236132129, -285935369, -84085009), ivec4(-387388173, 117241068, 202116365, 51122192), ivec4(285803264, 605885974, 1127427111, 1331652441), ivec4(623587904, 858991137, 320743472, -689769980), ivec4(-555886381, -134943260, 167835894, -83752435), ivec4(-353636878, -504631058, -640100134, -673917994), ivec4(-455089956, -219157271, 505154554, 199958), ivec4(605357826, 640364588, -16247264, 16380404), ivec4(387123715, 218763544, 85005843, -336661509), ivec4(16511981, -67504133, -286066437, -403968788), ivec4(-353703449, 134017260, -487654393, -539436581), ivec4(-151522324, -336464652, -152377624, 706614023), ivec4(539636015, 589965089, -117438187, 33355509), ivec4(67175432, 168692744, 50463494, 117834498), ivec4(218432518, -83290088, -505289747, 117568999), ivec4(-201654523, -656678423, -320346916, -134613261), ivec4(184546545, 219090961, 168101385, 270014994), ivec4(134876431, -185074943, -17304075, 134480384), ivec4(404888849, -218824693, 167769586, -33288945), ivec4(-404098568, 16313575, 303239175, 151192846), ivec4(659984, -505090827, -50860828, 100793851), ivec4(84412939, 168232451, 236000015, 387123978), ivec4(-336133619, -51451159, 236327946, -252116985), ivec4(-169022227, 151387899, -33553146, 353766914), ivec4(-83884014, 66712306, 50529544, -252314880), ivec4(-353769493, 83950319, 453971210, 202776870), ivec4(-100991743, 235669248, -269157112, -337123607), ivec4(150994422, 101190415, 487984135, -49867747), ivec4(-270145549, 168100603, 118165007, -202114559), ivec4(218495990, -151056620, -117440263, -370675976), ivec4(487456495, 286069533, 470748436, 1279800617), ivec4(1246846036, 440684880, -655889673, -1517711951), ivec4(-1012488564, -1479869711, -538521959, -1314597924), ivec4(16838092, -372193297, 470169631, -674311941), ivec4(-588516871, -119680315, 1347292192, 2019778899), ivec4(1852993902, 1262838128, -1495664122, 385136296), ivec4(-48810699, -503259658, -573050657, 117832151), ivec4(-1027943179, -824647753, -1009923611, 50921446), ivec4(-1026767125, 451671002, 1412707097, 1802662254), ivec4(1163354709, -771749809, -323245890, 103426829), ivec4(-355473164, -555949871, 419748570, -806677982), ivec4(-252851244, -656741651, 184543688, -909975036), ivec4(-34351420, 875896339, 1869376340, 927484771), ivec4(-469488862, -1415859774, 623050969, -789711870), ivec4(-774513958, -254685482, -620555257, -742340155), ivec4(-421008153, -35269409, -907277554, -473315382), ivec4(689046265, 1800880943, 1448306288, 523449933), ivec4(-1244930308, 368563126, -168032227, -622929185), ivec4(-538976809, 118819314, -825043476, -303044652), ivec4(-505682968, -66517002, -370547226, 336660728), ivec4(1294934814, 1365601384, 842416452, -385869267), ivec4(14798549, 102244630, -454758145, -606149914), ivec4(116974553, -589238015, -152380712, -571870215), ivec4(-530212, -286395138, 335869678, 706945052), ivec4(1297305146, 337783867, -150729458, -523053081), ivec4(471403255, -184546799, -132876, 151191037), ivec4(-571407602, -691286572, -302912286, -660504), ivec4(-201587965, -353965842, -17040140, 639569924), ivec4(202381858, 100925701, -252445436, 807604476), ivec4(169420339, -84675847, 218365951, 152575511), ivec4(-588976905, -135206688, -236262671, 117900284), ivec4(-285934334, -168431893, 167705333, 50859538), ivec4(-252445693, -370150415, 167439591, 337124114), ivec4(-218824693, 84017402, 168824073, -370347265), ivec4(-152180764, -218562561, 201916404, 202642962), ivec4(-17039354, -202050055, 84412411, 219155718), ivec4(253038348, -50725628, 336858887, -117306608), ivec4(151453173, 420744970, 34083096, -16974335), ivec4(-16119294, -135337231, 269091323, 264462), ivec4(33752579, 218956288, 134743304, -118032127), ivec4(-370347529, 252181740, 269882901, 117308163), ivec4(286461967, -167703279, -218959891, 201784823), ivec4(-84541946, 386926852, 68164124, -286002441), ivec4(15986414, 134613257, -33420530, -151257090), ivec4(16248048, 84215044, -303040511, 218628856), ivec4(202379533, 16579331, -50857732, -453903616), ivec4(16248035, 303501832, -84476920, -67503109), ivec4(84544002, -100530941, -202182670, -185798670), ivec4(201918207, -33026032, 134347254, 84347148), ivec4(-269420031, -134809354, -16579845, 49804022), ivec4(488116490, -285471720, -252645394, 184875763), ivec4(185141002, -67567609, -201654786, 50527732), ivec4(263427, -17501447, 168627719, -50001398), ivec4(197114, -33620997, -421072904, 268959473), ivec4(102047003, -67504394, 184746237, 67571217), ivec4(-302579966, -117967634, 66843380, 269289478), ivec4(-83883761, 168494335, -50331902, -51056909), ivec4(-33883138, -201588993, 285801200, 337386261), ivec4(-370610173, -151785750, 151783422, 67568900), ivec4(-67333, -134939649, -33686020, -134283009), ivec4(134215922, 134613260, -33881593, -117505022), ivec4(-252446729, -118758167, 471141637, -184742117), ivec4(50198773, 252512260, -50594040, -202509573), ivec4(-100729608, 134545659, 303041801, 16646155), ivec4(395524, -201655041, 50527219, -514), ivec4(-101254145, 403967746, -49342180, -236197652), ivec4(151256826, 34017039, -50067452, 84214784), ivec4(-67569666, 50265341, -16841209, 269420288), ivec4(134744587, 100728579, -151519225, -336530444), ivec4(235140588, 370875156, -168560377, 151520764), ivec4(-16184053, -134744585, -50727694, -84279296), ivec4(134546430, 169088013, 50331650, -100859899), ivec4(-118031878, -16513280, -16843266, 167836666), ivec4(336991507, -386792946, 16313574, 252512260), ivec4(33554696, 67240454, -150994173, -134876688), ivec4(185007864, 33686023, 168561927, 50791942), ivec4(17039358, -269421576, -185602320, 420744192), ivec4(17766170, 16118262, 134744327, -218693625), ivec4(-84346894, 67239934, -17303297, 285803522), ivec4(-16445162, -132871, -33883395, 50002429), ivec4(-50527994, -67372038, 269091325, 50924816), ivec4(-370742537, 218628341, 51122191, 16841724), ivec4(-33554175, -353437700, -395794, 135138822), ivec4(83886597, 33884169, -168034046, -201852170), ivec4(-185405455, 167902712, 286529044, -235470067), ivec4(100726255, 263944, -118229252, 16908543), ivec4(-83886080, 117504503, 404296718, -336133618), ivec4(-185405206, 16841976, 387123202, 118428693), ivec4(67503879, 263684, -487853320, -270344481), ivec4(437454844, 925771552, 1499223880, 1094468176), ivec4(455489089, -403439087, -1768049458, -1701935220), ivec4(-1095127390, -673787197, -521607973, -472065578), ivec4(554371324, -889771983, -1043213358, -320220730), ivec4(2037867775, 2121289828, 1330139505, 754983223), ivec4(371725357, -215675148, -1314482000, 301849026), ivec4(-586615315, -1074326809, -1718905705, -840513102), ivec4(-824968235, -1546718210, 14007991, 1381918506), ivec4(2120440673, 1126253412, 34081584, 772344341), ivec4(538965529, -960709360, -203434561, -33293584), ivec4(83619799, -1127565892, -403973174, -485684482), ivec4(-1141510934, -1062029929, 1327370981, 1566339422), ivec4(188636761, -421592551, 150791935, -185401576), ivec4(-1129385978, 13875397, 487851252, -18027510), ivec4(-792937216, -403979591, 454887919, -51252999), ivec4(-1397120068, 554431674, 1567581257, 1148411227), ivec4(-335140064, 167119365, -99734492, -1226635539), ivec4(-709442873, 385675767, -571208924, -826151427), ivec4(-439895604, 486597343, -119078123, -1078345741), ivec4(183746739, 1801929240, 1868517475, 102766907), ivec4(135728623, 842874136, -368574711, -1178088508), ivec4(-17041445, -165927645, -857216802, -843000887), ivec4(82111459, -149675494, -958269703, -322257462), ivec4(1631327241, 1078421867, 135541305, 16051193), ivec4(589365757, -100200917, -605949697, 335736797), ivec4(690827544, -589828863, -976695587, -404433204), ivec4(168954366, -152046589, -808923936, 671742431), ivec4(759318848, 118489622, -370677003, 503904758), ivec4(270280742, -184220419, 183955695, 774774550), ivec4(-554430681, -353768738, -236197910, 151125235), ivec4(-403505398, -606346774, 200927710, 926363167), ivec4(-117896669, -201919243, -67636495, 269617154), ivec4(-33488375, 201917949, 522198034, -217442277), ivec4(-488512797, -370151187, -269685781, 134809853), ivec4(-101120759, -84609289, 319555585, -235337452), ivec4(-151983635, 64762, 269026306, 151784979), ivec4(-256, 218694912, 84478476, -252513800), ivec4(16842229, -218629120, -133904, -184942336), ivec4(-168693775, 353306365, 68361243, -219090180), ivec4(16644853, -33751296, 67174912, 16776961), ivec4(319620353, 269751831, -269025782, -168562708), ivec4(-168298249, 49935346, 202444553, -134611194), ivec4(184876536, 118493198, -370544133, 16380652), ivec4(185403910, 117967112, -84016891, -118164747), ivec4(185140477, 330253, 16644603, -33488895), ivec4(-134940679, 50594044, -168100607, 100464627), ivec4(589371923, -201454053, -168693778, 16842748), ivec4(-66304, 16777474, 16580353, 302777603), ivec4(236000534, -218826492, -168693517, -168561419), ivec4(269025531, 67768081, -118032644, 386926848), ivec4(-83356906, -269619984, 134479348, 118098444), ivec4(84412936, -201653757, -50990351, 336727556), ivec4(34017044, -50462462, -185009413, 16513013), ivec4(84281093, -168363263, 386597113, 303964704), ivec4(-319883773, -101453845, -50462979, 33619451), ivec4(50791682, -84280578, 235537149, 658958), ivec4(-218826501, -185273615, -118098958, 117835262), ivec4(-168099577, 66843889, 286659854, -252379381), ivec4(-168759570, -16711685, -17171972, 117899777), ivec4(-336463358, -34279959, 336660996, 84478734), ivec4(-67305726, -319621383, -572596253, -707076899), ivec4(-657338415, 319290088, 337585438, -84213236), ivec4(-201458440, -135271190, 656280832, 842149675), ivec4(942287663, 1296583750, 1196973400, 1027093045), ivec4(758463806, 186525984, 689904914, 1598167063), ivec4(1600212303, 1230594670, -1126364631, -607994425), ivec4(-1111962653, -858992190, -1733840695, -1734373241), ivec4(-1162829173, -1176709210, -1782979367, -1297506666), ivec4(-827282004, -218698015, -771952133, -1613117761), ivec4(-52176206, -774976795, 473706249, 166457599), ivec4(805968706, 1177765461, 994797172, 638861892), ivec4(1330330420, 1799033407, 1466459743, 588648499), ivec4(423235619, 1444224313, 525757538, -402197245), ivec4(-266538780, 940174818, 274751018, -892870649), ivec4(-16909831, 1073747221, 442778417, -454363381), ivec4(-268634893, 116063973, 20002583, -876945167), ivec4(-69152278, -186780460, 270662139, -1564361287), ivec4(-944131425, -740433475, 404956161, -791551764), ivec4(-404622902, -758516753, 657264896, -824839165), ivec4(-591078443, -521600005, 992750875, -890568681), ivec4(-689903673, -773132571, 673325300, -1076498920), ivec4(-640627003, -503975183, 1127226614, -369157310), ivec4(-706811935, -235015190, 1279732987, -823454141), ivec4(-757936187, -251922712, 1228609520, -250531251), ivec4(-874916133, -370152744, 689634016, -183688401), ivec4(-471146267, 235537903, 1514348040, 53300320), ivec4(-606283545, 336396261, 941754889, 405552454), ivec4(-201918204, 151256302, 806484737, 287850052), ivec4(-437981700, 33617894, 402451450, 472331052), ivec4(-286328055, 420610288, 503974169, 404827432), ivec4(-168558841, 17170424, -119281158, 488776204), ivec4(-370213622, 184677100, 16123406, 320675852), ivec4(-437389308, -118627869, -219547141, 522526470), ivec4(-66909931, 184744441, -555680762, 202243818), ivec4(-403177462, -203236385, -84278789, 455283462), ivec4(-386465003, -152575520, -437126406, 420806127), ivec4(-285274853, -253566493, -285212421, 487652082), ivec4(320413733, 454037005, 490223662, -32963058), ivec4(-1733572635, -1718777204, -925974352, 82761417), ivec4(202248718, -33881849, 371136269, 588647689), ivec4(-150727137, -690561560, -118298400, 974455541), ivec4(2105044310, 1735423353, 1600679018, 252848192), ivec4(-571342584, -1161903412, -539833921, -136061219), ivec4(-32631800, -841621524, -219751730, -405020693), ivec4(-167705606, -707075348, 352250584, 1345988898), ivec4(1836281444, 1214080617, 455487026, -370346484), ivec4(-151061771, -942481428, -522860095, -387192083), ivec4(-50267406, -454628108, -387521823, -572002830), ivec4(-336664353, -640230687, 486730718, 1751669313), ivec4(1886876521, 69419614, -842346778, -723853351), ivec4(-269754412, -707076120, -472330032, -437390353), ivec4(66644963, -268631034, -556148512, -420943131), ivec4(32959204, 269421832, 1160847126, 1684497240), ivec4(1280267354, -99669696, -690299159, -539108651), ivec4(-455288100, -286199828, -538777877, -219223839), ivec4(151190261, -403439864, -791620131, -51189800), ivec4(706349827, 1111703607, 606680125, 539305250), ivec4(135271963, -134348282, -488512019, -488381213), ivec4(-135074844, -285671940, -690628383, -185867558), ivec4(16974589, -218563328, -118165523, 218497019), ivec4(690232597, 472000296, 320082965, 218893070), ivec4(-50330872, -370215687, -656613661, -270411820), ivec4(168100089, -168033271, -185602319, 50593272), ivec4(-33817602, 168034559, 235933453, 437720079), ivec4(505355293, 84347927, -65533, 0), ivec4(-84280577, -336201733, -270150961, 302778623), ivec4(17897751, -405083148, -17565186, 622460659), ivec4(202644520, 185667852, -252710144, 284886013), ivec4(1733439520, 1180259684, 1982013, -1077880834), ivec4(-926497863, -287188013, -1027027475, -1397112398), ivec4(-1247433295, 353235406, 656286745, -117895892), ivec4(-722539043, -876095788, 991557343, 1785162316), ivec4(1616474745, 204484677, -353435909, 487457015), ivec4(-520880375, -976889380, -606222646, -706878248), ivec4(369094622, -554303979, -1093805352, -455621429), ivec4(-168302115, 1159727869, 1499880806, 440224591), ivec4(-117898729, -875047972, -455684923, -370347269), ivec4(-185078556, 335479545, -100335347, -220013342), ivec4(67374347, 168362491, 1328753675, 1633769050), ivec4(589903434, 589509930, 319951640, -50461440), ivec4(-572594180, -859322673, 33423327, 168033792), ivec4(-470550018, -741155095, -724974129, 572132072), ivec4(1076832558, 1196704841, 405094476, -588844279), ivec4(-184948778, -235800835, -605822991, -690692130), ivec4(-404561439, 185924844, -454626298, -656810777), ivec4(-572464938, 49935080, 1885022478, 1314812792), ivec4(303574850, -436796411, -858596385, -556678715), ivec4(-437918241, -152113175, -16514823, -470548994), ivec4(-556544555, -589504803, -724763, 656479242), ivec4(1162231346, 1077294913, 270609722, -218826498), ivec4(-151389707, -689903120, -943733299, -185802795), ivec4(134742522, -167967734, -504960784, -421667619), ivec4(285671157, 1177953560, 1263686991, 590100803), ivec4(-66973670, 198146, -403901957, -538911008), ivec4(-556082210, -370678301, 50527729, -168297472), ivec4(-505157651, -219485981, 386795004, 1447705383), ivec4(1516068190, 590626639, -235405038, -286134033), ivec4(-353307922, -622992666, -152313894, 218958336), ivec4(-201324275, -639638294, -539240490, -101915422), ivec4(1026497287, 1583240521, 1196907613, 119023928), ivec4(-387123971, -336992024, -437917718, -404496158), ivec4(-235868951, -185602320, 64760, -471207688), ivec4(-505685539, 201323240, 723985432, 1296185137), ivec4(893338954, 135009573, 50528514, -184548093), ivec4(-572397329, -556082983, -404495391, -202248212), ivec4(-387124750, -219289370, -101189898, 83951098), ivec4(538513676, 522660134, 101191447, 118033161), ivec4(-134545661, -151652874, -252513547, -286396689), ivec4(-101256207, -83952133, -185338891, -202116108), ivec4(100464372, 589503762, 454959139, 404231703), ivec4(84479508, -370149376, -151785751, -185141001), ivec4(-135073807, -131589, -218431744, -455023639), ivec4(-50859542, 33554174, 168166661, 387388688), ivec4(353703190, 67636499, -117834751, -286198023), ivec4(-218827793, -269882642, -66571, -101254402), ivec4(-16645122, 67437056, -185272064, 370017532), ivec4(286595867, -33355507, -16908804, 16712193), ivec4(33949187, -50462720, -134545923, -185404684), ivec4(-303041034, -16975887, 84017407, 353833484), ivec4(202182161, -50066931, 83950585, 202246663), ivec4(-83885048, -168627467, -33488645, -84215045), ivec4(67173369, -50331646, -118164233, -50068736), ivec4(-84413194, 218628863, 404033806, 67570708), ivec4(-100794367, -202379277, 218694651, -50199287), ivec4(-185602316, 67173881, -50725887, 134744067), ivec4(219154694, -84412928, 66843895, -101255424), ivec4(219089407, 286397457, -16514297, 17039870), ivec4(-352912901, 33881072, 135467009, -50725379), ivec4(150860277, 135203604, -16581391, 186056425), ivec4(135334403, 168359161, 149941755, 83689988), ivec4(-151650802, -386339355, 656740352, -334877653), ivec4(234740943, 69217051, -422457370, 554563560), ivec4(404960047, -1076296431, 67035074, 69347340), ivec4(-470878730, 136121063, 118290931, -15987960), ivec4(-489963044, -621938441, 287906032, 1499342595), ivec4(1784891969, -249611183, -1397049135, -1145003625), ivec4(-1399355236, -725042769, -791686950, 152239583), ivec4(487321842, -672798204, -978542673, 1563491550), ivec4(2104718195, 1684434042, 1346126420, 624178759), ivec4(-605684979, -656615469, -726290750, -539634210), ivec4(-927283748, -1177822245, -1651337820, 30850993), ivec4(1194537513, 2038265963, 861101668, -84938995), ivec4(-422124551, -335540218, -741284114, 33616869), ivec4(-370281475, -302317837, -1043078937, 216453310), ivec4(1581990451, 1616864875, 405883480, 371731737), ivec4(-503838971, -34149663, -842080785, -640165935), ivec4(-690234408, -488911930, -942874909, -1044987192), ivec4(353632220, 2053522721, 1449090159, 320284474), ivec4(-622197484, -101652771, -723918607, -573583917), ivec4(67830767, -503905789, -943010605, -473252417), ivec4(588253953, 1481456943, 1079734124, 387917359), ivec4(-16183018, -454757641, -235012361, -537530392), ivec4(-674380343, -489302565, -975375120, -960051514), ivec4(420607700, 1211505683, 1651537246, 440423256), ivec4(488115717, 269157136, -790761471, -909653812), ivec4(-167843118, -201590547, -488251163, -909918000), ivec4(167831505, 874909966, 1851867953, 1364880245), ivec4(-184542658, -184880400, 185596655, -539504925), ivec4(-422129189, -757865489, -370746410, -775106081), ivec4(-69548339, 858333971, 927221826, 1009919528), ivec4(790437937, 335942707, 169089561, -840959741), ivec4(-388904503, -67239430, -757929733, -387851049), ivec4(185466863, -17499645, 369755654, 303640363), ivec4(152247067, 101913610, -462601, -521405693), ivec4(-757472803, 403503586, 168626452, -707468554), ivec4(33289448, 69215246, 151388926, 117767940), ivec4(-185469952, 438178816, 34079503, -219353869), ivec4(-84805380, -268894463, -134612497, 101382901), ivec4(470547963, 202184480, -572591353, 33222629), ivec4(-151650554, 167439341, 471935516, -570681565), ivec4(-320877110, 571145974, -67696865, 33950214), ivec4(-116909808, 33223412, -167966972, -555750154), ivec4(-84151836, 623121408, 134615068, -151122672), ivec4(-168230143, 185534717, -167047931, -51452440), ivec4(51318276, -201521404, 235733495, 51053826), ivec4(-572594188, 201520104, 287845143, 269684232), ivec4(16709118, -236262412, 337383682, -117441792), ivec4(117240045, 353045007, -386398700, -151720988), ivec4(-67244050, 486732271, 724249391, -336132068), ivec4(218034408, 33686285, -101519109, 83689984), ivec4(-335541230, -152511530, 504102912, -118162412), ivec4(-134807811, -168165122, 403505658, 50861340), ivec4(-320080127, 17038321, 437851400, -168889849), ivec4(-33815038, -134807807, 169086464, -352780028), ivec4(-388245796, 33751027, 269489676, 319950353), ivec4(185601036, -370938112, 261872, -150729980), ivec4(235668217, -202248194, -202905106, 185798147), ivec4(-285870082, 66186219, 605951246, -470676707), ivec4(16444645, -117770245, 301921520, 353968420), ivec4(-403636214, 66317547, 252380937, -269222650), ivec4(-152178189, -403045372, 285208290, 471539230), ivec4(84281619, -67105007, -252249345, 66910191), ivec4(67570188, -420941056, 84279792, 35069716), ivec4(-455351824, -387319053, 487918848, 405812263), ivec4(-100462581, -521935636, 67302113, 269882892), ivec4(218826246, 34278923, -202970117, 51778821), ivec4(-437324043, 50524901, 84214014, 268894722), ivec4(539171346, -150663404, -51584537, 505155590), ivec4(-470940137, 33550565, 33420277, 386597122), ivec4(-50462192, -420547338, 335408871, 673520411), ivec4(-67236833, 16646399, -336464390, 402978286), ivec4(185208860, 201787145, 67176462, -16316151), ivec4(-151916043, 67109378, -185271039, 538118657), ivec4(169616426, -185207818, -337121291, 201522678), ivec4(856851, -303238920, -404561690, 134941174), ivec4(-184481781, 117569263, -33751036, 150532857), ivec4(169549848, -218629889, -168562449, 16777465), ivec4(-185139964, 252378099, 199183, 167638261), ivec4(168825616, -387517437, -101125906, 285671673), ivec4(589570587, 151916314, -538445308, 234614245), ivec4(303503638, -286591994, -117703688, -252315145), ivec4(16513523, -168758020, -202048514, 83951609), ivec4(152508171, -151913984, -252248577, -168627729), ivec4(319818752, -167836147, -83886347, -168296962), ivec4(16974329, -151257088, -353109767, -101653536), ivec4(757997833, -32827101, -67109127, -17041413), ivec4(100924923, -117043959, -66978315, -17042445), ivec4(185206016, -185470206, 202178803, 84148230), ivec4(471008771, 34741790, -336661767, -68098588), ivec4(386859518, 168431383, 235734274, -320145915), ivec4(167637746, 528401, -218695944, -84677140), ivec4(437060608, 253041443, 50266119, -67699712), ivec4(235471361, -184414961, -724495, -134610941), ivec4(16579576, 67372037, -84215298, -84608262), ivec4(353176324, 354493472, -17104887, -487984647), ivec4(33025249, 320477712, 50397706, -50592762), ivec4(-101188610, -16712200, -67438083, -202049288), ivec4(285671156, 489040673, -185403894, 16842489), ivec4(151258115, 84478472, -101187578, -218694915), ivec4(-135140116, 201851131, -50659318, -100662784), ivec4(49805562, 639703567, -33352670, -319620865), ivec4(-101387799, 185009408, 1804, 84346885), ivec4(-117964795, 16843004, -437321727, -202050064), ivec4(50265078, 538909198, -83488229, -218695433), ivec4(-521, 134942473, -150794742, 262393), ivec4(-538317065, -528928, 34410504, -50133761), ivec4(16513274, 370543878, -49474798, -168036109), ivec4(-168299790, 168099574, 462093, 33420018), ivec4(-16711680, 33684988, -151126016, -202182160), ivec4(-202511377, 420348153, 354229789, -117900797), ivec4(-67503623, 83753468, 84411654, 167902720), ivec4(-352977145, -286463514, 67173366, 16513536), ivec4(16448255, 370018566, 236657692, -353832707), ivec4(-134941455, 100859898, 168627470, 16579071), ivec4(-117768192, -84412425, 84083714, -151453947), ivec4(-218892553, -199442, 471536391, 17173527), ivec4(132609, 117505280, 50595081, -33817343), ivec4(461315, -252381703, 49935343, -134610935), ivec4(-117901835, 420217595, 690956834, -302708450), ivec4(-269553425, -118230543, 201851644, 134876431), ivec4(134809350, 16646920, 134414851, -117570039), ivec4(-84083719, -185733387, 202181632, -150794224), ivec4(16972789, 370017536, 707537697, 976763445), ivec4(860445007, -993134568, -2086355250, -1632132718), ivec4(-1801675377, -842353267, -759909430, 572917757), ivec4(-891494919, -405223997, -338505000, 2004771376), ivec4(1987476346, 1315468404, -150132166, 389747434), ivec4(51380462, -1328159531, -1414999613, -521019443), ivec4(-1313227321, -1061573210, -826564697, 1513881078), ivec4(1970240350, 1062429023, -1193802712, 301525971), ivec4(-285396412, -793192230, -1280915476, -66974208), ivec4(34087684, -372989250, -994725944, 1311438065), ivec4(1753051478, 1380339553, -990441157, 84798946), ivec4(138161398, -589380659, -1580877893, -136386092), ivec4(-486270455, -777079849, -1395083319, 267382472), ivec4(1752846638, 1617326447, -1006622640, -389616434), ivec4(539295756, -556078871, -858671661, -638528612), ivec4(34997230, -1261249058, -1044129587, -135539785), ivec4(1683835921, 1566012272, 221924971, -488118294), ivec4(604771076, -689367761, -993337882, -891631943), ivec4(-201326633, -672797460, -639110690, -556283185), ivec4(1379079935, 1465802336, 758531407, 33883930), ivec4(488510470, -234744291, -774514209, -657865784), ivec4(201851117, -353042682, -471407648, -808594467), ivec4(319091935, 1195916841, 758593854, -134543848), ivec4(353306365, 270278684, -134151675, -707469330), ivec4(-34084130, 17171457, 63738, -386795267), ivec4(-17502746, 790959370, 438577456, -504891640), ivec4(251850980, 169088535, -202378498, -538513677), ivec4(-219289633, 453902328, 387323675, -352909291), ivec4(-337255711, 251853297, 706813207, -15589333), ivec4(-51055886, 286066434, -319686137, -370611476), ivec4(-50859283, 16580092, 67307270, -218101750), ivec4(-320545053, 369622773, 455024670, -83422440), ivec4(-236262928, 336200442, 84810526, -184746240), ivec4(-67637267, -118032389, 16579837, 101651210), ivec4(-639900167, -219685159, 151718400, 33884169), ivec4(67240191, 286001930, 17239571, -168231681), ivec4(-303437073, 117833717, 168760077, 185272841), ivec4(-521603325, -421601826, 538511350, 186065185), ivec4(-437784064, -50859799, -150993918, 83884534), ivec4(17040645, -33685247, 218825984, 202379019), ivec4(-100792822, -219025165, 302646008, 219420181), ivec4(-218497017, 33289198, 168758793, -218563840), ivec4(-168627472, -370413836, 133820136, 454694674), ivec4(922389, -286199049, 201323757, 471405584), ivec4(269752604, -100990966, -118033164, -286329865), ivec4(-594195, 185733898, -101320959, 201522427), ivec4(152047632, -370346751, 49934826, 370414863), ivec4(269488148, 168825617, -134743293, -16909833), ivec4(83951616, -33224182, -387321865, -135204628), ivec4(504892162, -16182504, -286461705, 134545655), ivec4(84281095, 353569800, -83752175, -387189769), ivec4(16183274, 286527239, 1292, 33817346), ivec4(269355782, -67041523, -471339788, 150926568), ivec4(286331409, 269619216, -16644083, -370084357), ivec4(-84940571, 353767944, -218364402, -118231056), ivec4(151257599, 117900809, 330250, 33685501), ivec4(16909316, 134744069, -117571838, -235275529), ivec4(-303503380, 33618675, -117438457, -50990605), ivec4(370412287, 151983384, -235406078, 117503727), ivec4(269357327, 454562320, 236066587, -134413816), ivec4(-218894353, 50264564, 303239177, -134611449), ivec4(16513014, 218892035, 151785231, 504367112), ivec4(808199458, 1128743480, 219884601, -874912008), ivec4(-893337148, -488778031, -538647324, -623782437), ivec4(-235936031, -67832590, -84214272, -151588106), ivec4(134414072, -100990969, 168032758, 471669780), ivec4(269358105, 706550041, 960314679, 152116010), ivec4(1289, 16973821, -437257991, -640295196), ivec4(-101981988, 387519494, 303109142, 51187729), ivec4(50397437, -134939903, 219088381, -269421056), ivec4(-67504396, 16776186, -33486840, 33289978), ivec4(201523973, 387586325, 725012, -386662656), ivec4(-337255966, -286331154, 285735922, -134084335), ivec4(-219090704, 117505530, 17567501, -488511244), ivec4(-202446619, -168035338, -168495627, -218893067), ivec4(-336924943, -336990994, -17108501, -50397186), ivec4(-134545924, -168429577, 16711931, -269355780), ivec4(-235934229, 185074426, 387190540, 219487000), ivec4(-84213752, -84280839, 471140864, 185735196), ivec4(-117571582, 33488377, 151586309, -50331130), ivec4(67042299, 454758921, 353703704, 252843030), ivec4(84478219, -168231680, 134149618, 168627980), ivec4(-33684727, 50330105, 202115333, -83884789), ivec4(-303239951, 83950579, 252118536, 202380051), ivec4(-67239416, -286134027, 16380652, 118033416), ivec4(-117768186, -67701514, 16645117, -83885824), ivec4(-202181386, 235471611, 269357328, 219091989), ivec4(262920, -286132742, -101453586, 84543488), ivec4(-201785084, -135140113, 33619451, 17238277), ivec4(-302975750, -118164754, 100729086, 235932938), ivec4(185404427, -117702907, -185404685, 319686654), ivec4(67768083, -263170, 67174401, -33357053), ivec4(-219023880, 100727800, 319884555, 387323412), ivec4(67833106, -370215171, -286659605, 218562551), ivec4(33950477, -168561156, -100992779, -33488131), ivec4(-117966083, 33488379, 201787656, 50857483), ivec4(-235472646, -673454355, -522462759, 470418161), ivec4(942746923, 1548566589, 1853321571, 2037937521), ivec4(962094188, -1412564707, -1819309926, -909855075), ivec4(-1080707878, -1666397229, -1464681553, 233746070), ivec4(-943074842, -1212954170, 183949740, -134217723), ivec4(-337972738, 790238185, -49999838, -101646333), ivec4(319359470, -925507589, -1196770108, 536470979), ivec4(875835954, 1446722353, 1684764509, 2003726185), ivec4(1364946803, 791693628, -437187032, -808922410), ivec4(49606609, -285864688, -909122840, -506278209), ivec4(-404164114, -690164758, -337453616, -67436040), ivec4(-218758912, -134876689, 168627456, 34147078), ivec4(-184681728, -656082440, -1077753906, -421869628), ivec4(218367737, 1077685273, 1752062544, 1683908455), ivec4(1802859117, 507399780, -454033139, -555623205), ivec4(-538515737, -589371933, -488317222, -656613405), ivec4(-774382890, -488251692, -438246687, -521606167), ivec4(134213603, 593161, -336268043, 201521647), ivec4(727058, -756749583, -674380599, -522198825), ivec4(-403905829, 941557235, 1817990210, 1735421553), ivec4(1970432105, 1096707436, -503905251, -253504040), ivec4(-201786377, -572201748, -556347946, -588847646), ivec4(-724316203, -404761645, -454498069, -522001946), ivec4(-203106602, 134873600, -201719801, 15854313), ivec4(236458769, -471207422, -893467698, -386997028), ivec4(-169089306, 554106100, 1380860988, 1734302548), ivec4(1902206301, 1601140344, 51720261, -506340629), ivec4(-84346898, -252644107, -657402143, -319886111), ivec4(-707601182, -641020974, -151718166, -505289493), ivec4(-421931299, 134678775, -235405564, -203103252), ivec4(319688451, -167967988, -993207831, -202842418), ivec4(-168627211, 49871357, 1296052762, 1162496334), ivec4(1010449731, 1701076300, 439635551, -387451383), ivec4(151585013, -151322619, -690099982, -303175973), ivec4(-572463380, -656810273, 16444124, -117768702), ivec4(-437257991, 235271910, 528661, -589371918), ivec4(167636448, 118493712, -622267652, -421932079), ivec4(-353834002, -132879, 689703424, 488711722), ivec4(354296093, 285738509, 253041177, -16776696), ivec4(16381433, 219286789, -16578550, -219221513), ivec4(-67372041, -84610313, 151322109, -33289461), ivec4(134480125, 269158921, 17239828, -151783939), ivec4(50527992, 286198278, 185273872, -252182006), ivec4(-235933456, -134876431, 235405820, 17370641), ivec4(-184943105, -84544269, -83951616, -303173902), ivec4(16578289, 17238277, -65537, -33554430), ivec4(-67372550, -67437830, 134677758, -50199547), ivec4(-101255174, 50133498, 185470474, -218366205), ivec4(-50991637, 286132995, 67373328, 132101), ivec4(-185207045, -421206803, 50264044, 264201), ivec4(-67569413, 33619710, -65789, -185141254), ivec4(-67635724, 252446978, 117967887, -100990714), ivec4(-118033162, -269355529, 100727026, 151719179), ivec4(-336659964, -50859281, 202180865, 33883914), ivec4(16580095, 118098693, 151455753, 67635208), ivec4(-16909056, -201785858, -101058572, 134546172), ivec4(-33553657, 100860157, 252841481, -134150389), ivec4(-219287824, 168165626, 151521290, 168627211), ivec4(-151191549, -319885330, -50990867, 151323137), ivec4(-16578550, -33752069, 50330105, 50792711), ivec4(-134743040, 319620605, 269619988, -16777208), ivec4(-100991746, -201852423, -34147086, 252446723), ivec4(-83884273, 16710648, 151454977, 168561418), ivec4(-185074170, 33290744, 252512774, 235999759), ivec4(84478733, -83951613, -286527243, 201851127), ivec4(67899151, -16975107, 513, -117505022), ivec4(-269421835, 33288942, 185140997, 34015754), ivec4(-302515203, -252843286, -235999760, 151124982), ivec4(253105680, -100729083, 117439222, 437719822), ivec4(50860055, 201719808, 303304976, 168364299), ivec4(151587595, 16843784, -50528768, 151322621), ivec4(101123592, -134809087, 33619963, 286198791), ivec4(-100661233, -185734158, 151454974, 168627211), ivec4(117901321, -134676989, -437784842, -67702807), ivec4(319949826, 67504913, 33817860, 117835270), ivec4(527114, -101321223, 235537918, 168825362), ivec4(-100793080, -134743817, -218827275, -50859280), ivec4(185403394, -269024760, -84479250, 117636860), ivec4(329481, -168429316, 130549, 151388672), ivec4(84149512, -151388155, -201918476, -235868948), ivec4(218430453, 17108241, 16777218, 184943361), ivec4(84609804, -252644357, 16447475, 202116104), ivec4(134876172, -151322619, -286397201, -219222289), ivec4(218562809, 84676624, -117966336, -34080776), ivec4(118229764, -83951614, 151124729, 168431117), ivec4(-16841976, -50134016, -50529799, -134875142), ivec4(134480122, 527629, -66564, 168099837), ivec4(319951118, -150927088, -185536014, 185139706), ivec4(201984266, 67635723, -50397696, -302843910), ivec4(100397548, 252579339, -33553140, 33685759), ivec4(117900546, 66565, -17237765, 353767431), ivec4(219025171, -33552116, -151652615, -218564618), ivec4(-263947, 505419529, -336395247, -842533136), ivec4(135139068, 757536012, 249224717, -101057785), ivec4(420605935, 49804820, -67567615, 941687287), ivec4(1734362957, 1735159658, 1567123816, -555021767), ivec4(-1162296111, -741161542, -1533629506, -623917652), ivec4(-455157548, -1213019441, -438383178, -775763514), ivec4(-440284734, 1464022784, -134015194, -1062354993), ivec4(167836618, -1279474471, -693000285, 1447639292), ivec4(1581722155, 1633110609, 1802398040, 1415926090), ivec4(1600146760, 1533963101, -807078361, -1044204352), ivec4(16772051, -859193386, 100720598, 691680803), ivec4(-1246578204, -690306113, 84213998, -1095518250), ivec4(201318353, 1414219048, -690096607, -403973160), ivec4(-151717140, -1600607794, -439042130, 689443826), ivec4(654770452, 1801674565, 1902536790, 253047644), ivec4(1362769437, 1481922879, -740161473, -808788265), ivec4(-539635263, -1111502621, 65727697, 538777350), ivec4(-1194199272, -539367991, -354164516, -1312565014), ivec4(-1052726, 992944399, -434819007, -369622298), ivec4(-707142426, -1463101474, -791427163, 33023194), ivec4(186456341, 1515996438, 1735221858, 878602861), ivec4(859647261, 1044196660, 53428550, -756817697), ivec4(-1010976824, -471080495, -236069418, -50794250), ivec4(-99807481, -336731677, -757999900, -471210278), ivec4(-269952297, 167573491, 791882261, 135074078), ivec4(-1077484811, -589442625, -606942512, -624110379), ivec4(656148459, 1430401322, 1128485973, 1583042368), ivec4(1128153426, 623195450, 808988706, -134478822), ivec4(-1346907933, -455951187, 16314349, -437520128), ivec4(100724964, -168561407, -875042315, -287059768), ivec4(-236066063, -202378508, 571999996, 219552550), ivec4(-739574775, -691289657, -640166180, -858333983), ivec4(133422032, 1127424537, 1112692308, 1279210297), ivec4(1179538263, 539965505, 908729372, 203041336), ivec4(-958599680, -876957256, -101586467, -184745986), ivec4(-169023251, -151585538, -504367370, -708196655), ivec4(-84808734, -100859649, 150730486, 488710423), ivec4(-302183915, -1010972968, -437985582, -639638042), ivec4(-388377901, 655623930, 1448167481, 1195987029), ivec4(1330597706, 977488206, 572796211, 303702050), ivec4(-201324531, -1010248735, -455355960, -202182164), ivec4(-235867405, -100795402, -218893579, -522000403), ivec4(-437918751, -337057817, 302512880, 421338138), ivec4(-117569776, -673125903, -656878124, -589703466), ivec4(-320610595, 184942325, 891886867, 1246184253), ivec4(1364151372, 792150861, 774514216, 640561714), ivec4(-184677864, -623124247, -471867941, -437917721), ivec4(-320412444, -101058830, -185469961, -386992906), ivec4(-404363801, -370611736, -51385879, 555356680), ivec4(152445478, -588844033, -673983531, -673654054), ivec4(-522594344, 168164846, 521539853, 993472810), ivec4(1179010626, 909984838, 842084658, 707801906), ivec4(-49670365, -572199948, -606545960, -320018206), ivec4(-421074709, -185405719, -370347532, -286331413), ivec4(-185274387, -471274254, -387850015, 302711028), ivec4(185800471, -117702909, -589306385, -707142693), ivec4(-657074989, -68098852, 369952258, 841820449), ivec4(1060977206, 960249151, 690564916, 993472556), ivec4(371668284, -336332026, -572661787, -488447777), ivec4(-404560926, -185273875, -336530443, -286529048), ivec4(-235802128, -269422094, -319753745, 134149101), ivec4(185536782, -201720060, -622861076, -723985959), ivec4(-959984434, -371207735, 353108210, 1346317340), ivec4(1785092696, 1263885408, 843336262, 1178742568), ivec4(893205820, -48877529, -134939395, -269495593), ivec4(-1042688037, -354893890, -824781089, -996497459), ivec4(-1397629455, -1057754938, -1178094418, -808864620), ivec4(117756084, -1295264829, -134676520, -237780015), ivec4(-236262675, 519104504, 503911463, 976894011), ivec4(1548704319, 1214741092, 1415994958, 1110851387), ivec4(1445543783, 789793115, 236077942, 184890162), ivec4(50279214, 67498473, 370013688, 404684806), ivec4(-135076110, -371003138, -320608011, -689051399), ivec4(-200604967, -165871646, -720369180, -354954794), ivec4(-336919808, 402714361, -554376972, -319817227), ivec4(-385414405, -772534022, -571610683, -236783635), ivec4(202173950, 49406421, 50653685, -487003688), ivec4(-705760012, -587139627, -639045157, -755569705), ivec4(-538848069, -321065748, -151920657, -842212112), ivec4(-387582482, -118092800, -234413030, -352194595), ivec4(393446, 337052661, -35262731, 319950091), ivec4(588718629, -200923595, 504762106, 337450007), ivec4(675029775, 773523474, 555623980, 386205726), ivec4(-269680352, 252974344, 34411277, -149545460), ivec4(168095462, 218497287, 756483078, -202769125), ivec4(67240962, 336599827, -217042132, 134938603), ivec4(370740484, 556537613, 49080317, 185077005), ivec4(419891473, -335931348, 67700984, -200996605), ivec4(-48952588, 419884522, 387126042, 184285451), ivec4(-691019519, -252381461, -319883534, -436005888), ivec4(-202251818, -151654674, 218361834, -472721423), ivec4(-135335696, 184550660, -453239006, -151325211), ivec4(-134416911, 203163638, -203105300, -461064), ivec4(183890173, -555681515, 197620, -268564734), ivec4(-436140813, 150725336, 185074952, 470481920), ivec4(-489101302, -202115084, -185599238, -486729974), ivec4(-50532644, 33947642, 303432186, -304292878), ivec4(-84740874, 436667140, -419684560, -67109137), ivec4(-167706116, 1773818, 66248420, 285869317), ivec4(234617352, -572920053, -16776974, -50395390), ivec4(-301196793, 167964383, 219023624, 588775936), ivec4(-253827065, 33554688, 66913545, -385868517), ivec4(-50333720, 67567609, 523048710, -169221384), ivec4(-34147081, 604569344, -201516236, 336991493), ivec4(923670, -149678847, 32825566, 252249091), ivec4(521078025, -337580273, 67306750, -50591991), ivec4(-486532850, 235336156, 337253648, 639897098), ivec4(-135664375, -197120, 268500995, -436725722), ivec4(-117638420, -50200840, 304683779, 15852528), ivec4(100728833, 453179905, -370408159, 117835258), ivec4(118231821, -317776368, -67968551, 134611197), ivec4(470876416, -270801917, 201984515, -33880561), ivec4(-520547569, 16510685, 202311682, 556538124), ivec4(-101716479, -135006469, 301922554, -386658527), ivec4(33883126, -100662784, 1643776, -219488282), ivec4(50198774, 537854979, -236126183, 185074941), ivec4(235869202, -419358699, 16247004, 185403653), ivec4(320014341, -371136258, 100859380, 184944135), ivec4(-386529264, -202446363, 84017144, 371070989), ivec4(117637127, -134479611, 83818485, -285999098), ivec4(-50793489, 134414334, 51253774, -269618953), ivec4(16644339, 50726660, -135006723, 353372415), ivec4(320149016, -403439091, -152378656, 286066689), ivec4(84676626, -370478597, 50264046, 101189637), ivec4(-218694398, -50793230, 100860158, 202313226), ivec4(-134611450, -134743560, 33553400, -235603456), ivec4(-199183, 134612482, 592393, -370347273), ivec4(-303042836, -185734937, 218563325, 1463559448), ivec4(1600810857, 1196513369, 892613437, 218621961), ivec4(-807339759, -1448628288, -1782985800, -1129674099), ivec4(-791688753, -540293174, -638320400, 285596623), ivec4(67569430, -488836096, -49283344, 909377518), ivec4(588517672, 134816807, 18813968, 303757298), ivec4(-102377743, -673711877, -739976230, 706342103), ivec4(940832526, 808079428, 826687296, 2053850160), ivec4(1564160858, 775317342, -385017298, 167830233), ivec4(-406338070, -824772629, -1127493929, 267701946), ivec4(182971653, -301851378, -992550160, 99141563), ivec4(65071358, 135668749, -150532331, 368961767), ivec4(-220597491, -402848007, -959061526, -255085131), ivec4(-254020869, -116715521, -252183040, 721480423), ivec4(689320762, 961563195, 506148924, 772604426), ivec4(185282362, 186915866, -588447739, -221330743), ivec4(16584970, 254023698, -420084473, -439695661), ivec4(-487849476, 34207475, -167770624, -371861017), ivec4(-503903999, -319362582, -773921051, -877349438), ivec4(-369689110, 17299702, -521276171, -574043435), ivec4(186325505, 841882647, 438708775, -236456953), ivec4(253960717, 707007764, 169352478, -522524677), ivec4(203166460, 538447886, 34673429, -556276235), ivec4(304025076, 369691664, 219419152, -505220608), ivec4(371066615, 218634003, -184220405, -1128083226), ivec4(184147401, 236198670, 286395151, -858658052), ivec4(150330322, 421733398, 723325715, -369357532), ivec4(82766057, 505881619, 66912271, -706611193), ivec4(-68822574, 1330724125, 438514760, -487060715), ivec4(-573453101, 656082417, 186132268, -218432255), ivec4(-438444314, 639043317, 506738738, -622595322), ivec4(-1229603893, -421868612, -268698894, -1515207974), ivec4(-1667522912, -1028347744, 184412115, -319224563), ivec4(-269752604, -17305361, 538249987, -82960859), ivec4(-219815960, 353175038, 1245656103, 1061966159), ivec4(50993965, -117374204, 16447221, 134744325), ivec4(-134545403, 352976118, 1009789217, 1465407051), ivec4(1600084821, 1061704283, 708065851, 101586464), ivec4(-387058179, -740367386, -1128546104, -1178812225), ivec4(-1111704905, -775109440, -589637163, -488316194), ivec4(-539305764, -235934488, -84149515, -252644618), ivec4(-185339152, 302711291, 437786387, 219487260), ivec4(-201983742, -370676752, -134941971, 201982972), ivec4(285935884, 909060125, 1195720763, 1145390919), ivec4(708000322, 437984803, 219092504, 51122190), ivec4(-639307782, -1044133167, -909589055, -674116664), ivec4(-589570595, -387521313, -488248855, -353638172), ivec4(-404297751, 16578029, 33817345, 16908544), ivec4(16711681, -50330878, 65532, 50660097), ivec4(-67305471, 134414075, 488577296, 639638297), ivec4(959787308, 1179009597, 1111902279, 876297277), ivec4(118562089, -33686016, 196863, -184943876), ivec4(-706943507, -808596273, -640232496, -488513573), ivec4(-639902240, -656877353, -639902757, -690827309), ivec4(-589505061, -572925991, -320083485, -152114709), ivec4(131066, 437455876, 959588130, 556478515), ivec4(303241501, 723522577, 1060846133, 1498696775), ivec4(1331190618, 606876994, 707340067, 354099238), ivec4(269422095, 218827535, 151784718, -33685500), ivec4(-353307398, -522067227, -522199329, -639902497), ivec4(-875506474, -758133558, -690431531, -236791337), ivec4(197630, -101847047, 218893060, -335541485), ivec4(-370942496, -454169370, -67507234, -33819653), ivec4(-118888461, 672273671, -134208712, -82765038), ivec4(-65461747, -32700686, -604773148, -473187903), ivec4(1075643389, -184536508, -420807680, -555617544), ivec4(-369425161, -756484121, 83417545, 489956624), ivec4(-455088902, 116909790, 1261248027, 1751084649), ivec4(1329950331, 1936552298, 743664509, -1362766343), ivec4(-270350166, -270021164, -119417881, -775696907), ivec4(469826798, -923394776, -1246247480, -235214373), ivec4(-387522337, 15453391, -305087526, 1245647102), ivec4(-621337024, -944258357, -452656928, -504171796), ivec4(-302192678, -590494259, 33616865, -1212955402), ivec4(14465719, 1414087714, 1668246871, 1249080163), ivec4(1482444350, 1516927077, -605158099, -220937530), ivec4(-118292458, -471534082, -756548366, 16180432), ivec4(137174546, -925443619, 15325892, -235733758), ivec4(-438505989, -892472830, 856553954, 187648068), ivec4(-975905294, 167630794, -135336457, -51582739), ivec4(-993270789, -101916459, -655749365, -792538927), ivec4(1143407842, 1902661714, 2036816487, 1161249630), ivec4(1835686730, -82036899, -1060908564, -50004267), ivec4(-420416532, -336337958, -422525736, 739640824), ivec4(-404094696, -792345390, -336072474, -420021778), ivec4(-368968739, -68692530, 590685973, -521011179), ivec4(-507329589, -353764617, -420481805, -890965004), ivec4(-354891075, -83623698, -992485658, 469489351), ivec4(1666141500, 1801680757, 877227386, 1380530487), ivec4(590957915, -841090038, 32361922, -319885571), ivec4(-304030229, -976822292, 100461265, -65986534), ivec4(-1127884300, -202908984, 50000367, 201059064), ivec4(-640295680, 521010921, -33023973, -993142549), ivec4(-319362605, -286003995, -286002969, -910179885), ivec4(-17834274, -353307389, 48487135, 1397898525), ivec4(1752459869, 1450602341, 824322357, 1011238966), ivec4(-82698194, -388310291, -370278145, -438113816), ivec4(-722799893, -253375281, 219547899, -723126531), ivec4(-455553851, -202313483, -168624641, -538245369), ivec4(-34872619, 68162062, -672730368, -68823857), ivec4(-152047113, -235802378, -993076239, -371206197), ivec4(-100990217, -337121291, 1262032898, 1885493074), ivec4(1750817384, 387658317, 925900571, 539307064), ivec4(-572064754, -150997024, -303043860, -218435089), ivec4(-421930011, 234813423, -201588727, -556280088), ivec4(65005, 320146944, 304225291, -336728579), ivec4(67698933, -336331781, -792277287, -605952028), ivec4(-421009437, -588976406, -539504175, -100797724), ivec4(-201458694, 520616172, 925905710, 808928577), ivec4(1649975, -219220999, -16907012, -386531071), ivec4(-253503779, -185733901, 33159671, -218891521), ivec4(168165879, 185603865, -201848306, 336396532), ivec4(807409174, 858794294, 202514735, 588251909), ivec4(387258145, -369819373, 67763948, 319554815), ivec4(286659855, -33750518, 269156607, 151258379), ivec4(-303305475, -151257865, -33096713, -302581515), ivec4(-623191585, 50788581, 135071233, -387780612), ivec4(-303040012, -101123855, 65792, 168034559), ivec4(320609296, -200799736, -219421464, -50792712), ivec4(33754634, -319159290, -404758041, -168165639), ivec4(-319422468, -101915678, -67898376, -168363778), ivec4(-353571085, -185996567, -151717381, -437388801), ivec4(-67374616, 251656442, 50530061, -185404163), ivec4(352712692, 454037016, -218560492, -66912524), ivec4(100924150, 118228743, 168232965, 420810509), ivec4(218695956, -269420537, 33620218, 505550339), ivec4(253434906, -235802115, 185204983, 202640899), ivec4(-101188347, 134546944, 236066836, -184875764), ivec4(-202181900, 219288066, 118690827, -17370887), ivec4(369558013, 404826662, -218627314, 100465400), ivec4(472132894, -133818851, -202512405, 167835382), ivec4(151587856, 16645891, 336004099, 236002847), ivec4(-335935213, -320149536, 470547952, 169024030), ivec4(-269684481, 251325932, 83887379, -302580477), ivec4(-252514323, 101121779, -100531453, -286331151), ivec4(386397933, 218695956, -303236861, -135007502), ivec4(252841471, -201325046, -286002450, 353698033), ivec4(67832330, -336858370, -168890386, 67438080), ivec4(-84081400, -67305218, -49739521, -168035596), ivec4(-337189910, 49803756, 387520786, -387121137), ivec4(-303502356, -133951999, -117572102, -17173517), ivec4(117570812, 201786120, -101122809, 66516474), ivec4(50664981, -167507190, -151719185, 353239804), ivec4(151785235, -17304836, 436599806, 16845342), ivec4(-218496509, -303042065, 67303919, 135269382), ivec4(50528256, 369819645, -118098681, -370543878), ivec4(-34082064, 471405574, -66118885, -168102158), ivec4(219283699, 83819004, 16580355, -16973823), ivec4(100992772, -66974707, -33684995, 135992836), ivec4(168493824, -235933442, 83555826, 218959370), ivec4(-185269748, 33555197, -49405933, -16646153), ivec4(-185207304, 16249073, 403638278, 100796436), ivec4(117243909, -268825065, -302515982, -135140121), ivec4(302777083, 252974357, -84544768, 234485241), ivec4(-101318899, -33356544, -134414851, 50527734), ivec4(51120387, -67307271, 454098427, -328179), ivec4(-286196478, -168693522, 134611709, -116978422), ivec4(33684469, 270010877, -395521, -151586304), ivec4(-202312713, 201721085, 660757, -100663296), ivec4(1118464, -50794254, -202445324, 151257082), ivec4(252579598, -235600880, -151388939, -117174521), ivec4(151585016, -67240189, 16249846, 252183300), ivec4(-50593523, 234881279, -83420385, -184549126), ivec4(-219091216, 117570806, 319884041, 117440007), ivec4(369689356, -117832170, -117702404, -269290252), ivec4(151321073, 320476173, 50331911, 336396286), ivec4(-252840698, -269420807, 50264819, 235801607), ivec4(-32631793, 16774646, 185533435, 100530688), ivec4(-50330360, -168561158, 100925948, -16379890), ivec4(50594042, 169614091, -84413701, -286461707), ivec4(-17173263, 184877824, -50131949, 33819138), ivec4(-117108468, -67373326, -252513289, 49869295), ivec4(420547850, -33552109, 117309698, -319158000), ivec4(-168431127, -17173262, 117835009, 219154439), ivec4(-84740094, 167705344, -84212982, 263168), ivec4(-235669509, 50264306, 168626434, 100662017), ivec4(437585669, -286196209, -286067469, -118296595), ivec4(67371004, 168891147, 117964544, 151848449), ivec4(-151718145, -202049544, -101453071, 286067200), ivec4(17700633, 16974076, 68161285, -168891661), ivec4(-151587081, 16907769, 235209730, -184611822), ivec4(249, 34344713, 50462461, -218826241), ivec4(-34213392, 201720065, -16906998, 336202246), ivec4(-184019173, -185339667, -235933710, 66976759), ivec4(387321094, 66847505, 134348806, -134412535), ivec4(-117901063, -134744330, 185007607, 219549966), ivec4(33422850, 168034307, -269618688, -67175179), ivec4(-134349575, -150992915, 269223936, 621798131), ivec4(152701966, -167380731, -201916435, -153227784), ivec4(-267179231, -267646201, 638711009, -468380412), ivec4(1026876858, -958337545, -354021899, 404100875), ivec4(-253892616, -133355749, 322046207, 455074541), ivec4(-639756027, -599592, 235992055, -69260502), ivec4(569905990, -1128526845, -892862430, 219612408), ivec4(705631481, 402661664, 185258224, 150395115), ivec4(-235857878, 420220699, -755892489, -368770564), ivec4(220067291, 355988967, 186988806, -321266420), ivec4(-925436686, -117375244, 640747257, -200927199), ivec4(-519960083, 438173158, 34013964, -168482540), ivec4(31974656, 16643035, 556924925, 506931696), ivec4(-149807848, -789255737, -253106219, 251791109), ivec4(304689665, -253095670, -420485127, 34801655), ivec4(134156290, -286387177, -302911232, -301797657), ivec4(135077629, 505946644, -436530926, -588717078), ivec4(32564453, 370081536, 202579744, -134941179), ivec4(33091056, 118231306, 101453059, -185600767), ivec4(-353572629, 234945264, 588846614, 287186984), ivec4(-605162242, -589964324, 184347620, 522194956), ivec4(17570851, -252644612, -50597141, 67700222), ivec4(50793487, -83756291, -320213261, 100661235), ivec4(538973969, 17898270, -319686404, -539108382), ivec4(168097255, 404297492, 84150032, -201916412), ivec4(-100794887, 134545662, -184942074, -50265863), ivec4(-185339405, 285605883, 522199068, -16774634), ivec4(-487917827, -421536546, 235273457, 337190423), ivec4(252578573, -67370999, -252710151, -16975629), ivec4(134282750, -50066161, -50463747, 151190777), ivec4(219090702, 50594053, -353306624, -101586713), ivec4(134349053, 50792714, 219023877, 34146314), ivec4(-101123330, -134611973, 33552628, -67372032), ivec4(50528509, 353570569, 84808723, -185009152), ivec4(-521869330, 16445926, 319752450, 168497171), ivec4(135270670, -218628603, -151851282, 16579576), ivec4(17040900, 33751808, 16580353, 202115845), ivec4(17107469, -151454722, -202445070, -50660359), ivec4(134677760, 117571845, 235867916, -117702649), ivec4(-134809867, -84412939, -101320196, 134677503), ivec4(286067208, 252842258, -201719800, -370414354), ivec4(-594712, 168100355, 185536527, 185207048), ivec4(-50133239, -185207047, -50595338, 50462973), ivec4(67108094, 16909060, 185206532, 101321995), ivec4(-184942846, -286199054, -33489932, 50396667), ivec4(50332420, 286330375, 16976144, -151454722), ivec4(-202115594, -201852683, 134610422, 235670539), ivec4(303240210, -117504497, -404165390, -135337238), ivec4(84281345, 219024393, 84018184, 50660616), ivec4(-84149250, -197893, 16711424, -134743296), ivec4(65788, 235406081, 320147984, -117438963), ivec4(-336860175, -17305363, 33488127, 84478213), ivec4(252512518, 396045, -100794626, -101123849), ivec4(-33687046, -330249, 84149507, 336727561), ivec4(67965460, -370017538, -320280601, 50724338), ivec4(184943104, 134810896, 117967369, -117833982), ivec4(-101123335, 65276, -100662527, -66568), ivec4(50331390, 319818759, 67768339, -302974976), ivec4(-202379540, -168296966, 134610937, 286067209), ivec4(118230801, -33620480, -185404422, -17040648), ivec4(-17039616, 84215042, 218694917, 202379279), ivec4(-134348281, -320214546, 50066414, 50199810), ivec4(151718922, 101123590, -67041530, -33489157), ivec4(-67372293, 67371004, -33883392, -1), ivec4(235340286, 202512150, -168099321, -286067982), ivec4(-151456529, 83884021, 235801607, 269751570), ivec4(-33815540, -336990728, -460813, 50001664), ivec4(219087869, 118034192, 286394889, -217837032), ivec4(-656414484, 15789028, 151913478, -50595336), ivec4(453773062, -49802984, -50331397, 0), ivec4(-118230789, 117832435, -83949559, 234682106), ivec4(354427418, -285867508, -118363156, -235144714), ivec4(-84677401, 252512773, 285869323, 151653646), ivec4(-235141364, -219091734, 67634425, -50659582), ivec4(84082431, 387320582, -67172850, -117835011), ivec4(-235801098, 33554682, 67635206, -151455234), ivec4(387320570, -50263277, -101518856, 33686273), ivec4(-219023873, 67173366, -117570554, 303041022), ivec4(152048660, -387321859, 16116712, -100925437), ivec4(33422586, 319621895, 51123481, -50331905), ivec4(-117835785, -67570187, 201785854, -16775668), ivec4(167705597, 101651733, -302778115, -50727955), ivec4(-33488384, 66975737, 329478, 151058939), ivec4(185404685, -218430198, -33950223, -33356798), ivec4(-117901320, 100925690, 319817990, 84347920), ivec4(-201850875, -286593808, -33686796, 50726144), ivec4(33554433, 387650568, -117701618, -168890636), ivec4(-66053, -50725633, 185338116, -100793335), ivec4(235734782, 395532, -269619466, 117570291), ivec4(-33816056, 16776960, 83886080, 185470988), ivec4(34081032, -101123845, 16776698, 16579583), ivec4(-131585, 235274752, 219354902, -218562553), ivec4(-286396946, -67504655, 67304698, 33686276), ivec4(285803779, 135007762, -353372160, 16579056), ivec4(-50265085, 134611710, -16974332, 185073917), ivec4(151717896, -336725757, -66830, -33817345), ivec4(50396669, -236260608, 370675200, 118753806), ivec4(251787262, -307567860, -167370722, 167111925), ivec4(-320401892, 119154430, -82962934, -469755903), ivec4(16774350, 134673897, 386989051, 320405274), ivec4(-67496936, -186718741, 16971261, 1709597), ivec4(-337319954, 217710833, 337715212, -454497522), ivec4(-33954314, 387523343, -707006214, -34345249), ivec4(590682137, -151057375, -254486311, 958799856), ivec4(-182899645, -1078671899, 654371799, 926631719), ivec4(-806091492, -168832565, 959325207, -706474971), ivec4(-540822591, 808258299, 204225610, -1077155853), ivec4(250930890, 708587811, -739971309, -35732801), ivec4(1059594504, -133092805, -876226832, 706151660), ivec4(372195125, -1076764434, 201054908, 960047391), ivec4(-269218520, -422982947, 992876293, -199347135), ivec4(-1380003876, 369486533, 876690474, -470745828), ivec4(31376590, 926031889, -722266836, -994655029), ivec4(773394925, 506938434, -790632960, 183684026), ivec4(842673679, -807140062, -575095860, 1008473352), ivec4(52311616, -1059857944, 454291142, 742213163), ivec4(-858329332, -86787902, 942281488, -184016332), ivec4(-841817880, 538446311, 305018680, -942613774), ivec4(116050363, 1010049294, -184411337, -388308497), ivec4(554831618, -183557852, -690168609, 336525021), ivec4(724116248, -168427241, -85334546, 336463625), ivec4(-335670760, -454826012, 252840952, 186127378), ivec4(-202247687, 403175667, 303306009, -437519348), ivec4(-135664919, 118099717, -49804537, -84149769), ivec4(319816955, 34016270, -538974217, 49341666), ivec4(235999760, -50065905, 33619707, 286724874), ivec4(-134282230, -337320981, 285735407, 118033938), ivec4(-218824698, -34081549, 202181638, -134216696), ivec4(-235934225, 403768310, 118166041, -185140479), ivec4(100398578, 101519373, -285869568, -269751573), ivec4(201785848, 269421579, 353636880, 606018328), ivec4(556346152, -83751915, -185470218, 269354751), ivec4(101321998, -168100096, -151653133, -286133258), ivec4(-521934869, -488710947, -336926491, -151456016), ivec4(-420744715, -438049820, -202314007, -218892554), ivec4(-101453839, 16776700, 286132740, 218828047), ivec4(336859664, 505092376, 135338013, 16777216), ivec4(302514945, 623322141, 118363422, 33488899), ivec4(258, -252315140, -17107730, 235472386), ivec4(236131089, -33619448, 16644860, 33751552), ivec4(-218694400, -118033165, 285934077, 67833872), ivec4(-218957828, 33420785, -50331133, -252578055), ivec4(-168495886, 16776696, -67174142, -117901320), ivec4(-132361, -201785857, -454826516, -202511898), ivec4(286132735, 17107986, -101057539, 50528765), ivec4(-33619968, 16513273, 185009667, 336728593), ivec4(-50198255, -101123590, 33685757, -83885822), ivec4(-84347402, 218366204, 286462482, -16710133), ivec4(117571582, 168562444, 33949705, 0), ivec4(151388161, 219089929, 33752329, 100794625), ivec4(17106952, -319686659, -151784978, 319620091), ivec4(168826133, -67240188, -17040904, -117834755), ivec4(-168495369, -33489415, 100991744, -83818744), ivec4(-202116106, -50661900, -67305730, -202312969), ivec4(-33883658, 151652355, -100728312, -84281098), ivec4(50660093, -16842751, -134809606, -33948935), ivec4(168166146, -33553143, -65795, 67503362), ivec4(-201720576, -135008017, 252051451, 303437333), ivec4(67341, -50594305, -33619713, -16777732), ivec4(84083199, 218629123, 135139086, -134743552), ivec4(-329223, 263427, -201983234, -33752586), ivec4(201982718, 84545038, 33619712, 151454466), ivec4(33818378, -50593790, -50462980, 151389182), ivec4(67767564, 65280, 84148480, -134545661), ivec4(-185470989, 67174137, 370480141, 17239314), ivec4(-67240192, -16711941, -33817603, 33619709), ivec4(100795140, 168495882, -151453690, -33817608), ivec4(84345856, -184943360, -84413454, 50199290), ivec4(50726405, -67503360, -50594563, -50397184), ivec4(-168232199, -84281354, 100793594, 185338890), ivec4(33554693, 117768963, -83819257, -252709898), ivec4(33553397, 286264068, 84610834, -33620480), ivec4(-17040902, -67437058, 16842750, 50595075), ivec4(168429829, -83950327, -50595593, 168165630), ivec4(-67239415, -67701257, -16974339, 151586563), ivec4(774, 131840, 33751551, -84149504), ivec4(-33883912, 67043070, 218958856, -33553398), ivec4(66048, -67042815, -286198794, -17239058), ivec4(218497280, 202313745, -50527994, -151652102), ivec4(-84083719, 16776699, 50528769, 117834496), ivec4(-16645113, -50660868, 67174141, -50264569), ivec4(-101189639, -100992004, 168297469, 101255690), ivec4(50594819, 117768705, -84016634, -33817863), ivec4(83820030, 185404170, -16644857, 84148735), ivec4(724234, -302909186, -168825620, 269024762), ivec4(151456015, -16578552, -353699846, 117571830), ivec4(-67437050, 167706113, 281265680, -100262097), ivec4(453378554, -758259198, 151785199, -152374530), ivec4(-824707838, 335737811, 117574416, -350478569), ivec4(167828435, 202246922, 472516094, -320352002), ivec4(100727808, 671881232, -854446020, -287052571), ivec4(-503706122, 923620123, -457580511, -555498522), ivec4(675223271, -486321832, -994187284, 468508362), ivec4(775760926, -419832324, -252450098, 740175368), ivec4(-658441920, -35204885, 808516843, -971229165), ivec4(-1109864529, 419493364, 1243423560, -289294853), ivec4(-49356587, 120398859, -1329192903, 349828057), ivec4(1109531422, -63171550, -135085903, 555758842), ivec4(268250409, -911946214, 1008661750, 826686776), ivec4(-1274992877, -101395029, 606415906, 353110568), ivec4(-306073115, 909186815, 119351855, -1581253878), ivec4(267903421, 522463015, -553385211, -557734484), ivec4(841356277, 471214385, -1196434416, 436399314), ivec4(338111270, -771681009, -119355724, 858924305), ivec4(505420590, -624702722, 437256692, 51452961), ivec4(-1109129974, 99999683, 758064920, 236919328), ivec4(-372260127, 302580474, 184552976, -707067116), ivec4(302843119, 118691861, -217314561, 200792784), ivec4(252842000, 150731529, -523246076, 386993661), ivec4(17700123, -503049460, 369947609, 34279700), ivec4(134214136, -52306695, 387586579, -117766639), ivec4(-689043706, 235995621, -319225848, -151328541), ivec4(116184285, 387652375, -17234922, -639830263), ivec4(320211699, -184415987, -83099151, 386198759), ivec4(185604126, -789761, -371070210, 219681280), ivec4(-302644730, -487524112, 184149470, 219419155), ivec4(67305218, -168889605, 185535488, -134808058), ivec4(-168100354, 151057906, 118559246, -50134272), ivec4(-67438342, 185009408, 67241741, 84082433), ivec4(269223685, 202775061, -33553400, -101189381), ivec4(50264569, 16842496, 197377, -117703169), ivec4(-50463238, 65534, 197377, -50661126), ivec4(-185141254, -84347147, -67634693, -16908546), ivec4(-67372035, -252249606, -286463254, -67504143), ivec4(84083455, 218629639, 269421837, 219025167), ivec4(67701517, 259, 83951872, 235604487), ivec4(235932940, 50858251, 515, -67371265), ivec4(50396925, 134743557, 132103, -50529026), ivec4(-84148740, -67306246, -218958086, -353308174), ivec4(-286529305, -84347664, 16908798, 258), ivec4(-84082944, -185338888, 50330358, 201984261), ivec4(353636879, 370611991, 134942226, 84346630), ivec4(16842754, 117835266, 168430345, 134875915), ivec4(-50330873, -84346373, -201786630, -185536786), ivec4(-134809866, -134810122, -84280841, -151520775), ivec4(-67372553, -151389188, -117901065, -67570186), ivec4(100925951, 269421320, 269422609, 235802640), ivec4(264460, 134611456, 202115850, 84478730), ivec4(16974595, -168297729, -218893325, -303305232), ivec4(-235933970, -16909834, -16776960, -50528771), ivec4(-117835527, -117769735, -151652872, 100728313), ivec4(134678793, 168364297, 202313486, 336662028), ivec4(353769495, 84413200, -33554687, -66052), ivec4(-65537, -117768707, -201984521, -353505038), ivec4(-236131864, 16710389, 16777471, 101188867), ivec4(-50593789, 16711164, 16908801, 100925955), ivec4(269289993, 269751314, 264202, -269355525), ivec4(-151653648, -16975369, -134742785, -101058055), ivec4(-67635976, 521341952, 1834766393, 2087876219), ivec4(1601533562, -855955649, -1280329533, -1498961736), ivec4(-1699360092, -1482963531, -1851944037, -1616930932), ivec4(-591221596, -134620482, -1212885543, -1466524991), ivec4(-1247236941, 335940064, 1970957125, 1516657495), ivec4(1718578004, 272197715, 1046835006, -203161576), ivec4(-608650518, -289158432, -384493099, 1378292023), ivec4(-758937655, -2085565511, -726664743, 1092669912), ivec4(-1428674778, -880623600, 700895000, 1094932773), ivec4(1749246568, 861027440, 551860980, 570293954), ivec4(354692093, -504370921, -1382697713, -826295129), ivec4(-557334387, 22952936, -1141906462, -1314602285), ivec4(-1181695563, 285603545, 1314526984, 269361501), ivec4(1229995291, 825977431, 1113812026, 84618054), ivec4(-825903642, -1009850428, -68302661, -385221928), ivec4(-420677393, -1095193648, -842081337, -537397044), ivec4(152835799, -962219050, -723789599, 1192294111), ivec4(1903260270, 1582520651, 338317932, -134021633), ivec4(5334027, 168558562, -1312765726, -1246514005), ivec4(-169935901, 117896707, -1094067482, 15192004), ivec4(-976756742, -132772395, -572066830, 150196448), ivec4(301266688, 1480214065, 1802528623, 1349214559), ivec4(-67692989, -421335299, -470226220, 17763831), ivec4(-742477336, -1346979392, -659044674, 153689092), ivec4(-402791199, -925772067, -540361014, 1183216), ivec4(254355463, -758524680, 755034849, 1515940699), ivec4(1869577834, 1097228391, 539171607, -489031645), ivec4(-285874456, -554829067, -690435884, -1297569612), ivec4(-926757691, -17569844, 270934554, -640499750), ivec4(-758130471, -253632810, -452193533, -320153384), ivec4(-102704670, 588186873, 1298819392, 1786017127), ivec4(859456613, 1092493598, 136201034, 69541389), ivec4(-1429941005, -507532635, -1466055202, -320217916), ivec4(-555426840, 185332196, -389227019, -690427918), ivec4(-471806504, -82642458, -18689575, -101188865), ivec4(268566514, 1080646695, 1548104500, 1062098781), ivec4(1313292854, 424637283, 185800201, -841620224), ivec4(-523844150, -1161303815, -841624901, -1061308995), ivec4(-102643778, -371066614, 33950204, -471010825), ivec4(150395094, -505946373, -353567752, -286133781), ivec4(723978224, 1075774740, 1178947153, 1464618568), ivec4(1400468832, 1480403256, 270019145, -218957570), ivec4(-654371833, -572798524, -892809770, -860178754), ivec4(-958992665, -673393464, -488778284, 183624929), ivec4(-421068268, -83294219, -605490959, 133555162), ivec4(-489496060, 235803134, 588780563, 1734494002), ivec4(1447115087, 1095324510, 791688248, 944652591), ivec4(252642319, -470877691, -741156385, -992024355), ivec4(-909526347, -1296648258, -641681996, -554368781), ivec4(-16845085, -235604486, 66712558, -470611951), ivec4(-521342230, -572859170, 621080032, 605560883), ivec4(893337914, 740961842, 1852000821, 690502489), ivec4(691419444, 404494880, 489366807, -303369728), ivec4(-588976656, -977025328, -773989168, -960117819), ivec4(-976763194, -556544567, -100663571, -134941451), ivec4(-302910734, -17897753, 330760, -134414340), ivec4(-117967115, 403834367, 875308318, 892614966), ivec4(1043936820, 1162429764, 1246448457, 539442246), ivec4(303175449, 34541839, -488182794, -589306910), ivec4(-875768618, -976827956, -758331449, -808595496), ivec4(-556150323, -370612768, -219289624, -67438092), ivec4(-34080775, 256, 67174144, -151651842), ivec4(353109760, 673586713, 757607211, 1346516530), ivec4(1280003147, 943406663, 673984309, 522070314), ivec4(1813, -437261582, -555293982, -740962610), ivec4(-891953710, -421340712, -974720535, -1027096903), ivec4(-589374518, -1059588372, 168159697, 116256510), ivec4(487129107, -215858619, -52571430, 66785564), ivec4(-200802299, 1228744201, 607070271, 2003391539), ivec4(809782885, 553712925, 675491386, 50597139), ivec4(522130712, -452386786, 556663789, -1094526719), ivec4(-926305606, -672601145, -1331781426, -1161246017), ivec4(-488516916, 555289843, -973996004, -270347593), ivec4(-253366262, -370612757, 757403907, 284425249), ivec4(642666045, 84742153, 687927816, 53686315), ivec4(655358706, 555621675, 976299303, 893865535), ivec4(-33813969, 120461304, -168231427, -118428691), ivec4(1250306, -17636633, -1110382849, -1431061568), ivec4(-690830164, -1363619620, -454831688, 386660589), ivec4(572661015, -15655394, -337979928, -184547326), ivec4(-320080395, 319027695, 455090719, 1044524573), ivec4(353440551, 336662028, 926297120, 33558823), ivec4(354296853, 656679446, 825173800, -65262800), ivec4(49670118, -252907010, -353768979, 16841973), ivec4(-640097032, -504170519, -959589932, -943604544), ivec4(-774318129, -237319734, -34014723, 218826499), ivec4(656415508, -268364250, -352979987, -387588386), ivec4(117109482, 270212113, 285013249, 656746533), ivec4(371207214, 370215947, 84743448, 909320460), ivec4(724183343, 269424673, 740825875, 336664612), ivec4(-335736293, -303239703, 100398062, -638583547), ivec4(-556151092, -825240616, -1010711095, -572993591), ivec4(-775039266, -117837345, 134677498, 134809608), ivec4(34213646, 218364408, -303302906, -67768338), ivec4(471471113, 67505944, 606544143, 236329758), ivec4(252314888, 623255575, 605426459, 505358637), ivec4(404496160, 605952795, 152181796, 219286790), ivec4(168099844, 168626957, -252182523, -657073691), ivec4(-521804577, -858597926, -842281780, -774581296), ivec4(-640430644, -370678559, -236066327, 252051702), ivec4(286529047, -16644852, 50462976, 100992516), ivec4(33883654, 65536, -84082943, 218496763), ivec4(555291922, 707603755, 572662566, 539174177), ivec4(303372571, 168364301, 17106696, 16447996), ivec4(538711306, 286661921, 286462224, 118296593), ivec4(-336595456, -437654807, -488645152, -454826523), ivec4(-387323417, -639769626, -774843691, -471868716), ivec4(-421141020, 117175018, 471537425, 303042839), ivec4(437851669, 118428952, -134677760, -286198538), ivec4(16512496, 286000898, 488314901, 555686940), ivec4(690299425, 522660908, 265237, 235537665), ivec4(396047, 184942590, 471603218, 252843290), ivec4(84347149, -33685758, -33685506, -50528772), ivec4(-504630280, -640231975, -320281635, -589240596), ivec4(-387916580, -50530063, -101058054, -118032648), ivec4(65276, 65535, 84082943, 303041800), ivec4(420877332, 370810140, -83884271, -50726664), ivec4(-168165890, -269619728, 67172851, 100992517), ivec4(471273482, 454827294, 185537562, 134744330), ivec4(84347145, 33554434, 353438471, 725525), ivec4(-337122830, 100793074, -100924922, -329480), ivec4(252775942, -50330871, -235801865, -118099471), ivec4(-117703174, -420679179, -539041823, -152115230), ivec4(185271549, -235207414, -252909334, -50661131), ivec4(-67437828, -16974084, -100990976, 571606265), ivec4(606940203, 303173912, 235735567, 134479616), ivec4(-67043327, 167772416, 168562196, 83948535), ivec4(742135039, -2019571991, -1296587623, -1416263274), ivec4(-253177163, -1076445006, -608050726, -538713612), ivec4(-338240820, 334815985, 912087090, 589307184), ivec4(741079294, 857544988, 1667055401, 1148088927), ivec4(1129409369, -707921371, 201463818, 591554374), ivec4(184746248, 2101476873, 321800030, -739774482), ivec4(219022815, -1445656831, -1012030059, -1463159315), ivec4(-908997198, -523123522, 266395365, 1766727693), ivec4(1097165926, 1027691585, 189558602, -1447308063), ivec4(-1363492167, -941693240, -1398820670, -439431739), ivec4(-673060628, -387852833, 236524794, -249219569), ivec4(-742079542, -183700247, 202116852, 84675863), ivec4(-235599613, 707003894, 657598766, 808330011), ivec4(997216294, -605555456, -252719414, 185928177), ivec4(-656347920, 235937024, 320735493, -218760706), ivec4(183496180, 1901308, -287450400, -404234513), ivec4(82103505, -370083326, 168891648, 722994441), ivec4(1279669548, 1125851206, 1298615876, -573184220), ivec4(-926502, 234683904, -1127030267, -1008475458), ivec4(-506015030, -152050721, 32834312, -134676469), ivec4(-942284555, -304687159, 168035326, 17437980), ivec4(-99084802, 319224558, 119087129, 318307841), ivec4(959852585, -234741710, -236588814, 371526895), ivec4(-218692072, 1027607525, -33754105, 454955777), ivec4(-134414075, -133427193, -909191967, -1027158846), ivec4(-186200384, 67832075, 655684588, 941360404), ivec4(1616136523, 607470663, 1227828797, -352380359), ivec4(-186393378, 17169156, -236396305, 81843430), ivec4(-641678864, -35201049, -167904512, -33292547), ivec4(-118161415, -1111636506, -136130874, 167378946), ivec4(437261081, -438835451, 538253070, 302250765), ivec4(692408621, 387196968, -235276021, 235075830), ivec4(-337184507, 201062903, -723712999, 470284267), ivec4(102311724, 118223855, -150468865, -523053078), ivec4(-775372584, -529453, 50531855, 320673041), ivec4(219419656, 722540831, 1213347118, 1096175937), ivec4(99944750, -33622521, -574039316, -385872128), ivec4(-1076958737, -573321535, -236462365, -320279050), ivec4(319155946, -959187449, -321200680, -84805636), ivec4(68951303, 270411025, 437849346, -453571567), ivec4(470748155, 320541202, 371138584, -504756971), ivec4(-167969046, 119283721, 188228611, 116844256), ivec4(-15723754, -118296074, 168954616, -891163903), ivec4(-943078469, -320612149, 354686724, 539162603), ivec4(436928521, 572327694, 690763051, 1261902364), ivec4(776092485, 151786776, -757869587, 34340318), ivec4(-203700000, -321668913, -640032276, -590424614), ivec4(66183650, 67833615, -540487701, -135405856), ivec4(655559936, 1059526441, -35526373, 16187666), ivec4(117373690, 16585756, 723388936, -150992360), ivec4(183824373, 741616415, 436802336, -135857378), ivec4(152047116, -656149511, -117767695, -386335236), ivec4(-556279846, -808856093, 252376799, 605430816), ivec4(269885231, 286138140, 521802776, 539437083), ivec4(859982904, -135271924, -622927896, 301196251), ivec4(-554757856, -639375392, -404100124, -405222186), ivec4(-285541910, -538316821, -488975404, -101584145), ivec4(99742455, 320810783, -133159649, 455349756), ivec4(-471857643, 268630520, 286326791, 201789204), ivec4(-203036672, 454168317, 321795632, -299095792), ivec4(168029913, -202178298, -50722816, -505810917), ivec4(-439566642, -504104720, 974384101, -97564602), ivec4(-50137630, 436862455, 676019226, 169290540), ivec4(-422646783, -521475339, -99212800, -839974695), ivec4(706627615, 403374109, -655699237, -351913218), ivec4(204214024, -1195583512, -1010827044, -571676176), ivec4(286445513, 525555486, -437316083, -928273471), ivec4(524757762, 371074079, -1044592903, -622537040), ivec4(-267314959, 1143013374, 860827704, -151588351), ivec4(-135538984, 540744968, 591875103, 65990151), ivec4(-370476020, 791409642, 218629913, 1884960024), ivec4(-84011194, -1449244, 807538985, 674833179), ivec4(-387976711, -471990529, -657076256, 351859947), ivec4(789581088, -100860388, -1197163819, 51189499), ivec4(285213703, -992808950, -1011896391, -455679010), ivec4(-17765136, 454501902, -286783964, -641152537), ivec4(573250291, 1452848, -622663196, -1110119453), ivec4(166255564, 18159128, 1010378500, -184347865), ivec4(-605749772, 285935082, 945244459, -268432629), ivec4(-453909272, -135009070, 118629389, 1380527905), ivec4(473250880, -589963528, 572460275, 572923934), ivec4(152379683, -286993700, -220278043, 370344444), ivec4(168428298, 908204306, -908467183, 218096334), ivec4(421601301, -336270336, -152972330, -287449869), ivec4(-404030469, 404753141, -67042040, -218628354), ivec4(-35660047, 35465233, -234810869, -506212889), ivec4(-69151015, -287376105, 302316285, 455290662), ivec4(50856977, 217044964, 773658902, -368435917), ivec4(-168498467, -421073426, 572654317, 184946708), ivec4(153172013, 421600011, -100595444, 907411964), ivec4(-335535813, -472720925, 101452793, -117308148), ivec4(14734559, 538580494, 303963948, -151916298), ivec4(-235737872, 436730352, -287181046, -655492095), ivec4(200530896, 16318718, 235404029, 117770516), ivec4(-320803595, 689373950, -116317655, -1095254063), ivec4(218039023, 370151699, -235669492, -67632898), ivec4(773720061, -101049035, 454039058, -202246122), ivec4(-218431492, -50529295, 84477956, -319489277), ivec4(369295862, 842476329, -554170339, 403832027), ivec4(354691884, -1025771776, -538186287, 217374432), ivec4(-15133175, -16580363, 16251392, 85598739), ivec4(16382201, -83622134, -908928539, -101062704), ivec4(335806975, -454297073, 150330843, 875306772), ivec4(-167043537, -252977184, 16580345, -336134649), ivec4(190169, -185863687, 285933818, 84017164), ivec4(369758735, -32235997, -51189525, 353965319), ivec4(-402976999, -186394154, 319357957, 101324057), ivec4(32828923, 218631692, 203434267, 268435465), ivec4(17698831, -184944134, -101653272, -218695432), ivec4(-84212740, -185996812, 286000896, 473445663), ivec4(-555949063, 269353192, -217903341, -489039903), ivec4(-336728343, -16712464, -592648, 118232593), ivec4(337121032, 16646921, 134807039, -50268167), ivec4(-422192660, 33487862, 303171328, -303237625), ivec4(352910322, 1010970652, -151714525, 252115451), ivec4(117966343, -286857224, 84543997, 50134271), ivec4(83689219, 421273364, 690165783, -235403238), ivec4(251987196, 302319118, -740428271, -186129186), ivec4(235602171, -168294387, -50593541, 605357315), ivec4(-454293986, 235141102, -117636856, -656611087), ivec4(-16975896, -198406, -336463874, 84212457), ivec4(386859265, -184083425, -51056406, 167706112), ivec4(-470483189, -17238042, 218564608, -67439094), ivec4(369431554, 521670679, -488376804, 66125534), ivec4(522325269, -607067128, 133886944, 421661720), ivec4(-100924658, -570555417, 807210496, -168424925), ivec4(505806576, 1185842, -756748046, -68434489), ivec4(369825554, -923787472, 318363852, -585616872), ivec4(169014996, -34417474, 439243562, -537787625), ivec4(620618451, 167717962, 575022604, 234343653), ivec4(-150795776, -941884428, 419751645, -84664780), ivec4(-355730666, 149085132, 859781685, 85944152), ivec4(-3025406, -976298515, -35924532, 468960215), ivec4(1128998158, 977363037, 2052805482, 509505392), ivec4(-403564536, -808276299, -1042103377, -1397371180), ivec4(-928596279, -218173210, -183963679, 65268214), ivec4(389614349, -1039853025, -1752127574, -1549485388), ivec4(351982270, 1631662864, 1936344431, 1231575383), ivec4(1465738325, -95990962, -1227557922, -1734297928), ivec4(-1061704022, -168366365, -774515229, -201592341), ivec4(-622596375, -774705426, 200605711, -838926836), ivec4(-1581861477, -757873485, -84090171, 522393612), ivec4(2002413403, 1667719030, 827546698, 337390379), ivec4(-1278029073, -1295921739, -775894856, 386790887), ivec4(-252910608, 470750205, -808131831, -808265007), ivec4(50462435, -167769842, -1027886645, -606876487), ivec4(14800354, 572331278, 1515274795, 1954116971), ivec4(1027951967, 405945137, -876159232, -774450992), ivec4(-555822908, 152043246, -455020553, 66779121), ivec4(-504691951, -773987101, 124882, 202313480), ivec4(-824973059, -893337650, -321071147, 656018174), ivec4(1313879083, 2021095262, 1045784182, 690956335), ivec4(-538050795, -926498866, -774651194, 369687774), ivec4(-419821546, -202644256, -588645123, -437394215), ivec4(-33494043, 185009912, -841551351, -1128346413), ivec4(-825832511, 369291996, 1211642412, 1820030049), ivec4(1195597412, 169155369, 15857163, -859052037), ivec4(-1162492732, 100985039, -50844902, -705301526), ivec4(-674573879, -16834844, -135405067, 168098560), ivec4(-1144253705, -911102292, -219159075, -234611969), ivec4(1780024833, 1701859394, 458708283, 350821683), ivec4(571349038, -891617042, -860633638, 49798637), ivec4(-653128469, -524887837, 32696305, 52557554), ivec4(-758782205, 721478362, -669576430, -1584552770), ivec4(-1976374, 556924141, 639577891, 1633241142), ivec4(1163737682, 521948988, 605691948, -419038953), ivec4(-1414610749, 100595417, -83823623, -824379918), ivec4(-288570158, 841351431, -857995764, -134878752), ivec4(32830470, -1548300832, -18954315, 251853313), ivec4(842733573, 1263295048, 2002142801, -14202012), ivec4(403835133, 252517675, -1143020049, -707540037), ivec4(183562722, -503644910, -320608547, 116584946), ivec4(-284486372, -370744098, -185532934, -1127952661), ivec4(-337525320, 167180270, 792408360, 1194929954), ivec4(1078019910, 1129270618, 51911708, 135071743), ivec4(-436202224, -556219187, -455286557, -285475854), ivec4(-455091742, -201457424, -83096830, 268302583), ivec4(-571608060, -706879267, -708855869, 66909157), ivec4(1110910479, 975712063, 1044068410, 1146312007), ivec4(370088232, 34475024, 168362234, -657465359), ivec4(-353704478, -219157016, -303174419, -352976645), ivec4(167964897, -353241862, -504958990, -674443307), ivec4(-1043736609, -287319344, 942216962, 286860343), ivec4(505423644, 639635730, 236463661, 218892044), ivec4(335804670, 50465812, -167311607, 83423462), ivec4(-285470961, 320604402, 251656955, 67604), ivec4(-319420671, -218826007, -470877952, 393970), ivec4(537062373, 68098609, 988942, -66919184), ivec4(453375228, -85393397, -370807549, -15201280), ivec4(-67045645, 266782429, -303832320, -260352), ivec4(218104074, 655950336, -134412256, -304683512), ivec4(-453439483, 1116139, -101914383, 470681612), ivec4(-34339814, -251253471, 83559926, 16972032), ivec4(301860357, -166775755, -284950280, -235345960), ivec4(200599790, 318438406, -234875108, 338900493), ivec4(387911436, -286328319, -235277344, -251656965), ivec4(370932970, -83427582, 133496834, -84344817), ivec4(2499849, 51054582, -51386124, -16318728), ivec4(33555716, 16383231, 167305709, 268434176), ivec4(-83355101, 235932168, 203296255, 267511021), ivec4(-118361330, -285940502, -118425622, 672728583), ivec4(200997390, -504427758, -67437583, 270337011), ivec4(134479877, 200801032, -252442596, -100729357), ivec4(-538183942, 233959404, -84013795, 270939157), ivec4(201523975, -134878979, -854031, -337050857), ivec4(-319358472, -33492250, 268172286, 101783063), ivec4(-335213561, 34735594, 167308787, 151126790), ivec4(-419953404, -386463493, -15597331, -202249753), ivec4(-83944693, 370543111, 86124567, -67568128), ivec4(-354821136, -386990852, 724985, 51187457), ivec4(117107956, 100661757, -83490290, 62197), ivec4(-15791112, 639240446, -252181220, -554500881), ivec4(-185143583, 51312876, 387386109, -169217527), ivec4(185536008, 17437705, -100007680, -320149270), ivec4(-202314265, 219088380, -252248058, 202047215), ivec4(436995335, -185466348, -285539587, -34281242), ivec4(354229260, 218298875, -505090298, 116582623), ivec4(168625415, 302974469, 386404366, -318896362), ivec4(-117377291, -101516304, -352784905, 251789557), ivec4(33624845, -217970668, -387843594, 672859638), ivec4(859441, -336199674, -252383762, 471207936), ivec4(17170445, -538055438, 133950694, 707399688), ivec4(32571444, 453583631, -420151561, -351070223), ivec4(-336469774, 1780996, 403177957, 285474540), ivec4(-539894768, 1276720199, -51245312, -17170706), ivec4(-317789718, 876540653, 556422166, -893589009), ivec4(-539368480, -337125372, 1529758780, 16848183), ivec4(-352980515, -402794284, 419810028, 675235602), ivec4(-472452099, -302847499, -418380016, 1160593693), ivec4(-522191831, -420097598, -185740061, 1579281675), ivec4(1702130002, 136729695, -992024041, -1395801913), ivec4(267185850, -723452638, -537803839, -892480542), ivec4(-122046760, 271192577, -908925704, -504959242), ivec4(17688025, 607594733, 420817464, 555808780), ivec4(-117238003, 14418447, 523048986, -1379144710), ivec4(-860042054, 65850058, 1666786042, 1145795951), ivec4(1025842734, 337981741, 841631022, 1969515107), ivec4(-721473198, -1380200766, -910976092, -85541190), ivec4(-605818389, -540818480, -875044631, -168100897), ivec4(791094023, -586998496, -1262434872, -507334478), ivec4(503642606, 1431588661, 656485964, -385341387), ivec4(-707140643, -219552297, -655231497, -555361324), ivec4(64934099, 959456275, 959852088, 67311416), ivec4(-117438711, 623320062, 1531391267, 221791319), ivec4(-1127689494, -1096375636, -151526193, 235998207), ivec4(168235029, -874055159, -825308736, -455487027), ivec4(85067254, -386926856, -489694747, -17305100), ivec4(201982977, -51315959, 34276870, 168097778), ivec4(285738764, 270406423, -689770250, -102507306), ivec4(707468559, 1397438251, 707673935, 102175005), ivec4(-353176073, -454037792, 235275776, 572528928), ivec4(-387975169, 84091172, -253706252, -217378578), ivec4(85193724, -34407460, 403446557, -102363334), ivec4(-335612431, -170468895, 672535276, 204811814), ivec4(-103016188, 83295248, 487976700, -825959461), ivec4(134016225, -65338646, -572190482, 269291779), ivec4(-66457081, -522985785, -82311671, 151983098), ivec4(-134084873, 1228026950, 674378819, -873796087), ivec4(723320292, 1601061702, -991228094, -1515541559), ivec4(-1365405272, -1851880811, -876892256, -286988075), ivec4(-351800326, 1009195260, 337975349, -1313029909), ivec4(-1111244890, -135404586, -185732615, 874518018), ivec4(1615413809, 1029134175, 1717199150, 1835297124), ivec4(1851350904, 85078088, -1144925449, -1769629784), ivec4(-270744422, 184091126, -236128510, 401858517), ivec4(269818646, -1211832577, -1465603426, -69548353), ivec4(50009104, 354159104, 554765583, 152314646), ivec4(1328618764, 1885633138, 608198260, 320211982), ivec4(-739245541, -1902462523, -859527784, 469825010), ivec4(-420545773, -117909273, -236654868, -974193659), ivec4(-1011042113, -607073851, 201651442, 353566460), ivec4(505880600, -301520604, 1259860725, 1886616678), ivec4(912550264, 235540766, -637467396, -1211704352), ivec4(-995250773, -387854117, 453773039, -252448512), ivec4(-387122944, -622004755, -792213289, -270345516), ivec4(320008689, -118427400, 690627861, 589574189), ivec4(352846861, 1817660222, 1668509537, 271596365), ivec4(-689567233, -842218289, -977814068, -606612537), ivec4(217969131, -335738616, -201916173, -387515656), ivec4(-1178746921, -371734605, 184676589, -151977200), ivec4(420876023, 740896050, 807476253, 1364869173), ivec4(1464552770, 658919768, -386463467, -1044660529), ivec4(-825900859, -824915005, -84482597, -386331134), ivec4(-100864788, -152175882, -1194403605, -489441865), ivec4(-135004183, -269682432, 757735182, 336857891), ivec4(875374113, 1380861249, 1397245258, 894721372), ivec4(-67431627, -539438624, -1211184681, -490160465), ivec4(-83165195, -336199939, -330013, -67373307), ivec4(-807737878, -842018872, -438508072, 135400696), ivec4(251987463, 606478872, 555752995, 1329936163), ivec4(1279808350, 1381457752, -218361036, -555751958), ivec4(-791160868, -859784765, -34281514, -134218498), ivec4(117039587, -268368631, -573319198, -740829223), ivec4(-605889323, 336460773, 218694412, 421009422), ivec4(724118562, 707207981, 1465207867, 1381194844), ivec4(-83351994, -689704967, -757605160, -927352119), ivec4(-185934125, -1054481, -17566973, -134217984), ivec4(-471669525, -757934622, -606416690, 335473114), ivec4(-151387373, 656279287, 623717932, 723395366), ivec4(1095584312, 1212761151, 152910927, -285738498), ivec4(-606413090, -943204383, -270413363, -185600009), ivec4(-404620801, 101186549, -319885060, -437915407), ivec4(-455552548, 116515036, -201452259, 319353583), ivec4(505815059, 269490712, 724639509, 421141019), ivec4(152577318, -397319, -303499526, -807800584), ivec4(-270214957, -134346753, 332038, 505550082), ivec4(168364818, 253171735, -472459018, -34869783), ivec4(-302247403, 167635688, -32760553, -151257345), ivec4(218889455, -167903228, 185796345, -471867667), ivec4(-253104917, -639240709, -219883307, -151189248), ivec4(825367811, 572597286, 455485734, 320413983), ivec4(-185931266, -17041164, -16250368, 167375352), ivec4(51781144, 134611717, 538053897, 386792701), ivec4(248301587, 216463144, 188950516, 356056564), ivec4(-795961392, -436459519, 1157695994, 842216782), ivec4(200207670, 148959699, -793068058, 994455008), ivec4(-78959359, -358237493, -389681661, 1278034444), ivec4(-373487301, -52760814, 117562574, -202170087), ivec4(52174830, -31325998, -607788602, -557198602), ivec4(1158874593, 15810384, 350752260, 3411968), ivec4(-540149774, -13750536, 1042807228, -605155585), ivec4(-119415296, 940115954, 134505561, -271581694), ivec4(35383012, -169146627, 741881356, 537844695), ivec4(-671879710, -541472010, 1159066855, -535994802), ivec4(167975682, 605607941, -755889143, 436074973), ivec4(15716602, -14882833, -657194988, 586409453), ivec4(-517126859, -418510100, 502458630, -251658739), ivec4(304161542, 401865240, -453907676, -776024899), ivec4(283239404, 861889619, -150012167, 66387950), ivec4(-287121425, 388572431, -151645430, -167768051), ivec4(-270346536, 116648935, 741957180, -134018293), ivec4(-286203689, -285076985, 419887863, -132367333), ivec4(35595264, -926824470, -186265910, 690236173), ivec4(758463018, -219027440, -253103888, -186520078), ivec4(18093577, -12965637, -370878500, -1582115), ivec4(927544336, -285210090, -369825556, 536600534), ivec4(-218427370, 85269774, -334950394, -403709736), ivec4(-304356897, 606013180, 102111010, -66845439), ivec4(184545261, -236459784, 50200844, 691941658), ivec4(-757011196, -101654828, 857143539, -149871295), ivec4(-421142300, -252650020, 386923761, 353638687), ivec4(50796321, -672992250, -337520683, 605483493), ivec4(135073058, -185863944, 353763321, -437519605), ivec4(67564775, 268828672, -200991206, -303501577), ivec4(16315634, -133953266, -69016345, 117505280), ivec4(83690256, 319885074, 117571337, -167379978), ivec4(-656745490, 688256997, -823452109, 570352845), ivec4(270538788, -235212792, 536937700, -368833006), ivec4(-100730368, 200736497, -83486954, -420149499), ivec4(-102703137, 153164045, -253164789, 789118445), ivec4(422780982, -858520312, -36975680, 386533407), ivec4(-49800691, 15198190, 555485443, -200142591), ivec4(-169680416, 470615062, 151525141, -387256593), ivec4(-724735, 202246399, -83293179, -51579398), ivec4(-133760274, 436988652, 808272184, -706345188), ivec4(-523253551, 150996224, 51580429, -134943249), ivec4(269027577, 455351061, -202378739, 100665338), ivec4(-49605872, 33292283, 34544400, -100792307), ivec4(-320478486, 269417196, 219482885, -51318278), ivec4(471670545, -318890717, -556541471, -100797206), ivec4(286130162, -16776182, 133953276, 202246659), ivec4(-135401727, 117768699, 85596169, -488706569), ivec4(370214131, 152113172, -236130822, -67834384), ivec4(320275965, -286589684, 404033282, 253434909), ivec4(-487852030, -320217119, 386396907, 16779540), ivec4(151654160, 336200200, -386792431, 167835891), ivec4(555816720, -302644463, 134545398, 201455360), ivec4(-285934329, -118428180, 268894203, -99673319), ivec4(185469950, 437456139, -453770223, -151589663), ivec4(-17897232, -117305331, 134416125, 185142802), ivec4(-369687796, -17042969, 285408507, -167306723), ivec4(133885677, 167510027, -100727540, -235736848), ivec4(49936115, 68888601, 353370103, 151389965), ivec4(-83558139, -134878229, -303369485, -67106558), ivec4(386661882, 84810014, -217575932, -269425954), ivec4(151060724, 1913367, 335477760, -17307657), ivec4(-149813508, -355212555, 701358880, 891482426), ivec4(-135145499, 87625977, 397310, 16705760), ivec4(251984381, -367192333, -50720274, -622789618), ivec4(639764196, 134285081, -370684167, 504887032), ivec4(606480903, -66310884, 120404259, -456792071), ivec4(-929115641, 17901817, -893597191, -388303110), ivec4(-304276459, -3163949, 2020819234, 1885148729), ivec4(1483236463, 659386988, -958264789, -721824826), ivec4(-1716938583, -772680539, -907750732, -673252882), ivec4(68162559, -1094727926, -1378961237, -639908426), ivec4(-1849765679, -202056523, 453842439, 1800697683), ivec4(1734627704, 1584689229, 1027218999, -418437104), ivec4(-117183528, -705698329, -520883503, 488703450), ivec4(-521067768, 487854846, 690624543, -940638701), ivec4(-1212957257, -1481850180, -1145521213, -336533818), ivec4(1162422783, 1868183337, 1635088497, 893668964), ivec4(-520873167, -220013086, 98620902, -301268978), ivec4(-724315954, -151195431, -623053319, -135996446), ivec4(270471689, -808396051, -1026963000, -842673713), ivec4(-1398161192, 420210887, 470945289, 1465468722), ivec4(1735554402, 623593826, 795439, -858795805), ivec4(234679003, -453700840, -572792091, -68030234), ivec4(-622993163, 638186469, 34478625, -1043205629), ivec4(-186000439, -1363687707, -758266702, -270347313), ivec4(556078330, 1851736360, 1869642619, 960778588), ivec4(-317443780, -522330147, -135536417, -503903993), ivec4(-472197933, 134149102, 723467, 334817262), ivec4(-99803097, -319755794, -959588127, -1061110846), ivec4(-893340232, -353836847, 637790695, 1650349376), ivec4(1835360351, 1162698606, 440289600, -573516564), ivec4(-50727703, -336069123, -607201826, 202048753), ivec4(-303764991, -84544528, 135665677, -688979451), ivec4(-269623598, -994062622, -387920943, -556673818), ivec4(16186604, 1649884443, 624576606, 925902129), ivec4(488780854, -32832002, 84603133, -521998583), ivec4(66318300, -134608632, -335409903, 184477406), ivec4(-385406429, -33484820, -640692506, -555028491), ivec4(-540152874, -454491392, 386726626, 1251355), ivec4(841427998, 337126697, -131786999, -51456053), ivec4(252779282, -151259908, -689574422, 724375793), ivec4(319814153, -218099700, -32239111, -151921165), ivec4(1180660, -35270436, -487912944, 50524384), ivec4(1446922, 723061248, -388571375, 338041335), ivec4(-236258806, -303569162, 133683157, -304548595), ivec4(-201523453, 605812198, 269294613, 823856146), ivec4(-101385447, -150072063, -35592977, 168362242), ivec4(-118227969, -638641899, 857798373, 152444707), ivec4(16715540, 267251975, -435808488, -117439505), ivec4(-186853137, -402980088, -118292241, 185471501), ivec4(707201540, -184811760, 487591941, -403107806), ivec4(-149745933, 32105695, -201193198, -133628698), ivec4(-184879128, 606411272, 286197771, -337051893), ivec4(-32565498, -201462548, -134417177, -168824847), ivec4(-521997833, 487386586, 438642986, 621738754), ivec4(-135336178, -132963571, 16577266, -286267404), ivec4(33022687, 234548988, -319424762, 606473973), ivec4(150602513, 100333573, 17109781, -184285440), ivec4(-135732762, -33421824, -472853782, -303629056), ivec4(1010049290, 150865185, -101777395, -17231592), ivec4(235672074, -419488227, -170936110, -236593156), ivec4(-118424843, 456142090, -302319606, -219354386), ivec4(556019988, -84339431, -518775288, -522531370), ivec4(-574236951, 757275884, 423572268, -975113753), ivec4(-403312392, 199554037, 187065384, -217393134), ivec4(-738989603, -69216831, 828668229, -1124857589), ivec4(-1279149088, 317901246, 1209205489, 105142890), ivec4(-115137004, -857354811, -355943999, 1314929155), ivec4(-1024268541, 254151917, -487060465, 486271166), ivec4(-603571138, 623181311, -436602617, -692070962), ivec4(1332759573, -821558753, -704706062, -474295856), ivec4(367847907, 625105764, 136919618, -926301986), ivec4(-373639257, 1161504533, -555550642, -202119445), ivec4(387516397, 787728346, -29474738, -505286170), ivec4(-269815568, 32165841, 1349992700, -1295652552), ivec4(-83369547, -890697749, 771026136, 658391129), ivec4(306008368, -1280521245, -204820810, 1211633642), ivec4(-403823776, 200336365, 53024762, 567591898), ivec4(1264933468, -774118656, -857935143, 637588677), ivec4(1685010454, -1347098319, -221067071, 69996788), ivec4(604506363, 589843276, -268768256, -538444049), ivec4(-455878175, 1143661786, -607257312, 587795721), ivec4(540484923, -421268741, 975051013, -253043178), ivec4(-402456338, -674833432, 1832644314, -907007926), ivec4(-472721456, -66322927, 370347761, 725703732), ivec4(334684698, -1378556661, -708393039, 1393157347), ivec4(-301455275, -1380880, 624709205, -992745728), ivec4(304282557, 351399443, -235274714, -1127691046), ivec4(1242033097, -31312804, -402594069, -353164781), ivec4(-590092044, 1467561200, -370407371, -977283323), ivec4(-1078810959, 1344937184, 305354870, -690175499), ivec4(-202373922, -235137277, 691402989, -421403138), ivec4(165866501, 16185867, 504693994, -888451508), ivec4(-171007056, 338704901, -975041794, 774762198), ivec4(-67174648, -67166697, -658843909, 284947428), ivec4(491679819, -555487479, -422392371, -806222620), ivec4(1174855370, 1415265889, -705686733, -357251640), ivec4(49936635, 206653726, -1161569044, 13415856), ivec4(677860627, 133820917, 370081819, 1053454), ivec4(-876351759, -185406476, 374752267, -908792849), ivec4(300140745, 288498962, 317845248, 1211245097), ivec4(-467978930, -1011826484, -841755428, 1482104549), ivec4(-184085965, -489568036, 606143465, 201462827), ivec4(303633692, -571410680, -725957680, 270403829), ivec4(625489429, -17370619, -35793163, 454758142), ivec4(-606012397, 68095486, 455019513, -639959027), ivec4(-101977103, 454491379, 337585182, -118949883), ivec4(-169220628, -437978628, 520818177, 455416346), ivec4(-673847816, 302382054, 808591644, -605552615), ivec4(-455815991, 82104545, 136129055, 921859), ivec4(201984258, 17367039, -219090949, -303041029), ivec4(-403114005, 235272932, 403575839, -269286885), ivec4(151717368, 673059593, -149808094, -270541591), ivec4(-338171144, 219154690, -101190145, -134611976), ivec4(538185733, 303968814, -387384309, 49866730), ivec4(268233464, -50920438, -184742128, 201786108), ivec4(50331657, 337054219, -522263308, -571936279), ivec4(639438322, 16584743, -219351809, 117505787), ivec4(135865631, -807471614, -152707113, 369097987), ivec4(235672095, 370480917, -68092399, -303368188), ivec4(184877822, -353766391, -251921680, 352382182), ivec4(-67498465, -16907774, 504696069, 421405987), ivec4(-521141997, -505683746, -134676236, -32697852), ivec4(269155831, 134220821, -252113131, 504828160), ivec4(-554690776, -504631064, 250404572, 186263591), ivec4(-83755004, -84809749, 236328198, -235405306), ivec4(-253238294, 185139960, 34741269, -386993674), ivec4(352451567, -185665003, 434692336, -81512911), ivec4(-926426392, 1024253643, 137901380, -506207512), ivec4(-184156692, 1550268168, -100723944, -759113997), ivec4(401722846, 372455982, -1280060420, -53763660), ivec4(-320019219, -756089875, -539304987, 168093374), ivec4(268104959, 1159470642, -1563959248, 671872961), ivec4(1986154050, 672676720, 706358326, 944201812), ivec4(1414479679, -1041889741, -811948352, -269092361), ivec4(34277632, -403112725, 98492653, -790958841), ivec4(-318366739, -1446252035, -489576818, 958602240), ivec4(-166701989, -235078400, 893464572, 992751423), ivec4(-536598723, -1784100658, -135076417, 33617651), ivec4(-17701899, -303299323, -235010808, 775294189), ivec4(-385018346, -743594808, 808718571, 441671229), ivec4(185075196, 908525308, 270154033, -149673434), ivec4(-907877401, -168963146, 116916224, -202374387), ivec4(-587659778, -454103338, 317707993, 33293336), ivec4(-1481781015, 957542093, 1247035191, 286002468), ivec4(756161056, 675496002, 135863314, -656348942), ivec4(-658987331, -503973659, -117115419, 269484273), ivec4(-83429890, -186126607, -234151918, -1312631572), ivec4(82561448, 806360867, 33630021, 606808337), ivec4(960189001, 554633766, -908592864, -422191139), ivec4(-520815099, 234413262, -287316736, 235278087), ivec4(-622662144, 119938296, -1010446628, 150855120), ivec4(186657812, 137972770, 925634559, 1047354420), ivec4(-219410908, -569693677, -689643057, -134084636), ivec4(-153432864, -370277622, 1185276, -218168058), ivec4(99933402, -808658692, -18950453, 674307346), ivec4(1144985102, 772538387, 1313356360, -352318173), ivec4(153094895, -136063259, 253363446, -1010440704), ivec4(-604769577, 83088074, -117372931, 15262447), ivec4(-773053918, -506347060, 1060577283, 553451300), ivec4(-454685899, 908929022, 186331982, 755887343), ivec4(-571999709, 250931941, -536209384, -168962357), ivec4(-271001625, -202183176, -555289871, 1968619), ivec4(-590555937, 975766251, -250791613, -385675009), ivec4(824899039, 455751206, 267583512, -267440847), ivec4(-302714657, 319949312, -220080144, -757602313), ivec4(-101318422, -67044868, 975109616, -756942815), ivec4(418569175, 137376041, -184619289, 232246752), ivec4(556210465, -386990067, 708191231, -202513148), ivec4(319554029, -303559386, -604963073, 16836047), ivec4(251592963, 503249933, -503041474, -489631022), ivec4(707008776, -18290678, -606737926, 521806862), ivec4(-386202088, 874247903, -320007627, 133884657), ivec4(35463948, 85004290, 15261170, -151256063), ivec4(-201718008, 305541126, -673456914, 437257960), ivec4(-571798494, -487064333, 522585566, -66513382), ivec4(250339822, -317179086, -203035418, 421002490), ivec4(269417985, -472190460, 168559872, 34672131), ivec4(891354356, -572657123, 167765721, -234154995), ivec4(-134941, 570352366, 236526114, -522260481), ivec4(675097348, -437722121, 200735731, 218435100), ivec4(-570816753, 134215134, 286329100, 217051397), ivec4(-402840529, -34741530, 134873859, -303701000), ivec4(-135728138, 471671577, -453967081, 824114141), ivec4(-555813082, -336335138, 186193658, -167768814), ivec4(-51455268, 370545932, -268891120, 137177094), ivec4(-152310808, 50332421, -253167868, -319360016), ivec4(437717492, -100196835, 418370279, -436064470), ivec4(32432105, 454361340, -570813427, -389163560), ivec4(641341718, -855951589, 523171021, -469953536), ivec4(133816526, -300281607, 48757493, -621740804), ivec4(306471945, -604969480, 1095702505, -809053722), ivec4(1377107450, -82317020, -319361542, 634900973), ivec4(304484642, 217576193, 389231895, 132093139), ivec4(403312644, 49938711, -487655914, 605290474), ivec4(-620880879, 924382452, -857733848, -201655100), ivec4(654246940, -153749746, -740102143, 1024997933), ivec4(-689631434, -520092194, -508637465, 588188420), ivec4(-67173099, 33230336, 248900346, -687269858), ivec4(670499813, -384350146, -402925863, 17106401), ivec4(-218425335, -638126600, 958274001, -183222194), ivec4(-32306192, -1244596250, 17171141, -32764669), ivec4(454233575, -371133947, 103752451, 115731426), ivec4(-80462043, -624172060, 371262935, 287644435), ivec4(-419500569, 737659064, 439633996, 251718647), ivec4(-520553724, 66311125, 34867216, 202965477), ivec4(-587986143, 1043002837, -336402689, 505814789), ivec4(-673260275, 185592016, 269620512, -117902061), ivec4(-539048996, 474495503, 250738194, 236584962), ivec4(-657334791, 168758272, 386919170, -804774889), ivec4(468374226, -49343690, 271650814, -403305465), ivec4(149536724, 321003287, -168162293, -723921931), ivec4(1111825122, -470611161, 184347887, -605290487), ivec4(34539230, 336198133, 253631758, 98423504), ivec4(-16378068, 151453930, -49015558, -18225935), ivec4(235342326, 118035470, -673316848, 891154112), ivec4(923940, 284420083, -555287293, 118685160), ivec4(33554684, 85199608, -220540948, 405224725), ivec4(-555289336, 202506481, -134807049, 83623184), ivec4(201064454, -621411580, 754766549, 523781434), ivec4(-422196757, -101514239, 487391999, -638387184), ivec4(420545250, -522455283, 488181504, -386460906), ivec4(268301540, -101254905, -654855, -303040765), ivec4(33950209, -135140881, 573387544, -287972093), ivec4(2236162, -370605313, -50198022, 33813236), ivec4(-840493811, 636804060, 372653112, -338040581), ivec4(-168823552, 487322876, -49470691, -84150021), ivec4(-538579471, 673714410, -537785558, 824180959), ivec4(-335541729, -622988563, 318433762, 203502634), ivec4(-354816770, 588911367, -302709478, -184613128), ivec4(99675117, 101584142, 100072964, -235011830), ivec4(571274730, -234086107, 100068070, -218626287), ivec4(16773097, 336461560, 219483659, -724047616), ivec4(723585507, -318627530, 84473060, -135075086), ivec4(236261376, 33686534, 101318918, 48554481), ivec4(505353751, -102042868, -217445115, -169416985), ivec4(285537532, 386991366, -386267891, 553835226), ivec4(85402404, 65855469, -152636408, 101382133), ivec4(0, 319028734, -370411251, 689639161), ivec4(-303168477, 252377077, -387783441, 217710848), ivec4(117969177, -150862324, -187706655, 757866779), ivec4(-219615734, -201584373, 184217850, 16515846), ivec4(-34213118, -201583341, 403631078, -267770332), ivec4(167505897, -521668597, -84151067, 236131849), ivec4(302513928, -757207292, 706681591, -420214493), ivec4(-16317708, -219221262, 167903233, -100333304), ivec4(169613054, 233693684, 354492956, 33027072), ivec4(-419951605, -135274528, 522459386, 134548247), ivec4(-655687156, 453696967, -150463200, 520419054), ivec4(50992672, 16779015, -605621765, 217965266), ivec4(-438044413, 825243915, -117764308, -354038052), ivec4(-456075555, 689704725, -66639563, -369481434), ivec4(-455357731, 70532379, 319495685, -13953541), ivec4(-99355935, -1309672223, -405673533, -1461775598), ivec4(-437657671, -66380536, -65532411, 52695036), ivec4(286001636, -350802413, 658187003, 316530426), ivec4(1700425053, -167099556, -655880944, -304088070), ivec4(990969331, 606205182, 68677881, -860449615), ivec4(-538977839, -18357532, 472387085, 33806567), ivec4(-553196338, 369349817, -150535166, 1614886438), ivec4(371345762, -371800320, -773073459, 302053355), ivec4(707404071, 488774182, -1314735627, -187113013), ivec4(235139093, 790302709, -203564523, -402723364), ivec4(-386407974, -384625677, 1294604526, 658792292), ivec4(-640417012, -622531857, -33824559, 218830087), ivec4(33171505, -1481376225, -540559428, -318702364), ivec4(286657776, -907075552, -236651808, -220012287), ivec4(353829106, 839450379, 1382246231, -739637211), ivec4(-186982429, 15258859, 538648337, 51981609), ivec4(-840499195, -894324551, 16578535, 201721602), ivec4(-31512286, -202447896, -522124542, 133622772), ivec4(-49998832, 1431849257, -470409662, -521933853), ivec4(-438177037, 572526592, 473115931, -49606385), ivec4(-1178743065, 151056593, 151916045, 202642445), ivec4(-421340181, -369098514, -152311582, 101780737), ivec4(1160711164, -116182972, -555952413, -437392164), ivec4(689570540, 943598630, 386993692, -891620340), ivec4(217438150, 117836823, 134348285, -488706551), ivec4(-51121683, -504501002, 335605216, 705560593), ivec4(186854444, -438771721, -267801, 99673584), ivec4(790764568, 118563890, -807078915, 351524552), ivec4(270607392, -134678019, -638648323, -251858984), ivec4(419430654, 303630345, -288298238, 1042747904), ivec4(-203753662, -220928254, 63095042, 773594911), ivec4(169157953, -369952264, 82168810, 304170816), ivec4(-33299990, -336990962, -84344597, 35520513), ivec4(-85788147, -840233960, 925560532, -235527610), ivec4(-185073925, -520884238, 369164278, 302785843), ivec4(757993229, -993925110, 404492275, 386728459), ivec4(-555089148, -254156563, 387121654, -251655673), ivec4(-117431798, 368433622, 2174246, 50271489), ivec4(-437260046, -101062183, 320419091, 251921414), ivec4(-1008865786, 739709901, -66250462, -386730237), ivec4(-673251879, 234942437, 34147096, -48816907), ivec4(-220670226, 556475158, -83291902, -286136078), ivec4(-85926677, 438769650, 253037850, -538114289), ivec4(369741756, 338240296, -286129405, -469571101), ivec4(-17242143, 151588611, 438370557, -572264437), ivec4(740235500, 1643300, -320805389, -387650333), ivec4(488436977, 353112342, -65530614, -103301155), ivec4(790829835, -16054246, 16378097, -203104281), ivec4(219020532, 403109633, -302247653, 655681755), ivec4(337387055, -455284742, -117575699, 352317429), ivec4(185273104, 706281991, -774839278, 419821027), ivec4(235802647, -118431498, -337647373, 336064493), ivec4(-67834, 134809086, 687924726, 624242220), ivec4(-404162802, 554496224, 252773645, 285346580), ivec4(756878088, -419032792, 419095506, 539500060), ivec4(-437322738, -454760734, 235139559, -269027587), ivec4(-51320855, -51319564, 405216265, -571935485), ivec4(-169620278, -268960774, -50069257, 286392307), ivec4(-334621430, -237056814, 505616391, -419294188), ivec4(-286137122, 134608615, -184810231, 262393), ivec4(-50000636, 740953334, 219026213, -773852936), ivec4(-116914202, 269750017, 772407044, -66968772), ivec4(-471068151, 891687425, -99605453, 13622516), ivec4(-184734414, -250344718, 269551342, 436269829), ivec4(-321132014, -31306724, -503382016, 470870224), ivec4(-235273975, -589363196, 53556753, -284032027), ivec4(65330132, 420943126, -1161039092, -434956826), ivec4(469822430, 235862019, -353830139, -352842749), ivec4(1028005112, -571870965, 14535890, 100598289), ivec4(-503382533, 875304936, 184282644, -421734660), ivec4(455219707, -554893542, 352901060, -50791682), ivec4(-984820, -134349566, -49411082, 755230698), ivec4(-151515083, -573053204, -235470598, 49936889), ivec4(789836794, -135195597, -573049087, 723583211), ivec4(-268430045, -53294623, 83625744, -66646264), ivec4(16778752, 353302521, 82178059, -31704530), ivec4(-504368135, 50328547, 393724, 234356739), ivec4(1782057, -469761543, 688451031, 135474232), ivec4(-875173125, 202641392, 117967115, -168431624), ivec4(234681332, -302774000, 859711240, -134744308), ivec4(-102507290, 67042306, -100139013, 455678459), ivec4(67302656, 234085098, 438973737, -840567547), ivec4(387180742, 235538696, -488114422, 16317169), ivec4(-401793005, 825231844, 50529558, -320938507), ivec4(-168689669, -100730114, 555023343, 336266257), ivec4(-203562487, 489303051, -486536685, 200988104), ivec4(168033535, -353436663, -50925337, -32235246), ivec4(654830569, 135340077, -606078971, -201920795), ivec4(117834744, 234615805, 151324434, -302972406), ivec4(454560249, -251259622, -51649821, -49934067), ivec4(-352583424, 16048863, 135862022, -168824323), ivec4(353767680, -234944240, -219680524, 67563757), ivec4(16253960, -49207525, -16514312, 787671788), ivec4(-98684346, -557328665, 219351540, 18433049), ivec4(-910504952, -34600984, -151912416, 958867969), ivec4(-1005438169, 133354705, -670691831, -168165395), ivec4(-318376723, 575545571, -540604151, 862602264), ivec4(149484818, 1381646878, 539432722, -1092365819), ivec4(-488329311, -1212230966, 183280325, -184481559), ivec4(-387654434, 32429028, -335224382, 753921007), ivec4(1614946600, 523180346, 1783514147, 1162623590), ivec4(1632188222, 959333462, -219668653, -355945013), ivec4(-891756303, -659505972, -337978886, -791682327), ivec4(-1062421043, -743267644, -691354935, 520292610), ivec4(605627700, 1531523115, 1111319662, 488316727), ivec4(791821869, -300006340, -691482910, -925832466), ivec4(-1061305401, -84344613, 52569104, -1211307276), ivec4(-1179269697, -674048301, 422188773, 220278822), ivec4(319752705, 220674857, 369956121, 573645593), ivec4(304820259, -1010509842, -420154409, -841621788), ivec4(50126798, 555355140, -520289783, -1043474993), ivec4(-236264495, 1009647858, 944062260, 262422), ivec4(304748029, 185733119, 706876178, 438639385), ivec4(-1043340800, -184819262, -521077775, -270280486), ivec4(134940407, -235010804, -891627557, -135536184), ivec4(823330312, 1095057468, -49539283, 437712879), ivec4(-16976647, 639045385, 387387931, -672665339), ivec4(116772291, 152307968, -286723330, 438372851), ivec4(185601808, -453776911, 15588048, 673458199), ivec4(977024310, 337914670, -152181777, -605953816), ivec4(420545002, 455418147, -505350141, -203897386), ivec4(184217845, -184087801, 235272436, 117116437), ivec4(-354821368, 81714148, -99874804, 522395435), ivec4(840240383, -1042819581, -18616069, 232771286), ivec4(625945357, 838541085, -254160385, 621359886), ivec4(909980979, -271989267, -1159452664, -1550086756), ivec4(-1668046438, -707798093, -119414314, -153958963), ivec4(-369747452, -920089, 49342185, 421011715), ivec4(959658805, 1565539873, 1684827737, 1902733660), ivec4(1666669653, 523653724, -823651565, -557009237), ivec4(-152509733, -520678904, -1011829820, -1144466992), ivec4(-622798652, -355023938, -454827287, -200532989), ivec4(520281301, 1331051059, 1886281556, 860239952), ivec4(625360188, -704306657, -725771859, -101062422), ivec4(120203276, -1211840791, -639117371, -454500396), ivec4(-186461719, -218302462, 203425770, 65720310), ivec4(1329342244, 1180193352, 1212166493, 1077424182), ivec4(-97969885, -1299210281, -455486267, 286783206), ivec4(-926820871, -372196163, -639446057, -590818594), ivec4(-135595796, 252239337, -339087867, 924784889), ivec4(1448230474, 1093358392, 959660876, 689973569), ivec4(-1650139910, -371337543, 368765937, -841548276), ivec4(-708260658, -270933515, -758064164, -83890976), ivec4(165672704, -571144430, 723057127, 1564755257), ivec4(1296774492, 1146048838, 741553985, -840628431), ivec4(-455626324, -203102483, -302841853, -707341348), ivec4(-404165927, -539828751, 150332129, -521407740), ivec4(66650364, 268233202, 1077553445, 1126451281), ivec4(1448166485, 909126981, -66707665, -658917152), ivec4(-556081435, -84740624, -404693261, -606681130), ivec4(-691350821, -135668003, -252446210, 15854315), ivec4(116846845, 555488782, 959789613, 1549294925), ivec4(741755739, -59096, -673847043, -892477986), ivec4(-421798703, -185928450, -775497235, -859252513), ivec4(-118826030, -319951633, -102240269, -85003529), ivec4(201593868, 1229399053, 1802326599, 304300626), ivec4(387850000, -554960130, -151066398, -574043425), ivec4(-218436891, -1076892955, -555692086, -185079585), ivec4(-572201243, -135930137, 118557687, 118495005), ivec4(856094973, 1650084679, 506154341, 471467278), ivec4(303633433, -556608539, 49669351, -453972225), ivec4(-219031603, -202247958, -942616358, -471408948), ivec4(420875761, 34342664, 336332020, 302449425), ivec4(455290147, 68034068, 335608835, 319953946), ivec4(-67304431, 689444361, 169354279, -270279433), ivec4(-135863059, -639636491, -286204203, -151654424), ivec4(-855559, 471931145, -386725872, 151779563), ivec4(354159879, -185662709, 135204097, 1251861), ivec4(151651317, 220207636, -235929082, -16381954), ivec4(-402781429, -236856612, 184942076, -200861932), ivec4(84017402, -184022520, -50268179, 134546176), ivec4(-402455036, 370872049, 186326289, -117573633), ivec4(270343686, -536934650, -454040107, 1049830), ivec4(-403836940, -235142927, -217445639, 167899876), ivec4(18159377, -201853450, 252315898, 51779604), ivec4(168030704, 471272969, -167834343, 471665140), ivec4(67703574, 32959992, 404293891, -286457588), ivec4(-50268690, 387319806, -219811323, 252708354), ivec4(-33421306, -33884169, 0, -34409737), ivec4(50137354, -134280436, 301919729, 267028), ivec4(-353964032, 117044721, -487784439, 183824879), ivec4(285605894, -471007478, 167838961, 33160721), ivec4(-168427262, 16712956, 16576245, 101844731), ivec4(-167698935, -253764366, 472062470, -151650809), ivec4(15464960, -402255837, -185798428, 603783430), ivec4(-183026851, -823009073, 369230819, 621153817), ivec4(168163092, -506212604, 302829777, 151589625), ivec4(51975444, -130533901, -722469676, -338172950), ivec4(406073360, -1192219611, -321459495, 487065865), ivec4(-17035239, -438362328, -337245671, 469946844), ivec4(100739628, -137431524, -926985, 53555192), ivec4(537063939, 67234581, -285344530, 555760657), ivec4(456707, -302526252, 421532416, -116974021), ivec4(17629430, 51253220, 367060459, 119481392), ivec4(-620298253, -337250837, 1412106242, -235402974), ivec4(-420408577, -269815807, 842270716, -168949726), ivec4(-507252212, 486406130, 1713695, 15200250), ivec4(250931984, -388111098, 371141383, 200469508), ivec4(-420946699, 487191526, -368826820, -50205730), ivec4(-319357714, 605027811, -386196432, -502986255), ivec4(-100666403, 219159566, -488247552, 17568500), ivec4(-537519855, 303036137, -505287939, -269811459), ivec4(184352765, 120663830, -338374177, 16645888), ivec4(217903871, -334685422, 184475867, 234350841), ivec4(135662859, -571866616, 402974427, 286722061), ivec4(251195636, -353368292, -151326236, 185006837), ivec4(941231887, -825499366, 235403492, 218433544), ivec4(404294934, -119676164, -101844474, 370019852), ivec4(135529993, -1909273, 319622672, -33947632), ivec4(-83028738, -118762522, 251721717, 521868046), ivec4(-655155401, 184213194, 235273219, 386797586), ivec4(-302776046, -201850118, 235602170, 320013578), ivec4(-286854402, 235602428, -83357166, 337318911), ivec4(-236127477, -168498712, 638648829, -83482056), ivec4(-622466068, 521205476, 604966171, -33552872), ivec4(-505154566, 403765220, 185798417, -50134275), ivec4(150663402, -32494546, -403110412, 66064115), ivec4(-270867192, 503380215, 100938020, 16186371), ivec4(-337521952, 823924465, 202120259, -204153624), ivec4(854246, 402653427, -251594240, -101383707), ivec4(386734856, 234748946, -654441984, 83488731), ivec4(-136646402, 354816510, -184281314, -591015703), ivec4(590089456, 236859936, -809046771, 269481967), ivec4(-150927856, 16449278, -436142325, 150793957), ivec4(270112, -436601325, 32431321, -234681587), ivec4(168231428, 85203217, -1059920896, 706410974), ivec4(422652718, -1177360632, 352839628, 68690716), ivec4(-420087556, 84149751, 16712441, -201127667), ivec4(202445303, -134679819, -100135416, -67699209), ivec4(101190144, -504365305, 469823707, 538842646), ivec4(-537258472, 15457992, 454954759, -67436282), ivec4(100792816, 185402378, -318502914, 218164447), ivec4(-16709618, -16251910, 83753969, 236193797), ivec4(-218760192, 83554533, 269948184, -66384633), ivec4(-202841618, 252381188, -67043572, 16448505), ivec4(50657789, 201654275, -17369349, 658705), ivec4(50067447, -16911879, 185074433, -251790844), ivec4(-84676882, 320541706, 151192848, -353306880), ivec4(83951355, 34149387, 84148743, -194035), ivec4(-17172482, -84475900, 50594559, -101516797), ivec4(16448254, 33687562, -151519488, -202117644), ivec4(437193723, -16511973, -84082688, -100861198), ivec4(151322878, -33685504, -16578559, -117899007), ivec4(34013692, 117770240, -185073142, -50791177), ivec4(50859266, -201981945, -168824336, 285999611), ivec4(67770647, -33554942, -152046856, 66714364), ivec4(218498061, 218959628, -218760697, -85004557), ivec4(-50726656, -403567618, 436798716, 335872021), ivec4(-48953847, -68093668, 369755121, 454768449), ivec4(219944249, -1328942573, -1128810843, -1497514574), ivec4(-150873695, -1395652116, -455087172, 84019943), ivec4(807412268, -450282210, 167110094, -317986809), ivec4(975378393, 84759117, 1718709059, 1114338640), ivec4(1395996514, -723905759, -1077478656, -740959288), ivec4(-67839778, -960509214, -524244307, -521418549), ivec4(218089188, -791415789, -472457520, -268122673), ivec4(1111555569, 1836540231, 1450005576, 523578196), ivec4(471216455, -66647253, -841634114, -706948097), ivec4(-470423074, -772931346, -421671215, -472848371), ivec4(133234449, -216655108, -574052657, -219288609), ivec4(1599227148, 1164605016, 521942605, -219474660), ivec4(-1043231, -957998049, -1060715842, -810429239), ivec4(-674177588, -368763909, -758783248, -822608427), ivec4(-32635703, -435351033, -740957490, 707730920), ivec4(1987861576, 1466987884, 16981052, -436275464), ivec4(-520423963, 16309457, -1128477729, -841753891), ivec4(-151858747, 185073137, -472129800, -387063069), ivec4(-353572880, 33613798, 386331893, 1751271983), ivec4(1247762280, 1112166735, -116912082, -418838540), ivec4(-540494129, -622403609, -757273891, -286468911), ivec4(-488188453, -51120912, -336399360, -133430037), ivec4(-320939797, 268626666, 1480538662, 1769301870), ivec4(926364222, 571810098, -251067887, -455485732), ivec4(-690892582, -102247226, -387850514, -168698141), ivec4(-404624923, 15525098, 51248370, 302053370), ivec4(-118823166, 756285160, 1061570896, 1042486812), ivec4(656417075, 640621852, -218429678, -85595915), ivec4(-438377485, -136258325, -354031101, -573455153), ivec4(-439427350, 336724223, -49997275, -473046796), ivec4(-387654170, 707399682, 842220102, -117762012), ivec4(-251984875, 33164555, 85135878, -68425472), ivec4(2375701, -555946491, -33749515, -506141187), ivec4(-66254852, -184880920, -386197760, -977218841), ivec4(83820257, 571080192, 507196710, -605619717), ivec4(-84015629, 588123904, 774711341, -100137193), ivec4(-520880916, -186588711, 51976711, -33812208), ivec4(134411765, -572132619, -387452182, 33555962), ivec4(369955599, -33880819, -252644608, -488309506), ivec4(319553000, 33557781, 336135952, -706018801), ivec4(-438774837, 17169656, 623057163, 68363043), ivec4(-151651838, -622137610, 571209955, 303837746), ivec4(67962376, -571997933, 319092969, 405018129), ivec4(168493834, -134213862, 151914998, -437194498), ivec4(99541475, 33752587, 454693121, 18293535), ivec4(-522135317, -186394923, 471667968, 337320226), ivec4(-537990152, -269948963, 268366062, 354490901), ivec4(-234812402, -33623054, -539436057, 50395368), ivec4(-151582957, 50396662, 67698943, 134219270), ivec4(-589963524, 185599213, 201129733, 269156105), ivec4(-387125250, 134215665, 420678413, 371531029), ivec4(-51384063, -370282760, 117370088, 337584399), ivec4(-84279797, 134478844, 67240194, -151518451), ivec4(505021435, -184809967, -68685316, 201589000), ivec4(302846987, 16911127, -17437447, 99677436), ivec4(253042723, -101385723, 49476087, 133163264), ivec4(286657298, -101581303, -50330368, 216326127), ivec4(370083611, -33421292, -454492672, 167831778), ivec4(-83815920, 621554194, -117632952, -201526825), ivec4(216203513, -16588271, -185133572, 419694083), ivec4(-131723516, -741023256, -488771584, 1061238016), ivec4(402058230, 48751380, 67433717, 286254802), ivec4(587396615, 1496782872, 233220055, -371000540), ivec4(1073202127, 236381440, 584907791, 653460260), ivec4(772987647, -994771934, 1478163694, -119348698), ivec4(-673380337, 402197249, 148947718, -672787679), ivec4(1109736462, -709765298, -200207900, -36377613), ivec4(368703282, -722076158, 253374211, 417850134), ivec4(-1107223510, 235074244, -285140418, -453311237), ivec4(136119520, -724634596, -485809914, 709166824), ivec4(-1058856387, 16180447, -570686968, 67306982), ivec4(-218098136, 690352097, -555748835, -132501989), ivec4(16434627, 186190344, -251593214, 369615847), ivec4(-705624562, 270598351, 940175590, -317445317), ivec4(-488313387, 17895919, -34875410, -133288950), ivec4(351069161, -538500555, 506076387, -37106949), ivec4(334629648, -50061546, 149875182, -151452145), ivec4(519823319, 401993487, 354041136, -520883479), ivec4(655286740, -456330226, 322379762, -185996293), ivec4(18822410, 471854297, -758253797, -134936073), ivec4(137633028, -18418697, 49745685, -286138373), ivec4(16782090, 707078949, 84864794, 165532645), ivec4(-638639567, 875291879, -387583737, 336922361), ivec4(687463955, -570288877, -184485922, 1092549894), ivec4(-302650605, -402647292, 48884999, 201715442), ivec4(153165835, 317391401, -691942149, -367389447), ivec4(769055203, -303562172, 67106034, 99357466), ivec4(201194791, -404235024, 603324152, -220391862), ivec4(-116459526, -1179409, -69799918, 488380962), ivec4(17509134, -959904988, 588251112, -437913088), ivec4(-335987157, -101515011, 18093564, -168548333), ivec4(-488044261, -50332961, -418234343, 66520577), ivec4(-286266134, -772598010, 505622517, 84937746), ivec4(-704961011, -219156512, -100535562, 54408183), ivec4(-286331929, 404494074, -368768249, 304422390), ivec4(-67381802, 136516349, -15791634, -370151682), ivec4(-620826152, 757591498, 471539262, -518450935), ivec4(-454631468, 301790453, 588772357, -319097330), ivec4(66049758, 506335760, 370077937, -19737856), ivec4(438111759, 253950708, -151323652, -117512216), ivec4(251985655, 50146600, -49147877, -169159723), ivec4(-219085312, -254086648, -66119928, -102895626), ivec4(588978454, 150002943, -605349870, 67767031), ivec4(436271618, -101516281, -67302643, -153230097), ivec4(441070857, 66981633, 149286405, -285935870), ivec4(-317511425, 352384237, -201263876, -83883015), ivec4(251139611, -553122538, 572125899, -253625326), ivec4(-83886070, -672595205, -16908308, 587922181), ivec4(135791375, -874772983, -168165136, -100010508), ivec4(200862947, -421526738, 303824622, -418833915), ivec4(319425531, -287714568, -167638531, -251456251), ivec4(135460590, -151064086, 167707131, 598568), ivec4(35062778, -116390929, 504101104, -319553771), ivec4(-250735369, 151388406, 386330360, 388107527), ivec4(-270270961, -49081853, 302313195, 100726528), ivec4(451926769, -83091928, 470546675, 460302), ivec4(401660394, 167048721, -236195584, 34473726), ivec4(167572717, -135003889, 469168890, -285203664), ivec4(150667004, -101252336, -169280254, -388170737), ivec4(-201651962, 773328384, -555088342, 15130075), ivec4(-302837223, -554038010, 788197, 218830863), ivec4(726223918, -486730983, 522474, 539829760), ivec4(-1311375084, -891558460, -1427959811, -571811413), ivec4(-571478317, -1346059828, 83878585, -888129509), ivec4(636214491, 1533757757, 793799253, 793658411), ivec4(-180539105, 186649576, 875572246, -605698296), ivec4(33611712, -1209794283, -1449750649, 1244332539), ivec4(-132374227, -217711658, 1430333435, 303245159), ivec4(387071, -822411784, 167761599, -185198057), ivec4(-710304073, -571740442, 334615771, 1532897843), ivec4(707991851, 286408771, 1143550482, 876178783), ivec4(-590359273, -83309372, -789905921, -506083901), ivec4(-657795617, -794181929, -252185373, 100266730), ivec4(1079318279, 531241, 487394571, 588913436), ivec4(270349619, -1180065321, 807075530, -1193340884), ivec4(-355154495, -1228085519, 317768885, 302186505), ivec4(352584472, 185804320, 1009522701, 708592453), ivec4(185670170, -555026158, 66377935, -150994675), ivec4(-507588886, -537460483, -555293473, -118958639), ivec4(454568210, -84144352, 622395644, 1582905637), ivec4(271000628, -691474680, -253630994, -67236339), ivec4(-437457166, -992947491, 99932360, -488243961), ivec4(387456010, 522134819, 856955696, 826620725), ivec4(52438567, -688320000, -34607137, -740955649), ivec4(-101129777, -705167107, -304362569, -101253895), ivec4(-32301044, 438769411, 420676864, 1346247959), ivec4(1095514172, -873522902, -153564466, -83821060), ivec4(-555167773, -572333866, -506080547, -151521809), ivec4(302575344, 420281341, 654838300, 776492106), ivec4(689312286, 18686501, -876551176, -34810674), ivec4(-66911482, -370548257, -708454422, -454428943), ivec4(134280937, 185601288, 133426426, 1414742308), ivec4(691555923, -185137635, -302645773, -135403795), ivec4(-571869187, -605165097, -606872099, 68357106), ivec4(-555228177, 234284759, 489696036, 724115472), ivec4(305218617, -33221099, -571213827, -336733228), ivec4(-572003607, -15598365, -926423305, 218361815), ivec4(102901796, -555162913, 488183293, 1179658766), ivec4(186530114, 101253375, 319885322, -33162754), ivec4(-840434185, -168765490, 529404, 16182262), ivec4(488245496, -285871864, -235210012, 773194233), ivec4(35005737, 32567544, 102304262, -808461335), ivec4(-16718641, 184089852, 184874499, 167773196), ivec4(438440975, -437191420, -336337184, 267841255), ivec4(606810158, -589175043, 789111257, -351986901), ivec4(-539896351, 218166760, 403967513, 33289219), ivec4(673256198, -319550940, -858136, -17764353), ivec4(571345158, -117239767, -168957205, -83359742), ivec4(-387717140, 166783985, 588979231, -268892133), ivec4(706345453, -268094657, -708653852, 201457650), ivec4(219945750, 83951364, -34541317, -49997805), ivec4(-101054969, -420808193, 621214961, -166714318), ivec4(-404692504, 422520829, -488507124, -85861405), ivec4(539172112, -318301153, -118098970, 51780365), ivec4(-253367823, 185865739, -168034048, 505088764), ivec4(33754132, -251656959, -588842250, -286067223), ivec4(605813224, 136455705, -724376329, 741416183), ivec4(-403505901, -34283044, 135335168, -234811893), ivec4(-50267922, 438372861, -387584767, 63728), ivec4(50263801, 573906948, -622528241, 217375449), ivec4(34410264, -218039820, 285862885, 403835397), ivec4(-101514218, 589237768, -723193075, 419354055), ivec4(134940947, 67108352, 101586194, 369487346), ivec4(49739529, 151058947, -219221502, 437781744), ivec4(-202309101, 787600102, -352182980, -354361631), ivec4(655095291, 524045, -102498549, 99610371), ivec4(-200997375, 940243698, -672793807, -67174176), ivec4(656022545, 789639432, 419356416, -387714529), ivec4(-52365307, -501877516, -689546223, 252828915), ivec4(-64328652, 335660478, 249167897, -134155506), ivec4(319104003, 198305037, -654163925, 252112627), ivec4(-133494302, -287251971, -216646405, 13155569), ivec4(-133038341, 149151483, -1007537372, -318765067), ivec4(405993683, 64547343, -197841876, -170336562), ivec4(270397956, -657921788, -47763453, -286848251), ivec4(440340747, 201384928, -98620133, -522065950), ivec4(721481451, -437716700, 1112753425, -1176964862), ivec4(50332383, 459509, 827467521, -405416722), ivec4(654243832, -219352562, 356268038, -673450493), ivec4(654368963, -133880517, 1213273317, -454897158), ivec4(183106273, -338830071, 790761214, -437188834), ivec4(504298723, -420740585, 790757096, -134675946), ivec4(114999770, -18283228, 1127223299, -942207928), ivec4(-402389548, -169018106, 1092548855, -335871441), ivec4(-186396198, -150987743, 318702327, -505344209), ivec4(-185409808, -502582004, 1278474720, -504817096), ivec4(-117581091, -304152319, 65398521, 203699490), ivec4(-252511216, -771480067, 857009366, -536796625), ivec4(31510501, -351732746, 653785586, -333492911), ivec4(-673584906, -183893797, 201919500, -249685750), ivec4(250866397, -64414437, 265994967, -133094359), ivec4(-34537981, -116193021, -286393866, 170275351), ivec4(-16646654, -605498405, 519890652, 338701092), ivec4(-237182987, 85402387, -169415169, -183361009), ivec4(-418967044, -17376563, 420808703, 1714982), ivec4(-303633426, 168492789, 15529471, -285010665), ivec4(-436662020, 337579250, -404557312, -202249238), ivec4(304030991, -68420859, 67302647, 656875025), ivec4(-875692015, -219157538, 16452091, 251722741), ivec4(51456306, -34280481, 16585228, 67767035), ivec4(-387251200, 503308766, -167305181, -116656679), ivec4(-183622129, -86125603, 757075201, -118228964), ivec4(-150934304, 472780019, -539036670, 485809885), ivec4(87506235, -186131746, 437450996, 638912524), ivec4(-100004576, -656877082, 353102556, 503973898), ivec4(-318760925, 268494568, 236987935, -286597137), ivec4(268235759, -117968379, 370349838, 33618183), ivec4(167902205, 16446718, 331535, -17765384), ivec4(455416586, 15262979, 64764, -269485047), ivec4(100991214, 66120707, 605424903, 369694769), ivec4(-318896110, -421798944, 453837045, -220137192), ivec4(555553033, -33482726, -16976640, -169018116), ivec4(-118491136, -219414523, 303500546, -219285500), ivec4(285541376, -655884528, 134217961, -234811369), ivec4(251394806, -134281458, -353039866, -369624851), ivec4(268828915, -454886382, 403571186, -200201689), ivec4(-16118793, -269157118, -387849753, -201390338), ivec4(236196863, -83621875, 302779396, -605225719), ivec4(-185144612, -200007421, 251719658, 101783572), ivec4(-184548093, -167771396, 33946353, -66780420), ivec4(302580218, -334552803, -101519387, 185794807), ivec4(-51452942, 18618113, 33555198, 152178438), ivec4(336723966, -302647296, -101258776, 1644030), ivec4(116713190, 606216216, -50857713, 65791), ivec4(-33425419, 50985968, 116979706, -134214379), ivec4(251719410, 202771721, -287055625, 437389045), ivec4(16517151, 67701254, 134214399, -219550218), ivec4(436468477, 338506292, -505548291, 185072366), ivec4(15330312, 169747462, -756675809, 1480324303), ivec4(1093476653, 1012947047, -454619858, -1278614544), ivec4(-1635409476, -639244081, -1497116196, -1598576227), ivec4(-86857339, -874846237, -85521166, 1667320347), ivec4(1835234157, 1499623021, 1193418812, 1130652253), ivec4(-47884228, -673654821, -1618239032, -1380859984), ivec4(-1380787743, -1751135038, -1518038354, 654573017), ivec4(1785428314, 1433033051, -692923624, 202569970), ivec4(339290905, -1009519092, -1617778235, -502932295), ivec4(-688131116, -284235324, -1464217393, 975110366), ivec4(1600944484, 1567120487, -1007022036, 153687542), ivec4(220728053, -352191230, -1834430243, -136195144), ivec4(-200542202, -303377471, -1346258990, -420098399), ivec4(1819425280, 1601988177, -1226563515, 370537934), ivec4(-200929028, -353896457, -1597384473, -439702116), ivec4(-33749251, -790958093, -1380726564, -16920147), ivec4(2070561799, 1853651829, -855027605, 352441019), ivec4(253038606, -622925568, -1059854372, -321337152), ivec4(-16385045, -202317075, -1666330912, -288246881), ivec4(1969568265, 1548834408, 305552492, 82698219), ivec4(387980310, -318501359, -892614186, -220607291), ivec4(-218168060, -287254555, -806618121, -372919622), ivec4(1632185358, 1314285682, 995385949, 100332564), ivec4(-353897982, -437915921, -251986695, -589965601), ivec4(-134612496, -759049493, -302516500, -656677655), ivec4(890434013, 1650218571, 1045916264, -135397597), ivec4(-200862713, -421272604, 133821678, -1060379903), ivec4(-202315827, -757339922, -51519273, -437783043), ivec4(251460593, 1077621028, 1533632072, -168160456), ivec4(-168165895, -554632713, 234547418, -420149482), ivec4(-421339684, -522196759, -201262867, -555424284), ivec4(335670752, 286861606, 1161240604, -401263812), ivec4(-135600928, 168556791, 118296579, -620816109), ivec4(-86980911, 100594954, 182707437, -151594485), ivec4(386205931, -47440848, 198427338, 507539561), ivec4(-993402623, 267308236, 354821912, -435076825), ivec4(-624964655, 187062593, -808462115, 689042419), ivec4(-1025570808, 35325645, -336193278, 353451294), ivec4(-336733202, -118756118, 1182442, 811029780), ivec4(-1212429056, 688526047, -553651176, 386333148), ivec4(-249946600, 67364831, 16187147, 137314326), ivec4(-438384896, 67232713, -386070252, 522321634), ivec4(-554888136, 219280853, 572192797, -420746763), ivec4(-301463045, 202701308, -219678465, 1078924291), ivec4(-741016527, -286931513, 289291275, -1320453), ivec4(-186187261, 17889022, 268500990, 555617026), ivec4(-251065333, 1006632960, -14728892, 639303159), ivec4(101192460, -977679640, 387974617, 200810009), ivec4(-656151303, 671672026, -488505075, -572989474), ivec4(18616822, -473572395, 117503484, 284948990), ivec4(-285933054, -689377049, 587718872, 201134858), ivec4(-250865618, 386133979, 219747335, -421007868), ivec4(756090619, -436335589, 370345216, 673057025), ivec4(594472, -537853943, 503575783, 51249170), ivec4(404298007, 167770370, 135862811, -453572851), ivec4(368764891, -33224925, -16905218, 16642299), ivec4(168892690, -521867528, 200138465, -268826346), ivec4(50791922, -201986059, 150140406, -437125113), ivec4(-17566997, -16776964, 471405314, -253432569), ivec4(184550912, -436204017, 200006361, 33882375), ivec4(218894086, -152177149, 438115085, -50068213), ivec4(-988947, -185207297, 303566841, -50065124), ivec4(402716659, 33423636, -219808253, -151322102), ivec4(68887557, -403114772, 336594404, 269221905), ivec4(-302057740, 249944537, 386468370, -335995613), ivec4(-420216839, 118689003, 167700972, 32502275), ivec4(319422471, -253497600, 32832769, 185935387), ivec4(-807334875, -218112064, 471072240, -100135407), ivec4(218167809, 49475331, -505085677, -621408255), ivec4(84412398, 271191044, -268629768, -101522196), ivec4(151257589, 150596096, -68290817, -486204403), ivec4(253895158, -33424378, -571677470, 369947863), ivec4(656674056, -1178331, -168827405, -67500802), ivec4(1578760, -67373578, 128235, 152504576), ivec4(638117611, 267386141, -33749469, -218436120), ivec4(218630141, 51059221, 134413574, 117569530), ivec4(655421688, 167116568, -304090610, 167839495), ivec4(672931602, -419818708, -386531088, 267770588), ivec4(336200965, 663332, 48691465, 16780312), ivec4(-168359669, -487455486, -166455301, 268961526), ivec4(335408641, -234612193, -83949568, -101910787), ivec4(-151583996, -31445481, -385871104, -252120082), ivec4(537787373, -166850028, -471141129, 50001382), ivec4(235477532, -165991647, -554043938, -16844315), ivec4(-167771904, 371132144, 336262900, -201257707), ivec4(-101845515, -134216958, -150995211, -67178014), ivec4(-234876405, 523511036, -67180556, -253238297), ivec4(117242871, 321133844, -184944644, -269092107), ivec4(-197390, 253432847, -386270723, 302045130), ivec4(134944280, -66185715, 15918065, -117374465), ivec4(-134875660, 67501301, 987141, 185074942), ivec4(-17041920, 370276850, -285011442, -169551644), ivec4(420481789, 640885023, -303435256, -572267803), ivec4(404360432, 488183315, -201458931, 469296104), ivec4(-66119399, -488314906, 588445931, 284164892), ivec4(151780612, 1194924291, -502257114, -943009327), ivec4(-69543990, -722469129, -65991142, 1547113460), ivec4(169102398, -436675328, 99616258, -591072525), ivec4(839115735, 1851009836, 1197108047, 1010586950), ivec4(-14860480, -1752330560, -1903127159, -1717987447), ivec4(-910313819, -876561214, -33229090, -639899674), ivec4(1193480175, 1817857372, 1785556592, 1617257302), ivec4(726624106, -959320042, -1549358419, -675373412), ivec4(-50329101, -1059789312, -758400333, -640761919), ivec4(251721442, 1027162429, 1331320142, 758260274), ivec4(539367707, -857470691, -1767065916, -945056112), ivec4(-34216237, -319552759, -320282652, -505685531), ivec4(673120744, 1330270775, 1195724884, 791031622), ivec4(740696356, -318434024, -1043869989, -1113084238), ivec4(-168693800, 922621, -219749649, -658188821), ivec4(252378859, 675035418, 825374505, 268768040), ivec4(167772177, -301330159, -740168991, -842742328), ivec4(-152246045, -234816263, -319690011, -236065039), ivec4(706412787, 573844775, 422195756, 101388565), ivec4(-33624328, -49874184, -219024137, -774380303), ivec4(201979364, 135463165, -169154827, -101386247), ivec4(639437827, 741812259, 555950367, 100599065), ivec4(-303305216, 17431534, -50795283, -236721671), ivec4(66779383, 236391173, -404033796, 419951328), ivec4(840502039, 539178047, 185932830, -33818631), ivec4(-404824848, 83357670, -151978230, 33818631), ivec4(235141622, 235537415, -522126833, 133819105), ivec4(555094545, 471935016, 16450578, -235274493), ivec4(-690296591, 352447450, 84085784, 16122642), ivec4(100794626, -33156078, -622068226, 32102876), ivec4(352716298, 304757036, -202706683, 134275818), ivec4(-620952081, -4205322, 168294177, 319755504), ivec4(183498264, 2301736, -1059392781, 283181805), ivec4(319089931, 521753, 167315967, -502792200), ivec4(-485821996, -421593608, -219749896, 962732307), ivec4(-1244585939, -69089333, -132642271, 469303017), ivec4(83163940, 2366774, -621547310, -405019925), ivec4(369623311, -368493800, 68158974, -151324674), ivec4(-502063634, -506207762, 622333196, 104605185), ivec4(-590621964, 51779332, -486151443, -218103050), ivec4(553977101, -166459362, -369361411, -185996826), ivec4(356457468, -353172466, 250739442, 254084876), ivec4(-707334140, 437723633, 471597326, -504625406), ivec4(167051756, -116386286, 83951588, 184088804), ivec4(320543771, -403897348, -1245730, 757337096), ivec4(-253362429, 84938738, 520291072, -522128384), ivec4(201654240, 605230874, -285864699, 101382116), ivec4(286070802, -101847058, -33492501, 403246094), ivec4(-184350460, -15926283, 520094461, -521203929), ivec4(-184422935, 807144958, -234156261, -51127578), ivec4(17571096, -318899454, 117960179, 235866887), ivec4(-453052400, -16517642, 538117882, -688916702), ivec4(201581539, 218103816, 187969325, -219221510), ivec4(-235735563, 655368, -35460877, 287514627), ivec4(-100598511, -119146503, 353899523, -336326370), ivec4(67107043, 117371128, 303441168, -269680640), ivec4(-151191558, 264441, -152835603, -32566268), ivec4(-16382992, -672661505, 571077600, 51388444), ivec4(-252184329, 134808571, 68357887, 67437817), ivec4(-83948533, -49874954, -67175693, 135203837), ivec4(386658802, -688319201, 352447189, 219155218), ivec4(-100271875, -84809241, -33292543, -32568578), ivec4(-51452956, 50593033, -152248086, 186387968), ivec4(268170235, -49020915, 117044726, 49801470), ivec4(488841231, -151196925, 351534325, 589568049), ivec4(-337515273, 117767167, -252779025, 368507906), ivec4(34477334, -119278832, 353298149, -101904608), ivec4(-150998028, 183763191, -285937908, 503516922), ivec4(-472261107, -386400019, 638449906, -588446960), ivec4(166323182, -166451436, 49144303, -100135675), ivec4(-320868359, 303434237, -505349610, 572591606), ivec4(-236391146, -301461498, -321137443, 152572166), ivec4(-403832560, 369949429, -386728694, 33947895), ivec4(-386068975, 67238127, -169149440, 472258061), ivec4(-420874484, 85398529, -219682831, 370477308), ivec4(-200926692, 454164217, -520876524, 353107172), ivec4(-302248683, 353304822, -319158263, 773719279), ivec4(-49538526, 117901310, -302711549, 167310316), ivec4(203694610, 302053884, -285471208, 269550060), ivec4(-185140731, 403637749, -285474543, 251064551), ivec4(-166980069, 167570405, -201521654, 49474280), ivec4(920331, 301789424, -403109615, 319089376), ivec4(-151189491, 16249587, 151849737, 32435958), ivec4(253432591, 117701374, -555027716, 234877666), ivec4(-33422322, 268103153, -99739620, 116910310), ivec4(-33486328, 16709886, 117308671, -84544773), ivec4(34411791, 167834605, -402977775, 99739360), ivec4(319819536, -235536115, 118097916, 50330880), ivec4(-235536125, 33423871, 84543749, -100860928), ivec4(370942731, 16185869, -251589616, -101387279), ivec4(251854332, -133885672, 135203068, 66846473), ivec4(1250574, -85069834, 84675591, -252315128), ivec4(420873458, 397590, -134679549, -218497801), ivec4(437520376, -402450661, 622659049, -253633278), ivec4(-101448182, 620291567, 925245494, -772604888), ivec4(756157654, 1448508006, 1818119014, -388575457), ivec4(-1564228416, -1768705606, -844325732, -1801411648), ivec4(-1227103299, -723517, -741812743, -1531659817), ivec4(115187590, 1701336369, 1986620533, 1027362419), ivec4(138100041, -754905858, 234285519, -471209715), ivec4(-756690982, -202579764, -1028334605, -1716138014), ivec4(-457861999, 539895044, 1987862830, 809327222), ivec4(-33357547, 217832928, -186193165, -538179569), ivec4(-135601958, 370344688, -554304256, -891754779), ivec4(-239824739, 1244599304, 1986415436, 1313041260), ivec4(169621340, -85929228, -589176603, -419166744), ivec4(-339561513, 116386028, -573649668, -1008865554), ivec4(-1417109322, 66511582, 1985756975, 828207977), ivec4(791857, -36518675, -774903799, -435812112), ivec4(-912343584, 50397953, -722271478, -992812076), ivec4(-977224774, 233825245, 1463435305, 1835888245), ivec4(337923687, -270137587, -1007874549, 454692316), ivec4(-742207247, -303371806, -118163981, -707138839), ivec4(-1313752115, -304750649, 859258910, 1752528983), ivec4(608387655, -202577935, -554953711, 100198105), ivec4(-742207755, -32895495, -487194896, -1076503327), ivec4(-891762239, 15055785, 992812569, 1733642312), ivec4(793266005, -199744468, -470418707, 318828260), ivec4(-823857397, -352788792, 134601675, -304294161), ivec4(-909846803, -423516235, 960044805, 1851672114), ivec4(740835169, 642407494, -335940864, -305548861), ivec4(328959, -253700127, -286923281, -454759437), ivec4(-908728858, -927287869, 318825938, 1718110752), ivec4(1163421805, 656745267, 318632453, -826159627), ivec4(-368568584, -674246957, -371073832, -118560281), ivec4(-824184075, -926167356, 133286598, 1816270598), ivec4(978282609, 759119686, 471140361, -371402012), ivec4(-789970693, -68562507, -235277320, -17173032), ivec4(-237576456, -1631728423, -354305380, 1411646188), ivec4(1718973294, 356401494, 168957199, -773525235), ivec4(-336793630, -168766239, -773394425, -640164133), ivec4(-16715034, -1277037312, -724782930, 855500767), ivec4(1584820068, 1230265943, 186521904, -740232949), ivec4(-118427166, -874981146, 201780694, -335939083), ivec4(-371795473, -1009391637, -977160011, 367774144), ivec4(2087675717, 1516332141, 287193422, -588185339), ivec4(-287847998, -169482761, -67370247, -824252944), ivec4(-253500460, -640229910, -624048172, -371532069), ivec4(1818445840, 1583772791, 286467913, -184545521), ivec4(-471536145, -623386394, 151188450, -538381310), ivec4(-370675486, -823922441, -993869119, -405157952), ivec4(1497047551, 1870232696, 709585006, -335607272), ivec4(-219618852, -824908811, -118233130, -335476219), ivec4(-421473067, -369952779, -1229010473, -455620418), ivec4(1413816569, 1835622234, 1163551847, -318100933), ivec4(-371076394, -538315536, -186198060, 264450), ivec4(-488118542, -504698919, -909523505, -843136826), ivec4(1277688799, 1903588964, 1331320417, 473251133), ivec4(-573449478, -404166684, -303045405, -286726170), ivec4(-286858515, -538253338, -876098350, -774711854), ivec4(788321486, 1953258569, 1230463854, 775635011), ivec4(-538708976, -454827547, 15587546, -285341691), ivec4(-522263321, -34214164, -1279867419, -775438665), ivec4(116383447, 1717321759, 1802860657, 858864986), ivec4(-386729445, -739643676, -355021879, 460025), ivec4(-774445573, -235409972, -605817867, -607999298), ivec4(-86395454, 1850093609, 1647196774, 1362441583), ivec4(-83097307, -1443623424, 15457436, -99347704), ivec4(354878957, -759521104, -723381504, -640433461), ivec4(-1483821106, 1800022770, 1717983341, 1114795635), ivec4(303502864, -721877772, 67233492, -474690060), ivec4(-506003932, -592520470, -1142082498, 32501974), ivec4(-2165246, 1381114895, 754247188, 539304002), ivec4(673719066, -825295065, -1109982978, -317985344), ivec4(-1092101423, -1044606068, -1378691134, -541276483), ivec4(-1515530770, 65656010, -385156620, -536074736), ivec4(271583190, 355013133, 270215441, 585827091), ivec4(1314278243, 1464017422, 475092577, 709569000), ivec4(35596852, 1014187523, 773193733, -267507156), ivec4(960043997, -507182023, -333437427, 520152537), ivec4(-419284419, -331035, 386599691, -82836736), ivec4(-708188435, -100206623, -133819901, -721417476), ivec4(402114496, -723386602, -183962144, -491016499), ivec4(-352384773, 183296230, -638708706, -386336526), ivec4(-404364069, -133366032, 65524696, -572855804), ivec4(385736415, -1043666685, -453972519, -120335140), ivec4(-552524261, 32955076, 33816317, -319753216), ivec4(-691811362, -252774926, 471010045, -890697698), ivec4(285535956, -235405046, -65531395, -19021363), ivec4(16711943, 487920134, -51048929, -318039021), ivec4(302838750, 286330379, 219351814, 117438975), ivec4(605360392, -286720737, 420020212, -168226785), ivec4(338373905, 556144134, 453969424, 270343455), ivec4(-304161288, 353307133, 875373342, -369089992), ivec4(286329076, 337914142, 471993603, -101717250), ivec4(436338175, 656350754, -67169755, -117174523), ivec4(285734898, 221131046, 184349679, 169478666), ivec4(470414845, -337972719, -151918343, 336729604), ivec4(-486794472, 183686367, 672339982, -82704370), ivec4(-440944157, 84607722, 32635649, -336260581), ivec4(83287508, 353107970, -134279669, -541477410), ivec4(-50393857, 200278284, -707598083, 286460661), ivec4(-506408470, -167374593, -271331107, -270076683), ivec4(403441166, -825366004, -503578391, -235535380), ivec4(-655689985, 622197467, 16518700, 68487171), ivec4(-978073115, 855541, 538846737, -788915930), ivec4(437582033, 320671237, -318107894, 116317145), ivec4(-403961578, 554760947, -688385767, 135662570), ivec4(-100467723, 2170630, 520150236, 50658836), ivec4(202177529, -69146372, -132503778, 403308779), ivec4(-486666462, 554689738, 841353742, 506670375), ivec4(-557987081, 201129724, 453709842, -521470187), ivec4(640621302, 504562178, 203041064, 132434148), ivec4(-51841010, 638847757, -387449321, 203106063), ivec4(-117700081, -150929668, 740425704, 32899104), ivec4(336594948, -372119026, -352447476, 352913141), ivec4(-856484314, 252310224, 488640775, 253304092), ivec4(-1318667, -286920702, 269422079, -856812779), ivec4(17039588, 488704761, -81973982, 99470286), ivec4(-100927997, -67635981, -18223107, -99342817), ivec4(-49475847, -420287241, 269020372, 403699713), ivec4(84346382, -237579278, 168102150, 15988738), ivec4(-453377786, 51514087, 403240950, 471539486), ivec4(-17900294, -271656973, 505091592, -858261741), ivec4(-67964192, 252975117, -184481266, 419751391), ivec4(-17168864, -370808851, 32177409, -251649242), ivec4(909777671, -1142874825, -170074181, 371663368), ivec4(-774113266, 453043948, -200593629, -457310990), ivec4(-252839963, 440151335, 739313675, 676819781), ivec4(-537518080, 1055251692, -1139655090, -1164539755), ivec4(-1881938471, -774842970, -973751908, -205263388), ivec4(419557399, -44612385, -909783068, 1831412474), ivec4(1668830557, 992692304, 1431921986, -319101451), ivec4(-1614886456, 384550042, -221594143, -1060913457), ivec4(-740368195, -20663604, 1161643049, 1613438759), ivec4(1819224911, 389102931, 185732605, -238103028), ivec4(-1968121092, 215133091, -169555444, -1143145484), ivec4(843713486, -741346520, 1041496329, 789179431), ivec4(538443064, 475687493, -299293393, -842741249), ivec4(-1817987119, -1498773365, 452445641, -922806983), ivec4(249873341, -403960765, -637927951, 756803551), ivec4(388706881, 624182306, 639638574, -170796246), ivec4(-436806188, -1144726803, -927018298, 69291284), ivec4(66508273, 468706812, -97973759, -220931637), ivec4(-66839006, -116972275, 1091698692, 741435495), ivec4(-839133200, -638325833, -287709723, 622396898), ivec4(873667631, 33560622, -64547318, -1110905384), ivec4(14607579, 997215502, 167835142, 605362178), ivec4(-842343924, -792675397, 134877929, 406394366), ivec4(673388037, -705552871, -51590453, 489361393), ivec4(-708321020, 841212107, 219817500, 67709973), ivec4(185535524, -756295210, -51786578, 286847209), ivec4(469564161, 1093477404, -219806661, -68235314), ivec4(-284877312, 168091096, 1816598778, 201989430), ivec4(1024064779, -723260396, -910443858, 1041431014), ivec4(1396661072, -151320788, -991773, -673921575), ivec4(419228617, 789189680, 973668377, -234742720), ivec4(-505549843, 217703902, -570750452, 401264858), ivec4(1312304679, -118094267, -34936839, -487588340), ivec4(-420481042, 303570448, -151063296, 235004915), ivec4(844910116, -792998904, -622273047, -490420001), ivec4(691149322, -97435321, 386265583, 337120273), ivec4(422187540, 452853514, 876166723, -1261705712), ivec4(-705693748, -1514814766, -909064524, -589181241), ivec4(-405293635, 455020549, -420611329, -1011692316), ivec4(1499345395, 423385940, 388043014, 420485393), ivec4(573704698, 622795537, -320408299, 49012187), ivec4(-201722368, -286526998, 1329864437, -48739755), ivec4(992213222, 461846, -135337994, 486470377), ivec4(50461962, 386796032, -370080497, -336991261), ivec4(251717093, 253172745, 82960890, -824776708), ivec4(-169421363, -287847201, -504297978, -220011811), ivec4(33685254, -890965511, 468964807, 187380535), ivec4(65923834, 320739093, -539502337, -50332173), ivec4(825698321, 521410861, 238305597, -218371849), ivec4(-118888465, 270735626, -723262470, -977155880), ivec4(-169159736, -184486159, 286528775, -436599794), ivec4(385473501, 235870493, -302583039, 926094834), ivec4(-134409438, 538250502, 504236565, 152838428), ivec4(1110183168, 690036014, -116907486, -674836248), ivec4(-237119523, -67178263, 133228525, -302250495), ivec4(-455618084, 285607673, 453182477, 251922205), ivec4(217774081, 84544531, 196602, 840961538), ivec4(184161587, 993009179, 471673399, -353108209), ivec4(15654885, -791154176, -185668896, -353635078), ivec4(-287846948, 404560136, -740494327, -336729119), ivec4(-253104656, 269288447, 386600718, 842875192), ivec4(138540, 133562377, -201515480, -134281724), ivec4(859056649, 507722544, -237254941, -102246177), ivec4(-842536960, -336527635, -1428222722, 286130371), ivec4(-586468554, -219757886, 438568178, 840755946), ivec4(-469565932, -1076828191, 470157800, -1326894799), ivec4(223420356, 1464229935, 284427862, -99665104), ivec4(-1500462851, 1312351439, -1832916967, 434433238), ivec4(1177165887, 3956540, -320996609, 115330284), ivec4(-286590469, -812081969, -878657026, -132708364), ivec4(-656413214, -808534832, -220942157, 169155347), ivec4(-625430048, 30586322, 1783184425, 825645177), ivec4(641213737, 1431254300, -654701509, 33276829), ivec4(1631651561, 1230332011, -1040964043, -1918123848), ivec4(-1044530024, -1412903223, -791887963, 655750365), ivec4(1246571805, 706094137, 960451140, 542536555), ivec4(-959186947, -218757138, 1733638156, 1699828844), ivec4(-269154243, -962809894, -992357678, -1835618377), ivec4(-657275999, 959193081, 642735442, 1109993243), ivec4(1514022210, -470407096, -473841955, 149350903), ivec4(1281442848, -283036627, -1161049644, -994007662), ivec4(-1078673719, -1029661259, 200335063, 807807004), ivec4(336206903, 876158998, 826819378, -436800246), ivec4(-437398580, 621211099, 876567119, -402646991), ivec4(-1414016547, -976894536, -1548240971, -1027825517), ivec4(941358554, 1112623429, 842084138, 1279938373), ivec4(-48153513, -790496528, -151323418, 1380262406), ivec4(506344773, -571603438, -927220784, -1077292853), ivec4(-1448494143, -455748922, 1380262145, 791033417), ivec4(1110125364, 943933270, -117501146, -388766989), ivec4(-85268235, 1398619928, 691157571, -605623546), ivec4(-1026636352, -1683903557, -1315467883, 553770690), ivec4(910449739, 1011105081, 1195520559, 337915448), ivec4(-302582267, -185277222, 737532137, 1414812238), ivec4(-368563901, -1111044137, -1025846079, -1481986635), ivec4(-977423190, 1009253332, 1061045058, 691354438), ivec4(438651959, -83878098, -790629889, -1011169838), ivec4(1714881757, 759654255, -605485546, -1213420093), ivec4(-1515343430, -1431787865, -338314066, 1497837320), ivec4(1313029454, 891428415, 320475937, 84213246), ivec4(-773791245, -102832936, 1583370540, 52048704), ivec4(-724381718, -673724984, -943799092, -1213022776), ivec4(316983487, 422855737, 254093330, 186061316), ivec4(-201784576, -100794121, -505485839, 1041296608), ivec4(843671138, -453572582, -623717159, -83821587), ivec4(-336729621, -522529061, 1194463218, 420819787), ivec4(-84340449, -201982205, 302577913, -352318702), ivec4(-976630319, 840494029, 219424055, -16973557), ivec4(66778359, -403570682, -436798482, -101718304), ivec4(657138698, 487917331, -185206262, -538516242), ivec4(-51057438, -403702523, -68426014, 792867609), ivec4(219219731, 770, 387451646, 83164434), ivec4(-83884011, 436403961, -267311324, -100269072), ivec4(523765, 117771525, 202706954, -319555581), ivec4(116318691, 1388069, 235537407, 252315914), ivec4(85334813, 185201902, -202247426, 268894450), ivec4(-84935409, -50264054, -17105149, 16381688), ivec4(-66450937, -572530452, 621540838, 100205593), ivec4(235735820, 522194959, -437385962, -33224461), ivec4(-168889610, 371333130, 217838077, -263161), ivec4(-49675266, 16446712, -319159549, -270081564), ivec4(304356864, 16313078, 16711682, 387652111), ivec4(65926153, -151188461, 49802739, -234680817), ivec4(525038, 33619448, -235143158, 33619958), ivec4(-522064135, 65527260, -32431841, 252448263), ivec4(488246539, -335474667, -101391908, -336005133), ivec4(336465398, 368512025, 149482251, -251663607), ivec4(736558334, -654567397, -890371893, 639826154), ivec4(133558317, 856159715, -556005320, -689101049), ivec4(-685113342, -636468532, 1024468230, -537470981), ivec4(166648273, 538511651, 336399619, -470486251), ivec4(-757804044, 438958574, -132245521, 958402298), ivec4(-150201299, -271919630, 15192796, 1058148369), ivec4(-349822683, -960501783, 521134553, 134546435), ivec4(220265213, -521991673, 15458289, -202829823), ivec4(-70525150, 827076875, -301851349, -454696245), ivec4(654966780, 203632426, 149883169, -555693339), ivec4(-168029191, -267841267, -134605045, -454504739), ivec4(83688169, 18283534, 588382950, 35672144), ivec4(-977409796, -168896038, 674377465, 437593903), ivec4(-922613257, -18756673, 235009791, 454494987), ivec4(-688123637, -285607708, -201790737, -168623619), ivec4(1430984700, -32434631, -404502825, 250671585), ivec4(589177892, 169019920, -757207293, 134543583), ivec4(252312049, 101388298, -170273280, -152182549), ivec4(252314875, 335082239, 339692862, -874777857), ivec4(-169815863, 1127090424, 438047272, 201920535), ivec4(-306069773, -169020685, 639112458, -469888476), ivec4(-335480868, -321068827, 150332404, 1362231800), ivec4(-117166502, -556080141, -51511304, 68364575), ivec4(353178131, -653979637, 33154249, 167640570), ivec4(117837847, -86185473, -555945212, 17366508), ivec4(-33813496, 775834158, -605423855, -320873248), ivec4(757664248, 135207203, 252780061, -977281282), ivec4(-67898653, 605950468, -217703901, -83953428), ivec4(-505812746, -269159958, 1042613490, 187384134), ivec4(-572396047, 15919585, 33818632, 672925953), ivec4(-301000675, -404299049, -16514063, 724997), ivec4(-84216072, -201589252, -33230115, 167377649), ivec4(472197143, -303367143, -286723084, 707137016), ivec4(-401861602, -353049116, 286791946, -302905838), ivec4(49732313, 185533195, 638650110, -873390301), ivec4(-692275250, 1110377453, 389564997, -505621797), ivec4(589893113, 236133412, -504956930, 100458975), ivec4(371660295, -83485673, -304426533, 437322748), ivec4(-16317926, -404227333, 32565221, 488645139), ivec4(-368893652, -67902247, 388304640, -67569408), ivec4(201787910, -117702648, 82833139, -50526441), ivec4(16777728, -82835970, -83885832, -555753233), ivec4(184547556, 589701146, -168887018, 168296447), ivec4(-252180470, 167835641, 252773893, -168296187), ivec4(252840700, -252448256, -218959123, 100665861), ivec4(-167706102, -34675481, 319292673, -49805552), ivec4(16509929, 387520779, -84082419, -83360003), ivec4(-184745221, 82831342, 185932304, -50922746), ivec4(218166525, -235867391, -689837335, 151452900), ivec4(405021458, -252243946, 251524600, 134163), ivec4(66449402, 151128332, -235667441, 319683820), ivec4(-268762098, -84481050, 101581566, -101452812), ivec4(48555258, 336265742, 118101272, -370347266), ivec4(404358897, -167311092, 302910202, 17103362), ivec4(-236328981, 454825224, -387251440, 151519479), ivec4(-352383218, -370217490, 67365337, 337056263), ivec4(17305617, -68358400, 1252105, 49742085), ivec4(253367822, -285471478, 150662630, 17240088), ivec4(-455420696, 150929651, -118031860, -218890756), ivec4(202315270, 319821075, -66384881, 15985390), ivec4(-202839040, 284880625, 69144, -522127096), ivec4(151386344, -805823466, 149732021, 589697548), ivec4(-82634466, 168171765, 1547451182, 1970493015), ivec4(-449357986, -1767928660, -1683906677, 285000619), ivec4(-859514880, -1060718652, 503576009, -1447311381), ivec4(404750510, -535681022, 1092360191, 1768258929), ivec4(1734570095, 1785289580, -1258281656, -708196146), ivec4(-203894339, -369548786, -839573487, -1045061713), ivec4(-1852912929, -1417438561, 14866402, -520476125), ivec4(1883188242, 2003847750, 1431988330, 996108910), ivec4(-1296786197, -910571076, 1008071141, 742665785), ivec4(-1343817993, -252524111, -1866742334, -524373345), ivec4(102775058, -52309755, 658845186, 858865988), ivec4(1718763825, -1509410987, -1432312690, -708587330), ivec4(573312001, -166390783, -893937464, -1007361109), ivec4(-1431524936, 67886513, -250204385, 637464793), ivec4(894453547, 942161205, 1400401251, -1431310798), ivec4(-791686214, 250476525, 471870783, -905441008), ivec4(-354954070, -1058869505, -539836244, 623713284), ivec4(-371785438, 1145774074, 338051905, 1664685081), ivec4(138698348, -1280464456, -203232811, 639762939), ivec4(-16775657, -1129061890, -33890605, -1044001312), ivec4(200665305, 303241246, 66314479, 792478243), ivec4(134745381, 1784955677, -1260050353, -271403348), ivec4(117239024, 169157400, -82900224, -590625062), ivec4(-655558673, -203369524, 706810877, -167305688), ivec4(840630518, 219756349, 537199628, 962222141), ivec4(-1312957169, -269557058, 471072499, 33556752), ivec4(-453967087, -320940328, -320607501, 134281199), ivec4(286661402, -336660730, 673518585, -235074532), ivec4(1296047098, -148686777, -456602150, 218166772), ivec4(303239184, 454561043, -774377974, -49613353), ivec4(-640558102, 285667817, -32894451, -69147663), ivec4(321794076, -387717128, 556276986, -672725735), ivec4(-101132596, 270014208, 66581762, 520688128), ivec4(-524889061, -166983934, -434697220, -689180212), ivec4(1708019, 33220835, -51175138, 450744287), ivec4(437066547, -1245391625, 605290198, 72502585), ivec4(519563227, -98617539, -339105853, 66645248), ivec4(-101771266, 855376904, -1308217804, 519163335), ivec4(404887808, 455283960, -1159273984, 97242333), ivec4(1598828841, -1027204801, 521653970, -198691299), ivec4(-352583700, -691284295, 335601656, 557397789), ivec4(-979579120, 353696459, 606221620, -603052742), ivec4(-1011765826, 756603825, 1080652625, -758263536), ivec4(487990260, -270794197, -707203574, -50340906), ivec4(891559932, 87115072, -725044282, 622069237), ivec4(1144139313, -923728089, -909258049, 1294277379), ivec4(52639834, 217241822, 354884121, -33034758), ivec4(-874783272, -169149725, 790434832, -755625428), ivec4(-185867056, 807145737, 390021170, -977416727), ivec4(468569808, 1129396261, -386068191, 606544387), ivec4(-504292820, -739901712, -254357551, 555022586), ivec4(254815509, -792472588, 83949023, 772870932), ivec4(-267770311, -590098982, 370736860, -285337305), ivec4(-203502888, 522792720, -321266433, -841688856), ivec4(-589505333, 756222199, -116188373, -1385759), ivec4(270409232, 640358667, -520681199, -2368027), ivec4(1145320733, -83159764, 1194066414, -14728108), ivec4(-235144464, -117964806, 218364667, 758133026), ivec4(-671805408, 117501913, 150862854, 286134799), ivec4(-589371393, 470084834, -15522264, -438637065), ivec4(893333770, -605879517, -269424927, -438444570), ivec4(318761186, 605954335, -623187438, 34409456), ivec4(386926847, -335081716, -539108134, 1126959854), ivec4(402985260, 417914368, 338181955, -740891647), ivec4(-688784156, -133629222, 557258496, -267384059), ivec4(147896774, 470290209, -50920677, -958790643), ivec4(116581842, 51981087, -704573445, 1344859858), ivec4(-385479379, -136061480, -791943938, -304024848), ivec4(489365512, -571666665, 134277084, 186456071), ivec4(66976003, -473775644, 471863296, -84608502), ivec4(-34074858, 322977042, -674373389, 84869362), ivec4(-102179351, 453176301, 353641511, -707995131), ivec4(302384105, -32102877, -266926098, -269624108), ivec4(-235406610, 772669689, 436207393, -16768713), ivec4(-134943751, -856946687, -386143540, 976096492), ivec4(-48688086, -52177197, 622135564, -33811674), ivec4(-858587370, 116980451, 269422614, -64283131), ivec4(925236710, -302448619, 352385004, -741613554), ivec4(-18351113, 675230490, -1042280938, 285795021), ivec4(624240915, 403567621, -152971024, 16577791), ivec4(83557881, -50187213, 69413653, -84477956), ivec4(-267121670, -51984703, 773388014, 168832827), ivec4(-389557505, 184946697, -335012072, -486273806), ivec4(-167843875, 50462444, 941492747, 284549130), ivec4(-100790752, -34211590, -1076821745, -336006188), ivec4(874911486, -301332961, 149672135, 673122318), ivec4(32768532, -589763057, -286395418, 16577524), ivec4(-48288496, 438111483, -84345083, 218627585), ivec4(-506740764, 385607911, 305086258, -875434750), ivec4(84475869, 663065, 236850174, -167969287), ivec4(-286855697, 706347001, -287182828, -261375), ivec4(201521661, -638120431, -84215583, 623319051), ivec4(-872869097, -440420685, 1614817038, 1969185394), ivec4(1043352176, 1564887374, 540357711, -1193672173), ivec4(-1598963797, -1835753827, -1615349602, -1029402720), ivec4(1328156649, 423311177, -1718309946, -490228828), ivec4(1799296000, 1752135803, 1667000934, 1197169238), ivec4(-585422822, -640687906, 169021195, -641008627), ivec4(-1164670804, -641557058, -318048014, -1294144552), ivec4(-996566877, 588051165, 1749036611, 2002139484), ivec4(1381917544, -335198395, -1229333267, -102505009), ivec4(-65275, -252185858, -690106932, 587984341), ivec4(-32366302, -1701138976, 250462113, 674511659), ivec4(85004557, 1213216537, -15518903, -724971288), ivec4(-842150456, 67301342, -335935478, -1530996257), ivec4(-809714269, 202437604, -774184969, -154156612), ivec4(943341093, -419688661, 469891833, 993609021), ivec4(-536472536, -605495602, 32496089, 673195032), ivec4(-235402981, -607991064, 453701870, -217833952), ivec4(-370742038, 1547704824, 558455656, -287120646), ivec4(672332778, 321006379, -808458490, -673585438), ivec4(756744161, 120139565, -1042422287, -505822030), ivec4(740628474, -84280298, 133427964, 1296579625), ivec4(-403102139, -219286808, 437589005, -32566497), ivec4(-168566048, -455353119, 706744315, 924971), ivec4(-724506120, 166518486, 321069857, 51118853), ivec4(705167360, 506277940, -488642814, -117707032), ivec4(-50660102, -369754888, -201192200, -51518995), ivec4(471339016, -268829686, -674048806, 252047072), ivec4(118168086, -167966450, 219221500, -386136309), ivec4(-101652257, 50529539, -252183040, 217508075), ivec4(-369226215, -135008280, 303766533, -436663023), ivec4(-169421348, 152113416, 15987701, 17236992), ivec4(-771488251, -707061020, 1055985704, -216084478), ivec4(386478062, 670494516, -471999249, 301592295), ivec4(757015090, -958798066, -33626456, 17773082), ivec4(270458857, 404368670, -371530995, 451337960), ivec4(-132181977, -84934418, 1182476, -300409595), ivec4(-170475061, 1495336188, 152447821, -1261905434), ivec4(386531543, -134661, 908207367, -30850998), ivec4(-505287950, 454815705, -1961697, 318695942), ivec4(34280721, -521006569, 166648526, 608910102), ivec4(-470019829, 48222941, -504171275, 15002853), ivec4(1229798453, -622000074, -85072695, 253174298), ivec4(-587736090, 438111459, 32964625, -304553738), ivec4(471335159, 50670389, -286660865, -402126618), ivec4(-607071007, 975040997, 692076868, -673650437), ivec4(386334966, -873991924, 49151458, 270215466), ivec4(-268108551, 286256612, 386995471, -50664186), ivec4(-101190422, -370604262, -135536669, 606674178), ivec4(-133356510, 32959472, -65726971, -186983703), ivec4(638582784, -252184050, -320472841, 521604358), ivec4(-200597222, -403833345, 218162914, -454300676), ivec4(218232548, 588781593, -66580198, 301791999), ivec4(-689111534, -50467887, 119414791, 101056511), ivec4(15524594, 504958985, -100729589, -589373205), ivec4(34212852, -236851970, 201786880, 168693010), ivec4(-218103554, 270408446, -657135619, 184416495), ivec4(-134479602, -268433925, 319420135, 219555875), ivec4(-370344950, -18291737, -419954937, 184609755), ivec4(337583125, 199947, 318766080, -302050787), ivec4(-85798179, 185797888, 151126277, -135201529), ivec4(538842893, -83819246, -336992530, 34142954), ivec4(-505153792, 353305843, -50722280, 16840698), ivec4(371266049, -588778493, 185071588, 33752069), ivec4(16578300, 571342336, -149149912, -134477823), ivec4(-588717073, 318893028, 134680334, -150269938), ivec4(470480604, 370416415, -319617267, -387587864), ivec4(152446976, -133954795, -319947262, 488642813), ivec4(-167506149, -321071129, 234348776, 168239897), ivec4(-235739392, 49605099, 387455255, -50721515), ivec4(-184091152, 85592303, -319754759, 219482604), ivec4(251595019, 118299159, 49939733, -706874882), ivec4(116910555, 185800213, -285671925, 621343468), ivec4(287060278, -420943616, -1184534, 269752600), ivec4(167769340, 252774915, 168755458, -336861713), ivec4(118162411, -320076277, -184876805, -66048), ivec4(-219087102, 303039994, 269618708, -16578796), ivec4(184019702, -218365952, -134415628, 84082169), ivec4(67770125, 33160444, -67305468, -101325074), ivec4(-168756488, 185403648, 67570443, -16052719), ivec4(117899515, -336200189, -100599830, 251460350), ivec4(201852946, 133890568, -117376000, -100400136), ivec4(-252248069, 67505404, -84150275, 16777727), ivec4(319488005, 67110668, 51319567, -67898117), ivec4(-184680443, -66715669, 134479611, 236325376), ivec4(100336913, -100860155, 99610873, -251789051), ivec4(167838200, 34672909, 84743431, 84212477), ivec4(-168230910, 134344688, 49871872, 33489419), ivec4(50333701, 17302282, 460793, -151257856), ivec4(50921715, -50594303, 33093882, 319027973), ivec4(-32959981, 101254659, -235539720, -150731528), ivec4(16644338, 218628096, 235734534, -67564780), ivec4(16776192, -219549704, 33093883, -184944900), ivec4(118557175, 657661, -268500739, 33883386), ivec4(-151520257, 351335661, 64684065, -318162373), ivec4(-118757655, -269156348, 18291970, -655885313), ivec4(153161454, 369352651, -69342203, 487132163), ivec4(-168554713, 51255550, -405416714, -283116055), ivec4(1026027999, -320271312, -169809423, -18157307), ivec4(-133288895, -672667664, -201257518, 1092680421), ivec4(-351468764, 201706710, 485357036, -284808153), ivec4(-321127457, -521136084, 540746503, 49410315), ivec4(-184290596, 689829102, -419822560, -69479940), ivec4(-85264892, 136196105, -890307588, 354426609), ivec4(757144355, -692196847, 705351616, 655949081), ivec4(-300536003, -254480917, 368709384, 187575324), ivec4(-891169036, 269088210, 773726730, -353364439), ivec4(131842526, 724964644, -216192738, -894125373), ivec4(439100928, 841948705, -807933923, 134275528), ivec4(622729980, -637718474, -422984753, 453511680), ivec4(522788378, -874912530, 606011604, 622605368), ivec4(-1143473625, 266514844, 471999779, 3555621), ivec4(-842869781, 151064314, 1042485788, -1109991410), ivec4(100785342, 455154709, -469621469, -523712556), ivec4(942349319, 321131298, -1498098976, 806419661), ivec4(672539447, -706410195, 115262655, 572460814), ivec4(-248107499, -910372399, 285737196, 454760216), ivec4(-740430323, 519627478, 607728950, -822470123), ivec4(-507991364, 825761534, 623975707, -925963256), ivec4(402911195, 269161233, -874375124, -287520308), ivec4(505288447, 186456333, -640560664, 908587742), ivec4(370156847, -1077349609, 149476800, 254359856), ivec4(-65397485, -254161449, 420479213, 621739539), ivec4(-438376687, -203431194, -201122549, -418698993), ivec4(-218434587, 875832835, 235598079, -473975847), ivec4(353174779, 150544423, -117635562, -234613497), ivec4(-620887307, 136250606, -49217310, 334554868), ivec4(234749477, -253102316, 50790381, 168896032), ivec4(-740031741, -67106316, 168099563, 320406532), ivec4(102167288, -117964800, -233825778, -187376901), ivec4(151257097, 15929096, 271851026, -420476165), ivec4(234807521, 17378345, 183155686, 387784707), ivec4(-135599848, 117900017, -183289551, 116781280), ivec4(-33092061, -67577389, 520557833, 51183116), ivec4(-848110, -504234227, 452456930, -317648348), ivec4(150726611, 202443026, -101057286, 419822851), ivec4(-504296161, 739967721, -233691090, -606677029), ivec4(218098910, 539106582, 319491354, -757469953), ivec4(319158748, -67173352, -100795401, 16382705), ivec4(-50132985, 203033349, -320146697, 471144451), ivec4(-252051946, -572793887, 504036840, -83225056), ivec4(-133955588, -202575889, 67110143, 84539127), ivec4(-151584508, 217905402, 83296266, 17633559), ivec4(33554432, -33293056, -419956242, 49409515), ivec4(438310670, -68357110, 100794368, -67172596), ivec4(-319689745, 235736059, -33621500, -16317448), ivec4(303104251, -67239928, 33819142, -202113024), ivec4(-118098436, 285932274, -117437167, 129004), ivec4(134612741, -285736441, 15592686, 855563), ivec4(-525573, 50266630, 101389581, 100727039), ivec4(17041415, -286265864, 16579053, 185734670), ivec4(-168954366, 218629122, -134150647, -219551760), ivec4(185203441, -134807289, 100860158, 336462849), ivec4(-168361975, 151586816, -201325302, -185273618), ivec4(470416376, -134085099, 66907627, 168233992), ivec4(-184810485, -151586831, -117371386, 117372919), ivec4(134940933, 185536008, 100597767, -83951868), ivec4(-538841868, 66910444, 505945871, -319290353), ivec4(453902575, 50728990, -438379021, 302775021), ivec4(-353239537, -100202779, 337584909, -185603587), ivec4(504954359, -83427305, 168294126, 587328759), ivec4(911890, 437062131, 939652108, -352464126), ivec4(370989481, -636267739, -338889745, 320213239), ivec4(754973713, -34402739, 170851028, -186721025), ivec4(973933065, -707467245, -99604221, 133234172), ivec4(454891811, -1365844987, 14616854, -436659679), ivec4(622796536, 217179642, -152642051, 217775098), ivec4(-518499256, -52507680, 84083975, 167707395), ivec4(-737532903, 53084107, -553578769, 534369776), ivec4(-788841660, -605754139, 338493407, 590029068), ivec4(-924126197, 253036021, -755236615, 337651428), ivec4(-169417965, 320405729, 286979065, 105201400), ivec4(-588263206, -132319025, -83677427, -217312508), ivec4(85923554, -488503548, 504426747, -484228053), ivec4(-522850596, 167511039, 385876240, -738060019), ivec4(202376416, -82444035, 184546527, 66319118), ivec4(-353636099, 320598495, 875898648, -287519495), ivec4(151911403, -235402478, 370999790, -218833177), ivec4(32503023, 335741970, -283171290, -321399085), ivec4(15919089, 285933061, -824373994, 487194348), ivec4(-185141742, 587460842, -50390982, -253502739), ivec4(285472487, 487656991, -304490232, 590323), ivec4(84085512, 437454086, -371204618, -235794681), ivec4(335214067, 306329121, -371398923, 335547655), ivec4(-402581734, -267641094, 15790836, -50926081), ivec4(470686731, -570605749, -69285158, 185275138), ivec4(469896463, -723057877, 51182812, -167964402), ivec4(991099388, -369423063, -639175697, 336067827), ivec4(187968786, -623651611, 134218491, -233960442), ivec4(120399605, -371398928, -184747018, -151388679), ivec4(53363231, -202648099, 186125816, 84549915), ivec4(-520354039, 185530075, -119017472, 1042028806), ivec4(-805232066, -488711482, 656150009, 555423249), ivec4(-1091176705, 571203261, -183430105, 1845505), ivec4(-135795456, -134608379, 32566774, 407185409), ivec4(-237713173, -132448290, 471076600, -233241586), ivec4(67502060, -237253922, 99880974, -568709067), ivec4(-153296947, 605686281, 604962822, -520551389), ivec4(-153170744, 605355253, 707668001, -976616140), ivec4(-184091941, 690097647, 1912623, -742672684), ivec4(571074519, -268489412, 302837221, -219024387), ivec4(51059214, -436992763, -133628698, 453175782), ivec4(134218525, -220210704, -554099698, 740162787), ivec4(-589104100, -589703204, 505878513, 34536712), ivec4(269876972, 503577861, -622195933, -201524758), ivec4(-134217484, 741286414, -924122347, 150466263), ivec4(184416522, 590754844, -809252622, 32239334), ivec4(120534311, -336000262, 369489904, 354031379), ivec4(-1381115, -302052342, 385275612, 252710676), ivec4(-219874798, -418376193, 555416789, -384884958), ivec4(-152773925, 218627577, 272162, 352250362), ivec4(404626196, -639106797, 16970970, -184222464), ivec4(439034362, -118751464, -989975, -17559269), ivec4(657204506, -690953972, -168302892, 773920778), ivec4(-419561444, 605352398, 370218272, -202838003), ivec4(-368702453, 199878111, 504633125, -520025074), ivec4(-33624610, 453768175, 988437, -774246664), ivec4(183493349, 304289547, -135660294, 69155890), ivec4(-218962443, 419160027, -33220068, -184550916), ivec4(33289456, -51774202, 168432390, 1311744), ivec4(-50330112, 67039228, -353896218, -369748991), ivec4(1109457132, -134606786, -1093672224, 1025575631), ivec4(254681151, -1079186178, 857212903, 306532901), ivec4(-957293858, -149693760, 623252977, -321265135), ivec4(-827611191, 1175186394, -265727399, -873018945), ivec4(48814547, 1919435814, 306408035, -271139598), ivec4(1043863316, -1984694730, -1164601207, -925904680), ivec4(-875321690, -1262627394, -1078739038, 894115553), ivec4(-1094125527, 638713582, 1701334048, 1516989289), ivec4(893999226, 1245916976, 406345022, -1735877671), ivec4(-202855008, -236915465, -49870333, -1397511471), ivec4(-1112565090, -65531401, -203704636, 907676909), ivec4(1752198758, 1011236696, -520944611, 1275989253), ivec4(-687657883, -1281123915, 149871833, 604757988), ivec4(-689168856, -1396848429, 115255978, -1109128422), ivec4(167111370, 994913812, 1347182935, 305546343), ivec4(149946625, 370282507, -975640839, -371270196), ivec4(-504489201, 234089712, -438248977, -691290139), ivec4(121579492, -1112094241, 403374300, 1145257028), ivec4(323307826, -251126522, -267978016, -32037099), ivec4(-674437642, 300273110, -353317914, -402915090), ivec4(-16716310, 385152748, -15786704, -185344016), ivec4(1027804399, 708462122, -51183584, -302908163), ivec4(941293553, 507000876, -756415476, -1093739302), ivec4(-355877454, 654768118, 825042497, 756421415), ivec4(803, -18156029, 759051044, -553574109), ivec4(268032191, -50788598, 335871232, 640757278), ivec4(-253626590, -807872030, -992151065, 168159955), ivec4(825435690, 101584916, -33485307, 488970513), ivec4(352788270, -691210736, -404101673, 387562), ivec4(673122039, -352115924, -791952433, -16719658), ivec4(167439870, 877411357, -839969252, -371405379), ivec4(604766202, 708125476, 405415965, -522726694), ivec4(32635635, 100600869, 520947203, 657071640), ivec4(-1244734464, -370744878, -136125461, -203427577), ivec4(-1481197612, -1431331945, 1245909452, 1211782737), ivec4(-385203, 723191308, 1362630937, 1735157076), ivec4(541816177, -168553953, 267708156, -16516330), ivec4(-723395610, -1614885174, -1498762850, -356598075), ivec4(353178898, 1229137682, -318237401, -622861350), ivec4(470749177, 1801215556, 1128543829, -789706724), ivec4(-369562922, -554632473, -471075864, -1431586095), ivec4(-1111641933, 604953527, 1346388274, 390554457), ivec4(-421135609, 403634158, 1009325327, 473510703), ivec4(322781725, 66122758, -370410747, -506869792), ivec4(-840901917, -1078154578, -792674374, 657133), ivec4(521340154, 707008547, 840898078, 219881261), ivec4(118755070, 418970631, 219753268, 15925002), ivec4(-487858709, 150331351, -437719806, -505219092), ivec4(-136260128, -219680771, 538251273, -234745830), ivec4(185270512, 302384132, 303638574, 606213641), ivec4(-202309610, -134547983, -420871931, -66973950), ivec4(318698744, -235340273, 135332082, -50331908), ivec4(471408135, -17431526, -66643691, 50723062), ivec4(-421007887, -16383762, 252249601, 371138073), ivec4(-1711363, -370281984, 220073457, -150860279), ivec4(-487785480, 15329256, 522655762, 538904071), ivec4(-197372, -167638779, 66186736, -286000630), ivec4(-135930913, 261881, 674373643, -219945726), ivec4(200868612, 302318097, -269686268, 150530027), ivec4(-572725257, 471473923, 66978581, -85597187), ivec4(352119540, -253298929, 201126126, -118554606), ivec4(-218694390, 756682739, 268500769, -251917806), ivec4(-271003676, 219421952, 319361551, -335934694));\n\nfloat audio_at_sample(int sample_idx)\n{\n    if (sample_idx < 0 || sample_idx >= audio_n_samples)\n    {\n        return 0.;\n    }\n\n    int packed = 0;\n    int ivec4_idx_in_part = (sample_idx / 16) % audio_n_ivec4_in_part;\n    int component_idx_in_ivec4 = (sample_idx % 16) / 4;\n\n    int part_idx = sample_idx / audio_n_i8_in_part;\n    if (part_idx == 0)\n    {\n        packed =\n            audio_data_packed_part0[ivec4_idx_in_part][component_idx_in_ivec4];\n    }\n\n    int sample_i8 = (packed >> (8 * (sample_idx % 4))) & 0xFF;\n    if (sample_i8 > 127)\n    {\n        sample_i8 -= 256;\n    }\n\n    return float(sample_i8) / 128.;\n}\n\n#define BICUBIC 1\n\nfloat audio_at_time(float time)\n{\n    int sample0_idx = int(floor(time * float(audio_sample_rate)));\n\n#if BICUBIC\n    float sample0 = audio_at_sample(sample0_idx);\n    float sample1 = audio_at_sample(sample0_idx + 1);\n    float sample2 = audio_at_sample(sample0_idx + 2);\n    float sample3 = audio_at_sample(sample0_idx + 3);\n    return bicubic(\n        sample0,\n        sample1,\n        sample2,\n        sample3,\n        fract(time * float(audio_sample_rate))\n    );\n#else\n    float sample0 = audio_at_sample(sample0_idx);\n    float sample1 = audio_at_sample(sample0_idx + 1);\n    return mix(\n        sample0,\n        sample1,\n        fract(time * float(audio_sample_rate))\n    );\n#endif\n}\n\n/*____________________ end ____________________*/\n\n\n\nvec2 mainSound(int samp, float time)\n{\n    if (time > 16.)\n    {\n        time = mod(time, 8.) + 8.;\n    }\n    return vec2(audio_at_time(time));\n}\n",
     "name": "Sound",
     "description": "",
     "type": "sound"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "M3VGRK",
    "date": "1717936266",
    "viewed": 220,
    "name": "Attack-Decay-Sustain-Release",
    "description": "The ADSR curve is a fundamental tool used in all audio synthesizers.\nFeel free to play with the values (see custom_adsr_curve_1() in Common).\n\nRead more: [url]https://en.wikipedia.org/wiki/Envelope_(music)[/url]\n",
    "likes": 9,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "audio",
     "utils",
     "adsr"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// NOTE: this tab is a modification of the following shader:\n// https://www.shadertoy.com/view/mtjyDw\n\n\n\nfloat f(float x)\n{\n    return custom_adsr_curve_1(x);\n}\n\nconst float zoom = 1.;\nconst float max_thickness = .01;\nfloat px2uv; // (defined in main)\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sd_segment(in vec2 p, in vec2 a, in vec2 b)\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat dist_f(vec2 p)\n{\n    // We have a line between every something pixels.\n    // The line vertices lie on f(x).\n    int n = int(iResolution.x);\n    \n    // Total horizontal length of the lines (screen length in UV)\n    float total_len = iResolution.x * px2uv;\n    \n    // Distance between the line vertices (in UV)\n    float step_size = total_len / float(n);\n    \n    // Index range of the lines which we want to check\n    int idx0 = int(floor((p.x - max(max_thickness, step_size)) / step_size));\n    int idx1 = int(floor((p.x + max(max_thickness, step_size)) / step_size));\n    \n    // Initial distance\n    float dist = 1e9;\n    \n    // Find the minimum distance from the lines we chose\n    for (int i = idx0; i <= idx1; i++)\n    {\n        // Point A of the line segment\n        float ax = float(i) * step_size;\n        float ay = f(ax);\n        \n        // Point B of the line segment\n        float bx = float(i + 1) * step_size;\n        float by = f(bx);\n        \n        // Distance\n        dist = min(dist, sd_segment(p, vec2(ax, ay), vec2(bx, by)));\n    }\n    \n    return dist;\n}\n\n#define SNAP(X, STEP) ((floor(X / STEP) + .5) * STEP)\n\nvec3 render(vec2 frag_coord)\n{\n    // UV\n    vec2 uv = px2uv * (frag_coord - iResolution.xy * .5);\n    uv += vec2(.5, .45);\n    if (iMouse.z > .2)\n    {\n        uv += px2uv * (abs(iMouse.zw) - iMouse.xy);\n    }\n\n    // Render grid\n    vec3 col = vec3(.024, .038, .064);\n    vec3 col_grid = vec3(0, 0, .02);\n    #if 0\n    {\n        // Snap grid lines to pixels\n        // For this to work you need to disable the paper effect above\n        \n        #define SNAP_PX(X) SNAP(X, px2uv)\n        \n        float d = min(abs(uv.x - SNAP_PX(round(uv.x))), abs(uv.y - SNAP_PX(round(uv.y))));\n        if (d < .5 * px2uv) col = mix(col, col_grid, .5);\n        \n        vec2 t = uv * 4.;\n        d = min(abs(t.x - SNAP_PX(round(t.x))), abs(t.y - SNAP_PX(round(t.y))));\n        if (d < .5 * px2uv * 4.) col = mix(col, col_grid, .2);\n        \n        d = min(abs(uv.x), abs(uv.y));\n        if (d < 1. * px2uv) col = col_grid;\n    }\n    #else\n    {\n        // Don't snap to pixels\n        \n        float d = min(abs(uv.x - round(uv.x)), abs(uv.y - round(uv.y)));\n        if (d < .004) col = mix(col, col_grid, .5);\n        \n        vec2 t = uv * 4.;\n        d = min(abs(t.x - round(t.x)), abs(t.y - round(t.y)));\n        if (d < .004 * 4.) col = mix(col, col_grid, .2);\n        \n        d = min(abs(uv.x), abs(uv.y));\n        if (d < .005) col = col_grid;\n    }\n    #endif\n    \n    // Distance from f(x)\n    float d = dist_f(uv);\n    \n    // Render the graph\n    float thick = max_thickness;\n    float graph_fac = remap01(d, thick, thick - px2uv);\n    col = mix(col, vec3(.3, .6, 0.7), graph_fac);\n    \n    // Highlight the current part in time\n    float highlight_fac = min(\n        remap01(abs(uv.x - mod(iTime, 1.8)), .03, .02),\n        graph_fac\n    );\n    col = mix(col, vec3(.12, 0, .3), highlight_fac);\n    \n    return col;\n}\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    // Pixel to UV conversion factor\n    px2uv = 2. * zoom / min(iResolution.x, iResolution.y);\n    \n    // Super-sampling\n    vec3 col = vec3(0);\n    {\n        col += render(frag_coord + vec2(-.25, -.25));\n        col += render(frag_coord + vec2(-.25, +.25));\n        col += render(frag_coord + vec2(+.25, +.25));\n        col += render(frag_coord + vec2(+.25, -.25));\n    }\n    col /= 4.;\n    \n    // Output\n    col = pow(col, vec3(1. / 2.2));\n    frag_col = vec4(col, 1.);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "/*__________ math utils (INCOMPLETE) __________*/\n\nconst float PI = 3.141592653589793238462643383;\nconst float TAU = 6.283185307179586476925286767;\nconst float PI_OVER_2 = 1.570796326794896619231321692;\nconst float INV_PI = .318309886183790671537767527;\nconst float INV_TAU = .159154943091895335768883763;\n\n#define FUNC_LERP(T) \\\nT lerp(T a, T b, float t) \\\n{ \\\n    return a + t * (b - a); \\\n}\n\n#define FUNC_WRAP(T) \\\nT wrap(T v, float start, float end) \\\n{ \\\n    return start + mod(v - start, end - start); \\\n}\n\n#define FUNC_REMAP(T) \\\nT remap(T v, float inp_start, float inp_end, float out_start, float out_end) \\\n{ \\\n    return out_start \\\n        + ((out_end - out_start) / (inp_end - inp_start)) * (v - inp_start); \\\n}\n\n#define FUNC_REMAP_CLAMP(T) \\\nT remap_clamp( \\\n    T v, \\\n    float inp_start, \\\n    float inp_end, \\\n    float out_start, \\\n    float out_end \\\n) \\\n{ \\\n    T t = clamp((v - inp_start) / (inp_end - inp_start), 0., 1.); \\\n    return out_start + t * (out_end - out_start); \\\n}\n\n#define FUNC_REMAP01(T) \\\nT remap01(T v, float inp_start, float inp_end) \\\n{ \\\n    return clamp((v - inp_start) / (inp_end - inp_start), 0., 1.); \\\n}\n\n#define FUNC_LENGTH_SQ(T) \\\nfloat length_sq(T v) \\\n{ \\\n    return dot(v, v); \\\n}\n\n#define FUNC_DIST_SQ(T) \\\nfloat dist_sq(T a, T b) \\\n{ \\\n    a -= b; \\\n    return dot(a, a); \\\n}\n\nFUNC_LERP(float)\nFUNC_LERP(vec2)\nFUNC_LERP(vec3)\nFUNC_LERP(vec4)\n\nFUNC_WRAP(float)\nFUNC_WRAP(vec2)\nFUNC_WRAP(vec3)\nFUNC_WRAP(vec4)\n\nFUNC_REMAP(float)\nFUNC_REMAP(vec2)\nFUNC_REMAP(vec3)\nFUNC_REMAP(vec4)\n\nFUNC_REMAP_CLAMP(float)\nFUNC_REMAP_CLAMP(vec2)\nFUNC_REMAP_CLAMP(vec3)\nFUNC_REMAP_CLAMP(vec4)\n\nFUNC_REMAP01(float)\nFUNC_REMAP01(vec2)\nFUNC_REMAP01(vec3)\nFUNC_REMAP01(vec4)\n\nFUNC_LENGTH_SQ(vec2)\nFUNC_LENGTH_SQ(vec3)\nFUNC_LENGTH_SQ(vec4)\n\nFUNC_DIST_SQ(vec2)\nFUNC_DIST_SQ(vec3)\nFUNC_DIST_SQ(vec4)\n\n\n\n/*___________________ audio ___________________*/\n\n// C0 = 0, C5 = 60\nfloat note_to_freq(int note)\n{\n    const float a = 440.;\n    return (a / 32.) * pow(2., float(note - 9) / 12.);\n}\n\nfloat db_to_mul(float db)\n{\n    return pow(10., .05 * db);\n}\n\nfloat mul_to_db(float mul)\n{\n    return 8.68588963808 * log(mul);\n}\n\n// curve similar to ones used in automation and envelope curves in most VSTs and\n// DAWs\n// https://www.desmos.com/calculator/kvkzogpxjk\nfloat expow(float t, float p)\n{\n    t = clamp(t, 0., 1.);\n    if (p >= 0.)\n    {\n        return pow(t, pow(2., p));\n    }\n    return 1. - pow(1. - t, pow(2., -p));\n}\n\nstruct Adsr\n{\n    float delay;        // >=0\n    float attack;       // >=0\n    float attack_pow;   // any\n    float hold;         // >=0\n    float decay;        // >=0\n    float decay_pow;    // any\n    float sustain;      // 0-1\n    float release;      // >=0\n    float release_pow;  // any\n};\n\nfloat Adsr_internal_ads(in Adsr self, float t)\n{\n    if (t < 0.)\n    {\n        return 0.;\n    }\n    if (t < self.attack)\n    {\n        return expow(t / self.attack, -self.attack_pow);\n    }\n    t -= self.attack;\n    if (t < self.hold)\n    {\n        return 1.;\n    }\n    t -= self.hold;\n    if (t < self.decay)\n    {\n        return remap(\n            expow(t / self.decay, self.decay_pow),\n            0., 1.,\n            1., self.sustain\n        );\n    }\n    return self.sustain;\n}\n\nfloat Adsr_internal_release(in Adsr self, float t, float v_before_release)\n{\n    if (t < self.release)\n    {\n        return remap(\n            expow(t / self.release, self.release_pow),\n            0., 1.,\n            v_before_release, 0.\n        );\n    }\n    return 0.;\n}\n\nfloat Adsr_eval(in Adsr self, float t, float note_length)\n{\n    t -= self.delay;\n    note_length -= self.delay;\n    if (t < note_length)\n    {\n        return Adsr_internal_ads(self, t);\n    }\n    else\n    {\n        float t_before_release = min(\n            note_length,\n            self.delay + self.attack + self.hold + self.decay\n        );\n        float v_before_release = Adsr_internal_ads(\n            self,\n            t_before_release\n        );\n        return Adsr_internal_release(\n            self,\n            t - note_length,\n            v_before_release\n        );\n    }\n}\n\nfloat custom_adsr_curve_1(float t)\n{\n    Adsr adsr;\n    adsr.delay = 0.02;      // start with 20 ms of delay\n    adsr.attack = .03;      // rise to full volume in 30 ms\n    adsr.attack_pow = 0.;   // rise to full volume linearly\n    adsr.hold = 0.05;       // stay at full volume for 50 ms\n    adsr.decay = .5;        // decay to 65% volume in 0.5 s\n    adsr.decay_pow = -.9;   // start decaying quickly and then slow down\n    adsr.sustain = .65;     // volume to decay to: 65%\n    adsr.release = .2;      // when the key is released, go to 0% in 200 ms\n    adsr.release_pow = -1.; // start going to 0% quickly and then slow down\n\n    return Adsr_eval(\n        adsr,\n        t,\n        1. // the key is released after 1 second\n    );\n}\n",
     "name": "Common",
     "description": "",
     "type": "common"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "const int KEY = 60;\n\nfloat inst_sine(float t, float freq)\n{\n    return sin(TAU * freq * t);\n}\n\nvec2 mainSound(int samp, float t)\n{\n    float v = .05 * inst_sine(note_to_freq(KEY), t + .1);\n    v += .05 * inst_sine(note_to_freq(KEY + 3), t + .2);\n    v += .05 * inst_sine(note_to_freq(KEY + 7), t + .3);\n    v += .05 * inst_sine(note_to_freq(KEY + 12), t + .4);\n    v += .05 * inst_sine(note_to_freq(KEY - 12), t + .5);\n    v += .05 * inst_sine(note_to_freq(KEY - 9), t + .6);\n    v += .05 * inst_sine(note_to_freq(KEY - 5), t + .7);\n    v += .01 * inst_sine(note_to_freq(KEY + 10), t + .8);\n    v += .01 * inst_sine(note_to_freq(KEY + 19), t + .7);\n    v += .005 * inst_sine(note_to_freq(KEY + 24), t + .7);\n    v *= 2.2;\n\n    // scale the volume with the ADSR curve\n    v *= custom_adsr_curve_1(mod(t, 1.8));\n    \n    return vec2(v);\n}\n",
     "name": "Sound",
     "description": "",
     "type": "sound"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "X3y3Rc",
    "date": "1717962362",
    "viewed": 108,
    "name": "Bean's Starting Point",
    "description": "Helper functions/structs/defines divided into sections.\nUse whichever section(s) you need:\n- math & integer utils\n- pseudo-random number generator\n- keyboard\n- flim\n",
    "likes": 0,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "utility",
     "functions",
     "helper"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "XsBSR3",
       "filepath": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png",
       "type": "texture",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// additional functions go here at the top\n// ...\n\nvec3 render(vec2 coord)\n{\n    vec2 uv = screen_to_uv_fit(coord, iResolution.xy);\n    return vec3(uv, 0);\n}\n\n// ASC CDL color grading\n// https://en.wikipedia.org/wiki/ASC_CDL\nvec3 asc_cdl(vec3 col, vec3 slope, vec3 offset, vec3 power)\n{\n    return pow(max(col, 0.) * slope + offset, power);\n}\n\nvec3 view_transform(vec3 col)\n{\n    // avoid any negative values before using power functions\n    col = max(col, 0.);\n\n    // color grading\n    col = asc_cdl(\n        col,\n        1.1 * vec3(1, .903, .94),\n        vec3(0, 0, .007),\n        1.05 * vec3(1, .95, 1)\n    );\n    \n    // flim\n    const float exposure = 0.;\n    col = flim_transform(col, exposure, false);\n\n    // OETF (Linear BT.709 I-D65 to sRGB 2.2)\n    col = pow(col, vec3(1. / 2.2));\n    col = clamp(col, 0., 1.);\n\n    return col;\n}\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    // render\n    // (you could implement supersampling here for example)\n    vec3 col = render(frag_coord);\n\n    // view transform\n    col = view_transform(col);\n\n    // blue noise dithering (iChannel0 contains BN texture)\n    float bn = texelFetch(\n        iChannel0,\n        ivec2(frag_coord) % textureSize(iChannel0, 0),\n        0\n    ).x * 2. - 1.;\n    col = clamp(col + bn / 254., 0., 1.);\n\n    // output\n    frag_col = vec4(col, 1);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "// this is used to indicate whether we're in the real Shadertoy\n// or the unofficial Shadertoy plugin for Visual Studio Code.\n// see https://marketplace.visualstudio.com/items?itemName=stevensona.shader-toy\n#define SHADERTOY 1\n\nprecision highp float;\nprecision highp int;\n\n\n\n/*___________ math & integer utils ____________*/\n\nconst float PI = 3.141592653589793238462643383;\nconst float TAU = 6.283185307179586476925286767;\nconst float PI_OVER_2 = 1.570796326794896619231321692;\nconst float INV_PI = .318309886183790671537767527;\nconst float INV_TAU = .159154943091895335768883763;\n\n#define FUNC_WRAP(T) \\\nT wrap(T v, float start, float end) \\\n{ \\\n    return start + mod(v - start, end - start); \\\n}\n\n#define FUNC_REMAP(T) \\\nT remap(T v, float inp_start, float inp_end, float out_start, float out_end) \\\n{ \\\n    return out_start \\\n        + ((out_end - out_start) / (inp_end - inp_start)) * (v - inp_start); \\\n}\n\n#define FUNC_REMAP_CLAMP(T) \\\nT remap_clamp( \\\n    T v, \\\n    float inp_start, \\\n    float inp_end, \\\n    float out_start, \\\n    float out_end \\\n) \\\n{ \\\n    T t = clamp((v - inp_start) / (inp_end - inp_start), 0., 1.); \\\n    return out_start + t * (out_end - out_start); \\\n}\n\n#define FUNC_REMAP01(T) \\\nT remap01(T v, float inp_start, float inp_end) \\\n{ \\\n    return clamp((v - inp_start) / (inp_end - inp_start), 0., 1.); \\\n}\n\n#define FUNC_LENGTH_SQ(T) \\\nfloat length_sq(T v) \\\n{ \\\n    return dot(v, v); \\\n}\n\n#define FUNC_DIST_SQ(T) \\\nfloat dist_sq(T a, T b) \\\n{ \\\n    a -= b; \\\n    return dot(a, a); \\\n}\n\nFUNC_WRAP(float)\nFUNC_WRAP(vec2)\nFUNC_WRAP(vec3)\nFUNC_WRAP(vec4)\n\nFUNC_REMAP(float)\nFUNC_REMAP(vec2)\nFUNC_REMAP(vec3)\nFUNC_REMAP(vec4)\n\nFUNC_REMAP_CLAMP(float)\nFUNC_REMAP_CLAMP(vec2)\nFUNC_REMAP_CLAMP(vec3)\nFUNC_REMAP_CLAMP(vec4)\n\nFUNC_REMAP01(float)\nFUNC_REMAP01(vec2)\nFUNC_REMAP01(vec3)\nFUNC_REMAP01(vec4)\n\nFUNC_LENGTH_SQ(vec2)\nFUNC_LENGTH_SQ(vec3)\nFUNC_LENGTH_SQ(vec4)\n\nFUNC_DIST_SQ(vec2)\nFUNC_DIST_SQ(vec3)\nFUNC_DIST_SQ(vec4)\n\nfloat chebyshev_dist(vec2 a, vec2 b)\n{\n    return max(abs(a.x - b.x), abs(a.y - b.y));\n}\n\nfloat chebyshev_dist(vec3 a, vec3 b)\n{\n    return max(\n        max(abs(a.x - b.x), abs(a.y - b.y)),\n        abs(a.z - b.z)\n    );\n}\n\nfloat chebyshev_dist(vec4 a, vec4 b)\n{\n    return max(\n        max(\n            max(abs(a.x - b.x), abs(a.y - b.y)),\n            abs(a.z - b.z)\n        ),\n        abs(a.w - b.w)\n    );\n}\n\n#define idiv_ceil(a, b) ((a + b - 1) / b)\n\nint iabs(int v)\n{\n    if (v < 0)\n    {\n        return -v;\n    }\n    return v;\n}\n\nint imin(int a, int b)\n{\n    if (a < b)\n    {\n        return a;\n    }\n    return b;\n}\n\nint imax(int a, int b)\n{\n    if (a > b)\n    {\n        return a;\n    }\n    return b;\n}\n\nint iclamp(int v, int start, int end)\n{\n    if (v < start)\n    {\n        v = start;\n    }\n    if (v > end)\n    {\n        v = end;\n    }\n    return v;\n}\n\nfloat min_component(vec2 v)\n{\n    return min(v.x, v.y);\n}\n\nfloat min_component(vec3 v)\n{\n    return min(min(v.x, v.y), v.z);\n}\n\nfloat min_component(vec4 v)\n{\n    return min(min(min(v.x, v.y), v.z), v.w);\n}\n\nfloat max_component(vec2 v)\n{\n    return max(v.x, v.y);\n}\n\nfloat max_component(vec3 v)\n{\n    return max(max(v.x, v.y), v.z);\n}\n\nfloat max_component(vec4 v)\n{\n    return max(max(max(v.x, v.y), v.z), v.w);\n}\n\nint min_component(ivec2 v)\n{\n    return imin(v.x, v.y);\n}\n\nint min_component(ivec3 v)\n{\n    return imin(imin(v.x, v.y), v.z);\n}\n\nint min_component(ivec4 v)\n{\n    return imin(imin(imin(v.x, v.y), v.z), v.w);\n}\n\nint max_component(ivec2 v)\n{\n    return imax(v.x, v.y);\n}\n\nint max_component(ivec3 v)\n{\n    return imax(imax(v.x, v.y), v.z);\n}\n\nint max_component(ivec4 v)\n{\n    return imax(imax(imax(v.x, v.y), v.z), v.w);\n}\n\nfloat bilinear(\n    float val_bl,\n    float val_tl,\n    float val_tr,\n    float val_br,\n    vec2 offs\n)\n{\n    return mix(\n        mix(val_bl, val_br, offs.x),\n        mix(val_tl, val_tr, offs.x),\n        offs.y\n    );\n}\n\n// credits to AHSEN (https://www.shadertoy.com/user/01000001)\n// https://www.desmos.com/calculator/5d6ph151vi interactive :D\nfloat cubic_interp(float a, float b, float c, float d, float t)\n{\n    float one = t - 1.;\n    float two = t - 2.;\n    float three = t - 3.;\n    return (\n        (-one * two * three * a)\n        + (t * one * two * d)\n        + (3. * t * two * three * b)\n        - (3. * t * one * three * c)\n    ) / 6.;\n}\n\nfloat dist_along_line(vec2 p, vec2 line_start, vec2 line_end)\n{\n    vec2 dir = line_end - line_start;\n    \n    // normalize\n    float len_sqr = dot(dir, dir);\n    if (len_sqr < .0001)\n        return 1e9;\n    dir /= sqrt(len_sqr);\n    \n    return dot(\n        dir,\n        p - line_start\n    );\n}\n\nfloat relative_dist_along_line(vec2 p, vec2 line_start, vec2 line_end)\n{\n    vec2 dir = line_end - line_start;\n    return dot(\n        dir,\n        p - line_start\n    );\n}\n\n// |a| * |b| * sin(theta)\nfloat cross2d(vec2 a, vec2 b)\n{\n    return a.x * b.y - a.y * b.x;\n}\n\n// references for barycentric coordinates\n// https://www.desmos.com/calculator/8g8xjejuox\n// https://www.shadertoy.com/view/mdjBWK\n\nvec3 cartesian_to_barycentric(\n    vec2 p,\n    vec2 v0,\n    vec2 v1,\n    vec2 v2,\n    bool clamp_,\n    out bool p_is_outside\n)\n{\n    vec3 b = vec3(\n        cross2d(v1 - p, v2 - p),\n        cross2d(v2 - p, v0 - p),\n        cross2d(v0 - p, v1 - p)\n    ) / cross2d(v1 - v0, v2 - v0);\n    p_is_outside = min(min(b.x, b.y), b.z) < 0.;\n    if (clamp_)\n    {\n        b = max(b, 0.);\n        b /= (b.x + b.y + b.z);\n    }\n    return b;\n}\n\nvec3 cartesian_to_barycentric(\n    vec3 p,\n    vec3 v0,\n    vec3 v1,\n    vec3 v2,\n    bool clamp_,\n    out bool p_is_outside\n)\n{\n    vec3 b = vec3(\n        length(cross(v1 - p, v2 - p)),\n        length(cross(v2 - p, v0 - p)),\n        length(cross(v0 - p, v1 - p))\n    ) / length(cross(v1 - v0, v2 - v0));\n    p_is_outside = min(min(b.x, b.y), b.z) < 0.;\n    if (clamp_)\n    {\n        b = max(b, 0.);\n        b /= (b.x + b.y + b.z);\n    }\n    return b;\n}\n\nfloat barycentric_interpolate(vec3 b, float v0, float v1, float v2)\n{\n    return dot(b, vec3(v0, v1, v2));\n}\n\nvec2 barycentric_interpolate(vec3 b, vec2 v0, vec2 v1, vec2 v2)\n{\n    return b.x * v0 + b.y * v1 + b.z * v2;\n}\n\nvec3 barycentric_interpolate(vec3 b, vec3 v0, vec3 v1, vec3 v2)\n{\n    return b.x * v0 + b.y * v1 + b.z * v2;\n}\n\nvec4 barycentric_interpolate(vec3 b, vec4 v0, vec4 v1, vec4 v2)\n{\n    return b.x * v0 + b.y * v1 + b.z * v2;\n}\n\nfloat barycentric_interpolate(vec2 b, float v0, float v1, float v2)\n{\n    return barycentric_interpolate(\n        vec3(b.x, b.y, 1. - b.x - b.y),\n        v0, v1, v2\n    );\n}\n\nvec2 barycentric_interpolate(vec2 b, vec2 v0, vec2 v1, vec2 v2)\n{\n    return barycentric_interpolate(\n        vec3(b.x, b.y, 1. - b.x - b.y),\n        v0, v1, v2\n    );\n}\n\nvec3 barycentric_interpolate(vec2 b, vec3 v0, vec3 v1, vec3 v2)\n{\n    return barycentric_interpolate(\n        vec3(b.x, b.y, 1. - b.x - b.y),\n        v0, v1, v2\n    );\n}\n\nvec4 barycentric_interpolate(vec2 b, vec4 v0, vec4 v1, vec4 v2)\n{\n    return barycentric_interpolate(\n        vec3(b.x, b.y, 1. - b.x - b.y),\n        v0, v1, v2\n    );\n}\n\n// angle from 0 to TAU\nfloat get_angle(vec2 p)\n{\n    float a = atan(p.y, p.x);\n    if (a < 0.)\n    {\n        return a + TAU;\n    }\n    return a;\n}\n\nmat2 rotate_2d(float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(\n        c, s,\n        -s, c\n    );\n}\n\nvec2 perpendicular(vec2 v)\n{\n    return vec2(-v.y, v.x);\n}\n\n// s.x=theta\n// s.y=phi\n// (there's no r)\nvec3 spherical_to_cartesian(vec2 s)\n{\n    float sin_theta = sin(s.x);\n    return vec3(\n        sin_theta * cos(s.y),\n        sin_theta * sin(s.y),\n        cos(s.x)\n    );\n}\n\n// s.x=r\n// s.y=theta\n// s.z=phi\nvec3 spherical_to_cartesian(vec3 s)\n{\n    float sin_theta = sin(s.y);\n    return s.x * vec3(\n        sin_theta * cos(s.z),\n        sin_theta * sin(s.z),\n        cos(s.y)\n    );\n}\n\nvec2 screen_to_uv01(vec2 coord, vec2 res)\n{\n    return coord / res;\n}\n\nvec2 screen_to_uv_horizontal(vec2 coord, vec2 res)\n{\n    return (2. * coord - res) / res.x;\n}\n\nvec2 screen_to_uv_vertical(vec2 coord, vec2 res)\n{\n    return (2. * coord - res) / res.y;\n}\n\nvec2 screen_to_uv_fit(vec2 coord, vec2 res)\n{\n    return (2. * coord - res) / min_component(res);\n}\n\nvec2 screen_to_uv_fill(vec2 coord, vec2 res)\n{\n    return (2. * coord - res) / max_component(res);\n}\n\n// * idx starts at 1\nfloat halton(int base, int idx)\n{\n    float result = 0.;\n    float digit_weight = 1.;\n    while (idx > 0)\n    {\n        digit_weight /= float(base);\n        result += float(idx % base) * digit_weight;\n        idx /= base;\n    }\n    return result;\n}\n\n// * idx starts at 1\nvec2 halton_2d(int idx)\n{\n    return vec2(halton(2, idx), halton(3, idx));\n}\n\n// * idx starts at 1\nvec3 halton_3d(int idx)\n{\n    return vec3(halton(2, idx), halton(3, idx), halton(5, idx));\n}\n\n// * idx starts at 1\nvec4 halton_4d(int idx)\n{\n    return vec4(\n        halton(2, idx),\n        halton(3, idx),\n        halton(5, idx),\n        halton(7, idx)\n    );\n}\n\n// for some reason we can't use intBitsToFloat() or floatBitsToInt() to store\n// integers below this value in a buffer.\nconst int BUFFER_MIN_INTEGER = 8388608;\n\n// * x must not be higher than 4,286,578,688 (see BUFFER_MIN_INTEGER above)\n// * for your sanity, don't use negative values\nfloat encode_int_for_buffer(int v)\n{\n    return intBitsToFloat(v + BUFFER_MIN_INTEGER);\n}\n\nint decode_int_from_buffer(float v)\n{\n    return floatBitsToInt(v) - BUFFER_MIN_INTEGER;\n}\n\n// pack two 16-bit integers in a single 32-bit integer\n// * both arguments should be in the 0-65535 range\n// * a must be less than 65279 (see the functions above)\nint pack_i16(int a, int b)\n{\n    return (a << 16) | b;\n}\n\n// unpack two 16-bit integers from a single 32-bit integer\nvoid unpack_i16(int v, out int a, out int b)\n{\n    a = (v >> 16) & 65535;\n    b = v & 65535;\n}\n\n// unpack the first 16-bit integer from a 32-bit integer\nint unpack_i16_a(int v)\n{\n    return (v >> 16) & 65535;\n}\n\n// unpack the second 16-bit integer from a 32-bit integer\nint unpack_i16_b(int v)\n{\n    return v & 65535;\n}\n\nbool icoord_in_bounds(ivec2 icoord, ivec2 ires)\n{\n    return\n        icoord.x >= 0 &&\n        icoord.y >= 0 &&\n        icoord.x < ires.x &&\n        icoord.y < ires.y;\n}\n\nbool icoord_in_bounds(ivec3 icoord, ivec3 ires)\n{\n    return\n        icoord.x >= 0 &&\n        icoord.y >= 0 &&\n        icoord.z >= 0 &&\n        icoord.x < ires.x &&\n        icoord.y < ires.y &&\n        icoord.z < ires.z;\n}\n\nint icoord_to_idx(ivec2 icoord, ivec2 ires)\n{\n    return icoord.x + (icoord.y * ires.x);\n}\n\nint icoord_to_idx(ivec3 icoord, ivec3 ires)\n{\n    return icoord.x + (icoord.y * ires.x) + (icoord.z * ires.x * ires.y);\n}\n\nivec2 idx_to_icoord(int idx, ivec2 ires)\n{\n    return ivec2(idx % ires.x, idx / ires.x);\n}\n\nivec3 idx_to_icoord(int idx, ivec3 ires)\n{\n    return ivec3(\n        idx % ires.x,\n        (idx % (ires.x * ires.y)) / ires.x,\n        idx / (ires.x * ires.y)\n    );\n}\n\n// https://www.desmos.com/calculator/kfe07basy9\n\nint compress_float_to_int_linear(float f, float min_f, float max_f, int max_i)\n{\n    return int(floor(\n        float(max_i) * remap01(f, min_f, max_f)\n    ));\n}\n\nfloat decompress_float_from_int_linear(\n    int i,\n    int max_i,\n    float min_f,\n    float max_f\n)\n{\n    return remap_clamp(\n        float(i) / float(max_i),\n        0., 1.,\n        min_f, max_f\n    );\n}\n\nint compress_float_to_int_log(\n    float f,\n    float log2_zero_offset,\n    float max_log2_f,\n    int max_i\n)\n{\n    f = max(0., f);\n    f += pow(2., log2_zero_offset);\n    return int(floor(\n        float(max_i) * remap01(log2(f), log2_zero_offset, max_log2_f)\n    ));\n}\n\nfloat decompress_float_from_int_log(\n    int i,\n    int max_i,\n    float log2_zero_offset,\n    float max_log2_f\n)\n{\n    return pow(2., remap_clamp(\n        float(i) / float(max_i),\n        0., 1.,\n        log2_zero_offset, max_log2_f\n    )) - pow(2., log2_zero_offset);\n}\n\n\n\n/*__________ hash function collection _________*/\n// sources: https://nullprogram.com/blog/2018/07/31/\n//          https://www.shadertoy.com/view/WttXWX\n\nuint triple32(uint x)\n{\n    x ^= x >> 17;\n    x *= 0xed5ad4bbU;\n    x ^= x >> 11;\n    x *= 0xac4c1b51U;\n    x ^= x >> 15;\n    x *= 0x31848babU;\n    x ^= x >> 14;\n    return x;\n}\n\n// uint -> uint\n\nuint hash(uint v)\n{\n    return triple32(v);\n}\n\nuint hash(uvec2 v)\n{\n    return triple32(v.x + triple32(v.y));\n}\n\nuint hash(uvec3 v)\n{\n    return triple32(v.x + triple32(v.y + triple32(v.z)));\n}\n\nuint hash(uvec4 v)\n{\n    return triple32(v.x + triple32(v.y + triple32(v.z + triple32(v.w))));\n}\n\n// int -> uint\n\nuint hash(int v)\n{\n    return triple32(uint(v));\n}\n\nuint hash(ivec2 v)\n{\n    return triple32(uint(v.x) + triple32(uint(v.y)));\n}\n\nuint hash(ivec3 v)\n{\n    return triple32(uint(v.x) + triple32(uint(v.y) + triple32(uint(v.z))));\n}\n\nuint hash(ivec4 v)\n{\n    return triple32(uint(v.x) + triple32(uint(v.y) + triple32(uint(v.z) + triple32(uint(v.w)))));\n}\n\n// float -> uint\n\nuint hash(float v)\n{\n    return triple32(floatBitsToUint(v));\n}\n\nuint hash(vec2 v)\n{\n    return triple32(floatBitsToUint(v.x) + triple32(floatBitsToUint(v.y)));\n}\n\nuint hash(vec3 v)\n{\n    return triple32(floatBitsToUint(v.x) + triple32(floatBitsToUint(v.y) + triple32(floatBitsToUint(v.z))));\n}\n\nuint hash(vec4 v)\n{\n    return triple32(floatBitsToUint(v.x) + triple32(floatBitsToUint(v.y) + triple32(floatBitsToUint(v.z) + triple32(floatBitsToUint(v.w)))));\n}\n\n// any -> int\n#define hashi(v) int(hash(v));\n\n// any -> float\n#define hashf(v) (float(hash(v)) / 4294967295.);\n\n\n\n/*_______ pseudo-random number generator ______*/\n// source: https://www.shadertoy.com/view/WdSSRt\n// (heavily modified)\n\n/* usage example:\n    void mainImage(out vec4 frag_col, in vec2 frag_coord)\n    {\n        // initialize PRNG\n        prng_init(vec3(frag_coord / iResolution.y, iTime));\n    \n        // use the function\n        float a = random();\n        vec3 b = vec3(random(), random(), random());\n        \n        ...\n    }\n*/\n\nuint prng_state[2];\n\nuint prng_rot(uint x, int k)\n{\n    return (x << k) | (x >> (32 - k));\n}\n\n// random uint from 0 to 2^32-1\nuint randomui()\n{\n    uint s0 = prng_state[0];\n    uint s1 = prng_state[1];\n    uint result = prng_rot(s0 * 2654435771u, 5) * 5u;\n    s1 ^= s0;\n    prng_state[0] = prng_rot(s0, 26) ^ s1 ^ (s1 << 9);\n    prng_state[1] = prng_rot(s1, 13);\n    return result;\n}\n\n// random int from 0 to 2^31-1\nint randomi()\n{\n    return int(randomui() % 0x7FFFFFFFu);\n}\n\n// random float from 0 to 1\nfloat random()\n{\n    return float(randomui()) / float(0xffffffffu);\n}\n\n// generate two normally distributed random numbers using the\n// Box-Muller transform\n// https://www.baeldung.com/cs/uniform-to-normal-distribution\nvec2 random_gauss()\n{\n    float u1 = random();\n    float u2 = random() * TAU;\n    float temp = sqrt(-2. * log(u1));\n    return temp * vec2(cos(u2), sin(u2));\n    \n    // unoptimized version\n    //float u1 = random();\n    //float u2 = random();\n    //return vec2(cos(TAU * u2), sin(TAU * u2)) * sqrt(-2. * log(u1));\n}\n\nvec2 random_on_circle()\n{\n    vec2 v = vec2(1);\n    float lensqr;\n\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec2(2. * random() - 1., 2. * random() - 1.);\n        lensqr = dot(v, v);\n        if (lensqr == 0.)\n            i--;\n        else if (lensqr <= 1.)\n            break;\n    }\n    return v / sqrt(lensqr);\n}\n\nvec3 random_on_sphere()\n{\n    vec3 v = vec3(1);\n    float lensqr;\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec3(2. * random() - 1., 2. * random() - 1., 2. * random() - 1.);\n        lensqr = dot(v, v);\n        if (lensqr == 0.)\n            i--;\n        else if (lensqr <= 1.)\n            break;\n    }\n    return v / sqrt(lensqr);\n}\n\nvec2 random_in_circle()\n{\n    vec2 v = vec2(1);\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec2(2. * random() - 1., 2. * random() - 1.);\n        if (dot(v, v) <= 1.)\n            return v;\n    }\n    return v;\n}\n\nvec3 random_in_sphere()\n{\n    vec3 v = vec3(1);\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec3(2. * random() - 1., 2. * random() - 1., 2. * random() - 1.);\n        if (dot(v, v) <= 1.)\n            return v;\n    }\n    return v;\n}\n\nvec3 random_on_hemisphere(vec3 normal)\n{\n    vec3 v = random_on_sphere();\n    return v * sign(dot(v, normal));\n}\n\nvec3 random_in_hemisphere(vec3 normal)\n{\n    vec3 v = random_in_sphere();\n    return v * sign(dot(v, normal));\n}\n\n// initialize with uvec2\nvoid prng_init(uvec2 seed)\n{\n    seed += uvec2(1317, 944573125);\n    seed *= 464973573u;\n    prng_state[0] = seed.x;\n    prng_state[1] = seed.y;\n    randomi();\n}\n\n// initialize with uint\nvoid prng_init(uint seed)\n{\n    prng_init(uvec2(seed, 1));\n}\n\n// initialize with vec3\nvoid prng_init(vec3 seed)\n{\n    seed += 3.49276101561702;\n    seed.xy *= (seed.z + 10.258);\n    prng_state[0] = floatBitsToUint(seed.x);\n    prng_state[1] = floatBitsToUint(seed.y);\n    randomui();\n}\n\n// initialize with vec2\nvoid prng_init(vec2 seed)\n{\n    prng_init(vec3(seed, 1));\n}\n\n// initialize with float\nvoid prng_init(float seed)\n{\n    prng_init(vec3(seed, 1, 1));\n}\n\n\n\n/*__________________ keyboard _________________*/\n\n// put this code in every buffer that uses the keyboard input:\n/*\n#if SHADERTOY\n// iChannelX must be set to Keyboard in Shadertoy\n#define SHADERTOY_KEYBOARD_CH iChannelX\n#else\n#iKeyboard\n#endif\n\nDEFINE_KEYBOARD_UTILS\n*/\n\n#if SHADERTOY\n\n#define DEFINE_KEYBOARD_UTILS \\\n \\\n/* https://github.com/stevensona/shader-toy/blob/c4833b972649d78a2ee090af60b79a3907e8e091/src/extensions/keyboard/keyboard_shader_extension.ts#L11 */ \\\nconst int \\\n    Key_Backspace = 8, Key_Tab = 9, Key_Enter = 13, Key_Shift = 16, \\\n    Key_Ctrl = 17, Key_Alt = 18, Key_Pause = 19, Key_Caps = 20, \\\n    Key_Escape = 27, Key_PageUp = 33, Key_PageDown = 34, Key_End = 35, \\\n    Key_Home = 36, Key_LeftArrow = 37, Key_UpArrow = 38, Key_RightArrow = 39, \\\n    Key_DownArrow = 40, Key_Insert = 45, Key_Delete = 46, Key_0 = 48, \\\n    Key_1 = 49, Key_2 = 50, Key_3 = 51, Key_4 = 52, Key_5 = 53, Key_6 = 54, \\\n    Key_7 = 55, Key_8 = 56, Key_9 = 57, Key_A = 65, Key_B = 66, Key_C = 67, \\\n    Key_D = 68, Key_E = 69, Key_F = 70, Key_G = 71, Key_H = 72, \\\n    Key_I = 73, Key_J = 74, Key_K = 75, Key_L = 76, Key_M = 77, Key_N = 78, \\\n    Key_O = 79, Key_P = 80, Key_Q = 81, Key_R = 82, Key_S = 83, Key_T = 84, \\\n    Key_U = 85, Key_V = 86, Key_W = 87, Key_X = 88, Key_Y = 89, Key_Z = 90, \\\n    Key_LeftWindow = 91, Key_RightWindows = 92, Key_Select = 93, \\\n    Key_Numpad0 = 96, Key_Numpad1 = 97, Key_Numpad2 = 98, Key_Numpad3 = 99, \\\n    Key_Numpad4 = 100, Key_Numpad5 = 101, Key_Numpad6 = 102, \\\n    Key_Numpad7 = 103, Key_Numpad8 = 104, Key_Numpad9 = 105, \\\n    Key_NumpadMultiply = 106, Key_NumpadAdd = 107, Key_NumpadSubtract = 109, \\\n    Key_NumpadPeriod = 110, Key_NumpadDivide = 111, Key_F1 = 112, \\\n    Key_F2 = 113, Key_F3 = 114, Key_F4 = 115, Key_F5 = 116, Key_F6 = 117, \\\n    Key_F7 = 118, Key_F8 = 119, Key_F9 = 120, Key_F10 = 121, Key_F11 = 122, \\\n    Key_F12 = 123, Key_NumLock = 144, Key_ScrollLock = 145, \\\n    Key_SemiColon = 186, Key_Equal = 187, Key_Comma = 188, Key_Dash = 189, \\\n    Key_Period = 190, Key_ForwardSlash = 191, Key_GraveAccent = 192, \\\n    Key_OpenBracket = 219, Key_BackSlash = 220, Key_CloseBraket = 221, \\\n    Key_SingleQuote = 222; \\\nconst int Key_Space = 32; \\\n \\\nbool is_key_pressed(int key) \\\n{ \\\n    return texelFetch(SHADERTOY_KEYBOARD_CH, ivec2(key, 1), 0).x > .5; \\\n} \\\n \\\nbool is_key_down(int key) \\\n{ \\\n    return texelFetch(SHADERTOY_KEYBOARD_CH, ivec2(key, 0), 0).x > .5; \\\n} \\\n \\\nbool is_key_toggled(int key) \\\n{ \\\n    return texelFetch(SHADERTOY_KEYBOARD_CH, ivec2(key, 2), 0).x > .5; \\\n}\n\n#else\n\n#define define_keyboard_utils \\\n \\\nconst int Key_Space = 32; \\\n \\\nbool is_key_pressed(int key) \\\n{ \\\n    return isKeyPressed(key); \\\n} \\\n \\\nbool is_key_down(int key) \\\n{ \\\n    return isKeyDown(key); \\\n} \\\n \\\nbool is_key_toggled(int key) \\\n{ \\\n    return isKeyToggled(key); \\\n}\n\n#endif\n\n\n\n/*-----------------------------------------------\n\nflim - Filmic Color Transform\n\nInput Color Space:   Linear BT.709 I-D65\nOutput Color Space:  Linear BT.709 I-D65 / sRGB 2.2 (depends on arguments)\n\nDescription:\n  Experimental port of flim for GLSL/Shadertoy\n  matching flim v1.1.0.\n\nAuthor:\n  Bean (beans_please on Shadertoy)\n\nOriginal Repo:\n  https://github.com/bean-mhm/flim\n\nOriginal Shader:\n  https://www.shadertoy.com/view/dd2yDz\n\n-----------------------------------------------*/\n\n// parameters\n\nconst float flim_pre_exposure = 4.3;\nconst vec3 flim_pre_formation_filter = vec3(1.);\nconst float flim_pre_formation_filter_strength = 0.;\n\nconst float flim_extended_gamut_red_scale = 1.05;\nconst float flim_extended_gamut_green_scale = 1.12;\nconst float flim_extended_gamut_blue_scale = 1.045;\nconst float flim_extended_gamut_red_rot = .5;\nconst float flim_extended_gamut_green_rot = 2.;\nconst float flim_extended_gamut_blue_rot = .1;\nconst float flim_extended_gamut_red_mul = 1.;\nconst float flim_extended_gamut_green_mul = 1.;\nconst float flim_extended_gamut_blue_mul = 1.;\n\nconst float flim_sigmoid_log2_min = -10.;\nconst float flim_sigmoid_log2_max = 22.;\nconst float flim_sigmoid_toe_x = .44;\nconst float flim_sigmoid_toe_y = .28;\nconst float flim_sigmoid_shoulder_x = .591;\nconst float flim_sigmoid_shoulder_y = .779;\n\nconst float flim_negative_film_exposure = 6.;\nconst float flim_negative_film_density = 5.;\n\nconst vec3 flim_print_backlight = vec3(1);\nconst float flim_print_film_exposure = 6.;\nconst float flim_print_film_density = 27.5;\n\nconst float flim_black_point = -1.; // -1 = auto\nconst vec3 flim_post_formation_filter = vec3(1);\nconst float flim_post_formation_filter_strength = 0.;\nconst float flim_midtone_saturation = 1.02;\n\n// color space conversions\n// the matrices below represent data in row-major, but GLSL matrices are in\n// column-major, so we need to multiply a vec3 by a matrix rather than\n// multiplying a matrix by a vec3.\n\nconst mat3 mat_bt2020_to_xyz = mat3(\n     0.6369580483,  0.1446169036,  0.1688809752,\n     0.2627002120,  0.6779980715,  0.0593017165,\n     0.0000000000,  0.0280726930,  1.0609850577\n);\n\nconst mat3 mat_xyz_to_bt2020 = mat3(\n     1.7166511880, -0.3556707838, -0.2533662814,\n    -0.6666843518,  1.6164812366,  0.0157685458,\n     0.0176398574, -0.0427706133,  0.9421031212\n);\n\nconst mat3 mat_bt709_to_xyz = mat3(\n     0.4123907993,  0.3575843394,  0.1804807884,\n     0.2126390059,  0.7151686788,  0.0721923154,\n     0.0193308187,  0.1191947798,  0.9505321522\n);\n\nconst mat3 mat_xyz_to_bt709 = mat3(\n     3.2409699419, -1.5373831776, -0.4986107603,\n    -0.9692436363,  1.8759675015,  0.0415550574,\n     0.0556300797, -0.2039769589,  1.0569715142\n);\n\nconst mat3 mat_dcip3_to_xyz = mat3(\n     0.4451698156,  0.2771344092,  0.1722826698,\n     0.2094916779,  0.7215952542,  0.0689130679,\n     0.0000000000,  0.0470605601,  0.9073553944\n);\n\nconst mat3 mat_xyz_to_dcip3 = mat3(\n     2.7253940305, -1.0180030062, -0.4401631952,\n    -0.7951680258,  1.6897320548,  0.0226471906,\n     0.0412418914, -0.0876390192,  1.1009293786\n);\n\nvec3 oetf_pow(vec3 col, float power)\n{\n    return pow(col, vec3(1. / power));\n}\n\nvec3 eotf_pow(vec3 col, float power)\n{\n    return pow(col, vec3(power));\n}\n\n// flim's utility functions\n\nfloat flim_wrap(float v, float start, float end)\n{\n    return start + mod(v - start, end - start);\n}\n\nfloat flim_remap(\n    float v,\n    float inp_start,\n    float inp_end,\n    float out_start,\n    float out_end\n)\n{\n    return out_start\n        + ((out_end - out_start) / (inp_end - inp_start)) * (v - inp_start);\n}\n\nfloat flim_remap_clamp(\n    float v,\n    float inp_start,\n    float inp_end,\n    float out_start,\n    float out_end\n)\n{\n    float t = clamp((v - inp_start) / (inp_end - inp_start), 0., 1.);\n    return out_start + t * (out_end - out_start);\n}\n\nfloat flim_remap01(\n    float v,\n    float inp_start,\n    float inp_end\n)\n{\n    return clamp((v - inp_start) / (inp_end - inp_start), 0., 1.);\n}\n\nvec3 flim_blender_rgb_to_hsv(vec3 rgb)\n{\n    float cmax, cmin, h, s, v, cdelta;\n    vec3 c;\n\n    cmax = max(rgb[0], max(rgb[1], rgb[2]));\n    cmin = min(rgb[0], min(rgb[1], rgb[2]));\n    cdelta = cmax - cmin;\n\n    v = cmax;\n    if (cmax != 0.)\n    {\n        s = cdelta / cmax;\n    }\n    else\n    {\n        s = 0.;\n        h = 0.;\n    }\n\n    if (s == 0.)\n    {\n        h = 0.;\n    }\n    else\n    {\n        c = (vec3(cmax) - rgb.xyz) / cdelta;\n\n        if (rgb.x == cmax)\n        {\n            h = c[2] - c[1];\n        }\n        else if (rgb.y == cmax)\n        {\n            h = 2. + c[0] - c[2];\n        }\n        else\n        {\n            h = 4. + c[1] - c[0];\n        }\n\n        h /= 6.;\n\n        if (h < 0.)\n        {\n            h += 1.;\n        }\n    }\n\n    return vec3(h, s, v);\n}\n\nvec3 flim_blender_hsv_to_rgb(vec3 hsv)\n{\n    float f, p, q, t, h, s, v;\n    vec3 rgb;\n\n    h = hsv[0];\n    s = hsv[1];\n    v = hsv[2];\n\n    if (s == 0.)\n    {\n        rgb = vec3(v, v, v);\n    }\n    else\n    {\n        if (h == 1.)\n        {\n            h = 0.;\n        }\n\n        h *= 6.;\n        int i = int(floor(h));\n        f = h - float(i);\n        rgb = vec3(f, f, f);\n        p = v * (1. - s);\n        q = v * (1. - (s * f));\n        t = v * (1. - (s * (1. - f)));\n\n        if (i == 0)\n        {\n            rgb = vec3(v, t, p);\n        }\n        else if (i == 1)\n        {\n            rgb = vec3(q, v, p);\n        }\n        else if (i == 2)\n        {\n            rgb = vec3(p, v, t);\n        }\n        else if (i == 3)\n        {\n            rgb = vec3(p, q, v);\n        }\n        else if (i == 4)\n        {\n            rgb = vec3(t, p, v);\n        }\n        else\n        {\n            rgb = vec3(v, p, q);\n        }\n    }\n\n    return rgb;\n}\n\nvec3 flim_blender_hue_sat(vec3 col, float hue, float sat, float value)\n{\n    vec3 hsv = flim_blender_rgb_to_hsv(col);\n\n    hsv[0] = fract(hsv[0] + hue + .5);\n    hsv[1] = clamp(hsv[1] * sat, 0., 1.);\n    hsv[2] = hsv[2] * value;\n\n    return flim_blender_hsv_to_rgb(hsv);\n}\n\nfloat flim_rgb_avg(vec3 col)\n{\n    return (col.x + col.y + col.z) / 3.;\n}\n\nfloat flim_rgb_sum(vec3 col)\n{\n    return col.x + col.y + col.z;\n}\n\nfloat flim_rgb_max(vec3 col)\n{\n    return max(max(col.x, col.y), col.z);\n}\n\nfloat flim_rgb_min(vec3 col)\n{\n    return min(min(col.x, col.y), col.z);\n}\n\nvec3 flim_rgb_uniform_offset(vec3 col, float black_point, float white_point)\n{\n    float mono = flim_rgb_avg(col);\n    float mono2 = flim_remap01(\n        mono, black_point / 1000.,\n        1. - (white_point / 1000.)\n    );\n    return col * (mono2 / mono);\n}\n\nvec3 flim_rgb_sweep(float hue)\n{\n    hue = flim_wrap(hue * 360., 0., 360.);\n\n    vec3 col = vec3(1, 0, 0);\n    col = mix(col, vec3(1, 1, 0), flim_remap01(hue, 0., 60.));\n    col = mix(col, vec3(0, 1, 0), flim_remap01(hue, 60., 120.));\n    col = mix(col, vec3(0, 1, 1), flim_remap01(hue, 120., 180.));\n    col = mix(col, vec3(0, 0, 1), flim_remap01(hue, 180., 240.));\n    col = mix(col, vec3(1, 0, 1), flim_remap01(hue, 240., 300.));\n    col = mix(col, vec3(1, 0, 0), flim_remap01(hue, 300., 360.));\n    \n    return col;\n}\n\nvec3 flim_rgb_exposure_sweep_test(vec2 uv0to1)\n{\n    float hue = 1. - uv0to1.y;\n    float exposure = flim_remap(uv0to1.x, 0., 1., -5., 10.);\n    return flim_rgb_sweep(hue) * pow(2., exposure);\n}\n\n// https://www.desmos.com/calculator/khkztixyeu\nfloat flim_super_sigmoid(\n    float v,\n    float toe_x,\n    float toe_y,\n    float shoulder_x,\n    float shoulder_y\n)\n{\n    // clip\n    v = clamp(v, 0., 1.);\n    toe_x = clamp(toe_x, 0., 1.);\n    toe_y = clamp(toe_y, 0., 1.);\n    shoulder_x = clamp(shoulder_x, 0., 1.);\n    shoulder_y = clamp(shoulder_y, 0., 1.);\n\n    // calculate straight line slope\n    float slope = (shoulder_y - toe_y) / (shoulder_x - toe_x);\n\n    // toe\n    if (v < toe_x)\n    {\n        float toe_pow = slope * toe_x / toe_y;\n        return toe_y * pow(v / toe_x, toe_pow);\n    }\n\n    // straight line\n    if (v < shoulder_x)\n    {\n        float intercept = toe_y - (slope * toe_x);\n        return slope * v + intercept;\n    }\n\n    // shoulder\n    float shoulder_pow =\n        -slope / (\n            ((shoulder_x - 1.) / pow(1. - shoulder_x, 2.))\n            * (1. - shoulder_y)\n        );\n    return\n        (1. - pow(1. - (v - shoulder_x) / (1. - shoulder_x), shoulder_pow))\n        * (1. - shoulder_y)\n        + shoulder_y;\n}\n\nfloat flim_dye_mix_factor(float mono, float max_density)\n{\n    // log2 and map range\n    float offset = pow(2., flim_sigmoid_log2_min);\n    float fac = flim_remap01(\n        log2(mono + offset),\n        flim_sigmoid_log2_min,\n        flim_sigmoid_log2_max\n    );\n\n    // calculate amount of exposure from 0 to 1\n    fac = flim_super_sigmoid(\n        fac,\n        flim_sigmoid_toe_x,\n        flim_sigmoid_toe_y,\n        flim_sigmoid_shoulder_x,\n        flim_sigmoid_shoulder_y\n    );\n\n    // calculate dye density\n    fac *= max_density;\n\n    // mix factor\n    fac = pow(2., -fac);\n\n    // clip and return\n    return clamp(fac, 0., 1.);\n}\n\nvec3 flim_rgb_color_layer(\n    vec3 col,\n    vec3 sensitivity_tone,\n    vec3 dye_tone,\n    float max_density\n)\n{\n    // normalize\n    vec3 sensitivity_tone_norm =\n        sensitivity_tone / flim_rgb_sum(sensitivity_tone);\n    vec3 dye_tone_norm = dye_tone / flim_rgb_max(dye_tone);\n\n    // dye mix factor\n    float mono = dot(col, sensitivity_tone_norm);\n    float mix_fac = flim_dye_mix_factor(mono, max_density);\n\n    // dye mixing\n    return mix(dye_tone_norm, vec3(1), mix_fac);\n}\n\nvec3 flim_rgb_develop(vec3 col, float exposure, float max_density)\n{\n    // exposure\n    col *= pow(2., exposure);\n\n    // blue-sensitive layer\n    vec3 result = flim_rgb_color_layer(\n        col,\n        vec3(0, 0, 1),\n        vec3(1, 1, 0),\n        max_density\n    );\n\n    // green-sensitive layer\n    result *= flim_rgb_color_layer(\n        col,\n        vec3(0, 1, 0),\n        vec3(1, 0, 1),\n        max_density\n    );\n\n    // red-sensitive layer\n    result *= flim_rgb_color_layer(\n        col,\n        vec3(1, 0, 0),\n        vec3(0, 1, 1),\n        max_density\n    );\n\n    return result;\n}\n\nvec3 flim_gamut_extension_mat_row(\n    float primary_hue,\n    float scale,\n    float rotate,\n    float mul\n)\n{\n    vec3 result = flim_blender_hsv_to_rgb(vec3(\n        flim_wrap(primary_hue + (rotate / 360.), 0., 1.),\n        1. / scale,\n        1.\n    ));\n    result /= flim_rgb_sum(result);\n    result *= mul;\n    return result;\n}\n\nmat3 flim_gamut_extension_mat(\n    float red_scale,\n    float green_scale,\n    float blue_scale,\n    float red_rot,\n    float green_rot,\n    float blue_rot,\n    float red_mul,\n    float green_mul,\n    float blue_mul\n)\n{\n    mat3 m;\n    m[0] = flim_gamut_extension_mat_row(\n        0.,\n        red_scale,\n        red_rot,\n        red_mul\n    );\n    m[1] = flim_gamut_extension_mat_row(\n        1. / 3.,\n        green_scale,\n        green_rot,\n        green_mul\n    );\n    m[2] = flim_gamut_extension_mat_row(\n        2. / 3.,\n        blue_scale,\n        blue_rot,\n        blue_mul\n    );\n    return m;\n}\n\nvec3 negative_and_print(vec3 col, vec3 backlight_ext)\n{\n    // develop negative\n    col = flim_rgb_develop(\n        col,\n        flim_negative_film_exposure,\n        flim_negative_film_density\n    );\n\n    // backlight\n    col *= backlight_ext;\n\n    // develop print\n    col = flim_rgb_develop(\n        col,\n        flim_print_film_exposure,\n        flim_print_film_density\n    );\n\n    return col;\n}\n\n// the flim transform\n\nvec3 flim_transform(vec3 col, float exposure, bool convert_to_srgb)\n{\n    // eliminate negative values\n    col = max(col, 0.);\n\n    // pre-Exposure\n    col *= pow(2., flim_pre_exposure + exposure);\n\n    // clip very large values for float precision issues\n    col = min(col, 5000.);\n\n    // gamut extension matrix (Linear BT.709)\n    mat3 extend_mat = flim_gamut_extension_mat(\n        flim_extended_gamut_red_scale,\n        flim_extended_gamut_green_scale,\n        flim_extended_gamut_blue_scale,\n        flim_extended_gamut_red_rot,\n        flim_extended_gamut_green_rot,\n        flim_extended_gamut_blue_rot,\n        flim_extended_gamut_red_mul,\n        flim_extended_gamut_green_mul,\n        flim_extended_gamut_blue_mul\n    );\n    mat3 extend_mat_inv = inverse(extend_mat);\n\n    // backlight in the extended gamut\n    vec3 backlight_ext = flim_print_backlight * extend_mat;\n\n    // upper limit in the print (highlight cap)\n    const float big = 10000000.;\n    vec3 white_cap = negative_and_print(vec3(big, big, big), backlight_ext);\n\n    // pre-formation filter\n    col = mix(\n        col,\n        col * flim_pre_formation_filter,\n        flim_pre_formation_filter_strength\n    );\n\n    // convert to the extended gamut\n    col *= extend_mat;\n\n    // negative & print\n    col = negative_and_print(col, backlight_ext);\n\n    // convert from the extended gamut\n    col *= extend_mat_inv;\n\n    // eliminate negative values\n    col = max(col, 0.);\n\n    // white cap\n    col /= white_cap;\n\n    // black cap (-1 = auto)\n    if (flim_black_point == -1.)\n    {\n        vec3 black_cap = negative_and_print(vec3(0.), backlight_ext);\n        black_cap /= white_cap;\n        col = flim_rgb_uniform_offset(\n            col,\n            flim_rgb_avg(black_cap) * 1000.,\n            0.\n        );\n    }\n    else\n    {\n        col = flim_rgb_uniform_offset(col, flim_black_point, 0.);\n    }\n\n    // post-formation filter\n    col = mix(\n        col,\n        col * flim_post_formation_filter,\n        flim_post_formation_filter_strength\n    );\n\n    // clip\n    col = clamp(col, 0., 1.);\n\n    // midtone saturation\n    float mono = flim_rgb_avg(col);\n    float mix_fac =\n        (mono < .5)\n        ? flim_remap01(mono, .05, .5)\n        : flim_remap01(mono, .95, .5);\n    col = mix(\n        col,\n        flim_blender_hue_sat(col, .5, flim_midtone_saturation, 1.),\n        mix_fac\n    );\n\n    // clip\n    col = clamp(col, 0., 1.);\n\n    // OETF\n    if (convert_to_srgb)\n    {\n        col = oetf_pow(col, 2.2);\n    }\n\n    return col;\n}\n\n/*____________________ end ____________________*/\n",
     "name": "Common",
     "description": "",
     "type": "common"
    },
    {
     "inputs": [
      {
       "id": "4dXGRr",
       "filepath": "/presets/tex00.jpg",
       "type": "keyboard",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "// example buffer that uses the keyboard utils\n\n#if SHADERTOY\n// iChannel0 must be set to Keyboard in Shadertoy\n#define SHADERTOY_KEYBOARD_CH iChannel0\n#else\n#iKeyboard\n#endif\n\nDEFINE_KEYBOARD_UTILS\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    frag_col = vec4(0, 0, 1, 1);\n    \n    if (is_key_down(Key_Space))\n    {\n        frag_col = vec4(0, 1, 0, 1);\n    }\n}\n",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "M3tXWn",
    "date": "1718891537",
    "viewed": 691,
    "name": "Digital Logic Simulation",
    "description": "[url=https://www.shadertoy.com/view/X33XDN]UPDATE: NEW VERSION[/url]\nSee the first comment for tutorial and description.\n",
    "likes": 49,
    "published": "Public API",
    "usePreview": 1,
    "tags": [
     "2d",
     "binary",
     "simulation",
     "digital",
     "wires",
     "physics",
     "chip",
     "logic",
     "turing",
     "sim",
     "wire",
     "gates",
     "complete",
     "dls",
     "voltage",
     "computers"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4sXGR8",
       "filepath": "/media/previz/buffer02.png",
       "type": "buffer",
       "channel": 2,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// the image tab finally takes the wire state info from the\n// simulation buffer and displays them with different colors.\n// it also shows a panel at the top left showing the available\n// draw modes with their icons, and highlighting the selected\n// one. it also shows a circle outline around the cursor when\n// the mouse button is down and draw mode is set to erase.\n// it iterates through the gate buffer and renders the logic\n// gates.\n\n#define ICHANNEL_SIM_BUF iChannel0\n#define ICHANNEL_GATE_BUF iChannel1\n#define ICHANNEL_DATA_BUF iChannel2\n\nvoid dls_fetch(\n    ivec2 icoord,\n    out int wire_state,\n    out int last_updated\n)\n{\n    if (!icoord_in_bounds(\n        icoord,\n        ivec2(iResolution.xy)\n    ))\n    {\n        wire_state = WIRE_STATE_NOT_WIRE;\n        last_updated = -1;\n        return;\n    }\n    \n    vec4 data = texelFetch(ICHANNEL_SIM_BUF, icoord, 0);\n    dls_decode(data, wire_state, last_updated);\n}\n\nvoid gate_fetch(\n    int idx,\n    out int gate_type,\n    out ivec2 icoord_bl\n)\n{\n    if (idx < 0 || idx >= N_GATES)\n    {\n        gate_type = GATE_TYPE_NONE;\n        icoord_bl = ivec2(0);\n        return;\n    }\n    \n    ivec2 icoord = idx_to_icoord(idx, GATE_BUF_SIZE);\n    vec4 data = texelFetch(ICHANNEL_GATE_BUF, icoord, 0);\n    gate_buf_decode(data, gate_type, icoord_bl);\n}\n\nvec3 render_gate(\n    vec3 col,\n    int gate_type,\n    vec2 block_uv,\n    float block_uv_1px\n)\n{\n    if (gate_type == GATE_TYPE_AND)\n    {\n        if (point_inside_and_gate(block_uv))\n        {\n            col = COL_AND_GATE;\n        }\n        \n        float sd = sd_and_gate(block_uv);\n        col = mix(\n            col,\n            vec3(.7),\n            remap01(sd, .4 * block_uv_1px, -.4 * block_uv_1px)\n        );\n    }\n    else if (gate_type == GATE_TYPE_OR)\n    {\n        if (point_inside_or_gate(block_uv))\n        {\n            col = COL_OR_GATE;\n        }\n        \n        float sd = sd_or_gate(block_uv);\n        col = mix(\n            col,\n            vec3(.7),\n            remap01(sd, .4 * block_uv_1px, -.4 * block_uv_1px)\n        );\n    }\n    else if (gate_type == GATE_TYPE_XOR)\n    {\n        if (point_inside_xor_gate(block_uv))\n        {\n            col = COL_XOR_GATE;\n        }\n        \n        float sd = sd_xor_gate(block_uv);\n        col = mix(\n            col,\n            vec3(.7),\n            remap01(sd, .4 * block_uv_1px, -.4 * block_uv_1px)\n        );\n    }\n    else if (gate_type == GATE_TYPE_NOT)\n    {\n        if (point_inside_not_gate(block_uv))\n        {\n            col = COL_NOT_GATE;\n        }\n        \n        float sd = sd_not_gate(block_uv);\n        col = mix(\n            col,\n            vec3(.7),\n            remap01(sd, .4 * block_uv_1px, -.4 * block_uv_1px)\n        );\n    }\n    else if (gate_type == GATE_TYPE_NAND)\n    {\n        if (point_inside_nand_gate(block_uv))\n        {\n            col = COL_NAND_GATE;\n        }\n        \n        float sd = sd_nand_gate(block_uv);\n        col = mix(\n            col,\n            vec3(.7),\n            remap01(sd, .4 * block_uv_1px, -.4 * block_uv_1px)\n        );\n    }\n    else if (gate_type == GATE_TYPE_NOR)\n    {\n        if (point_inside_nor_gate(block_uv))\n        {\n            col = COL_NOR_GATE;\n        }\n        \n        float sd = sd_nor_gate(block_uv);\n        col = mix(\n            col,\n            vec3(.7),\n            remap01(sd, .4 * block_uv_1px, -.4 * block_uv_1px)\n        );\n    }\n    else if (gate_type == GATE_TYPE_XNOR)\n    {\n        if (point_inside_xnor_gate(block_uv))\n        {\n            col = COL_XNOR_GATE;\n        }\n        \n        float sd = sd_xnor_gate(block_uv);\n        col = mix(\n            col,\n            vec3(.7),\n            remap01(sd, .4 * block_uv_1px, -.4 * block_uv_1px)\n        );\n    }\n    else if (gate_type == GATE_TYPE_SWC)\n    {\n        if (point_inside_swc_gate(block_uv))\n        {\n            col = COL_SWC_GATE;\n        }\n        \n        float sd = sd_swc_gate(block_uv);\n        col = mix(\n            col,\n            vec3(.7),\n            remap01(sd, .4 * block_uv_1px, -.4 * block_uv_1px)\n        );\n    }\n    return col;\n}\n\nvec3 render_gates(\n    vec3 col,\n    vec2 coord\n)\n{\n    ivec2 icoord = ivec2(coord);\n    for (int i = 0; i < N_GATES; i++)\n    {\n        int gate_type;\n        ivec2 gate_icoord_bl;\n        gate_fetch(i, gate_type, gate_icoord_bl);\n        if (gate_type == GATE_TYPE_NONE)\n        {\n            continue;\n        }\n        \n        ivec2 gate_icoord_tr = gate_icoord_bl + GATE_SIZE_PX;\n        if (any(lessThan(icoord, gate_icoord_bl))\n            || any(greaterThanEqual(icoord, gate_icoord_tr)))\n        {\n            continue;\n        }\n        \n        vec2 block_uv = clamp(\n            (coord - vec2(gate_icoord_bl) - .5) / float(GATE_SIZE_PX),\n            0.,\n            1.\n        );\n        float block_uv_1px = 1. / float(GATE_SIZE_PX);\n        \n        col = render_gate(\n            col,\n            gate_type,\n            block_uv,\n            block_uv_1px\n        );\n    }\n    return col;\n}\n\nvec3 render_eraser_size_indicator(\n    vec3 col,\n    vec2 coord,\n    int draw_mode\n)\n{\n    vec2 mouse_toolbar_uv = dls_toolbar_uv(iMouse.xy, iResolution.xy); \n    bool mouse_in_toolbar = point_inside_dls_toolbar(\n        mouse_toolbar_uv,\n        iResolution.xy\n    );\n    \n    if (iMouse.z < .5 || draw_mode != DRAW_MODE_ERASE || mouse_in_toolbar)\n    {\n        return col;\n    }\n\n    float d = distance(coord, iMouse.xy);\n    float sd = max(\n        -(d - ERASER_THICKNESS_PX),\n        d - ERASER_THICKNESS_PX - 3.\n    );\n    col = mix(\n        col,\n        vec3(.7),\n        remap01(sd, .4, -.4)\n    );\n    return col;\n}\n\nvec3 render_draw_mode_block(\n    vec3 col,\n    int block_idx,\n    vec2 block_uv,\n    float block_uv_1px\n)\n{\n    if (block_idx == DRAW_MODE_WIRE)\n    {\n        float sd = sd_oriented_box(block_uv, vec2(.38), vec2(.7), .15);\n        sd = min(\n            sd,\n            sd_oriented_box(block_uv, vec2(.3), vec2(.6), .07)\n        );\n        col = mix(\n            col,\n            vec3(.7),\n            remap01(sd, .4 * block_uv_1px, -.4 * block_uv_1px)\n        );\n    }\n    else if (block_idx == DRAW_MODE_ERASE)\n    {\n        float sd = sd_oriented_box(block_uv, vec2(.45), vec2(.68), .24);\n        sd = min(\n            sd,\n            max(\n                sd_oriented_box(block_uv, vec2(.32), vec2(.6), .24),\n                -sd_oriented_box(block_uv, vec2(.35), vec2(.6), .15)\n            )\n        );\n        \n        col = mix(\n            col,\n            vec3(.7),\n            remap01(sd, .4 * block_uv_1px, -.4 * block_uv_1px)\n        );\n    }\n    else if (block_idx == DRAW_MODE_WIRE_LOW)\n    {\n        float sd = distance(block_uv, vec2(.5)) - .24;\n        col = mix(\n            col,\n            vec3(.7),\n            remap01(sd, .4 * block_uv_1px, -.4 * block_uv_1px)\n        );\n        \n        sd = distance(block_uv, vec2(.5)) - .18;\n        col = mix(\n            col,\n            vec3(.68, .05, .02),\n            remap01(sd, .4 * block_uv_1px, -.4 * block_uv_1px)\n        );\n    }\n    else if (block_idx == DRAW_MODE_WIRE_HIGH)\n    {\n        float sd = distance(block_uv, vec2(.5)) - .24;\n        col = mix(\n            col,\n            vec3(.7),\n            remap01(sd, .4 * block_uv_1px, -.4 * block_uv_1px)\n        );\n        \n        sd = distance(block_uv, vec2(.5)) - .18;\n        col = mix(\n            col,\n            vec3(.02, .45, .01),\n            remap01(sd, .4 * block_uv_1px, -.4 * block_uv_1px)\n        );\n    }\n    else if (block_idx == DRAW_MODE_GATE_AND)\n    {\n        block_uv = remap(block_uv, .08, .92, 0., 1.);\n        col = render_gate(col, GATE_TYPE_AND, block_uv, block_uv_1px);\n    }\n    else if (block_idx == DRAW_MODE_GATE_OR)\n    {\n        block_uv = remap(block_uv, .08, .92, 0., 1.);\n        col = render_gate(col, GATE_TYPE_OR, block_uv, block_uv_1px);\n    }\n    else if (block_idx == DRAW_MODE_GATE_XOR)\n    {\n        block_uv = remap(block_uv, .08, .92, 0., 1.);\n        col = render_gate(col, GATE_TYPE_XOR, block_uv, block_uv_1px);\n    }\n    else if (block_idx == DRAW_MODE_GATE_NOT)\n    {\n        block_uv = remap(block_uv, .08, .92, 0., 1.);\n        col = render_gate(col, GATE_TYPE_NOT, block_uv, block_uv_1px);\n    }\n    else if (block_idx == DRAW_MODE_GATE_NAND)\n    {\n        block_uv = remap(block_uv, .08, .92, 0., 1.);\n        col = render_gate(col, GATE_TYPE_NAND, block_uv, block_uv_1px);\n    }\n    else if (block_idx == DRAW_MODE_GATE_NOR)\n    {\n        block_uv = remap(block_uv, .08, .92, 0., 1.);\n        col = render_gate(col, GATE_TYPE_NOR, block_uv, block_uv_1px);\n    }\n    else if (block_idx == DRAW_MODE_GATE_XNOR)\n    {\n        block_uv = remap(block_uv, .08, .92, 0., 1.);\n        col = render_gate(col, GATE_TYPE_XNOR, block_uv, block_uv_1px);\n    }\n    else if (block_idx == DRAW_MODE_GATE_SWC)\n    {\n        block_uv = remap(block_uv, .08, .92, 0., 1.);\n        col = render_gate(col, GATE_TYPE_SWC, block_uv, block_uv_1px);\n    }\n    \n    return col;\n}\n\nvec3 render_draw_mode_toolbar(\n    vec3 col,\n    vec2 coord,\n    int draw_mode\n)\n{\n    vec2 toolbar_uv = dls_toolbar_uv(coord, iResolution.xy);\n    \n    if (!point_inside_dls_toolbar(toolbar_uv, iResolution.xy))\n    {\n        return col;\n    }\n    \n    int block_idx = dls_toolbar_block_idx(toolbar_uv);\n    vec2 block_uv = dls_toolbar_block_uv(toolbar_uv, iResolution.xy);\n    \n    float block_uv_1px = (1. / iResolution.x) / TOOLBAR_BLOCK_SIZE;\n\n    // highlight selected\n    if (block_idx == draw_mode)\n    {\n        col = mix(col, vec3(.3), .4);\n    }\n    else\n    {\n        col = mix(col, vec3(.1), .4);\n    }\n\n    // draw mode icon\n    col = render_draw_mode_block(\n        col,\n        block_idx,\n        block_uv,\n        block_uv_1px\n    );\n    \n    // separator line\n    float sd = 1e9;\n    if (block_idx > 0)\n    {\n        sd = min(sd, abs(block_uv.x - 0.) - .008);\n    }\n    if (block_idx < (N_TOOLBAR_BLOCKS - 1))\n    {\n        sd = min(sd, abs(block_uv.x - 1.) - .008);\n    }\n    col = mix(\n        col,\n        vec3(.03),\n        remap01(sd, .4 * block_uv_1px, -.4 * block_uv_1px)\n    );\n    \n    return col;\n}\n\nvec3 view_transform(vec3 col)\n{\n    col = max(col, 0.);\n    col = pow(col, vec3(1. / 2.2));\n    return col;\n}\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    ivec2 icoord = ivec2(frag_coord);\n\n    // current pixel's values from the DLS buffer\n    int wire_state;\n    int last_updated;\n    dls_fetch(icoord, wire_state, last_updated);\n    \n    // values from the data buffer\n    ivec2 res;\n    int draw_mode;\n    bool prev_mouse_down;\n    ivec2 prev_imouse;\n    data_buf_decode(\n        texelFetch(ICHANNEL_DATA_BUF, ivec2(0), 0),\n        res,\n        draw_mode,\n        prev_mouse_down,\n        prev_imouse\n    );\n\n    // wires and background\n    vec3 col = vec3(0);\n    if (wire_state == WIRE_STATE_NOT_WIRE)\n    {\n        col = COL_BACKGROUND;\n    }\n    else if (wire_state == WIRE_STATE_DISCONNECTED)\n    {\n        col = COL_WIRE_DISCONNECTED;\n    }\n    else if (wire_state == WIRE_STATE_LOW)\n    {\n        col = COL_WIRE_LOW;\n    }\n    else if (wire_state == WIRE_STATE_HIGH)\n    {\n        col = COL_WIRE_HIGH;\n    }\n    \n    // gates\n    col = render_gates(col, frag_coord);\n    \n    // eraser size indicator\n    col = render_eraser_size_indicator(\n        col,\n        frag_coord,\n        draw_mode\n    );\n    \n    // draw mode toolbar\n    col = render_draw_mode_toolbar(\n        col,\n        frag_coord,\n        draw_mode\n    );\n\n    // output\n    col = view_transform(col);\n    frag_col = vec4(col, 1);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "#define SHADERTOY 1\n\nprecision highp float;\nprecision highp int;\n\n\n\n/*_________________ math utils ________________*/\n\nconst float PI = 3.141592653589793238462643383;\nconst float TAU = 6.283185307179586476925286767;\nconst float PI_OVER_2 = 1.570796326794896619231321692;\nconst float INV_PI = .318309886183790671537767527;\nconst float INV_TAU = .159154943091895335768883763;\n\n#define FUNC_LERP(T) \\\nT lerp(T a, T b, float t) \\\n{ \\\n    return a + t * (b - a); \\\n}\n\n#define FUNC_WRAP(T) \\\nT wrap(T v, float start, float end) \\\n{ \\\n    return start + mod(v - start, end - start); \\\n}\n\n#define FUNC_REMAP(T) \\\nT remap(T v, float inp_start, float inp_end, float out_start, float out_end) \\\n{ \\\n    return out_start \\\n        + ((out_end - out_start) / (inp_end - inp_start)) * (v - inp_start); \\\n}\n\n#define FUNC_REMAP_CLAMP(T) \\\nT remap_clamp( \\\n    T v, \\\n    float inp_start, \\\n    float inp_end, \\\n    float out_start, \\\n    float out_end \\\n) \\\n{ \\\n    T t = clamp((v - inp_start) / (inp_end - inp_start), 0., 1.); \\\n    return out_start + t * (out_end - out_start); \\\n}\n\n#define FUNC_REMAP01(T) \\\nT remap01(T v, float inp_start, float inp_end) \\\n{ \\\n    return clamp((v - inp_start) / (inp_end - inp_start), 0., 1.); \\\n}\n\n#define FUNC_LENGTH_SQ(T) \\\nfloat length_sq(T v) \\\n{ \\\n    return dot(v, v); \\\n}\n\n#define FUNC_DIST_SQ(T) \\\nfloat dist_sq(T a, T b) \\\n{ \\\n    a -= b; \\\n    return dot(a, a); \\\n}\n\nFUNC_LERP(float)\nFUNC_LERP(vec2)\nFUNC_LERP(vec3)\nFUNC_LERP(vec4)\n\nFUNC_WRAP(float)\nFUNC_WRAP(vec2)\nFUNC_WRAP(vec3)\nFUNC_WRAP(vec4)\n\nFUNC_REMAP(float)\nFUNC_REMAP(vec2)\nFUNC_REMAP(vec3)\nFUNC_REMAP(vec4)\n\nFUNC_REMAP_CLAMP(float)\nFUNC_REMAP_CLAMP(vec2)\nFUNC_REMAP_CLAMP(vec3)\nFUNC_REMAP_CLAMP(vec4)\n\nFUNC_REMAP01(float)\nFUNC_REMAP01(vec2)\nFUNC_REMAP01(vec3)\nFUNC_REMAP01(vec4)\n\nFUNC_LENGTH_SQ(vec2)\nFUNC_LENGTH_SQ(vec3)\nFUNC_LENGTH_SQ(vec4)\n\nFUNC_DIST_SQ(vec2)\nFUNC_DIST_SQ(vec3)\nFUNC_DIST_SQ(vec4)\n\nfloat chebyshev_dist(vec2 a, vec2 b)\n{\n    return max(abs(a.x - b.x), abs(a.y - b.y));\n}\n\nfloat chebyshev_dist(vec3 a, vec3 b)\n{\n    return max(\n        max(abs(a.x - b.x), abs(a.y - b.y)),\n        abs(a.z - b.z)\n    );\n}\n\nfloat chebyshev_dist(vec4 a, vec4 b)\n{\n    return max(\n        max(\n            max(abs(a.x - b.x), abs(a.y - b.y)),\n            abs(a.z - b.z)\n        ),\n        abs(a.w - b.w)\n    );\n}\n\n#define idiv_ceil(a, b) ((a + b - 1) / b)\n\nint iabs(int v)\n{\n    if (v < 0)\n    {\n        return -v;\n    }\n    return v;\n}\n\nint imin(int a, int b)\n{\n    if (a < b)\n    {\n        return a;\n    }\n    return b;\n}\n\nint imax(int a, int b)\n{\n    if (a > b)\n    {\n        return a;\n    }\n    return b;\n}\n\nint iclamp(int v, int start, int end)\n{\n    if (v < start)\n    {\n        v = start;\n    }\n    if (v > end)\n    {\n        v = end;\n    }\n    return v;\n}\n\nfloat min_component(vec2 v)\n{\n    return min(v.x, v.y);\n}\n\nfloat min_component(vec3 v)\n{\n    return min(min(v.x, v.y), v.z);\n}\n\nfloat min_component(vec4 v)\n{\n    return min(min(min(v.x, v.y), v.z), v.w);\n}\n\nfloat max_component(vec2 v)\n{\n    return max(v.x, v.y);\n}\n\nfloat max_component(vec3 v)\n{\n    return max(max(v.x, v.y), v.z);\n}\n\nfloat max_component(vec4 v)\n{\n    return max(max(max(v.x, v.y), v.z), v.w);\n}\n\nint min_component(ivec2 v)\n{\n    return imin(v.x, v.y);\n}\n\nint min_component(ivec3 v)\n{\n    return imin(imin(v.x, v.y), v.z);\n}\n\nint min_component(ivec4 v)\n{\n    return imin(imin(imin(v.x, v.y), v.z), v.w);\n}\n\nint max_component(ivec2 v)\n{\n    return imax(v.x, v.y);\n}\n\nint max_component(ivec3 v)\n{\n    return imax(imax(v.x, v.y), v.z);\n}\n\nint max_component(ivec4 v)\n{\n    return imax(imax(imax(v.x, v.y), v.z), v.w);\n}\n\n// credits to AHSEN (https://www.shadertoy.com/user/01000001)\n// https://www.desmos.com/calculator/5d6ph151vi interactive :D\nfloat bicubic(float a, float b, float c, float d, float t)\n{\n    float one = t - 1.;\n    float two = t - 2.;\n    float three = t - 3.;\n    return (\n        (-one * two * three * a)\n        + (t * one * two * d)\n        + (3. * t * two * three * b)\n        - (3. * t * one * three * c)\n    ) / 6.;\n}\n\n// |a| * |b| * sin(theta)\nfloat cross2d(vec2 a, vec2 b)\n{\n    return a.x * b.y - a.y * b.x;\n}\n\n// references for barycentric coordinates\n// https://www.desmos.com/calculator/8g8xjejuox\n// https://www.shadertoy.com/view/mdjBWK\n\nvec3 cartesian_to_barycentric(\n    vec2 p,\n    vec2 v0,\n    vec2 v1,\n    vec2 v2,\n    bool clamp_,\n    out bool p_is_outside\n)\n{\n    vec3 b = vec3(\n        cross2d(v1 - p, v2 - p),\n        cross2d(v2 - p, v0 - p),\n        cross2d(v0 - p, v1 - p)\n    ) / cross2d(v1 - v0, v2 - v0);\n    p_is_outside = min(min(b.x, b.y), b.z) < 0.;\n    if (clamp_)\n    {\n        b = max(b, 0.);\n        b /= (b.x + b.y + b.z);\n    }\n    return b;\n}\n\nvec3 cartesian_to_barycentric(\n    vec3 p,\n    vec3 v0,\n    vec3 v1,\n    vec3 v2,\n    bool clamp_,\n    out bool p_is_outside\n)\n{\n    vec3 b = vec3(\n        length(cross(v1 - p, v2 - p)),\n        length(cross(v2 - p, v0 - p)),\n        length(cross(v0 - p, v1 - p))\n    ) / length(cross(v1 - v0, v2 - v0));\n    p_is_outside = min(min(b.x, b.y), b.z) < 0.;\n    if (clamp_)\n    {\n        b = max(b, 0.);\n        b /= (b.x + b.y + b.z);\n    }\n    return b;\n}\n\nfloat barycentric_interpolate(vec3 b, float v0, float v1, float v2)\n{\n    return dot(b, vec3(v0, v1, v2));\n}\n\nvec2 barycentric_interpolate(vec3 b, vec2 v0, vec2 v1, vec2 v2)\n{\n    return b.x * v0 + b.y * v1 + b.z * v2;\n}\n\nvec3 barycentric_interpolate(vec3 b, vec3 v0, vec3 v1, vec3 v2)\n{\n    return b.x * v0 + b.y * v1 + b.z * v2;\n}\n\nvec4 barycentric_interpolate(vec3 b, vec4 v0, vec4 v1, vec4 v2)\n{\n    return b.x * v0 + b.y * v1 + b.z * v2;\n}\n\nfloat barycentric_interpolate(vec2 b, float v0, float v1, float v2)\n{\n    return barycentric_interpolate(\n        vec3(b.x, b.y, 1. - b.x - b.y),\n        v0, v1, v2\n    );\n}\n\nvec2 barycentric_interpolate(vec2 b, vec2 v0, vec2 v1, vec2 v2)\n{\n    return barycentric_interpolate(\n        vec3(b.x, b.y, 1. - b.x - b.y),\n        v0, v1, v2\n    );\n}\n\nvec3 barycentric_interpolate(vec2 b, vec3 v0, vec3 v1, vec3 v2)\n{\n    return barycentric_interpolate(\n        vec3(b.x, b.y, 1. - b.x - b.y),\n        v0, v1, v2\n    );\n}\n\nvec4 barycentric_interpolate(vec2 b, vec4 v0, vec4 v1, vec4 v2)\n{\n    return barycentric_interpolate(\n        vec3(b.x, b.y, 1. - b.x - b.y),\n        v0, v1, v2\n    );\n}\n\n// angle from 0 to TAU\nfloat get_angle(vec2 p)\n{\n    float a = atan(p.y, p.x);\n    if (a < 0.)\n    {\n        return a + TAU;\n    }\n    return a;\n}\n\nmat2 rotate_2d(float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(\n        c, s,\n        -s, c\n    );\n}\n\nvec3 spherical_to_cartesian(vec2 s)\n{\n    float sin_theta = sin(s.x);\n    return vec3(\n        sin_theta * cos(s.y),\n        sin_theta * sin(s.y),\n        cos(s.x)\n    );\n}\n\nvec2 screen_to_uv01(vec2 coord, vec2 res)\n{\n    return coord / res;\n}\n\nvec2 screen_to_uv_horizontal(vec2 coord, vec2 res)\n{\n    return (2. * coord - res) / res.x;\n}\n\nvec2 screen_to_uv_vertical(vec2 coord, vec2 res)\n{\n    return (2. * coord - res) / res.y;\n}\n\nvec2 screen_to_uv_fit(vec2 coord, vec2 res)\n{\n    return (2. * coord - res) / min_component(res);\n}\n\nvec2 screen_to_uv_fill(vec2 coord, vec2 res)\n{\n    return (2. * coord - res) / max_component(res);\n}\n\n// for some reason we can't use intBitsToFloat() or floatBitsToInt() to store\n// integers below this value in a buffer.\nconst int BUFFER_MIN_INTEGER = 8388608;\n\n// * x must not be higher than 4,286,578,688 (see BUFFER_MIN_INTEGER above)\n// * for your sanity, don't use negative values\nfloat encode_int_for_buffer(int v)\n{\n    return intBitsToFloat(v + BUFFER_MIN_INTEGER);\n}\n\nint decode_int_from_buffer(float v)\n{\n    return floatBitsToInt(v) - BUFFER_MIN_INTEGER;\n}\n\n// pack two 16-bit integers in a single 32-bit integer\n// * both arguments should be in the 0-65535 range\n// * a must be less than 65279 (see the functions above)\nint pack_i16(int a, int b)\n{\n    return (a << 16) | b;\n}\n\n// unpack two 16-bit integers from a single 32-bit integer\nvoid unpack_i16(int v, out int a, out int b)\n{\n    a = (v >> 16) & 65535;\n    b = v & 65535;\n}\n\n// unpack the first 16-bit integer from a 32-bit integer\nint unpack_i16_a(int v)\n{\n    return (v >> 16) & 65535;\n}\n\n// unpack the second 16-bit integer from a 32-bit integer\nint unpack_i16_b(int v)\n{\n    return v & 65535;\n}\n\nbool icoord_in_bounds(ivec2 icoord, ivec2 ires)\n{\n    return\n        icoord.x >= 0 &&\n        icoord.y >= 0 &&\n        icoord.x < ires.x &&\n        icoord.y < ires.y;\n}\n\nbool icoord_in_bounds(ivec3 icoord, ivec3 ires)\n{\n    return\n        icoord.x >= 0 &&\n        icoord.y >= 0 &&\n        icoord.z >= 0 &&\n        icoord.x < ires.x &&\n        icoord.y < ires.y &&\n        icoord.z < ires.z;\n}\n\nint icoord_to_idx(ivec2 icoord, ivec2 ires)\n{\n    return icoord.x + (icoord.y * ires.x);\n}\n\nint icoord_to_idx(ivec3 icoord, ivec3 ires)\n{\n    return icoord.x + (icoord.y * ires.x) + (icoord.z * ires.x * ires.y);\n}\n\nivec2 idx_to_icoord(int idx, ivec2 ires)\n{\n    return ivec2(idx % ires.x, idx / ires.x);\n}\n\nivec3 idx_to_icoord(int idx, ivec3 ires)\n{\n    return ivec3(\n        idx % ires.x,\n        (idx % (ires.x * ires.y)) / ires.x,\n        idx / (ires.x * ires.y)\n    );\n}\n\n/*__________________ keyboard _________________*/\n\n// put this code in every buffer that uses the keyboard input:\n/*\n#if SHADERTOY\n// iChannelX must be set to Keyboard in Shadertoy\n#define SHADERTOY_KEYBOARD_CH iChannelX\n#else\n#iKeyboard\n#endif\n\ndefine_keyboard_utils\n*/\n\n#if SHADERTOY\n\n#define define_keyboard_utils \\\n \\\n/* https://github.com/stevensona/shader-toy/blob/c4833b972649d78a2ee090af60b79a3907e8e091/src/extensions/keyboard/keyboard_shader_extension.ts#L11 */ \\\nconst int \\\n    Key_Backspace = 8, Key_Tab = 9, Key_Enter = 13, Key_Shift = 16, \\\n    Key_Ctrl = 17, Key_Alt = 18, Key_Pause = 19, Key_Caps = 20, \\\n    Key_Escape = 27, Key_PageUp = 33, Key_PageDown = 34, Key_End = 35, \\\n    Key_Home = 36, Key_LeftArrow = 37, Key_UpArrow = 38, Key_RightArrow = 39, \\\n    Key_DownArrow = 40, Key_Insert = 45, Key_Delete = 46, Key_0 = 48, \\\n    Key_1 = 49, Key_2 = 50, Key_3 = 51, Key_4 = 52, Key_5 = 53, Key_6 = 54, \\\n    Key_7 = 55, Key_8 = 56, Key_9 = 57, Key_A = 65, Key_B = 66, Key_C = 67, \\\n    Key_D = 68, Key_E = 69, Key_F = 70, Key_G = 71, Key_H = 72, \\\n    Key_I = 73, Key_J = 74, Key_K = 75, Key_L = 76, Key_M = 77, Key_N = 78, \\\n    Key_O = 79, Key_P = 80, Key_Q = 81, Key_R = 82, Key_S = 83, Key_T = 84, \\\n    Key_U = 85, Key_V = 86, Key_W = 87, Key_X = 88, Key_Y = 89, Key_Z = 90, \\\n    Key_LeftWindow = 91, Key_RightWindows = 92, Key_Select = 93, \\\n    Key_Numpad0 = 96, Key_Numpad1 = 97, Key_Numpad2 = 98, Key_Numpad3 = 99, \\\n    Key_Numpad4 = 100, Key_Numpad5 = 101, Key_Numpad6 = 102, \\\n    Key_Numpad7 = 103, Key_Numpad8 = 104, Key_Numpad9 = 105, \\\n    Key_NumpadMultiply = 106, Key_NumpadAdd = 107, Key_NumpadSubtract = 109, \\\n    Key_NumpadPeriod = 110, Key_NumpadDivide = 111, Key_F1 = 112, \\\n    Key_F2 = 113, Key_F3 = 114, Key_F4 = 115, Key_F5 = 116, Key_F6 = 117, \\\n    Key_F7 = 118, Key_F8 = 119, Key_F9 = 120, Key_F10 = 121, Key_F11 = 122, \\\n    Key_F12 = 123, Key_NumLock = 144, Key_ScrollLock = 145, \\\n    Key_SemiColon = 186, Key_Equal = 187, Key_Comma = 188, Key_Dash = 189, \\\n    Key_Period = 190, Key_ForwardSlash = 191, Key_GraveAccent = 192, \\\n    Key_OpenBracket = 219, Key_BackSlash = 220, Key_CloseBraket = 221, \\\n    Key_SingleQuote = 222; \\\nconst int Key_Space = 32; \\\n \\\nbool is_key_pressed(int key) \\\n{ \\\n    return texelFetch(SHADERTOY_KEYBOARD_CH, ivec2(key, 1), 0).x > .5; \\\n} \\\n \\\nbool is_key_down(int key) \\\n{ \\\n    return texelFetch(SHADERTOY_KEYBOARD_CH, ivec2(key, 0), 0).x > .5; \\\n} \\\n \\\nbool is_key_toggled(int key) \\\n{ \\\n    return texelFetch(SHADERTOY_KEYBOARD_CH, ivec2(key, 2), 0).x > .5; \\\n}\n\n#else\n\n#define define_keyboard_utils \\\n \\\nconst int Key_Space = 32; \\\n \\\nbool is_key_pressed(int key) \\\n{ \\\n    return isKeyPressed(key); \\\n} \\\n \\\nbool is_key_down(int key) \\\n{ \\\n    return isKeyDown(key); \\\n} \\\n \\\nbool is_key_toggled(int key) \\\n{ \\\n    return isKeyToggled(key); \\\n}\n\n#endif\n\n\n\n/*___________________ SDF _____________________*/\n\n// most but not all of these are from the following article\n// https://iquilezles.org/articles/distfunctions2d/\n\nfloat sd_segment(vec2 p, vec2 a, vec2 b)\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sd_segment_2sided(vec2 p, vec2 a, vec2 b)\n{\n    vec2 tangent_unnorm = b - a;\n    float tangent_len = length(tangent_unnorm);\n    vec2 tangent = tangent_unnorm / tangent_len;\n    \n    float u = dot(p - a, tangent);\n    if (u < 0. || u > tangent_len)\n    {\n        return min(distance(p, a), distance(p, b));\n    }\n    else\n    {\n        vec2 normal = vec2(-tangent.y, tangent.x);\n        return dot(p - a, normal);\n    }\n}\n\nfloat sd_ring(vec2 p, vec2 n, float r, float thickness)\n{\n    p.x = abs(p.x);\n    \n    p = mat2(n.x,n.y,-n.y,n.x)*p;\n\n    return max( abs(length(p)-r)-thickness*0.5,\n                length(vec2(p.x,max(0.0,abs(r-p.y)-thickness*0.5)))*sign(p.x) );\n}\n\nfloat sd_oriented_box(vec2 p, vec2 a, vec2 b, float thickness)\n{\n    float l = length(b-a);\n    vec2  d = (b-a)/l;\n    vec2  q = (p-(a+b)*0.5);\n          q = mat2(d.x,-d.y,d.y,d.x)*q;\n          q = abs(q)-vec2(l,thickness)*0.5;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0);    \n}\n\nfloat sd_parabola(vec2 pos, float width, float height)\n{\n    pos.x = abs(pos.x);\n\n    float ik = width*width/height;\n    float p = ik*(height-pos.y-0.5*ik)/3.0;\n    float q = pos.x*ik*ik*0.25;\n    float h = q*q - p*p*p;\n    \n    float x;\n    if( h>0.0 ) // 1 root\n    {\n        float r = sqrt(h);\n        x = pow(q+r,1.0/3.0) + pow(abs(q-r),1.0/3.0)*sign(p);\n    }\n    else        // 3 roots\n    {\n        float r = sqrt(p);\n        x = 2.0*r*cos(acos(q/(p*r))/3.0); // see https://www.shadertoy.com/view/WltSD7 for an implementation of cos(acos(x)/3) without trigonometrics\n    }\n    \n    x = min(x,width);\n    \n    return length(pos-vec2(x,height-x*x/ik)) * \n           sign(ik*(pos.y-height)+pos.x*pos.x);\n}\n\nfloat sd_bezier(vec2 pos, vec2 A, vec2 B, vec2 C)\n{    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n    float kk = 1.0/dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);      \n    float res = 0.0;\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx-3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n    if( h >= 0.0) \n    { \n        h = sqrt(h);\n        vec2 x = (vec2(h,-h)-q)/2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = clamp( uv.x+uv.y-kx, 0.0, 1.0 );\n        res = length_sq(d + (c + b*t)*t);\n    }\n    else\n    {\n        float z = sqrt(-p);\n        float v = acos( q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3  t = clamp(vec3(m+m,-n-m,n-m)*z-kx,0.0,1.0);\n        res = min( length_sq(d+(c+b*t.x)*t.x),\n                   length_sq(d+(c+b*t.y)*t.y) );\n        // the third root cannot be the closest\n        // res = min(res,dot2(d+(c+b*t.z)*t.z));\n    }\n    return sqrt(res);\n}\n\n#define DEFINE_SD_POLYGON(n_sides) \\\nfloat sd_polygon(vec2 p, vec2[n_sides] v) \\\n{ \\\n    float d = dot(p-v[0],p-v[0]); \\\n    float s = 1.0; \\\n    for( int i=0, j=n_sides-1; i<n_sides; j=i, i++ ) \\\n    { \\\n        vec2 e = v[j] - v[i]; \\\n        vec2 w =    p - v[i]; \\\n        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 ); \\\n        d = min( d, dot(b,b) ); \\\n        bvec3 c = bvec3(p.y>=v[i].y,p.y<v[j].y,e.x*w.y>e.y*w.x); \\\n        if( all(c) || all(not(c)) ) s*=-1.0;   \\\n    } \\\n    return s*sqrt(d); \\\n}\n\n\n\n/*___________ bezier sdf approx. ______________*/\n\nvec2 bezier(vec2 a, vec2 b, vec2 c, float t)\n{\n    return mix(\n        mix(a, b, t),\n        mix(b, c, t),\n        t\n    );\n}\n\nvec2 bezier(vec2 a, vec2 b, vec2 c, vec2 d, float t)\n{\n    return mix(\n        mix(\n            mix(a, b, t),\n            mix(b, c, t),\n            t\n        ),\n        mix(\n            mix(b, c, t),\n            mix(c, d, t),\n            t\n        ),\n        t\n    );\n}\n\nconst int BEZIER_RES = 6;\n\nfloat sd_bezier_approx(vec2 p, vec2 a, vec2 b, vec2 c)\n{\n    float sd = 1e9;\n    for (int i = 0; i < BEZIER_RES; i++)\n    {\n        sd = min(sd, sd_segment(\n            p,\n            bezier(a, b, c, float(i) / float(BEZIER_RES)),\n            bezier(a, b, c, float(i + 1) / float(BEZIER_RES))\n        ));\n    }\n    return sd;\n}\n\nfloat sd_bezier_approx(vec2 p, vec2 a, vec2 b, vec2 c, vec2 d)\n{\n    float sd = 1e9;\n    for (int i = 0; i < BEZIER_RES; i++)\n    {\n        sd = min(sd, sd_segment(\n            p,\n            bezier(a, b, c, d, float(i) / float(BEZIER_RES)),\n            bezier(a, b, c, d, float(i + 1) / float(BEZIER_RES))\n        ));\n    }\n    return sd;\n}\n\n\n\n/*______________ DLS constants ________________*/\n\nconst int WIRE_STATE_NOT_WIRE = 0;\nconst int WIRE_STATE_DISCONNECTED = 1;\nconst int WIRE_STATE_LOW = 2;\nconst int WIRE_STATE_HIGH = 3;\n\nconst int DRAW_MODE_WIRE = 0;\nconst int DRAW_MODE_ERASE = 1;\nconst int DRAW_MODE_WIRE_LOW = 2;\nconst int DRAW_MODE_WIRE_HIGH = 3;\nconst int DRAW_MODE_GATE_AND = 4;\nconst int DRAW_MODE_GATE_OR = 5;\nconst int DRAW_MODE_GATE_XOR = 6;\nconst int DRAW_MODE_GATE_NOT = 7;\nconst int DRAW_MODE_GATE_NAND = 8;\nconst int DRAW_MODE_GATE_NOR = 9;\nconst int DRAW_MODE_GATE_XNOR = 10;\nconst int DRAW_MODE_GATE_SWC = 11;\nconst int N_DRAW_MODES = 12;\n\nconst float TOOLBAR_BLOCK_SIZE = .05;\nconst int N_TOOLBAR_BLOCKS = N_DRAW_MODES;\n\nconst float BRUSH_THICKNESS_PX = 6.;\nconst float ERASER_THICKNESS_PX = 26.;\n\nconst vec3 COL_BACKGROUND = vec3(.024, .036, .062);\nconst vec3 COL_WIRE_DISCONNECTED = vec3(.013, .013, .024);\nconst vec3 COL_WIRE_LOW = vec3(.680, .074, .028);\nconst vec3 COL_WIRE_HIGH = vec3(.074, .659, .032);\nconst vec3 COL_AND_GATE = vec3(.12, .101, .06);\nconst vec3 COL_OR_GATE = vec3(.077, .12, .06);\nconst vec3 COL_XOR_GATE = vec3(.107, .06, .12);\nconst vec3 COL_NOT_GATE = vec3(.12, .06, .075);\nconst vec3 COL_NAND_GATE = vec3(.06, .12, .066);\nconst vec3 COL_NOR_GATE = vec3(.06, .081, .12);\nconst vec3 COL_XNOR_GATE = vec3(.06, .12, .112);\nconst vec3 COL_SWC_GATE = vec3(.08, .06, .12);\n\nconst float GATE_ICON_THICKNESS = .02;\nconst int GATE_SIZE_PX = 80;\n\n// amount of empty space at the top & bottom,\n// this is there because gates are basically\n// considered squares but the actual shapes\n// are more elongated, so to make the\n// intersection tests more accurate, we account\n// for the vertical empty space at the top and\n// bottom of the gates. intersection tests are\n// used to avoid spawning a gate on top of\n// another one.\n// since the gate SDFs have 20% vertical margins\n// we'll use the same ratio here.\nconst int GATE_VERT_PADDING = int(.2 * float(GATE_SIZE_PX));\n\nconst int GATE_TYPE_NONE = 0;\nconst int GATE_TYPE_AND = 1;\nconst int GATE_TYPE_OR = 2;\nconst int GATE_TYPE_XOR = 3;\nconst int GATE_TYPE_NOT = 4;\nconst int GATE_TYPE_NAND = 5;\nconst int GATE_TYPE_NOR = 6;\nconst int GATE_TYPE_XNOR = 7;\nconst int GATE_TYPE_SWC = 8;\n\n// size of the block of pixels at the bottom left corner of\n// the gate buffer to represent gates\nconst ivec2 GATE_BUF_SIZE = ivec2(8);\nconst int N_GATES = GATE_BUF_SIZE.x * GATE_BUF_SIZE.y;\n\n\n\n/*_________ DLS buffer data encoding __________*/\n\nvec4 dls_encode(int wire_state, int last_updated)\n{\n    wire_state = iclamp(wire_state, 0, 3);\n    return vec4(\n        encode_int_for_buffer((last_updated << 2) | wire_state),\n        0, 0, 0\n    );\n}\n\nvoid dls_decode(\n    vec4 data,\n    out int wire_state,\n    out int last_updated\n)\n{\n    int packed = decode_int_from_buffer(data.x);\n    wire_state = packed & 3;\n    last_updated = packed >> 2;\n}\n\nvec4 gate_buf_encode(int gate_type, ivec2 icoord_bl)\n{\n    return vec4(\n        encode_int_for_buffer(gate_type),\n        encode_int_for_buffer(icoord_bl.x),\n        encode_int_for_buffer(icoord_bl.y),\n        0\n    );\n}\n\nvoid gate_buf_decode(\n    vec4 data,\n    out int gate_type,\n    out ivec2 icoord_bl\n)\n{\n    gate_type = decode_int_from_buffer(data.x);\n    icoord_bl = ivec2(\n        decode_int_from_buffer(data.y),\n        decode_int_from_buffer(data.z)\n    );\n}\n\nvec4 data_buf_encode(\n    ivec2 res,\n    int draw_mode,\n    bool prev_mouse_down,\n    ivec2 prev_imouse\n)\n{\n    int prev_mouse_down_01 = (prev_mouse_down ? 1 : 0);\n    return vec4(\n        encode_int_for_buffer(res.x),\n        encode_int_for_buffer(res.y),\n        encode_int_for_buffer((draw_mode << 1) | prev_mouse_down_01),\n        encode_int_for_buffer((prev_imouse.x << 16) | prev_imouse.y)\n    );\n}\n\nvoid data_buf_decode(\n    vec4 data,\n    out ivec2 res,\n    out int draw_mode,\n    out bool prev_mouse_down,\n    out ivec2 prev_imouse\n)\n{\n    res = ivec2(\n        decode_int_from_buffer(data.x),\n        decode_int_from_buffer(data.y)\n    );\n    \n    int packed = decode_int_from_buffer(data.z);\n    draw_mode = packed >> 1;\n    prev_mouse_down = bool(packed & 1);\n    \n    packed = decode_int_from_buffer(data.w);\n    prev_imouse = ivec2(\n        packed >> 16,\n        packed & ((1 << 16) - 1)\n    );\n}\n\n\n\n/*_________________ DLS SDFs __________________*/\n\nconst vec2 GATE_TOP_INPUT_UV = vec2(0., .65);\nconst vec2 GATE_BOTTOM_INPUT_UV = vec2(0., .35);\nconst vec2 GATE_CENTER_INPUT_UV = vec2(0., .5); // for single-input gates\n\n#define N_SIDES_AND_GATE (4 + BEZIER_RES + BEZIER_RES - 1)\nDEFINE_SD_POLYGON(N_SIDES_AND_GATE)\n\nbool point_inside_and_gate(vec2 block_uv)\n{\n    vec2 p[N_SIDES_AND_GATE];\n    p[0] = vec2(.5, .2);\n    p[1] = vec2(.2, .2);\n    p[2] = vec2(.2, .8);\n    p[3] = vec2(.5, .8);\n    for (int i = 1; i <= BEZIER_RES; i++)\n    {\n        p[3 + i] = bezier(\n            vec2(.5, .8),\n            vec2(.5 + .13, .8),\n            vec2(.75, .5 + .13),\n            vec2(.75, .5),\n            float(i) / float(BEZIER_RES)\n        );\n    }\n    for (int i = 1; i < BEZIER_RES; i++)\n    {\n        p[3 + BEZIER_RES + i] = bezier(\n            vec2(.75, .5),\n            vec2(.75, .5 - .13),\n            vec2(.5 + .13, .2),\n            vec2(.5, .2),\n            float(i) / float(BEZIER_RES)\n        );\n    }\n    \n    return sd_polygon(block_uv, p) < 0.;\n}\n\nbool point_inside_nand_gate(vec2 block_uv)\n{\n    return point_inside_and_gate(block_uv);\n}\n\nfloat sd_and_gate_no_output_line(vec2 block_uv)\n{\n    float sd = sd_bezier_approx(\n        block_uv,\n        vec2(.5, .8),\n        vec2(.5 + .13, .8),\n        vec2(.75, .5 + .13),\n        vec2(.75, .5)\n    ) - GATE_ICON_THICKNESS;\n    \n    sd = min(sd, sd_bezier_approx(\n        block_uv,\n        vec2(.75, .5),\n        vec2(.75, .5 - .13),\n        vec2(.5 + .13, .2),\n        vec2(.5, .2)\n    ) - GATE_ICON_THICKNESS);\n    \n    sd = min(sd, sd_segment(\n        block_uv,\n        vec2(.2, .8),\n        vec2(.5, .8)\n    ) - GATE_ICON_THICKNESS);\n    \n    sd = min(sd, sd_segment(\n        block_uv,\n        vec2(.2, .2),\n        vec2(.5, .2)\n    ) - GATE_ICON_THICKNESS);\n    \n    sd = min(sd, sd_segment(\n        block_uv,\n        vec2(.2, .2),\n        vec2(.2, .8)\n    ) - GATE_ICON_THICKNESS);\n    \n    // input line 1\n    sd = min(sd, sd_segment(\n        block_uv,\n        GATE_TOP_INPUT_UV,\n        GATE_TOP_INPUT_UV + vec2(.2, 0)\n    ) - GATE_ICON_THICKNESS);\n    \n    // input line 2\n    sd = min(sd, sd_segment(\n        block_uv,\n        GATE_BOTTOM_INPUT_UV,\n        GATE_BOTTOM_INPUT_UV + vec2(.2, 0)\n    ) - GATE_ICON_THICKNESS);\n    \n    return sd;\n}\n\nfloat sd_and_gate(vec2 block_uv)\n{\n    float sd = sd_and_gate_no_output_line(block_uv);\n    \n    // output line\n    sd = min(sd, sd_segment(\n        block_uv,\n        vec2(.76, .5),\n        vec2(1, .5)\n    ) - GATE_ICON_THICKNESS);\n    \n    return sd;\n}\n\n#define N_SIDES_OR_GATE (3 * BEZIER_RES)\nDEFINE_SD_POLYGON(N_SIDES_OR_GATE)\n\nbool point_inside_or_gate(vec2 block_uv)\n{\n    vec2 p[N_SIDES_OR_GATE];\n    for (int i = 0; i < BEZIER_RES; i++)\n    {\n        p[i] = bezier(\n            vec2(.2, .8),\n            vec2(.5, .8),\n            vec2(.75, .5),\n            float(i) / float(BEZIER_RES)\n        );\n    }\n    for (int i = 0; i < BEZIER_RES; i++)\n    {\n        p[BEZIER_RES + i] = bezier(\n            vec2(.75, .5),\n            vec2(.5, .2),\n            vec2(.2, .2),\n            float(i) / float(BEZIER_RES)\n        );\n    }\n    for (int i = 0; i < BEZIER_RES; i++)\n    {\n        p[2 * BEZIER_RES + i] = bezier(\n            vec2(.2, .2),\n            vec2(.43, .5),\n            vec2(.2, .8),\n            float(i) / float(BEZIER_RES)\n        );\n    }\n    \n    return sd_polygon(block_uv, p) < 0.;\n}\n\nbool point_inside_xor_gate(vec2 block_uv)\n{\n    return point_inside_or_gate(block_uv);\n}\n\nbool point_inside_nor_gate(vec2 block_uv)\n{\n    return point_inside_or_gate(block_uv);\n}\n\nbool point_inside_xnor_gate(vec2 block_uv)\n{\n    return point_inside_or_gate(block_uv);\n}\n\nfloat sd_or_gate_no_output_line(vec2 block_uv)\n{\n    float sd = sd_bezier_approx(\n        block_uv,\n        vec2(.2, .8),\n        vec2(.5, .8),\n        vec2(.75, .5)\n    ) - GATE_ICON_THICKNESS;\n    \n    sd = min(sd, sd_bezier_approx(\n        block_uv,\n        vec2(.75, .5),\n        vec2(.5, .2),\n        vec2(.2, .2)\n    ) - GATE_ICON_THICKNESS);\n    \n    sd = min(sd, sd_bezier_approx(\n        block_uv,\n        vec2(.2, .2),\n        vec2(.43, .5),\n        vec2(.2, .8)\n    ) - GATE_ICON_THICKNESS);\n    \n    // input line 1\n    sd = min(sd, sd_segment(\n        block_uv,\n        GATE_TOP_INPUT_UV,\n        GATE_TOP_INPUT_UV + vec2(.28, 0)\n    ) - GATE_ICON_THICKNESS);\n    \n    // input line 2\n    sd = min(sd, sd_segment(\n        block_uv,\n        GATE_BOTTOM_INPUT_UV,\n        GATE_BOTTOM_INPUT_UV + vec2(.28, 0)\n    ) - GATE_ICON_THICKNESS);\n    \n    return sd;\n}\n\nfloat sd_or_gate(vec2 block_uv)\n{\n    float sd = sd_or_gate_no_output_line(block_uv);\n    \n    // output line\n    sd = min(sd, sd_segment(\n        block_uv,\n        vec2(.76, .5),\n        vec2(1, .5)\n    ) - GATE_ICON_THICKNESS);\n    \n    return sd;\n}\n\nfloat sd_xor_gate_no_output_line(vec2 block_uv)\n{\n    float sd = sd_or_gate_no_output_line(block_uv);\n    \n    sd = min(sd, sd_bezier_approx(\n        block_uv + vec2(.08, 0),\n        vec2(.2, .8),\n        vec2(.43, .5),\n        vec2(.2, .2)\n    ) - GATE_ICON_THICKNESS);\n    \n    return sd;\n}\n\nfloat sd_xor_gate(vec2 block_uv)\n{\n    float sd = sd_xor_gate_no_output_line(block_uv);\n    \n    // output line\n    sd = min(sd, sd_segment(\n        block_uv,\n        vec2(.76, .5),\n        vec2(1, .5)\n    ) - GATE_ICON_THICKNESS);\n    \n    return sd;\n}\n\nfloat sd_gate_dot_and_output_line(vec2 block_uv)\n{\n    // dot (the dot at the end of NOT, NOR, XNOR, etc.)\n    float sd = abs(\n        distance(\n            block_uv,\n            vec2(.84, .5)\n        ) - .05\n    ) - GATE_ICON_THICKNESS;\n    \n    // output line\n    sd = min(sd, sd_segment(\n        block_uv,\n        vec2(.89, .5),\n        vec2(1, .5)\n    ) - GATE_ICON_THICKNESS);\n    \n    return sd;\n}\n\n#define N_SIDES_NOT_GATE 3\nDEFINE_SD_POLYGON(N_SIDES_NOT_GATE)\n\nbool point_inside_not_gate(vec2 block_uv)\n{\n    vec2 p[N_SIDES_NOT_GATE] = vec2[](\n        vec2(.2, .2),\n        vec2(.8, .5),\n        vec2(.2, .8)\n    );\n    return sd_polygon(block_uv, p) < 0.;\n}\n\nfloat sd_not_gate(vec2 block_uv)\n{\n    float sd = sd_segment(\n        block_uv,\n        vec2(.2, .2),\n        vec2(.8, .5)\n    ) - GATE_ICON_THICKNESS;\n    \n    sd = min(sd, sd_segment(\n        block_uv,\n        vec2(.2, .8),\n        vec2(.8, .5)\n    ) - GATE_ICON_THICKNESS);\n    \n    sd = min(sd, sd_segment(\n        block_uv,\n        vec2(.2, .2),\n        vec2(.2, .8)\n    ) - GATE_ICON_THICKNESS);\n    \n    // input line\n    sd = min(sd, sd_segment(\n        block_uv,\n        GATE_CENTER_INPUT_UV,\n        GATE_CENTER_INPUT_UV + vec2(.2, 0)\n    ) - GATE_ICON_THICKNESS);\n    \n    // output line\n    sd = min(sd, sd_segment(\n        block_uv,\n        vec2(.89, .5),\n        vec2(1, .5)\n    ) - GATE_ICON_THICKNESS);\n    \n    sd = min(sd, sd_gate_dot_and_output_line(block_uv));\n    \n    return sd;\n}\n\nfloat sd_nand_gate(vec2 block_uv)\n{\n    float sd = sd_and_gate_no_output_line(block_uv);\n    sd = min(sd, sd_gate_dot_and_output_line(block_uv));\n    return sd;\n}\n\nfloat sd_nor_gate(vec2 block_uv)\n{\n    float sd = sd_or_gate_no_output_line(block_uv);\n    sd = min(sd, sd_gate_dot_and_output_line(block_uv));\n    return sd;\n}\n\nfloat sd_xnor_gate(vec2 block_uv)\n{\n    float sd = sd_xor_gate_no_output_line(block_uv);\n    sd = min(sd, sd_gate_dot_and_output_line(block_uv));\n    return sd;\n}\n\nconst vec2 SWC_GATE_CIRCLE_CENTER = vec2(.46, .5);\nconst float SWC_GATE_CIRCLE_RADIUS = .29;\n\nbool point_inside_swc_gate(vec2 block_uv)\n{\n    return\n        dist_sq(block_uv, SWC_GATE_CIRCLE_CENTER)\n        < (SWC_GATE_CIRCLE_RADIUS * SWC_GATE_CIRCLE_RADIUS);\n}\n\nfloat sd_swc_gate(vec2 block_uv)\n{\n    float sd = abs(\n        distance(\n            block_uv,\n            SWC_GATE_CIRCLE_CENTER\n        ) - SWC_GATE_CIRCLE_RADIUS\n    ) - GATE_ICON_THICKNESS;\n    \n    // input line 1\n    sd = min(sd, sd_segment(\n        block_uv,\n        GATE_TOP_INPUT_UV,\n        GATE_TOP_INPUT_UV + vec2(.2, 0)\n    ) - GATE_ICON_THICKNESS);\n    \n    // input line 2\n    sd = min(sd, sd_segment(\n        block_uv,\n        GATE_BOTTOM_INPUT_UV,\n        GATE_BOTTOM_INPUT_UV + vec2(.2, 0)\n    ) - GATE_ICON_THICKNESS);\n    \n    // output line\n    sd = min(sd, sd_segment(\n        block_uv,\n        vec2(.76, .5),\n        vec2(1, .5)\n    ) - GATE_ICON_THICKNESS);\n    \n    // text\n    {\n        // S\n    \n        sd = min(sd, sd_segment(\n            block_uv,\n            vec2(.38, .62),\n            vec2(.3, .62)\n        ) - .5 * GATE_ICON_THICKNESS);\n        \n        sd = min(sd, sd_segment(\n            block_uv,\n            vec2(.3, .62),\n            vec2(.38, .38)\n        ) - .5 * GATE_ICON_THICKNESS);\n        \n        sd = min(sd, sd_segment(\n            block_uv,\n            vec2(.38, .38),\n            vec2(.3, .38)\n        ) - .5 * GATE_ICON_THICKNESS);\n        \n        // W\n        \n        sd = min(sd, sd_segment(\n            block_uv,\n            vec2(.42, .62),\n            vec2(.42, .38)\n        ) - .5 * GATE_ICON_THICKNESS);\n        \n        sd = min(sd, sd_segment(\n            block_uv,\n            vec2(.42, .38),\n            vec2(.46, .5)\n        ) - .5 * GATE_ICON_THICKNESS);\n        \n        sd = min(sd, sd_segment(\n            block_uv,\n            vec2(.46, .5),\n            vec2(.5, .38)\n        ) - .5 * GATE_ICON_THICKNESS);\n        \n        sd = min(sd, sd_segment(\n            block_uv,\n            vec2(.5, .38),\n            vec2(.5, .62)\n        ) - .5 * GATE_ICON_THICKNESS);\n        \n        // C\n        \n        sd = min(sd, sd_segment(\n            block_uv,\n            vec2(.62, .62),\n            vec2(.54, .62)\n        ) - .5 * GATE_ICON_THICKNESS);\n        \n        sd = min(sd, sd_segment(\n            block_uv,\n            vec2(.54, .62),\n            vec2(.54, .38)\n        ) - .5 * GATE_ICON_THICKNESS);\n        \n        sd = min(sd, sd_segment(\n            block_uv,\n            vec2(.54, .38),\n            vec2(.62, .38)\n        ) - .5 * GATE_ICON_THICKNESS);\n    }\n    \n    return sd;\n}\n\nbool point_inside_gate(vec2 block_uv, int gate_type)\n{\n    if (gate_type == GATE_TYPE_AND)\n    {\n        return point_inside_and_gate(block_uv);\n    }\n    else if (gate_type == GATE_TYPE_OR)\n    {\n        return point_inside_or_gate(block_uv);\n    }\n    else if (gate_type == GATE_TYPE_XOR)\n    {\n        return point_inside_xor_gate(block_uv);\n    }\n    else if (gate_type == GATE_TYPE_NOT)\n    {\n        return point_inside_not_gate(block_uv);\n    }\n    else if (gate_type == GATE_TYPE_NAND)\n    {\n        return point_inside_nand_gate(block_uv);\n    }\n    else if (gate_type == GATE_TYPE_NOR)\n    {\n        return point_inside_nor_gate(block_uv);\n    }\n    else if (gate_type == GATE_TYPE_XNOR)\n    {\n        return point_inside_xnor_gate(block_uv);\n    }\n    else if (gate_type == GATE_TYPE_SWC)\n    {\n        return point_inside_swc_gate(block_uv);\n    }\n    return false;\n}\n\nbool point_inside_gate_output(vec2 block_uv)\n{\n    float sd = sd_segment(\n        block_uv,\n        vec2(.89, .5),\n        vec2(1, .5)\n    ) - GATE_ICON_THICKNESS;\n    return sd < 0.;\n}\n\n\n\n/*_______________ DLS toolbar _________________*/\n\nvec2 dls_toolbar_uv(vec2 coord, vec2 res)\n{\n    return coord / res.x;\n}\n\nbool point_inside_dls_toolbar(vec2 toolbar_uv, vec2 res)\n{\n    vec2 uv_top_left = vec2(0, res.y) / res.x;\n    return\n        toolbar_uv.x <= TOOLBAR_BLOCK_SIZE * float(N_TOOLBAR_BLOCKS)\n        && toolbar_uv.y >= (uv_top_left.y - TOOLBAR_BLOCK_SIZE);\n}\n\nint dls_toolbar_block_idx(vec2 toolbar_uv)\n{\n    return iclamp(\n        int(toolbar_uv.x / TOOLBAR_BLOCK_SIZE),\n        0,\n        N_TOOLBAR_BLOCKS - 1\n    );\n}\n\nvec2 dls_toolbar_block_uv(vec2 toolbar_uv, vec2 res)\n{\n    vec2 uv_top_left = vec2(0, res.y) / res.x;\n    return vec2(\n        mod(toolbar_uv.x, TOOLBAR_BLOCK_SIZE) / TOOLBAR_BLOCK_SIZE,\n        (toolbar_uv.y - (uv_top_left.y - TOOLBAR_BLOCK_SIZE)) / TOOLBAR_BLOCK_SIZE\n    );\n}\n\n\n\n// The following is a copy of the tutorial comment posted by the author\n// under the original shader (https://www.shadertoy.com/view/XXG3zW).\n\n/*\nThis is a digital logic simulation shader for learning and experimenting with logic gates and digital circuits like binary adders, ALUs (arithmetic logic units), and if you're really nerdy, entire basic CPUs. It simulates logic values propagating inside wires, and logic gates that read & manipulate those values at their inputs and outputs.\n\nThis shader is written by bean.\nGitHub: [url]https://github.com/bean-mhm[/url]\n\n[b]DON'T PANIC[/b]\nIf it says \"Compiled in 0.0 secs\" and shows a black screen, it's lying to you. The shader is still being compiled, just wait for 30-60 seconds.\n\n[b]Controls[/b]\n[Hold Mouse] Draw / Erase\n[Click] Select tool\n[C] Clear\n[i]NOTE: Resolution changes will reset everything and cause data loss.[/i]\n\n[b]Toolbar[/b]\nClick on the icons in the toolbar to change the draw mode to one of the following, respectively.\n- Wire brush\n- Eraser\n- Inject 0 in wire\n- Inject 1 in wire\n- AND gate\n- OR gate\n- XOR gate\n- NOT gate\n- NAND gate\n- NOR gate\n- XNOR gate\n- SWC gate\n\n[b]How logic gates work[/b]\n\nThe following terms refer to the same thing: 0, false, low, and off. Same with 1, true, high, and on.\n\n[i]AND[/i] outputs true if both inputs are true.\n[i]OR[/i] outputs true if either input is true.\n[i]XOR[/i] outputs true if the inputs have different values.\n\n[i]NOT[/i] outputs the inverted version of the input ([i]NOT[/i] has only one input).\n\n[i]NAND[/i] outputs true if either input is false.\n[i]NOR[/i] outputs true if both inputs are false.\n[i]XNOR[/i] outputs true if the inputs have equal values.\n\n[i]SWC[/i] outputs the first input only if the second input is true, does nothing otherwise.\n\n[b]Colors in wires[/b]\nThis is kinda obvious, but green means high, and red is low.\n*/\n\n\n\n// The following is a copy of my personal to-do list for this project\n\n/*\ndata buffer\n- new draw modes for the gates\n\nimage\n- icons for the new draw modes\n\ngate buffer\n- contains an array of logic gates\n- struct LogicGate:\n    type: int GATE_TYPE_AND\n    icoord_bottom_left: ivec2\n- [C] should clear the gates too\n- if draw mode is a gate, add it if mouse is down in this frame but wasnt in prev frame\n\nimage\n- iterate through the gate array from the gate buffer and see if we're inside\n  one, and if so, render that gate.\n- fill the interior of the gates\n\ngate buffer\n- if mouse is on a gate already, don't add anything\n- if mouse is on a gate and draw mode is erase, delete it on mouse press\n\nDLS buffer\n- don't run simulation inside a logic gate (ignore wires under gates)\n- if at the output of a logic gate, do the operation based on the inputs\n\nDLS buffer\n- only draw wires if prev_mouse_down is on, use line segments to avoid the nasty cirlce issue (use prev_imouse)\n*/",
     "name": "Common",
     "description": "",
     "type": "common"
    },
    {
     "inputs": [
      {
       "id": "4dXGRr",
       "filepath": "/presets/tex00.jpg",
       "type": "keyboard",
       "channel": 3,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4sXGR8",
       "filepath": "/media/previz/buffer02.png",
       "type": "buffer",
       "channel": 2,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "// simulation buffer. this stores wire states and \"last updated\"\n// values.\n\n#if SHADERTOY\n// iChannel1 must be set to Keyboard in Shadertoy\n#define SHADERTOY_KEYBOARD_CH iChannel3\n#else\n#iKeyboard\n#endif\n\ndefine_keyboard_utils\n\n#define ICHANNEL_SELF iChannel0\n#define ICHANNEL_GATE_BUF iChannel1\n#define ICHANNEL_DATA_BUF iChannel2\n\nvoid dls_fetch(\n    ivec2 icoord,\n    out int wire_state,\n    out int last_updated\n)\n{\n    if (!icoord_in_bounds(\n        icoord,\n        ivec2(iResolution.xy)\n    ))\n    {\n        wire_state = WIRE_STATE_NOT_WIRE;\n        last_updated = -1;\n        return;\n    }\n    \n    vec4 data = texelFetch(ICHANNEL_SELF, icoord, 0);\n    dls_decode(data, wire_state, last_updated);\n}\n\nvoid gate_fetch(\n    int idx,\n    out int gate_type,\n    out ivec2 icoord_bl\n)\n{\n    if (idx < 0 || idx >= N_GATES)\n    {\n        gate_type = GATE_TYPE_NONE;\n        icoord_bl = ivec2(0);\n        return;\n    }\n    \n    ivec2 icoord = idx_to_icoord(idx, GATE_BUF_SIZE);\n    vec4 data = texelFetch(ICHANNEL_GATE_BUF, icoord, 0);\n    gate_buf_decode(data, gate_type, icoord_bl);\n}\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    // values from the data buffer\n    ivec2 res;\n    int draw_mode;\n    bool prev_mouse_down;\n    ivec2 prev_imouse;\n    data_buf_decode(\n        texelFetch(ICHANNEL_DATA_BUF, ivec2(0), 0),\n        res,\n        draw_mode,\n        prev_mouse_down,\n        prev_imouse\n    );\n    \n    // resolution changed since last frame?\n    bool res_changed = imax(\n        iabs(res.x - int(iResolution.x)),\n        iabs(res.y - int(iResolution.y))\n    ) > 0;\n    \n    // are we in the first frame?\n    bool first_frame = (iFrame < 1) || (iTime < .02);\n\n    // set initial values and return on resolution change or\n    // the first frame, or if C is pressed\n    if (res_changed || first_frame || is_key_pressed(Key_C))\n    {\n        frag_col = dls_encode(\n            WIRE_STATE_NOT_WIRE,\n            -1\n        );\n        return;\n    }\n    \n    // see if mouse is in the toolbar\n    vec2 mouse_toolbar_uv = dls_toolbar_uv(iMouse.xy, iResolution.xy); \n    bool mouse_in_toolbar = point_inside_dls_toolbar(\n        mouse_toolbar_uv,\n        iResolution.xy\n    );\n    \n    ivec2 icoord = ivec2(frag_coord);\n    \n    // current pixel's values\n    int wire_state;\n    int last_updated;\n    dls_fetch(icoord, wire_state, last_updated);\n    \n    // see if the current pixel is inside a logic gate\n    bool inside_gate = false;\n    for (int i = 0; i < N_GATES; i++)\n    {\n        int gate_type;\n        ivec2 gate_icoord_bl;\n        gate_fetch(i, gate_type, gate_icoord_bl);\n        \n        if (gate_type == GATE_TYPE_NONE)\n        {\n            continue;\n        }\n        \n        ivec2 gate_icoord_tr = gate_icoord_bl + GATE_SIZE_PX;\n        vec2 block_uv =\n            (frag_coord - vec2(gate_icoord_bl) - .5) / float(GATE_SIZE_PX);\n        \n        if (point_inside_gate_output(block_uv))\n        {\n            // we're on the output of a gate so don't run the\n            // simulation, we'll perform the correct logic\n            // operation instead.\n            inside_gate = true;\n            \n            // read the wire states at the inputs\n            \n            ivec2 icoord_top_input = ivec2(\n                GATE_TOP_INPUT_UV * float(GATE_SIZE_PX)\n                + vec2(gate_icoord_bl) + .5\n            );\n            ivec2 icoord_bottom_input = ivec2(\n                GATE_BOTTOM_INPUT_UV * float(GATE_SIZE_PX)\n                + vec2(gate_icoord_bl) + .5\n            );\n            ivec2 icoord_center_input = ivec2(\n                GATE_CENTER_INPUT_UV * float(GATE_SIZE_PX)\n                + vec2(gate_icoord_bl) + .5\n            );\n            \n            int top_inp_state;\n            int bottom_inp_state;\n            int center_inp_state;\n            int dont_care_about_last_updated;\n            \n            dls_fetch(\n                icoord_top_input,\n                top_inp_state,\n                dont_care_about_last_updated\n            );\n            dls_fetch(\n                icoord_bottom_input,\n                bottom_inp_state,\n                dont_care_about_last_updated\n            );\n            dls_fetch(\n                icoord_center_input,\n                center_inp_state,\n                dont_care_about_last_updated\n            );\n            \n            // perform logic operations\n            if (gate_type == GATE_TYPE_AND)\n            {\n                if (top_inp_state == WIRE_STATE_LOW && bottom_inp_state == WIRE_STATE_LOW)\n                {\n                    wire_state = WIRE_STATE_LOW;\n                    last_updated = iFrame;\n                }\n                else if (top_inp_state == WIRE_STATE_LOW && bottom_inp_state == WIRE_STATE_HIGH)\n                {\n                    wire_state = WIRE_STATE_LOW;\n                    last_updated = iFrame;\n                }\n                else if (top_inp_state == WIRE_STATE_HIGH && bottom_inp_state == WIRE_STATE_LOW)\n                {\n                    wire_state = WIRE_STATE_LOW;\n                    last_updated = iFrame;\n                }\n                else if (top_inp_state == WIRE_STATE_HIGH && bottom_inp_state == WIRE_STATE_HIGH)\n                {\n                    wire_state = WIRE_STATE_HIGH;\n                    last_updated = iFrame;\n                }\n            }\n            else if (gate_type == GATE_TYPE_OR)\n            {\n                if (top_inp_state == WIRE_STATE_LOW && bottom_inp_state == WIRE_STATE_LOW)\n                {\n                    wire_state = WIRE_STATE_LOW;\n                    last_updated = iFrame;\n                }\n                else if (top_inp_state == WIRE_STATE_LOW && bottom_inp_state == WIRE_STATE_HIGH)\n                {\n                    wire_state = WIRE_STATE_HIGH;\n                    last_updated = iFrame;\n                }\n                else if (top_inp_state == WIRE_STATE_HIGH && bottom_inp_state == WIRE_STATE_LOW)\n                {\n                    wire_state = WIRE_STATE_HIGH;\n                    last_updated = iFrame;\n                }\n                else if (top_inp_state == WIRE_STATE_HIGH && bottom_inp_state == WIRE_STATE_HIGH)\n                {\n                    wire_state = WIRE_STATE_HIGH;\n                    last_updated = iFrame;\n                }\n            }\n            else if (gate_type == GATE_TYPE_XOR)\n            {\n                if (top_inp_state == WIRE_STATE_LOW && bottom_inp_state == WIRE_STATE_LOW)\n                {\n                    wire_state = WIRE_STATE_LOW;\n                    last_updated = iFrame;\n                }\n                else if (top_inp_state == WIRE_STATE_LOW && bottom_inp_state == WIRE_STATE_HIGH)\n                {\n                    wire_state = WIRE_STATE_HIGH;\n                    last_updated = iFrame;\n                }\n                else if (top_inp_state == WIRE_STATE_HIGH && bottom_inp_state == WIRE_STATE_LOW)\n                {\n                    wire_state = WIRE_STATE_HIGH;\n                    last_updated = iFrame;\n                }\n                else if (top_inp_state == WIRE_STATE_HIGH && bottom_inp_state == WIRE_STATE_HIGH)\n                {\n                    wire_state = WIRE_STATE_LOW;\n                    last_updated = iFrame;\n                }\n            }\n            else if (gate_type == GATE_TYPE_NOT)\n            {\n                if (center_inp_state == WIRE_STATE_LOW)\n                {\n                    wire_state = WIRE_STATE_HIGH;\n                    last_updated = iFrame;\n                }\n                else if (center_inp_state == WIRE_STATE_HIGH)\n                {\n                    wire_state = WIRE_STATE_LOW;\n                    last_updated = iFrame;\n                }\n            }\n            else if (gate_type == GATE_TYPE_NAND)\n            {\n                if (top_inp_state == WIRE_STATE_LOW && bottom_inp_state == WIRE_STATE_LOW)\n                {\n                    wire_state = WIRE_STATE_HIGH;\n                    last_updated = iFrame;\n                }\n                else if (top_inp_state == WIRE_STATE_LOW && bottom_inp_state == WIRE_STATE_HIGH)\n                {\n                    wire_state = WIRE_STATE_HIGH;\n                    last_updated = iFrame;\n                }\n                else if (top_inp_state == WIRE_STATE_HIGH && bottom_inp_state == WIRE_STATE_LOW)\n                {\n                    wire_state = WIRE_STATE_HIGH;\n                    last_updated = iFrame;\n                }\n                else if (top_inp_state == WIRE_STATE_HIGH && bottom_inp_state == WIRE_STATE_HIGH)\n                {\n                    wire_state = WIRE_STATE_LOW;\n                    last_updated = iFrame;\n                }\n            }\n            else if (gate_type == GATE_TYPE_NOR)\n            {\n                if (top_inp_state == WIRE_STATE_LOW && bottom_inp_state == WIRE_STATE_LOW)\n                {\n                    wire_state = WIRE_STATE_HIGH;\n                    last_updated = iFrame;\n                }\n                else if (top_inp_state == WIRE_STATE_LOW && bottom_inp_state == WIRE_STATE_HIGH)\n                {\n                    wire_state = WIRE_STATE_LOW;\n                    last_updated = iFrame;\n                }\n                else if (top_inp_state == WIRE_STATE_HIGH && bottom_inp_state == WIRE_STATE_LOW)\n                {\n                    wire_state = WIRE_STATE_LOW;\n                    last_updated = iFrame;\n                }\n                else if (top_inp_state == WIRE_STATE_HIGH && bottom_inp_state == WIRE_STATE_HIGH)\n                {\n                    wire_state = WIRE_STATE_LOW;\n                    last_updated = iFrame;\n                }\n            }\n            else if (gate_type == GATE_TYPE_XNOR)\n            {\n                if (top_inp_state == WIRE_STATE_LOW && bottom_inp_state == WIRE_STATE_LOW)\n                {\n                    wire_state = WIRE_STATE_HIGH;\n                    last_updated = iFrame;\n                }\n                else if (top_inp_state == WIRE_STATE_LOW && bottom_inp_state == WIRE_STATE_HIGH)\n                {\n                    wire_state = WIRE_STATE_LOW;\n                    last_updated = iFrame;\n                }\n                else if (top_inp_state == WIRE_STATE_HIGH && bottom_inp_state == WIRE_STATE_LOW)\n                {\n                    wire_state = WIRE_STATE_LOW;\n                    last_updated = iFrame;\n                }\n                else if (top_inp_state == WIRE_STATE_HIGH && bottom_inp_state == WIRE_STATE_HIGH)\n                {\n                    wire_state = WIRE_STATE_HIGH;\n                    last_updated = iFrame;\n                }\n            }\n            else if (gate_type == GATE_TYPE_SWC)\n            {\n                if (top_inp_state == WIRE_STATE_LOW && bottom_inp_state == WIRE_STATE_LOW)\n                {\n                    // do nothing\n                }\n                else if (top_inp_state == WIRE_STATE_LOW && bottom_inp_state == WIRE_STATE_HIGH)\n                {\n                    wire_state = WIRE_STATE_LOW;\n                    last_updated = iFrame;\n                }\n                else if (top_inp_state == WIRE_STATE_HIGH && bottom_inp_state == WIRE_STATE_LOW)\n                {\n                    // do nothing\n                }\n                else if (top_inp_state == WIRE_STATE_HIGH && bottom_inp_state == WIRE_STATE_HIGH)\n                {\n                    wire_state = WIRE_STATE_HIGH;\n                    last_updated = iFrame;\n                }\n            }\n            \n            break;\n        }\n        if (point_inside_gate(block_uv, gate_type))\n        {\n            // we're inside a gate so don't run the simulation\n            inside_gate = true;\n            break;\n        }\n    }\n    \n    // only run the simulation for wire pixels, and not inside gates\n    if (wire_state != WIRE_STATE_NOT_WIRE && !inside_gate)\n    {\n        // check neighbors (5x5 window excluding the center)\n        for (int y_offs = -2; y_offs <= 2; y_offs++)\n        {\n            for (int x_offs = -2; x_offs <= 2; x_offs++)\n            {\n                // skip self (offset=0)\n                ivec2 offs = ivec2(x_offs, y_offs);\n                if (offs == ivec2(0))\n                {\n                    continue;\n                }\n                \n                // fetch neighbor's values\n                int neighbor_wire_state;\n                int neighbor_last_updated;\n                dls_fetch(\n                    icoord + offs,\n                    neighbor_wire_state,\n                    neighbor_last_updated\n                );\n                \n                // skip if neighbor is not a wire\n                if (neighbor_wire_state == WIRE_STATE_NOT_WIRE)\n                {\n                    continue;\n                }\n                \n                // only care about connected neighbors\n                if (neighbor_wire_state == WIRE_STATE_DISCONNECTED)\n                {\n                    continue;\n                }\n                \n                // if we're disconnected\n                if (wire_state == WIRE_STATE_DISCONNECTED)\n                {\n                    // change our values to that of the neighbor\n                    wire_state = neighbor_wire_state;\n                    last_updated = neighbor_last_updated;\n                }\n                \n                // or if we're connected and neighbor has a more recent value\n                if (neighbor_last_updated > last_updated\n                    && wire_state != WIRE_STATE_DISCONNECTED)\n                {\n                    // change our values to that of the neighbor\n                    wire_state = neighbor_wire_state;\n                    last_updated = neighbor_last_updated;\n                }\n            }\n        }\n        \n        // if mouse is down and on this pixel (and it's a wire)\n        if (iMouse.z > .5 && ivec2(iMouse.xy) == icoord && !mouse_in_toolbar)\n        {\n            // draw wire state\n            if (draw_mode == DRAW_MODE_WIRE_LOW)\n            {\n                wire_state = WIRE_STATE_LOW;\n                last_updated = iFrame;\n            }\n            else if (draw_mode == DRAW_MODE_WIRE_HIGH)\n            {\n                wire_state = WIRE_STATE_HIGH;\n                last_updated = iFrame;\n            }\n        }\n    }\n    \n    // on mouse down\n    if (iMouse.z > .5 && prev_mouse_down && !mouse_in_toolbar)\n    {\n        float line_segment_dist = sd_segment(\n            frag_coord,\n            vec2(prev_imouse) + .5,\n            iMouse.xy\n        );\n    \n        // draw wires\n        if (draw_mode == DRAW_MODE_WIRE\n            && line_segment_dist < BRUSH_THICKNESS_PX\n            && wire_state == WIRE_STATE_NOT_WIRE)\n        {\n            wire_state = WIRE_STATE_DISCONNECTED;\n            last_updated = -1;\n        }\n        \n        // erase wires\n        if (draw_mode == DRAW_MODE_ERASE\n            && line_segment_dist < ERASER_THICKNESS_PX)\n        {\n            wire_state = WIRE_STATE_NOT_WIRE;\n            last_updated = -1;\n        }\n    }\n    \n    // output the new values\n    frag_col = dls_encode(wire_state, last_updated);\n}\n",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [
      {
       "id": "4dXGRr",
       "filepath": "/presets/tex00.jpg",
       "type": "keyboard",
       "channel": 3,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4sXGR8",
       "filepath": "/media/previz/buffer02.png",
       "type": "buffer",
       "channel": 2,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "XsXGR8",
       "channel": 0
      }
     ],
     "code": "// gate buffer. this stores a fixed array of logic gates. by\n// default, the elements are initialized to represent no gates,\n// but they can change based on user input.\n\n// this buffer operates in the bottom left GATE_BUF_SIZE block\n// of pixels, so it stores a fixed array of\n// (GATE_BUF_SIZE.x * GATE_BUF_SIZE.y) gates. each pixel stores\n// a gate's type and its bottom left coordinates in pixel space.\n// the simulation buffer uses this info to perform boolean\n// operations at the gate outputs, and the image tab uses this\n// buffer to render the gates.\n\n#if SHADERTOY\n// iChannel1 must be set to Keyboard in Shadertoy\n#define SHADERTOY_KEYBOARD_CH iChannel3\n#else\n#iKeyboard\n#endif\n\ndefine_keyboard_utils\n\n#define ICHANNEL_SIM_BUF iChannel0\n#define ICHANNEL_SELF iChannel1\n#define ICHANNEL_DATA_BUF iChannel2\n\nvoid gate_fetch(\n    int idx,\n    out int gate_type,\n    out ivec2 icoord_bl\n)\n{\n    if (idx < 0 || idx >= N_GATES)\n    {\n        gate_type = GATE_TYPE_NONE;\n        icoord_bl = ivec2(0);\n        return;\n    }\n    \n    ivec2 icoord = idx_to_icoord(idx, GATE_BUF_SIZE);\n    vec4 data = texelFetch(ICHANNEL_SELF, icoord, 0);\n    gate_buf_decode(data, gate_type, icoord_bl);\n}\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    ivec2 icoord = ivec2(frag_coord);\n    \n    // only care about the bottom left block\n    if (!icoord_in_bounds(icoord, GATE_BUF_SIZE))\n    {\n        return;\n    }\n    \n    // 1D index of this pixel in the buffer\n    int my_idx = icoord_to_idx(icoord, GATE_BUF_SIZE);\n    \n    // values from the data buffer\n    ivec2 res;\n    int draw_mode;\n    bool prev_mouse_down;\n    ivec2 prev_imouse;\n    data_buf_decode(\n        texelFetch(ICHANNEL_DATA_BUF, ivec2(0), 0),\n        res,\n        draw_mode,\n        prev_mouse_down,\n        prev_imouse\n    );\n    \n    // resolution changed since last frame?\n    bool res_changed = imax(\n        iabs(res.x - int(iResolution.x)),\n        iabs(res.y - int(iResolution.y))\n    ) > 0;\n    \n    // are we in the first frame?\n    bool first_frame = (iFrame < 1) || (iTime < .02);\n\n    // set initial values and return on resolution change or\n    // the first frame, or if C is pressed\n    if (res_changed || first_frame || is_key_pressed(Key_C))\n    {\n        frag_col = gate_buf_encode(\n            GATE_TYPE_NONE,\n            ivec2(0)\n        );\n        return;\n    }\n    \n    // see if mouse is in the toolbar\n    vec2 mouse_toolbar_uv = dls_toolbar_uv(iMouse.xy, iResolution.xy); \n    bool mouse_in_toolbar = point_inside_dls_toolbar(\n        mouse_toolbar_uv,\n        iResolution.xy\n    );\n    \n    // current values\n    int gate_type;\n    ivec2 icoord_bl;\n    gate_buf_decode(\n        texelFetch(ICHANNEL_SELF, icoord, 0),\n        gate_type,\n        icoord_bl\n    );\n    \n    // on mouse down and in erase mode\n    if (iMouse.z > .5\n        && prev_mouse_down\n        && !mouse_in_toolbar\n        && draw_mode == DRAW_MODE_ERASE)\n    {\n        // find the index of the gate under the mouse\n        int delete_idx = -1;\n        for (int i = 0; i < N_GATES; i++)\n        {\n            int elem_gate_type;\n            ivec2 elem_icoord_bl;\n            gate_fetch(i, elem_gate_type, elem_icoord_bl);\n            \n            // skip empty slots\n            if (elem_gate_type == GATE_TYPE_NONE)\n            {\n                continue;\n            }\n            \n            // is the gate under the mouse?\n            ivec2 elem_icoord_tr = elem_icoord_bl + GATE_SIZE_PX;\n            ivec2 imouse = ivec2(iMouse.xy);\n            bool under_mouse =\n                all(greaterThanEqual(imouse, elem_icoord_bl))\n                && all(lessThan(imouse, elem_icoord_tr));\n            \n            if (!under_mouse)\n            {\n                continue;\n            }\n            \n            // found a gate under the mouse\n            delete_idx = i;\n            break;\n        }\n        \n        // if we found a gate to delete and it's exactly this pixel\n        if (delete_idx != -1 && delete_idx == my_idx)\n        {\n            // reset this pixel to delete the gate\n            gate_type = GATE_TYPE_NONE;\n            icoord_bl = ivec2(0);\n        }\n    }\n    \n    // on mouse press\n    if (iMouse.z > .5\n        && !prev_mouse_down\n        && !mouse_in_toolbar)\n    {\n        // do we need to add a gate? and what type?\n        int gate_to_add = GATE_TYPE_NONE;\n        if (draw_mode == DRAW_MODE_GATE_AND)\n        {\n            gate_to_add = GATE_TYPE_AND;\n        }\n        else if (draw_mode == DRAW_MODE_GATE_OR)\n        {\n            gate_to_add = GATE_TYPE_OR;\n        }\n        else if (draw_mode == DRAW_MODE_GATE_XOR)\n        {\n            gate_to_add = GATE_TYPE_XOR;\n        }\n        else if (draw_mode == DRAW_MODE_GATE_NOT)\n        {\n            gate_to_add = GATE_TYPE_NOT;\n        }\n        else if (draw_mode == DRAW_MODE_GATE_NAND)\n        {\n            gate_to_add = GATE_TYPE_NAND;\n        }\n        else if (draw_mode == DRAW_MODE_GATE_NOR)\n        {\n            gate_to_add = GATE_TYPE_NOR;\n        }\n        else if (draw_mode == DRAW_MODE_GATE_XNOR)\n        {\n            gate_to_add = GATE_TYPE_XNOR;\n        }\n        else if (draw_mode == DRAW_MODE_GATE_SWC)\n        {\n            gate_to_add = GATE_TYPE_SWC;\n        }\n        \n        // if we need to add a gate\n        if (gate_to_add != GATE_TYPE_NONE)\n        {\n            // bounds of the new gate to add\n            ivec2 gate_to_add_bl = ivec2(iMouse.xy) - GATE_SIZE_PX / 2;\n            ivec2 gate_to_add_tr = gate_to_add_bl + GATE_SIZE_PX;\n            \n            // find the index of the first empty slot\n            int empty_idx = -1;\n            for (int i = 0; i < N_GATES; i++)\n            {\n                int elem_gate_type;\n                ivec2 elem_icoord_bl;\n                gate_fetch(i, elem_gate_type, elem_icoord_bl);\n                \n                // if slot already occupied\n                if (elem_gate_type != GATE_TYPE_NONE)\n                {\n                    // does the gate in this slot intersect with the\n                    // bounds of the new gate we wanna add?\n                    ivec2 elem_icoord_tr = elem_icoord_bl + GATE_SIZE_PX;\n                    bool intersects =\n                        elem_icoord_tr.x >= gate_to_add_bl.x\n                        && elem_icoord_bl.x <= gate_to_add_tr.x\n                        && elem_icoord_tr.y - GATE_VERT_PADDING >= gate_to_add_bl.y + GATE_VERT_PADDING\n                        && elem_icoord_bl.y + GATE_VERT_PADDING <= gate_to_add_tr.y - GATE_VERT_PADDING;\n                    \n                    // if so, just don't add the new gate\n                    if (intersects)\n                    {\n                        break;\n                    }\n                    \n                    // otherwise, skip this slot and continue looking\n                    // for an empty slot\n                    continue;\n                }\n                \n                // found an empty slot\n                empty_idx = i;\n                break;\n            }\n            \n            // if we found an empty slot and it's exactly this pixel\n            if (empty_idx != -1 && empty_idx == my_idx)\n            {\n                // update this pixel\n                gate_type = gate_to_add;\n                icoord_bl = gate_to_add_bl;\n            }\n        }\n    }\n    \n    // output the new values\n    frag_col = gate_buf_encode(\n        gate_type,\n        icoord_bl\n    );\n}\n",
     "name": "Buffer B",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [
      {
       "id": "4sXGR8",
       "filepath": "/media/previz/buffer02.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4sXGR8",
       "channel": 0
      }
     ],
     "code": "// data buffer. this stores the last frame's resolution, the\n// current draw mode, whether the mouse button was down in\n// the previous frame, and the mouse coordinates in the\n// previous frame.\n\n#define ICHANNEL_SELF iChannel0\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    ivec2 icoord = ivec2(frag_coord);\n    \n    // only care about pixel (0, 0)\n    if (icoord != ivec2(0))\n    {\n        return;\n    }\n    \n    // current values\n    ivec2 res;\n    int draw_mode;\n    bool prev_mouse_down;\n    ivec2 prev_imouse;\n    data_buf_decode(\n        texelFetch(ICHANNEL_SELF, icoord, 0),\n        res,\n        draw_mode,\n        prev_mouse_down,\n        prev_imouse\n    );\n    \n    // resolution changed since last frame?\n    bool res_changed = imax(\n        iabs(res.x - int(iResolution.x)),\n        iabs(res.y - int(iResolution.y))\n    ) > 0;\n    \n    // set resolution to the current resolution\n    res = ivec2(iResolution.xy);\n\n    // are we in the first frame?\n    bool first_frame = (iFrame < 1) || (iTime < .02);\n    \n    // reset on resolution change or the first frame\n    if (res_changed || first_frame)\n    {\n        draw_mode = DRAW_MODE_WIRE;\n        prev_mouse_down = false;\n        prev_imouse = ivec2(iMouse.xy);\n    }\n    \n    // change draw mode with mouse\n    {\n        vec2 mouse_toolbar_uv = dls_toolbar_uv(iMouse.xy, iResolution.xy);\n        \n        bool mouse_in_toolbar = point_inside_dls_toolbar(\n            mouse_toolbar_uv,\n            iResolution.xy\n        );\n        \n        if (mouse_in_toolbar && iMouse.z > .5 && !prev_mouse_down)\n        {\n            int block_idx = dls_toolbar_block_idx(mouse_toolbar_uv);\n            draw_mode = block_idx;\n        }\n    }\n    \n    // output the new values\n    frag_col = data_buf_encode(\n        res,\n        draw_mode,\n        iMouse.z > .5,\n        ivec2(iMouse.xy)\n    );\n}\n",
     "name": "Buffer C",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "X33XDN",
    "date": "1719435553",
    "viewed": 630,
    "name": "DLS + Wire Cross + Clock + Rot",
    "description": "See the first comment for tutorial and description.\nSee the first comment for tutorial and description.\nSee the first comment for tutorial and description.\nSee the first comment for tutorial and description.\n",
    "likes": 26,
    "published": "Public API",
    "usePreview": 1,
    "tags": [
     "2d",
     "binary",
     "simulation",
     "digital",
     "wires",
     "ui",
     "physics",
     "gui",
     "chip",
     "logic",
     "turing",
     "sim",
     "wire",
     "gates",
     "complete",
     "dls",
     "voltage"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGRr",
       "filepath": "/presets/tex00.jpg",
       "type": "keyboard",
       "channel": 3,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4sXGR8",
       "filepath": "/media/previz/buffer02.png",
       "type": "buffer",
       "channel": 2,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// the image tab finally takes the wire state info from the\n// simulation buffer and displays them with different colors.\n// it also shows a panel at the top left showing the available\n// draw modes with their icons, and highlighting the selected\n// one. it also shows a circle outline around the cursor when\n// the mouse button is down and draw mode is set to erase.\n// it iterates through the gate buffer and renders the logic\n// gates.\n\n#if SHADERTOY\n// iChannel3 must be set to Keyboard in Shadertoy\n#define SHADERTOY_KEYBOARD_CH iChannel3\n#else\n#iKeyboard\n#endif\n\ndefine_keyboard_utils\n\n#define ICHANNEL_SIM_BUF iChannel0\n#define ICHANNEL_GATE_BUF iChannel1\n#define ICHANNEL_DATA_BUF iChannel2\n\nvoid dls_fetch(\n    ivec2 icoord,\n    out int wire_state,\n    out int last_updated\n)\n{\n    if (!icoord_in_bounds(\n        icoord,\n        ivec2(iResolution.xy)\n    ))\n    {\n        wire_state = WIRE_STATE_NOT_WIRE;\n        last_updated = -1;\n        return;\n    }\n    \n    vec4 data = texelFetch(ICHANNEL_SIM_BUF, icoord, 0);\n    dls_decode(data, wire_state, last_updated);\n}\n\nvoid gate_fetch(\n    int idx,\n    out int gate_type,\n    out int rotation,\n    out int clock_interval,\n    out ivec2 icoord_bl\n)\n{\n    if (idx < 0 || idx >= N_GATES)\n    {\n        gate_type = GATE_TYPE_NONE;\n        icoord_bl = ivec2(0);\n        return;\n    }\n    \n    ivec2 icoord = idx_to_icoord(idx, GATE_BUF_SIZE);\n    vec4 data = texelFetch(ICHANNEL_GATE_BUF, icoord, 0);\n    gate_buf_decode(\n        data,\n        gate_type,\n        rotation,\n        clock_interval,\n        icoord_bl\n    );\n}\n\nvec3 render_gate(\n    vec3 col,\n    int gate_type,\n    int clock_interval,\n    vec2 block_uv,\n    float block_uv_1px\n)\n{\n    if (gate_type == GATE_TYPE_AND)\n    {\n        if (point_inside_and_gate(block_uv))\n        {\n            col = COL_AND_GATE;\n        }\n        \n        float sd = sd_and_gate(block_uv);\n        col = mix(\n            col,\n            vec3(.7),\n            remap01(sd, .4 * block_uv_1px, -.4 * block_uv_1px)\n        );\n    }\n    else if (gate_type == GATE_TYPE_OR)\n    {\n        if (point_inside_or_gate(block_uv))\n        {\n            col = COL_OR_GATE;\n        }\n        \n        float sd = sd_or_gate(block_uv);\n        col = mix(\n            col,\n            vec3(.7),\n            remap01(sd, .4 * block_uv_1px, -.4 * block_uv_1px)\n        );\n    }\n    else if (gate_type == GATE_TYPE_XOR)\n    {\n        if (point_inside_xor_gate(block_uv))\n        {\n            col = COL_XOR_GATE;\n        }\n        \n        float sd = sd_xor_gate(block_uv);\n        col = mix(\n            col,\n            vec3(.7),\n            remap01(sd, .4 * block_uv_1px, -.4 * block_uv_1px)\n        );\n    }\n    else if (gate_type == GATE_TYPE_NOT)\n    {\n        if (point_inside_not_gate(block_uv))\n        {\n            col = COL_NOT_GATE;\n        }\n        \n        float sd = sd_not_gate(block_uv);\n        col = mix(\n            col,\n            vec3(.7),\n            remap01(sd, .4 * block_uv_1px, -.4 * block_uv_1px)\n        );\n    }\n    else if (gate_type == GATE_TYPE_NAND)\n    {\n        if (point_inside_nand_gate(block_uv))\n        {\n            col = COL_NAND_GATE;\n        }\n        \n        float sd = sd_nand_gate(block_uv);\n        col = mix(\n            col,\n            vec3(.7),\n            remap01(sd, .4 * block_uv_1px, -.4 * block_uv_1px)\n        );\n    }\n    else if (gate_type == GATE_TYPE_NOR)\n    {\n        if (point_inside_nor_gate(block_uv))\n        {\n            col = COL_NOR_GATE;\n        }\n        \n        float sd = sd_nor_gate(block_uv);\n        col = mix(\n            col,\n            vec3(.7),\n            remap01(sd, .4 * block_uv_1px, -.4 * block_uv_1px)\n        );\n    }\n    else if (gate_type == GATE_TYPE_XNOR)\n    {\n        if (point_inside_xnor_gate(block_uv))\n        {\n            col = COL_XNOR_GATE;\n        }\n        \n        float sd = sd_xnor_gate(block_uv);\n        col = mix(\n            col,\n            vec3(.7),\n            remap01(sd, .4 * block_uv_1px, -.4 * block_uv_1px)\n        );\n    }\n    else if (gate_type == GATE_TYPE_SWITCH)\n    {\n        if (point_inside_switch_gate(block_uv))\n        {\n            col = COL_SWITCH_GATE;\n        }\n        \n        float sd = sd_switch_gate(block_uv);\n        col = mix(\n            col,\n            vec3(.7),\n            remap01(sd, .4 * block_uv_1px, -.4 * block_uv_1px)\n        );\n    }\n    else if (gate_type == GATE_TYPE_CLOCK)\n    {\n        if (point_inside_clock_gate(block_uv))\n        {\n            col = COL_CLOCK_GATE;\n        }\n        \n        float sd = sd_clock_gate(block_uv, clock_interval);\n        col = mix(\n            col,\n            vec3(.7),\n            remap01(sd, .4 * block_uv_1px, -.4 * block_uv_1px)\n        );\n    }\n    else if (gate_type == GATE_TYPE_CROSS)\n    {\n        float sd = sd_cross_gate(block_uv);\n        col = mix(\n            col,\n            vec3(.7),\n            remap01(sd, .4 * block_uv_1px, -.4 * block_uv_1px)\n        );\n    }\n    return col;\n}\n\nvec3 render_gates(\n    vec3 col,\n    vec2 coord\n)\n{\n    ivec2 icoord = ivec2(coord);\n    for (int i = 0; i < N_GATES; i++)\n    {\n        int gate_type;\n        int gate_rotation;\n        int clock_interval;\n        ivec2 gate_icoord_bl;\n        gate_fetch(i, gate_type, gate_rotation, clock_interval, gate_icoord_bl);\n\n        if (gate_type == GATE_TYPE_NONE)\n        {\n            continue;\n        }\n        \n        ivec2 gate_icoord_tr = gate_icoord_bl + GATE_SIZE_PX;\n        if (any(lessThan(icoord, gate_icoord_bl))\n            || any(greaterThanEqual(icoord, gate_icoord_tr)))\n        {\n            continue;\n        }\n        \n        vec2 block_uv_norot = clamp(\n            (coord - vec2(gate_icoord_bl) - .5) / float(GATE_SIZE_PX),\n            0.,\n            1.\n        );\n        vec2 block_uv = rotate_block_uv(block_uv_norot, gate_rotation);\n        float block_uv_1px = 1. / float(GATE_SIZE_PX);\n        \n        col = render_gate(\n            col,\n            gate_type,\n            clock_interval,\n            block_uv,\n            block_uv_1px\n        );\n    }\n    return col;\n}\n\nvec3 render_eraser_size_indicator(\n    vec3 col,\n    vec2 coord,\n    int draw_mode\n)\n{\n    vec2 mouse_toolbar_uv = dls_toolbar_uv(iMouse.xy, iResolution.xy); \n    bool mouse_in_toolbar = point_inside_dls_toolbar(\n        mouse_toolbar_uv,\n        iResolution.xy\n    );\n    \n    if (iMouse.z < .5 || draw_mode != DRAW_MODE_ERASE || mouse_in_toolbar)\n    {\n        return col;\n    }\n    \n    float eraser_thick = eraser_thickness_px(is_key_down(Key_Shift));\n\n    float d = distance(coord, iMouse.xy);\n    float sd = max(\n        -(d - eraser_thick),\n        d - eraser_thick - 3.\n    );\n    col = mix(\n        col,\n        vec3(.7),\n        remap01(sd, .4, -.4)\n    );\n    return col;\n}\n\nvec3 render_draw_mode_block(\n    vec3 col,\n    int block_idx,\n    vec2 block_uv,\n    float block_uv_1px\n)\n{\n    if (block_idx == DRAW_MODE_WIRE)\n    {\n        float sd = sd_oriented_box(block_uv, vec2(.38), vec2(.7), .15);\n        sd = min(\n            sd,\n            sd_oriented_box(block_uv, vec2(.3), vec2(.6), .07)\n        );\n        col = mix(\n            col,\n            vec3(.7),\n            remap01(sd, .4 * block_uv_1px, -.4 * block_uv_1px)\n        );\n    }\n    else if (block_idx == DRAW_MODE_ERASE)\n    {\n        float sd = sd_oriented_box(block_uv, vec2(.45), vec2(.68), .24);\n        sd = min(\n            sd,\n            max(\n                sd_oriented_box(block_uv, vec2(.32), vec2(.6), .24),\n                -sd_oriented_box(block_uv, vec2(.35), vec2(.6), .15)\n            )\n        );\n        \n        col = mix(\n            col,\n            vec3(.7),\n            remap01(sd, .4 * block_uv_1px, -.4 * block_uv_1px)\n        );\n    }\n    else if (block_idx == DRAW_MODE_WIRE_LOW)\n    {\n        float sd = distance(block_uv, vec2(.5)) - .24;\n        col = mix(\n            col,\n            vec3(.7),\n            remap01(sd, .4 * block_uv_1px, -.4 * block_uv_1px)\n        );\n        \n        sd = distance(block_uv, vec2(.5)) - .18;\n        col = mix(\n            col,\n            vec3(.68, .05, .02),\n            remap01(sd, .4 * block_uv_1px, -.4 * block_uv_1px)\n        );\n    }\n    else if (block_idx == DRAW_MODE_WIRE_HIGH)\n    {\n        float sd = distance(block_uv, vec2(.5)) - .24;\n        col = mix(\n            col,\n            vec3(.7),\n            remap01(sd, .4 * block_uv_1px, -.4 * block_uv_1px)\n        );\n        \n        sd = distance(block_uv, vec2(.5)) - .18;\n        col = mix(\n            col,\n            vec3(.02, .45, .01),\n            remap01(sd, .4 * block_uv_1px, -.4 * block_uv_1px)\n        );\n    }\n    else if (block_idx == DRAW_MODE_GATE_AND)\n    {\n        block_uv = remap(block_uv, .08, .92, 0., 1.);\n        col = render_gate(col, GATE_TYPE_AND, 0, block_uv, block_uv_1px);\n    }\n    else if (block_idx == DRAW_MODE_GATE_OR)\n    {\n        block_uv = remap(block_uv, .08, .92, 0., 1.);\n        col = render_gate(col, GATE_TYPE_OR, 0, block_uv, block_uv_1px);\n    }\n    else if (block_idx == DRAW_MODE_GATE_XOR)\n    {\n        block_uv = remap(block_uv, .08, .92, 0., 1.);\n        col = render_gate(col, GATE_TYPE_XOR, 0, block_uv, block_uv_1px);\n    }\n    else if (block_idx == DRAW_MODE_GATE_NOT)\n    {\n        block_uv = remap(block_uv, .08, .92, 0., 1.);\n        col = render_gate(col, GATE_TYPE_NOT, 0, block_uv, block_uv_1px);\n    }\n    else if (block_idx == DRAW_MODE_GATE_NAND)\n    {\n        block_uv = remap(block_uv, .08, .92, 0., 1.);\n        col = render_gate(col, GATE_TYPE_NAND, 0, block_uv, block_uv_1px);\n    }\n    else if (block_idx == DRAW_MODE_GATE_NOR)\n    {\n        block_uv = remap(block_uv, .08, .92, 0., 1.);\n        col = render_gate(col, GATE_TYPE_NOR, 0, block_uv, block_uv_1px);\n    }\n    else if (block_idx == DRAW_MODE_GATE_XNOR)\n    {\n        block_uv = remap(block_uv, .08, .92, 0., 1.);\n        col = render_gate(col, GATE_TYPE_XNOR, 0, block_uv, block_uv_1px);\n    }\n    else if (block_idx == DRAW_MODE_GATE_SWITCH)\n    {\n        block_uv = remap(block_uv, .08, .92, 0., 1.);\n        col = render_gate(col, GATE_TYPE_SWITCH, 0, block_uv, block_uv_1px);\n    }\n    else if (block_idx == DRAW_MODE_GATE_CLOCK)\n    {\n        block_uv = remap(block_uv, .08, .92, 0., 1.);\n        col = render_gate(col, GATE_TYPE_CLOCK, 0, block_uv, block_uv_1px);\n    }\n    else if (block_idx == DRAW_MODE_GATE_CROSS)\n    {\n        col = render_gate(col, GATE_TYPE_CROSS, 0, block_uv, block_uv_1px);\n    }\n    \n    return col;\n}\n\nvec3 render_draw_mode_toolbar(\n    vec3 col,\n    vec2 coord,\n    int draw_mode\n)\n{\n    vec2 toolbar_uv = dls_toolbar_uv(coord, iResolution.xy);\n    \n    if (!point_inside_dls_toolbar(toolbar_uv, iResolution.xy))\n    {\n        return col;\n    }\n    \n    int block_idx = dls_toolbar_block_idx(toolbar_uv);\n    vec2 block_uv = dls_toolbar_block_uv(toolbar_uv, iResolution.xy);\n    float block_uv_1px = (1. / iResolution.x) / TOOLBAR_BLOCK_SIZE;\n\n    // highlight selected\n    if (block_idx == draw_mode)\n    {\n        col = mix(col, vec3(.3), .4);\n    }\n    else\n    {\n        col = mix(col, vec3(.1), .4);\n    }\n\n    // draw mode icon\n    col = render_draw_mode_block(\n        col,\n        block_idx,\n        block_uv,\n        block_uv_1px\n    );\n    \n    // separator line\n    float sd = 1e9;\n    if (block_idx > 0)\n    {\n        sd = min(sd, abs(block_uv.x - 0.) - .008);\n    }\n    if (block_idx < (N_TOOLBAR_BLOCKS - 1))\n    {\n        sd = min(sd, abs(block_uv.x - 1.) - .008);\n    }\n    col = mix(\n        col,\n        vec3(.03),\n        remap01(sd, .4 * block_uv_1px, -.4 * block_uv_1px)\n    );\n    \n    return col;\n}\n\nvec3 view_transform(vec3 col)\n{\n    col = max(col, 0.);\n    col = pow(col, vec3(1. / 2.2));\n    return col;\n}\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    ivec2 icoord = ivec2(frag_coord);\n\n    // current pixel's values from the DLS buffer\n    int wire_state;\n    int last_updated;\n    dls_fetch(icoord, wire_state, last_updated);\n    \n    // values from the data buffer\n    ivec2 res;\n    int draw_mode;\n    bool prev_mouse_down;\n    ivec2 prev_imouse;\n    int iter;\n    data_buf_decode(\n        texelFetch(ICHANNEL_DATA_BUF, ivec2(0), 0),\n        res,\n        draw_mode,\n        prev_mouse_down,\n        prev_imouse,\n        iter\n    );\n\n    // wires and background\n    vec3 col = vec3(0);\n    if (wire_state == WIRE_STATE_NOT_WIRE)\n    {\n        col = COL_BACKGROUND;\n    }\n    else if (wire_state == WIRE_STATE_DISCONNECTED)\n    {\n        col = COL_WIRE_DISCONNECTED;\n    }\n    else if (wire_state == WIRE_STATE_LOW)\n    {\n        col = COL_WIRE_LOW;\n    }\n    else if (wire_state == WIRE_STATE_HIGH)\n    {\n        col = COL_WIRE_HIGH;\n    }\n    \n    // gates\n    col = render_gates(col, frag_coord);\n    \n    // eraser size indicator\n    col = render_eraser_size_indicator(\n        col,\n        frag_coord,\n        draw_mode\n    );\n    \n    // draw mode toolbar\n    col = render_draw_mode_toolbar(\n        col,\n        frag_coord,\n        draw_mode\n    );\n\n    // output\n    col = view_transform(col);\n    frag_col = vec4(col, 1);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "#define SHADERTOY 1\n\nprecision highp float;\nprecision highp int;\n\n\n\n/*_________________ math utils ________________*/\n\nconst float PI = 3.141592653589793238462643383;\nconst float TAU = 6.283185307179586476925286767;\nconst float PI_OVER_2 = 1.570796326794896619231321692;\nconst float INV_PI = .318309886183790671537767527;\nconst float INV_TAU = .159154943091895335768883763;\n\n#define FUNC_LERP(T) \\\nT lerp(T a, T b, float t) \\\n{ \\\n    return a + t * (b - a); \\\n}\n\n#define FUNC_WRAP(T) \\\nT wrap(T v, float start, float end) \\\n{ \\\n    return start + mod(v - start, end - start); \\\n}\n\n#define FUNC_REMAP(T) \\\nT remap(T v, float inp_start, float inp_end, float out_start, float out_end) \\\n{ \\\n    return out_start \\\n        + ((out_end - out_start) / (inp_end - inp_start)) * (v - inp_start); \\\n}\n\n#define FUNC_REMAP_CLAMP(T) \\\nT remap_clamp( \\\n    T v, \\\n    float inp_start, \\\n    float inp_end, \\\n    float out_start, \\\n    float out_end \\\n) \\\n{ \\\n    T t = clamp((v - inp_start) / (inp_end - inp_start), 0., 1.); \\\n    return out_start + t * (out_end - out_start); \\\n}\n\n#define FUNC_REMAP01(T) \\\nT remap01(T v, float inp_start, float inp_end) \\\n{ \\\n    return clamp((v - inp_start) / (inp_end - inp_start), 0., 1.); \\\n}\n\n#define FUNC_LENGTH_SQ(T) \\\nfloat length_sq(T v) \\\n{ \\\n    return dot(v, v); \\\n}\n\n#define FUNC_DIST_SQ(T) \\\nfloat dist_sq(T a, T b) \\\n{ \\\n    a -= b; \\\n    return dot(a, a); \\\n}\n\nFUNC_LERP(float)\nFUNC_LERP(vec2)\nFUNC_LERP(vec3)\nFUNC_LERP(vec4)\n\nFUNC_WRAP(float)\nFUNC_WRAP(vec2)\nFUNC_WRAP(vec3)\nFUNC_WRAP(vec4)\n\nFUNC_REMAP(float)\nFUNC_REMAP(vec2)\nFUNC_REMAP(vec3)\nFUNC_REMAP(vec4)\n\nFUNC_REMAP_CLAMP(float)\nFUNC_REMAP_CLAMP(vec2)\nFUNC_REMAP_CLAMP(vec3)\nFUNC_REMAP_CLAMP(vec4)\n\nFUNC_REMAP01(float)\nFUNC_REMAP01(vec2)\nFUNC_REMAP01(vec3)\nFUNC_REMAP01(vec4)\n\nFUNC_LENGTH_SQ(vec2)\nFUNC_LENGTH_SQ(vec3)\nFUNC_LENGTH_SQ(vec4)\n\nFUNC_DIST_SQ(vec2)\nFUNC_DIST_SQ(vec3)\nFUNC_DIST_SQ(vec4)\n\nfloat chebyshev_dist(vec2 a, vec2 b)\n{\n    return max(abs(a.x - b.x), abs(a.y - b.y));\n}\n\nfloat chebyshev_dist(vec3 a, vec3 b)\n{\n    return max(\n        max(abs(a.x - b.x), abs(a.y - b.y)),\n        abs(a.z - b.z)\n    );\n}\n\nfloat chebyshev_dist(vec4 a, vec4 b)\n{\n    return max(\n        max(\n            max(abs(a.x - b.x), abs(a.y - b.y)),\n            abs(a.z - b.z)\n        ),\n        abs(a.w - b.w)\n    );\n}\n\n#define idiv_ceil(a, b) ((a + b - 1) / b)\n\nint iabs(int v)\n{\n    if (v < 0)\n    {\n        return -v;\n    }\n    return v;\n}\n\nint imin(int a, int b)\n{\n    if (a < b)\n    {\n        return a;\n    }\n    return b;\n}\n\nint imax(int a, int b)\n{\n    if (a > b)\n    {\n        return a;\n    }\n    return b;\n}\n\nint iclamp(int v, int start, int end)\n{\n    if (v < start)\n    {\n        v = start;\n    }\n    if (v > end)\n    {\n        v = end;\n    }\n    return v;\n}\n\nfloat min_component(vec2 v)\n{\n    return min(v.x, v.y);\n}\n\nfloat min_component(vec3 v)\n{\n    return min(min(v.x, v.y), v.z);\n}\n\nfloat min_component(vec4 v)\n{\n    return min(min(min(v.x, v.y), v.z), v.w);\n}\n\nfloat max_component(vec2 v)\n{\n    return max(v.x, v.y);\n}\n\nfloat max_component(vec3 v)\n{\n    return max(max(v.x, v.y), v.z);\n}\n\nfloat max_component(vec4 v)\n{\n    return max(max(max(v.x, v.y), v.z), v.w);\n}\n\nint min_component(ivec2 v)\n{\n    return imin(v.x, v.y);\n}\n\nint min_component(ivec3 v)\n{\n    return imin(imin(v.x, v.y), v.z);\n}\n\nint min_component(ivec4 v)\n{\n    return imin(imin(imin(v.x, v.y), v.z), v.w);\n}\n\nint max_component(ivec2 v)\n{\n    return imax(v.x, v.y);\n}\n\nint max_component(ivec3 v)\n{\n    return imax(imax(v.x, v.y), v.z);\n}\n\nint max_component(ivec4 v)\n{\n    return imax(imax(imax(v.x, v.y), v.z), v.w);\n}\n\n// credits to AHSEN (https://www.shadertoy.com/user/01000001)\n// https://www.desmos.com/calculator/5d6ph151vi interactive :D\nfloat bicubic(float a, float b, float c, float d, float t)\n{\n    float one = t - 1.;\n    float two = t - 2.;\n    float three = t - 3.;\n    return (\n        (-one * two * three * a)\n        + (t * one * two * d)\n        + (3. * t * two * three * b)\n        - (3. * t * one * three * c)\n    ) / 6.;\n}\n\n// |a| * |b| * sin(theta)\nfloat cross2d(vec2 a, vec2 b)\n{\n    return a.x * b.y - a.y * b.x;\n}\n\n// references for barycentric coordinates\n// https://www.desmos.com/calculator/8g8xjejuox\n// https://www.shadertoy.com/view/mdjBWK\n\nvec3 cartesian_to_barycentric(\n    vec2 p,\n    vec2 v0,\n    vec2 v1,\n    vec2 v2,\n    bool clamp_,\n    out bool p_is_outside\n)\n{\n    vec3 b = vec3(\n        cross2d(v1 - p, v2 - p),\n        cross2d(v2 - p, v0 - p),\n        cross2d(v0 - p, v1 - p)\n    ) / cross2d(v1 - v0, v2 - v0);\n    p_is_outside = min(min(b.x, b.y), b.z) < 0.;\n    if (clamp_)\n    {\n        b = max(b, 0.);\n        b /= (b.x + b.y + b.z);\n    }\n    return b;\n}\n\nvec3 cartesian_to_barycentric(\n    vec3 p,\n    vec3 v0,\n    vec3 v1,\n    vec3 v2,\n    bool clamp_,\n    out bool p_is_outside\n)\n{\n    vec3 b = vec3(\n        length(cross(v1 - p, v2 - p)),\n        length(cross(v2 - p, v0 - p)),\n        length(cross(v0 - p, v1 - p))\n    ) / length(cross(v1 - v0, v2 - v0));\n    p_is_outside = min(min(b.x, b.y), b.z) < 0.;\n    if (clamp_)\n    {\n        b = max(b, 0.);\n        b /= (b.x + b.y + b.z);\n    }\n    return b;\n}\n\nfloat barycentric_interpolate(vec3 b, float v0, float v1, float v2)\n{\n    return dot(b, vec3(v0, v1, v2));\n}\n\nvec2 barycentric_interpolate(vec3 b, vec2 v0, vec2 v1, vec2 v2)\n{\n    return b.x * v0 + b.y * v1 + b.z * v2;\n}\n\nvec3 barycentric_interpolate(vec3 b, vec3 v0, vec3 v1, vec3 v2)\n{\n    return b.x * v0 + b.y * v1 + b.z * v2;\n}\n\nvec4 barycentric_interpolate(vec3 b, vec4 v0, vec4 v1, vec4 v2)\n{\n    return b.x * v0 + b.y * v1 + b.z * v2;\n}\n\nfloat barycentric_interpolate(vec2 b, float v0, float v1, float v2)\n{\n    return barycentric_interpolate(\n        vec3(b.x, b.y, 1. - b.x - b.y),\n        v0, v1, v2\n    );\n}\n\nvec2 barycentric_interpolate(vec2 b, vec2 v0, vec2 v1, vec2 v2)\n{\n    return barycentric_interpolate(\n        vec3(b.x, b.y, 1. - b.x - b.y),\n        v0, v1, v2\n    );\n}\n\nvec3 barycentric_interpolate(vec2 b, vec3 v0, vec3 v1, vec3 v2)\n{\n    return barycentric_interpolate(\n        vec3(b.x, b.y, 1. - b.x - b.y),\n        v0, v1, v2\n    );\n}\n\nvec4 barycentric_interpolate(vec2 b, vec4 v0, vec4 v1, vec4 v2)\n{\n    return barycentric_interpolate(\n        vec3(b.x, b.y, 1. - b.x - b.y),\n        v0, v1, v2\n    );\n}\n\n// angle from 0 to TAU\nfloat get_angle(vec2 p)\n{\n    float a = atan(p.y, p.x);\n    if (a < 0.)\n    {\n        return a + TAU;\n    }\n    return a;\n}\n\nmat2 rotate_2d(float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(\n        c, s,\n        -s, c\n    );\n}\n\nvec3 spherical_to_cartesian(vec2 s)\n{\n    float sin_theta = sin(s.x);\n    return vec3(\n        sin_theta * cos(s.y),\n        sin_theta * sin(s.y),\n        cos(s.x)\n    );\n}\n\nvec2 screen_to_uv01(vec2 coord, vec2 res)\n{\n    return coord / res;\n}\n\nvec2 screen_to_uv_horizontal(vec2 coord, vec2 res)\n{\n    return (2. * coord - res) / res.x;\n}\n\nvec2 screen_to_uv_vertical(vec2 coord, vec2 res)\n{\n    return (2. * coord - res) / res.y;\n}\n\nvec2 screen_to_uv_fit(vec2 coord, vec2 res)\n{\n    return (2. * coord - res) / min_component(res);\n}\n\nvec2 screen_to_uv_fill(vec2 coord, vec2 res)\n{\n    return (2. * coord - res) / max_component(res);\n}\n\n// for some reason we can't use intBitsToFloat() or floatBitsToInt() to store\n// integers below this value in a buffer.\nconst int BUFFER_MIN_INTEGER = 8388608;\n\n// * x must not be higher than 4,286,578,688 (see BUFFER_MIN_INTEGER above)\n// * for your sanity, don't use negative values\nfloat encode_int_for_buffer(int v)\n{\n    return intBitsToFloat(v + BUFFER_MIN_INTEGER);\n}\n\nint decode_int_from_buffer(float v)\n{\n    return floatBitsToInt(v) - BUFFER_MIN_INTEGER;\n}\n\n// pack two 16-bit integers in a single 32-bit integer\n// * both arguments should be in the 0-65535 range\n// * a must be less than 65279 (see the functions above)\nint pack_i16(int a, int b)\n{\n    return (a << 16) | b;\n}\n\n// unpack two 16-bit integers from a single 32-bit integer\nvoid unpack_i16(int v, out int a, out int b)\n{\n    a = (v >> 16) & 65535;\n    b = v & 65535;\n}\n\n// unpack the first 16-bit integer from a 32-bit integer\nint unpack_i16_a(int v)\n{\n    return (v >> 16) & 65535;\n}\n\n// unpack the second 16-bit integer from a 32-bit integer\nint unpack_i16_b(int v)\n{\n    return v & 65535;\n}\n\nbool icoord_in_bounds(ivec2 icoord, ivec2 ires)\n{\n    return\n        icoord.x >= 0 &&\n        icoord.y >= 0 &&\n        icoord.x < ires.x &&\n        icoord.y < ires.y;\n}\n\nbool icoord_in_bounds(ivec3 icoord, ivec3 ires)\n{\n    return\n        icoord.x >= 0 &&\n        icoord.y >= 0 &&\n        icoord.z >= 0 &&\n        icoord.x < ires.x &&\n        icoord.y < ires.y &&\n        icoord.z < ires.z;\n}\n\nint icoord_to_idx(ivec2 icoord, ivec2 ires)\n{\n    return icoord.x + (icoord.y * ires.x);\n}\n\nint icoord_to_idx(ivec3 icoord, ivec3 ires)\n{\n    return icoord.x + (icoord.y * ires.x) + (icoord.z * ires.x * ires.y);\n}\n\nivec2 idx_to_icoord(int idx, ivec2 ires)\n{\n    return ivec2(idx % ires.x, idx / ires.x);\n}\n\nivec3 idx_to_icoord(int idx, ivec3 ires)\n{\n    return ivec3(\n        idx % ires.x,\n        (idx % (ires.x * ires.y)) / ires.x,\n        idx / (ires.x * ires.y)\n    );\n}\n\n/*__________________ keyboard _________________*/\n\n// put this code in every buffer that uses the keyboard input:\n/*\n#if SHADERTOY\n// iChannelX must be set to Keyboard in Shadertoy\n#define SHADERTOY_KEYBOARD_CH iChannelX\n#else\n#iKeyboard\n#endif\n\ndefine_keyboard_utils\n*/\n\n#if SHADERTOY\n\n#define define_keyboard_utils \\\n \\\n/* https://github.com/stevensona/shader-toy/blob/c4833b972649d78a2ee090af60b79a3907e8e091/src/extensions/keyboard/keyboard_shader_extension.ts#L11 */ \\\nconst int \\\n    Key_Backspace = 8, Key_Tab = 9, Key_Enter = 13, Key_Shift = 16, \\\n    Key_Ctrl = 17, Key_Alt = 18, Key_Pause = 19, Key_Caps = 20, \\\n    Key_Escape = 27, Key_PageUp = 33, Key_PageDown = 34, Key_End = 35, \\\n    Key_Home = 36, Key_LeftArrow = 37, Key_UpArrow = 38, Key_RightArrow = 39, \\\n    Key_DownArrow = 40, Key_Insert = 45, Key_Delete = 46, Key_0 = 48, \\\n    Key_1 = 49, Key_2 = 50, Key_3 = 51, Key_4 = 52, Key_5 = 53, Key_6 = 54, \\\n    Key_7 = 55, Key_8 = 56, Key_9 = 57, Key_A = 65, Key_B = 66, Key_C = 67, \\\n    Key_D = 68, Key_E = 69, Key_F = 70, Key_G = 71, Key_H = 72, \\\n    Key_I = 73, Key_J = 74, Key_K = 75, Key_L = 76, Key_M = 77, Key_N = 78, \\\n    Key_O = 79, Key_P = 80, Key_Q = 81, Key_R = 82, Key_S = 83, Key_T = 84, \\\n    Key_U = 85, Key_V = 86, Key_W = 87, Key_X = 88, Key_Y = 89, Key_Z = 90, \\\n    Key_LeftWindow = 91, Key_RightWindows = 92, Key_Select = 93, \\\n    Key_Numpad0 = 96, Key_Numpad1 = 97, Key_Numpad2 = 98, Key_Numpad3 = 99, \\\n    Key_Numpad4 = 100, Key_Numpad5 = 101, Key_Numpad6 = 102, \\\n    Key_Numpad7 = 103, Key_Numpad8 = 104, Key_Numpad9 = 105, \\\n    Key_NumpadMultiply = 106, Key_NumpadAdd = 107, Key_NumpadSubtract = 109, \\\n    Key_NumpadPeriod = 110, Key_NumpadDivide = 111, Key_F1 = 112, \\\n    Key_F2 = 113, Key_F3 = 114, Key_F4 = 115, Key_F5 = 116, Key_F6 = 117, \\\n    Key_F7 = 118, Key_F8 = 119, Key_F9 = 120, Key_F10 = 121, Key_F11 = 122, \\\n    Key_F12 = 123, Key_NumLock = 144, Key_ScrollLock = 145, \\\n    Key_SemiColon = 186, Key_Equal = 187, Key_Comma = 188, Key_Dash = 189, \\\n    Key_Period = 190, Key_ForwardSlash = 191, Key_GraveAccent = 192, \\\n    Key_OpenBracket = 219, Key_BackSlash = 220, Key_CloseBraket = 221, \\\n    Key_SingleQuote = 222; \\\nconst int Key_Space = 32; \\\n \\\nbool is_key_pressed(int key) \\\n{ \\\n    return texelFetch(SHADERTOY_KEYBOARD_CH, ivec2(key, 1), 0).x > .5; \\\n} \\\n \\\nbool is_key_down(int key) \\\n{ \\\n    return texelFetch(SHADERTOY_KEYBOARD_CH, ivec2(key, 0), 0).x > .5; \\\n} \\\n \\\nbool is_key_toggled(int key) \\\n{ \\\n    return texelFetch(SHADERTOY_KEYBOARD_CH, ivec2(key, 2), 0).x > .5; \\\n}\n\n#else\n\n#define define_keyboard_utils \\\n \\\nconst int Key_Space = 32; \\\n \\\nbool is_key_pressed(int key) \\\n{ \\\n    return isKeyPressed(key); \\\n} \\\n \\\nbool is_key_down(int key) \\\n{ \\\n    return isKeyDown(key); \\\n} \\\n \\\nbool is_key_toggled(int key) \\\n{ \\\n    return isKeyToggled(key); \\\n}\n\n#endif\n\n\n\n/*___________________ SDF _____________________*/\n\n// most but not all of these are from the following article\n// https://iquilezles.org/articles/distfunctions2d/\n\nfloat sd_segment(vec2 p, vec2 a, vec2 b)\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sd_segment_2sided(vec2 p, vec2 a, vec2 b)\n{\n    vec2 tangent_unnorm = b - a;\n    float tangent_len = length(tangent_unnorm);\n    vec2 tangent = tangent_unnorm / tangent_len;\n    \n    float u = dot(p - a, tangent);\n    if (u < 0. || u > tangent_len)\n    {\n        return min(distance(p, a), distance(p, b));\n    }\n    else\n    {\n        vec2 normal = vec2(-tangent.y, tangent.x);\n        return dot(p - a, normal);\n    }\n}\n\nfloat sd_ring(vec2 p, vec2 n, float r, float thickness)\n{\n    p.x = abs(p.x);\n    \n    p = mat2(n.x,n.y,-n.y,n.x)*p;\n\n    return max( abs(length(p)-r)-thickness*0.5,\n                length(vec2(p.x,max(0.0,abs(r-p.y)-thickness*0.5)))*sign(p.x) );\n}\n\nfloat sd_oriented_box(vec2 p, vec2 a, vec2 b, float thickness)\n{\n    float l = length(b-a);\n    vec2  d = (b-a)/l;\n    vec2  q = (p-(a+b)*0.5);\n          q = mat2(d.x,-d.y,d.y,d.x)*q;\n          q = abs(q)-vec2(l,thickness)*0.5;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0);    \n}\n\nfloat sd_parabola(vec2 pos, float width, float height)\n{\n    pos.x = abs(pos.x);\n\n    float ik = width*width/height;\n    float p = ik*(height-pos.y-0.5*ik)/3.0;\n    float q = pos.x*ik*ik*0.25;\n    float h = q*q - p*p*p;\n    \n    float x;\n    if( h>0.0 ) // 1 root\n    {\n        float r = sqrt(h);\n        x = pow(q+r,1.0/3.0) + pow(abs(q-r),1.0/3.0)*sign(p);\n    }\n    else        // 3 roots\n    {\n        float r = sqrt(p);\n        x = 2.0*r*cos(acos(q/(p*r))/3.0); // see https://www.shadertoy.com/view/WltSD7 for an implementation of cos(acos(x)/3) without trigonometrics\n    }\n    \n    x = min(x,width);\n    \n    return length(pos-vec2(x,height-x*x/ik)) * \n           sign(ik*(pos.y-height)+pos.x*pos.x);\n}\n\nfloat sd_bezier(vec2 pos, vec2 A, vec2 B, vec2 C)\n{    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n    float kk = 1.0/dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);      \n    float res = 0.0;\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx-3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n    if( h >= 0.0) \n    { \n        h = sqrt(h);\n        vec2 x = (vec2(h,-h)-q)/2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = clamp( uv.x+uv.y-kx, 0.0, 1.0 );\n        res = length_sq(d + (c + b*t)*t);\n    }\n    else\n    {\n        float z = sqrt(-p);\n        float v = acos( q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3  t = clamp(vec3(m+m,-n-m,n-m)*z-kx,0.0,1.0);\n        res = min( length_sq(d+(c+b*t.x)*t.x),\n                   length_sq(d+(c+b*t.y)*t.y) );\n        // the third root cannot be the closest\n        // res = min(res,dot2(d+(c+b*t.z)*t.z));\n    }\n    return sqrt(res);\n}\n\n#define DEFINE_SD_POLYGON(n_sides) \\\nfloat sd_polygon(vec2 p, vec2[n_sides] v) \\\n{ \\\n    float d = dot(p-v[0],p-v[0]); \\\n    float s = 1.0; \\\n    for( int i=0, j=n_sides-1; i<n_sides; j=i, i++ ) \\\n    { \\\n        vec2 e = v[j] - v[i]; \\\n        vec2 w =    p - v[i]; \\\n        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 ); \\\n        d = min( d, dot(b,b) ); \\\n        bvec3 c = bvec3(p.y>=v[i].y,p.y<v[j].y,e.x*w.y>e.y*w.x); \\\n        if( all(c) || all(not(c)) ) s*=-1.0;   \\\n    } \\\n    return s*sqrt(d); \\\n}\n\n\n\n/*___________ bezier sdf approx. ______________*/\n\nvec2 bezier(vec2 a, vec2 b, vec2 c, float t)\n{\n    return mix(\n        mix(a, b, t),\n        mix(b, c, t),\n        t\n    );\n}\n\nvec2 bezier(vec2 a, vec2 b, vec2 c, vec2 d, float t)\n{\n    return mix(\n        mix(\n            mix(a, b, t),\n            mix(b, c, t),\n            t\n        ),\n        mix(\n            mix(b, c, t),\n            mix(c, d, t),\n            t\n        ),\n        t\n    );\n}\n\nconst int BEZIER_RES = 6;\n\nfloat sd_bezier_approx(vec2 p, vec2 a, vec2 b, vec2 c)\n{\n    float sd = 1e9;\n    for (int i = 0; i < BEZIER_RES; i++)\n    {\n        sd = min(sd, sd_segment(\n            p,\n            bezier(a, b, c, float(i) / float(BEZIER_RES)),\n            bezier(a, b, c, float(i + 1) / float(BEZIER_RES))\n        ));\n    }\n    return sd;\n}\n\nfloat sd_bezier_approx(vec2 p, vec2 a, vec2 b, vec2 c, vec2 d)\n{\n    float sd = 1e9;\n    for (int i = 0; i < BEZIER_RES; i++)\n    {\n        sd = min(sd, sd_segment(\n            p,\n            bezier(a, b, c, d, float(i) / float(BEZIER_RES)),\n            bezier(a, b, c, d, float(i + 1) / float(BEZIER_RES))\n        ));\n    }\n    return sd;\n}\n\n\n\n/*______________ DLS constants ________________*/\n\nconst int WIRE_STATE_NOT_WIRE = 0;\nconst int WIRE_STATE_DISCONNECTED = 1;\nconst int WIRE_STATE_LOW = 2;\nconst int WIRE_STATE_HIGH = 3;\n\nconst int DRAW_MODE_WIRE = 0;\nconst int DRAW_MODE_ERASE = 1;\nconst int DRAW_MODE_WIRE_LOW = 2;\nconst int DRAW_MODE_WIRE_HIGH = 3;\nconst int DRAW_MODE_GATE_AND = 4;\nconst int DRAW_MODE_GATE_OR = 5;\nconst int DRAW_MODE_GATE_XOR = 6;\nconst int DRAW_MODE_GATE_NOT = 7;\nconst int DRAW_MODE_GATE_NAND = 8;\nconst int DRAW_MODE_GATE_NOR = 9;\nconst int DRAW_MODE_GATE_XNOR = 10;\nconst int DRAW_MODE_GATE_SWITCH = 11;\nconst int DRAW_MODE_GATE_CLOCK = 12;\nconst int DRAW_MODE_GATE_CROSS = 13;\nconst int N_DRAW_MODES = 14;\n\nconst float TOOLBAR_BLOCK_SIZE = .05;\nconst int N_TOOLBAR_BLOCKS = N_DRAW_MODES;\n\nconst float BRUSH_THICKNESS_NORMAL_PX = 4.3;\nconst float BRUSH_THICKNESS_SMALL_PX = 3.;\n\nconst float ERASER_THICKNESS_NORMAL_PX = 26.;\nconst float ERASER_THICKNESS_SMALL_PX = 6.;\n\nfloat brush_thickness_px(bool small)\n{\n    return small ? BRUSH_THICKNESS_SMALL_PX : BRUSH_THICKNESS_NORMAL_PX;\n}\n\nfloat eraser_thickness_px(bool small)\n{\n    return small ? ERASER_THICKNESS_SMALL_PX : ERASER_THICKNESS_NORMAL_PX;\n}\n\nconst vec3 COL_BACKGROUND = vec3(.024, .036, .062);\nconst vec3 COL_WIRE_DISCONNECTED = vec3(.013, .013, .024);\nconst vec3 COL_WIRE_LOW = vec3(.680, .074, .028);\nconst vec3 COL_WIRE_HIGH = vec3(.074, .659, .032);\nconst vec3 COL_AND_GATE = vec3(.12, .101, .06);\nconst vec3 COL_OR_GATE = vec3(.077, .12, .06);\nconst vec3 COL_XOR_GATE = vec3(.107, .06, .12);\nconst vec3 COL_NOT_GATE = vec3(.12, .06, .075);\nconst vec3 COL_NAND_GATE = vec3(.06, .12, .066);\nconst vec3 COL_NOR_GATE = vec3(.06, .07, .13);\nconst vec3 COL_XNOR_GATE = vec3(.06, .12, .112);\nconst vec3 COL_SWITCH_GATE = vec3(.08, .05, .13);\nconst vec3 COL_CLOCK_GATE = vec3(.04, .07, .14);\n\nconst float GATE_ICON_THICKNESS = .02;\nconst int GATE_SIZE_PX = 80;\n\n// amount of empty space at the top & bottom,\n// this is there because gates are basically\n// considered squares but the actual shapes\n// are more elongated, so to make the\n// intersection tests more accurate, we account\n// for the vertical empty space at the top and\n// bottom of the gates. intersection tests are\n// used to avoid spawning a gate on top of\n// another one.\n// since the gate SDFs have 20% vertical margins\n// we'll use the same ratio here.\nconst int GATE_VERT_PADDING = int(.2 * float(GATE_SIZE_PX));\n\nconst int GATE_TYPE_NONE = 0;\nconst int GATE_TYPE_AND = 1;\nconst int GATE_TYPE_OR = 2;\nconst int GATE_TYPE_XOR = 3;\nconst int GATE_TYPE_NOT = 4;\nconst int GATE_TYPE_NAND = 5;\nconst int GATE_TYPE_NOR = 6;\nconst int GATE_TYPE_XNOR = 7;\nconst int GATE_TYPE_SWITCH = 8;\nconst int GATE_TYPE_CLOCK = 9;\nconst int GATE_TYPE_CROSS = 10;\n\nconst int GATE_ROT_NONE = 0;\nconst int GATE_ROT_90CW = 1;\nconst int GATE_ROT_180CW = 2;\nconst int GATE_ROT_270CW = 3;\nconst int N_GATE_ROT = 4;\n\nconst int N_CLOCK_INTERV = 5;\nconst int CLOCK_INTERV[N_CLOCK_INTERV] = int[](\n    128,\n    64,\n    32,\n    8,\n    4\n);\n\n// size of the block of pixels at the bottom left corner of\n// the gate buffer to represent gates. this determines the\n// maximum number of gates that can be there at a time.\nconst ivec2 GATE_BUF_SIZE = ivec2(10, 5);\nconst int N_GATES = GATE_BUF_SIZE.x * GATE_BUF_SIZE.y;\n\n\n\n/*_________ DLS buffer data encoding __________*/\n\nvec4 dls_encode(int wire_state, int last_updated)\n{\n    wire_state = iclamp(wire_state, 0, 3);\n    return vec4(\n        encode_int_for_buffer((last_updated << 2) | wire_state),\n        0, 0, 0\n    );\n}\n\nvoid dls_decode(\n    vec4 data,\n    out int wire_state,\n    out int last_updated\n)\n{\n    int packed = decode_int_from_buffer(data.x);\n    wire_state = packed & 3;\n    last_updated = packed >> 2;\n}\n\nvec4 gate_buf_encode(\n    int gate_type,\n    int rotation,\n    int clock_interval,\n    ivec2 icoord_bl\n)\n{\n    return vec4(\n        encode_int_for_buffer((gate_type << 16) | rotation),\n        encode_int_for_buffer(clock_interval),\n        encode_int_for_buffer((icoord_bl.x << 16) | icoord_bl.y),\n        0\n    );\n}\n\nvoid gate_buf_decode(\n    vec4 data,\n    out int gate_type,\n    out int rotation,\n    out int clock_interval,\n    out ivec2 icoord_bl\n)\n{\n    int packed = decode_int_from_buffer(data.x);\n    gate_type = packed >> 16;\n    rotation = packed & ((1 << 16) - 1);\n    \n    clock_interval = decode_int_from_buffer(data.y);\n    \n    packed = decode_int_from_buffer(data.z);\n    icoord_bl = ivec2(\n        packed >> 16,\n        packed & ((1 << 16) - 1)\n    );\n}\n\nvec4 data_buf_encode(\n    ivec2 res,\n    int draw_mode,\n    bool prev_mouse_down,\n    ivec2 prev_imouse,\n    int iter\n)\n{\n    int prev_mouse_down_01 = (prev_mouse_down ? 1 : 0);\n    return vec4(\n        encode_int_for_buffer((res.x << 16) | res.y),\n        encode_int_for_buffer((draw_mode << 1) | prev_mouse_down_01),\n        encode_int_for_buffer((prev_imouse.x << 16) | prev_imouse.y),\n        encode_int_for_buffer(iter)\n    );\n}\n\nvoid data_buf_decode(\n    vec4 data,\n    out ivec2 res,\n    out int draw_mode,\n    out bool prev_mouse_down,\n    out ivec2 prev_imouse,\n    out int iter\n)\n{\n    int packed = decode_int_from_buffer(data.x);\n    res = ivec2(\n        packed >> 16,\n        packed & ((1 << 16) - 1)\n    );\n    \n    packed = decode_int_from_buffer(data.y);\n    draw_mode = packed >> 1;\n    prev_mouse_down = bool(packed & 1);\n    \n    packed = decode_int_from_buffer(data.z);\n    prev_imouse = ivec2(\n        packed >> 16,\n        packed & ((1 << 16) - 1)\n    );\n    \n    iter = decode_int_from_buffer(data.w);\n}\n\n\n\n/*_________________ DLS SDFs __________________*/\n\nvec2 rotate_block_uv(vec2 uv, int rotation)\n{\n    if (rotation == GATE_ROT_90CW)\n    {\n        return vec2(1. - uv.y, uv.x);\n    }\n    if (rotation == GATE_ROT_180CW)\n    {\n        return 1. - uv;\n    }\n    if (rotation == GATE_ROT_270CW)\n    {\n        return vec2(uv.y, 1. - uv.x);\n    }\n    return uv;\n}\n\nvec2 unrotate_block_uv(vec2 uv, int rotation)\n{\n    if (rotation == GATE_ROT_90CW)\n    {\n        return vec2(uv.y, 1. - uv.x);\n    }\n    if (rotation == GATE_ROT_180CW)\n    {\n        return 1. - uv;\n    }\n    if (rotation == GATE_ROT_270CW)\n    {\n        return vec2(1. - uv.y, uv.x);\n    }\n    return uv;\n}\n\nvec2 GATE_TOP_INPUT_UV = vec2(0., .65);\nvec2 GATE_BOTTOM_INPUT_UV = vec2(0., .35);\nvec2 GATE_CENTER_INPUT_UV = vec2(0., .5); // for single-input gates\n\n#define N_SIDES_AND_GATE (4 + BEZIER_RES + BEZIER_RES - 1)\nDEFINE_SD_POLYGON(N_SIDES_AND_GATE)\n\nbool point_inside_and_gate(vec2 block_uv)\n{\n    vec2 p[N_SIDES_AND_GATE];\n    p[0] = vec2(.5, .2);\n    p[1] = vec2(.2, .2);\n    p[2] = vec2(.2, .8);\n    p[3] = vec2(.5, .8);\n    for (int i = 1; i <= BEZIER_RES; i++)\n    {\n        p[3 + i] = bezier(\n            vec2(.5, .8),\n            vec2(.5 + .13, .8),\n            vec2(.75, .5 + .13),\n            vec2(.75, .5),\n            float(i) / float(BEZIER_RES)\n        );\n    }\n    for (int i = 1; i < BEZIER_RES; i++)\n    {\n        p[3 + BEZIER_RES + i] = bezier(\n            vec2(.75, .5),\n            vec2(.75, .5 - .13),\n            vec2(.5 + .13, .2),\n            vec2(.5, .2),\n            float(i) / float(BEZIER_RES)\n        );\n    }\n    \n    return sd_polygon(block_uv, p) < 0.;\n}\n\nbool point_inside_nand_gate(vec2 block_uv)\n{\n    return point_inside_and_gate(block_uv);\n}\n\nfloat sd_and_gate_no_output_line(vec2 block_uv)\n{\n    float sd = sd_bezier_approx(\n        block_uv,\n        vec2(.5, .8),\n        vec2(.5 + .13, .8),\n        vec2(.75, .5 + .13),\n        vec2(.75, .5)\n    ) - GATE_ICON_THICKNESS;\n    \n    sd = min(sd, sd_bezier_approx(\n        block_uv,\n        vec2(.75, .5),\n        vec2(.75, .5 - .13),\n        vec2(.5 + .13, .2),\n        vec2(.5, .2)\n    ) - GATE_ICON_THICKNESS);\n    \n    sd = min(sd, sd_segment(\n        block_uv,\n        vec2(.2, .8),\n        vec2(.5, .8)\n    ) - GATE_ICON_THICKNESS);\n    \n    sd = min(sd, sd_segment(\n        block_uv,\n        vec2(.2, .2),\n        vec2(.5, .2)\n    ) - GATE_ICON_THICKNESS);\n    \n    sd = min(sd, sd_segment(\n        block_uv,\n        vec2(.2, .2),\n        vec2(.2, .8)\n    ) - GATE_ICON_THICKNESS);\n    \n    // input line 1\n    sd = min(sd, sd_segment(\n        block_uv,\n        GATE_TOP_INPUT_UV,\n        GATE_TOP_INPUT_UV + vec2(.2, 0)\n    ) - GATE_ICON_THICKNESS);\n    \n    // input line 2\n    sd = min(sd, sd_segment(\n        block_uv,\n        GATE_BOTTOM_INPUT_UV,\n        GATE_BOTTOM_INPUT_UV + vec2(.2, 0)\n    ) - GATE_ICON_THICKNESS);\n    \n    return sd;\n}\n\nfloat sd_and_gate(vec2 block_uv)\n{\n    float sd = sd_and_gate_no_output_line(block_uv);\n    \n    // output line\n    sd = min(sd, sd_segment(\n        block_uv,\n        vec2(.76, .5),\n        vec2(1, .5)\n    ) - GATE_ICON_THICKNESS);\n    \n    return sd;\n}\n\n#define N_SIDES_OR_GATE (3 * BEZIER_RES)\nDEFINE_SD_POLYGON(N_SIDES_OR_GATE)\n\nbool point_inside_or_gate(vec2 block_uv)\n{\n    vec2 p[N_SIDES_OR_GATE];\n    for (int i = 0; i < BEZIER_RES; i++)\n    {\n        p[i] = bezier(\n            vec2(.2, .8),\n            vec2(.5, .8),\n            vec2(.75, .5),\n            float(i) / float(BEZIER_RES)\n        );\n    }\n    for (int i = 0; i < BEZIER_RES; i++)\n    {\n        p[BEZIER_RES + i] = bezier(\n            vec2(.75, .5),\n            vec2(.5, .2),\n            vec2(.2, .2),\n            float(i) / float(BEZIER_RES)\n        );\n    }\n    for (int i = 0; i < BEZIER_RES; i++)\n    {\n        p[2 * BEZIER_RES + i] = bezier(\n            vec2(.2, .2),\n            vec2(.43, .5),\n            vec2(.2, .8),\n            float(i) / float(BEZIER_RES)\n        );\n    }\n    \n    return sd_polygon(block_uv, p) < 0.;\n}\n\nbool point_inside_xor_gate(vec2 block_uv)\n{\n    return point_inside_or_gate(block_uv);\n}\n\nbool point_inside_nor_gate(vec2 block_uv)\n{\n    return point_inside_or_gate(block_uv);\n}\n\nbool point_inside_xnor_gate(vec2 block_uv)\n{\n    return point_inside_or_gate(block_uv);\n}\n\nfloat sd_or_gate_no_output_line(vec2 block_uv)\n{\n    float sd = sd_bezier_approx(\n        block_uv,\n        vec2(.2, .8),\n        vec2(.5, .8),\n        vec2(.75, .5)\n    ) - GATE_ICON_THICKNESS;\n    \n    sd = min(sd, sd_bezier_approx(\n        block_uv,\n        vec2(.75, .5),\n        vec2(.5, .2),\n        vec2(.2, .2)\n    ) - GATE_ICON_THICKNESS);\n    \n    sd = min(sd, sd_bezier_approx(\n        block_uv,\n        vec2(.2, .2),\n        vec2(.43, .5),\n        vec2(.2, .8)\n    ) - GATE_ICON_THICKNESS);\n    \n    // input line 1\n    sd = min(sd, sd_segment(\n        block_uv,\n        GATE_TOP_INPUT_UV,\n        GATE_TOP_INPUT_UV + vec2(.28, 0)\n    ) - GATE_ICON_THICKNESS);\n    \n    // input line 2\n    sd = min(sd, sd_segment(\n        block_uv,\n        GATE_BOTTOM_INPUT_UV,\n        GATE_BOTTOM_INPUT_UV + vec2(.28, 0)\n    ) - GATE_ICON_THICKNESS);\n    \n    return sd;\n}\n\nfloat sd_or_gate(vec2 block_uv)\n{\n    float sd = sd_or_gate_no_output_line(block_uv);\n    \n    // output line\n    sd = min(sd, sd_segment(\n        block_uv,\n        vec2(.76, .5),\n        vec2(1, .5)\n    ) - GATE_ICON_THICKNESS);\n    \n    return sd;\n}\n\nfloat sd_xor_gate_no_output_line(vec2 block_uv)\n{\n    float sd = sd_or_gate_no_output_line(block_uv);\n    \n    sd = min(sd, sd_bezier_approx(\n        block_uv + vec2(.08, 0),\n        vec2(.2, .8),\n        vec2(.43, .5),\n        vec2(.2, .2)\n    ) - GATE_ICON_THICKNESS);\n    \n    return sd;\n}\n\nfloat sd_xor_gate(vec2 block_uv)\n{\n    float sd = sd_xor_gate_no_output_line(block_uv);\n    \n    // output line\n    sd = min(sd, sd_segment(\n        block_uv,\n        vec2(.76, .5),\n        vec2(1, .5)\n    ) - GATE_ICON_THICKNESS);\n    \n    return sd;\n}\n\nfloat sd_gate_dot_and_output_line(vec2 block_uv)\n{\n    // dot (the dot at the end of NOT, NOR, XNOR, etc.)\n    float sd = abs(\n        distance(\n            block_uv,\n            vec2(.84, .5)\n        ) - .05\n    ) - GATE_ICON_THICKNESS;\n    \n    // output line\n    sd = min(sd, sd_segment(\n        block_uv,\n        vec2(.89, .5),\n        vec2(1, .5)\n    ) - GATE_ICON_THICKNESS);\n    \n    return sd;\n}\n\n#define N_SIDES_NOT_GATE 3\nDEFINE_SD_POLYGON(N_SIDES_NOT_GATE)\n\nbool point_inside_not_gate(vec2 block_uv)\n{\n    vec2 p[N_SIDES_NOT_GATE] = vec2[](\n        vec2(.2, .2),\n        vec2(.8, .5),\n        vec2(.2, .8)\n    );\n    return sd_polygon(block_uv, p) < 0.;\n}\n\nfloat sd_not_gate(vec2 block_uv)\n{\n    float sd = sd_segment(\n        block_uv,\n        vec2(.2, .2),\n        vec2(.8, .5)\n    ) - GATE_ICON_THICKNESS;\n    \n    sd = min(sd, sd_segment(\n        block_uv,\n        vec2(.2, .8),\n        vec2(.8, .5)\n    ) - GATE_ICON_THICKNESS);\n    \n    sd = min(sd, sd_segment(\n        block_uv,\n        vec2(.2, .2),\n        vec2(.2, .8)\n    ) - GATE_ICON_THICKNESS);\n    \n    // input line\n    sd = min(sd, sd_segment(\n        block_uv,\n        GATE_CENTER_INPUT_UV,\n        GATE_CENTER_INPUT_UV + vec2(.2, 0)\n    ) - GATE_ICON_THICKNESS);\n    \n    // output line\n    sd = min(sd, sd_segment(\n        block_uv,\n        vec2(.89, .5),\n        vec2(1, .5)\n    ) - GATE_ICON_THICKNESS);\n    \n    sd = min(sd, sd_gate_dot_and_output_line(block_uv));\n    \n    return sd;\n}\n\nfloat sd_nand_gate(vec2 block_uv)\n{\n    float sd = sd_and_gate_no_output_line(block_uv);\n    sd = min(sd, sd_gate_dot_and_output_line(block_uv));\n    return sd;\n}\n\nfloat sd_nor_gate(vec2 block_uv)\n{\n    float sd = sd_or_gate_no_output_line(block_uv);\n    sd = min(sd, sd_gate_dot_and_output_line(block_uv));\n    return sd;\n}\n\nfloat sd_xnor_gate(vec2 block_uv)\n{\n    float sd = sd_xor_gate_no_output_line(block_uv);\n    sd = min(sd, sd_gate_dot_and_output_line(block_uv));\n    return sd;\n}\n\nconst vec2 SWITCH_GATE_CIRCLE_CENTER = vec2(.46, .5);\nconst float SWITCH_GATE_CIRCLE_RADIUS = .29;\n\nbool point_inside_switch_gate(vec2 block_uv)\n{\n    return\n        dist_sq(block_uv, SWITCH_GATE_CIRCLE_CENTER)\n        < (SWITCH_GATE_CIRCLE_RADIUS * SWITCH_GATE_CIRCLE_RADIUS);\n}\n\nfloat sd_switch_gate(vec2 block_uv)\n{\n    float sd = abs(\n        distance(\n            block_uv,\n            SWITCH_GATE_CIRCLE_CENTER\n        ) - SWITCH_GATE_CIRCLE_RADIUS\n    ) - GATE_ICON_THICKNESS;\n    \n    // input line 1\n    sd = min(sd, sd_segment(\n        block_uv,\n        GATE_TOP_INPUT_UV,\n        GATE_TOP_INPUT_UV + vec2(.2, 0)\n    ) - GATE_ICON_THICKNESS);\n    \n    // input line 2\n    sd = min(sd, sd_segment(\n        block_uv,\n        GATE_BOTTOM_INPUT_UV,\n        GATE_BOTTOM_INPUT_UV + vec2(.2, 0)\n    ) - GATE_ICON_THICKNESS);\n    \n    // output line\n    sd = min(sd, sd_segment(\n        block_uv,\n        vec2(.76, .5),\n        vec2(1, .5)\n    ) - GATE_ICON_THICKNESS);\n    \n    // text\n    {\n        // S\n    \n        sd = min(sd, sd_segment(\n            block_uv,\n            vec2(.38, .62),\n            vec2(.3, .62)\n        ) - .5 * GATE_ICON_THICKNESS);\n        \n        sd = min(sd, sd_segment(\n            block_uv,\n            vec2(.3, .62),\n            vec2(.38, .38)\n        ) - .5 * GATE_ICON_THICKNESS);\n        \n        sd = min(sd, sd_segment(\n            block_uv,\n            vec2(.38, .38),\n            vec2(.3, .38)\n        ) - .5 * GATE_ICON_THICKNESS);\n        \n        // W\n        \n        sd = min(sd, sd_segment(\n            block_uv,\n            vec2(.42, .62),\n            vec2(.42, .38)\n        ) - .5 * GATE_ICON_THICKNESS);\n        \n        sd = min(sd, sd_segment(\n            block_uv,\n            vec2(.42, .38),\n            vec2(.46, .5)\n        ) - .5 * GATE_ICON_THICKNESS);\n        \n        sd = min(sd, sd_segment(\n            block_uv,\n            vec2(.46, .5),\n            vec2(.5, .38)\n        ) - .5 * GATE_ICON_THICKNESS);\n        \n        sd = min(sd, sd_segment(\n            block_uv,\n            vec2(.5, .38),\n            vec2(.5, .62)\n        ) - .5 * GATE_ICON_THICKNESS);\n        \n        // C\n        \n        sd = min(sd, sd_segment(\n            block_uv,\n            vec2(.62, .62),\n            vec2(.54, .62)\n        ) - .5 * GATE_ICON_THICKNESS);\n        \n        sd = min(sd, sd_segment(\n            block_uv,\n            vec2(.54, .62),\n            vec2(.54, .38)\n        ) - .5 * GATE_ICON_THICKNESS);\n        \n        sd = min(sd, sd_segment(\n            block_uv,\n            vec2(.54, .38),\n            vec2(.62, .38)\n        ) - .5 * GATE_ICON_THICKNESS);\n    }\n    \n    return sd;\n}\n\nbool point_inside_clock_gate(vec2 block_uv)\n{\n    return chebyshev_dist(block_uv, vec2(.48, .5)) < .26;\n}\n\nfloat sd_clock_gate(vec2 block_uv, int clock_interval)\n{\n    float sd = abs(\n        chebyshev_dist(block_uv, vec2(.48, .5)) - .26\n    ) - GATE_ICON_THICKNESS;\n    \n    // triangle waves\n    for (int i = 0; i < clock_interval + 1; i++)\n    {\n        float left_x = mix(.22, .74, float(i) / float(clock_interval + 1));\n        float right_x = mix(.22, .74, float(i + 1) / float(clock_interval + 1));\n        \n        sd = min(sd, sd_segment(\n            block_uv,\n            vec2(mix(left_x, right_x, 0.), .5),\n            vec2(mix(left_x, right_x, .25), .66)\n        ) - .7 * GATE_ICON_THICKNESS);\n        \n        sd = min(sd, sd_segment(\n            block_uv,\n            vec2(mix(left_x, right_x, .25), .66),\n            vec2(mix(left_x, right_x, .75), .34)\n        ) - .7 * GATE_ICON_THICKNESS);\n        \n        sd = min(sd, sd_segment(\n            block_uv,\n            vec2(mix(left_x, right_x, .75), .34),\n            vec2(mix(left_x, right_x, 1.), .5)\n        ) - .7 * GATE_ICON_THICKNESS);\n    }\n    \n    // output line\n    sd = min(sd, sd_segment(\n        block_uv,\n        vec2(.76, .5),\n        vec2(1, .5)\n    ) - GATE_ICON_THICKNESS);\n    \n    return sd;\n}\n\nconst vec2 CROSS_TOP_LEFT_INPUT_UV = vec2(.36, .64);\nconst vec2 CROSS_BOTTOM_RIGHT_INPUT_UV = vec2(.64, .36);\nconst vec2 CROSS_TOP_RIGHT_INPUT_UV = vec2(.64, .64);\nconst vec2 CROSS_BOTTOM_LEFT_INPUT_UV = vec2(.36, .36);\n\nfloat sd_cross_gate(vec2 block_uv)\n{\n    block_uv = abs(block_uv - .5) + .5;\n\n    float sd = sd_segment(\n        block_uv,\n        vec2(.5, .5),\n        vec2(.64, .64) - (.06 * .7071068)\n    ) - .7 * GATE_ICON_THICKNESS;\n    \n    sd = min(sd, abs(\n        distance(\n            block_uv,\n            vec2(.64, .64)\n        ) - .06\n    ) - .7 * GATE_ICON_THICKNESS);\n    \n    return sd;\n}\n\n// usually we use a single function like point_inside_X_gate()\n// for both rendering the gate's interior fill color and also\n// disabling the DLS simulation inside the gate. The cross\n// component doesn't have a fill color, but also its\n// \"point_inside\" function doesn't match its actual shape.\n// Instead, it's designed to disable DLS in specific areas to\n// avoid leakage.\nbool point_inside_cross_gate_for_dls(vec2 block_uv)\n{\n    float x = block_uv.x;\n    float y = block_uv.y;\n    return\n        (abs(x - .5) < ((.64 - .5) + .06) && abs(y - .5) < ((.64 - .5) - .06))\n        || (abs(y - .5) < ((.64 - .5) + .06) && abs(x - .5) < ((.64 - .5) - .06));\n}\n\nbool point_inside_gate(vec2 block_uv, int gate_type)\n{\n    if (gate_type == GATE_TYPE_AND)\n    {\n        return point_inside_and_gate(block_uv);\n    }\n    else if (gate_type == GATE_TYPE_OR)\n    {\n        return point_inside_or_gate(block_uv);\n    }\n    else if (gate_type == GATE_TYPE_XOR)\n    {\n        return point_inside_xor_gate(block_uv);\n    }\n    else if (gate_type == GATE_TYPE_NOT)\n    {\n        return point_inside_not_gate(block_uv);\n    }\n    else if (gate_type == GATE_TYPE_NAND)\n    {\n        return point_inside_nand_gate(block_uv);\n    }\n    else if (gate_type == GATE_TYPE_NOR)\n    {\n        return point_inside_nor_gate(block_uv);\n    }\n    else if (gate_type == GATE_TYPE_XNOR)\n    {\n        return point_inside_xnor_gate(block_uv);\n    }\n    else if (gate_type == GATE_TYPE_SWITCH)\n    {\n        return point_inside_switch_gate(block_uv);\n    }\n    else if (gate_type == GATE_TYPE_CLOCK)\n    {\n        return point_inside_clock_gate(block_uv);\n    }\n    else if (gate_type == GATE_TYPE_CROSS)\n    {\n        return point_inside_cross_gate_for_dls(block_uv);\n    }\n    return false;\n}\n\nbool point_inside_gate_output(vec2 block_uv)\n{\n    float sd = sd_segment(\n        block_uv,\n        vec2(.89, .5),\n        vec2(1, .5)\n    ) - GATE_ICON_THICKNESS;\n    return sd < 0.;\n}\n\n\n\n/*_______________ DLS toolbar _________________*/\n\nvec2 dls_toolbar_uv(vec2 coord, vec2 res)\n{\n    return coord / res.x;\n}\n\nbool point_inside_dls_toolbar(vec2 toolbar_uv, vec2 res)\n{\n    vec2 uv_top_left = vec2(0, res.y) / res.x;\n    return\n        toolbar_uv.x <= TOOLBAR_BLOCK_SIZE * float(N_TOOLBAR_BLOCKS)\n        && toolbar_uv.y >= (uv_top_left.y - TOOLBAR_BLOCK_SIZE);\n}\n\nint dls_toolbar_block_idx(vec2 toolbar_uv)\n{\n    return iclamp(\n        int(toolbar_uv.x / TOOLBAR_BLOCK_SIZE),\n        0,\n        N_TOOLBAR_BLOCKS - 1\n    );\n}\n\nvec2 dls_toolbar_block_uv(vec2 toolbar_uv, vec2 res)\n{\n    vec2 uv_top_left = vec2(0, res.y) / res.x;\n    return vec2(\n        mod(toolbar_uv.x, TOOLBAR_BLOCK_SIZE) / TOOLBAR_BLOCK_SIZE,\n        (toolbar_uv.y - (uv_top_left.y - TOOLBAR_BLOCK_SIZE)) / TOOLBAR_BLOCK_SIZE\n    );\n}\n\n\n\n// The following is a copy of the tutorial comment posted by the author\n// under the original shader (https://www.shadertoy.com/view/XXG3zW).\n\n/*\n[b]DON'T PANIC[/b]\nIf it says \"Compiled in 0.0 secs\" and shows a black screen, it's lying to you. The shader is still being compiled, just wait for 30-60 seconds.\n\n[b]What's this?[/b]\nThis is a digital logic simulation shader for learning and experimenting with logic gates and digital circuits like binary adders, ALUs (arithmetic logic units), and if you're really nerdy, entire basic CPUs. It simulates logic values propagating inside wires, and logic gates that read & manipulate those values at their inputs and outputs.\n[url=https://www.shadertoy.com/view/M3tXWn]See the first version.[/url]\n\n[b]Who made this?[/b]\nThis shader is written by bean ([url=https://github.com/bean-mhm]GitHub[/url]).\n\n[b]Controls[/b]\n- [i]Click[/i] to [b]select tools in the toolbar[/b]\n- [i]Hold Mouse[/i] to [b]draw/erase wires when wire brush or eraser selected[/b]\n- [i]Hold Shift[/i] to [b]use smaller brush/eraser size[/b]\n- [i]Click[/i] to [b]inject logic values / add gates[/b]\n- [i]Alt+Click[/i] [b]on a gate to rotate it[/b]\n- [i]Ctrl+Click[/i] [b]on a clock to change the interval[/b]\n- [i]Press C[/i] to [b]clear the screen[/b]\n\n[b]WARNING[/b]\nResolution changes will reset everything and cause data loss.\n\n[b]Toolbar[/b]\nClick on the icons in the toolbar to change the draw mode to one of the following, respectively.\n- Wire brush\n- Eraser\n- Inject 0 in wire\n- Inject 1 in wire\n- AND gate\n- OR gate\n- XOR gate\n- NOT gate\n- NAND gate\n- NOR gate\n- XNOR gate\n- SWITCH gate\n- Clock\n- Cross\n\n[b]How logic gates work[/b]\n\nThe following terms refer to the same thing: 0, false, low, and off. Same with 1, true, high, and on.\n\n[i]AND[/i] outputs true if both inputs are true.\n[i]OR[/i] outputs true if either input is true.\n[i]XOR[/i] outputs true if the inputs have different values.\n\n[i]NOT[/i] outputs the inverted version of the input ([i]NOT[/i] has only one input).\n\n[i]NAND[/i] outputs true if either input is false.\n[i]NOR[/i] outputs true if both inputs are false.\n[i]XNOR[/i] outputs true if the inputs have equal values.\n\n[i]SWITCH[/i] outputs the first input only if the second input is true, does nothing otherwise. It acts like a tri-state buffer.\n\n[b]Clock and Cross[/b]\nThe [i]Clock[/i] component oscillates its output with a constant frequency that can be changed by [i]Ctrl+Click[/i]ing on it.\nA [i]Cross[/i] connects the pixels at the two ends on each axis, allowing you to cross wires.\n\n[b]Gate limit[/b]\nThe maximum number of gates is 50 by default. You can increase it by changing the GATE_BUF_SIZE constant.\n*/\n\n\n\n// The following is a copy of my personal to-do list for this project\n\n/*\ndata buffer\n- new draw modes for the gates\n\nimage\n- icons for the new draw modes\n\ngate buffer\n- contains an array of logic gates\n- struct LogicGate:\n    type: int GATE_TYPE_AND\n    icoord_bottom_left: ivec2\n- [C] should clear the gates too\n- if draw mode is a gate, add it if mouse is down in this frame but wasnt in prev frame\n\nimage\n- iterate through the gate array from the gate buffer and see if we're inside\n  one, and if so, render that gate.\n- fill the interior of the gates\n\ngate buffer\n- if mouse is on a gate already, don't add anything\n- if mouse is on a gate and draw mode is erase, delete it on mouse press\n\nDLS buffer\n- don't run simulation inside a logic gate (ignore wires under gates)\n- if at the output of a logic gate, do the operation based on the inputs\n\nDLS buffer\n- only draw wires if prev_mouse_down is on, use line segments to avoid the nasty cirlce issue (use prev_imouse)\n\nmake sure all gates can be erased properly\n\ncross shouldnt be rotated\n*/\n",
     "name": "Common",
     "description": "",
     "type": "common"
    },
    {
     "inputs": [
      {
       "id": "4dXGRr",
       "filepath": "/presets/tex00.jpg",
       "type": "keyboard",
       "channel": 3,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4sXGR8",
       "filepath": "/media/previz/buffer02.png",
       "type": "buffer",
       "channel": 2,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "// simulation buffer. this stores wire states and \"last updated\"\n// values.\n\n#if SHADERTOY\n// iChannel3 must be set to Keyboard in Shadertoy\n#define SHADERTOY_KEYBOARD_CH iChannel3\n#else\n#iKeyboard\n#endif\n\ndefine_keyboard_utils\n\n#define ICHANNEL_SELF iChannel0\n#define ICHANNEL_GATE_BUF iChannel1\n#define ICHANNEL_DATA_BUF iChannel2\n\nvoid dls_fetch(\n    ivec2 icoord,\n    out int wire_state,\n    out int last_updated\n)\n{\n    if (!icoord_in_bounds(\n        icoord,\n        ivec2(iResolution.xy)\n    ))\n    {\n        wire_state = WIRE_STATE_NOT_WIRE;\n        last_updated = -1;\n        return;\n    }\n    \n    vec4 data = texelFetch(ICHANNEL_SELF, icoord, 0);\n    dls_decode(data, wire_state, last_updated);\n}\n\nvoid gate_fetch(\n    int idx,\n    out int gate_type,\n    out int rotation,\n    out int clock_interval,\n    out ivec2 icoord_bl\n)\n{\n    if (idx < 0 || idx >= N_GATES)\n    {\n        gate_type = GATE_TYPE_NONE;\n        icoord_bl = ivec2(0);\n        return;\n    }\n    \n    ivec2 icoord = idx_to_icoord(idx, GATE_BUF_SIZE);\n    vec4 data = texelFetch(ICHANNEL_GATE_BUF, icoord, 0);\n    gate_buf_decode(\n        data,\n        gate_type,\n        rotation,\n        clock_interval,\n        icoord_bl\n    );\n}\n\nvoid take_on_neighbor_value_if_needed(\n    inout int my_wire_state,\n    inout int my_last_updated,\n    int neighbor_wire_state,\n    int neighbor_last_updated\n)\n{\n    // return if neighbor is not a wire\n    if (neighbor_wire_state == WIRE_STATE_NOT_WIRE)\n    {\n        return;\n    }\n    \n    // only care about connected neighbors\n    if (neighbor_wire_state == WIRE_STATE_DISCONNECTED)\n    {\n        return;\n    }\n    \n    // if we're disconnected\n    if (my_wire_state == WIRE_STATE_DISCONNECTED)\n    {\n        // change our values to that of the neighbor\n        my_wire_state = neighbor_wire_state;\n        my_last_updated = neighbor_last_updated;\n    }\n    \n    // or if we're connected and neighbor has a more recent value\n    if (neighbor_last_updated > my_last_updated\n        && my_wire_state != WIRE_STATE_DISCONNECTED)\n    {\n        // change our values to that of the neighbor\n        my_wire_state = neighbor_wire_state;\n        my_last_updated = neighbor_last_updated;\n    }\n}\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    // values from the data buffer\n    ivec2 res;\n    int draw_mode;\n    bool prev_mouse_down;\n    ivec2 prev_imouse;\n    int iter;\n    data_buf_decode(\n        texelFetch(ICHANNEL_DATA_BUF, ivec2(0), 0),\n        res,\n        draw_mode,\n        prev_mouse_down,\n        prev_imouse,\n        iter\n    );\n    \n    // resolution changed since last frame?\n    bool res_changed = imax(\n        iabs(res.x - int(iResolution.x)),\n        iabs(res.y - int(iResolution.y))\n    ) > 0;\n    \n    // are we in the first frame?\n    bool first_frame = (iFrame < 1) || (iTime < .02);\n\n    // set initial values and return on resolution change or\n    // the first frame, or if C is pressed\n    if (res_changed || first_frame || is_key_pressed(Key_C))\n    {\n        frag_col = dls_encode(\n            WIRE_STATE_NOT_WIRE,\n            -1\n        );\n        return;\n    }\n    \n    // see if mouse is in the toolbar\n    vec2 mouse_toolbar_uv = dls_toolbar_uv(iMouse.xy, iResolution.xy); \n    bool mouse_in_toolbar = point_inside_dls_toolbar(\n        mouse_toolbar_uv,\n        iResolution.xy\n    );\n    \n    ivec2 icoord = ivec2(frag_coord);\n    \n    // current pixel's values\n    int wire_state;\n    int last_updated;\n    dls_fetch(icoord, wire_state, last_updated);\n    \n    // see if the current pixel is inside a logic gate\n    bool inside_gate = false;\n    for (int i = 0; i < N_GATES; i++)\n    {\n        int gate_type;\n        int gate_rotation;\n        int clock_interval;\n        ivec2 gate_icoord_bl;\n        gate_fetch(i, gate_type, gate_rotation, clock_interval, gate_icoord_bl);\n        \n        if (gate_type == GATE_TYPE_NONE)\n        {\n            continue;\n        }\n        \n        ivec2 gate_icoord_tr = gate_icoord_bl + GATE_SIZE_PX;\n        vec2 block_uv_norot =\n            (frag_coord - vec2(gate_icoord_bl) - .5) / float(GATE_SIZE_PX);\n        vec2 block_uv = rotate_block_uv(block_uv_norot, gate_rotation);\n        \n        if (gate_type == GATE_TYPE_CROSS)\n        {\n            // * we don't set inside_gate to true when we're\n            // on the inputs of a cross, because the cross\n            // acts like a teleport for wires so it\n            // shouldn't ignore the neighbors of the input\n            // pixels.\n            \n            ivec2 icoord_top_left_input = ivec2(\n                vec2(gate_icoord_bl) + .5\n                + CROSS_TOP_LEFT_INPUT_UV * float(GATE_SIZE_PX)\n            );\n            ivec2 icoord_bottom_right_input = ivec2(\n                vec2(gate_icoord_bl) + .5\n                + CROSS_BOTTOM_RIGHT_INPUT_UV * float(GATE_SIZE_PX)\n            );\n            ivec2 icoord_top_right_input = ivec2(\n                vec2(gate_icoord_bl) + .5\n                + CROSS_TOP_RIGHT_INPUT_UV * float(GATE_SIZE_PX)\n            );\n            ivec2 icoord_bottom_left_input = ivec2(\n                vec2(gate_icoord_bl) + .5\n                + CROSS_BOTTOM_LEFT_INPUT_UV * float(GATE_SIZE_PX)\n            );\n            \n            if (icoord == icoord_top_left_input)\n            {\n                // we're on the top left input of the cross, so\n                // we'll read the bottom right input and see if\n                // it has a more recent value.\n                \n                int other_inp_state;\n                int other_inp_last_updated;\n                \n                dls_fetch(\n                    icoord_bottom_right_input,\n                    other_inp_state,\n                    other_inp_last_updated\n                );\n                \n                take_on_neighbor_value_if_needed(\n                    wire_state,\n                    last_updated,\n                    other_inp_state,\n                    other_inp_last_updated\n                );\n            }\n            else if (icoord == icoord_bottom_right_input)\n            {\n                // the rest just follows the pattern\n                \n                int other_inp_state;\n                int other_inp_last_updated;\n                \n                dls_fetch(\n                    icoord_top_left_input,\n                    other_inp_state,\n                    other_inp_last_updated\n                );\n                \n                take_on_neighbor_value_if_needed(\n                    wire_state,\n                    last_updated,\n                    other_inp_state,\n                    other_inp_last_updated\n                );\n            }\n            else if (icoord == icoord_top_right_input)\n            {\n                int other_inp_state;\n                int other_inp_last_updated;\n                \n                dls_fetch(\n                    icoord_bottom_left_input,\n                    other_inp_state,\n                    other_inp_last_updated\n                );\n                \n                take_on_neighbor_value_if_needed(\n                    wire_state,\n                    last_updated,\n                    other_inp_state,\n                    other_inp_last_updated\n                );\n            }\n            else if (icoord == icoord_bottom_left_input)\n            {\n                int other_inp_state;\n                int other_inp_last_updated;\n                \n                dls_fetch(\n                    icoord_top_right_input,\n                    other_inp_state,\n                    other_inp_last_updated\n                );\n                \n                take_on_neighbor_value_if_needed(\n                    wire_state,\n                    last_updated,\n                    other_inp_state,\n                    other_inp_last_updated\n                );\n            }\n            else if (point_inside_gate(block_uv, gate_type))\n            {\n                // we're inside the cross itself and not on\n                // any of its inputs so we shouldn't run\n                // the simulation.\n                inside_gate = true;\n                break;\n            }\n        }\n        else if (point_inside_gate_output(block_uv))\n        {\n            // we're on the output of a gate so don't run the\n            // simulation, we'll perform the correct logic\n            // operation instead.\n            inside_gate = true;\n            \n            // read the wire states at the inputs\n            \n            vec2 input_uv_unrot = unrotate_block_uv(\n                GATE_TOP_INPUT_UV,\n                gate_rotation\n            );\n            ivec2 icoord_top_input = ivec2(\n                input_uv_unrot * float(GATE_SIZE_PX)\n                + vec2(gate_icoord_bl) + .5\n            );\n            \n            input_uv_unrot = unrotate_block_uv(\n                GATE_BOTTOM_INPUT_UV,\n                gate_rotation\n            );\n            ivec2 icoord_bottom_input = ivec2(\n                input_uv_unrot * float(GATE_SIZE_PX)\n                + vec2(gate_icoord_bl) + .5\n            );\n            \n            input_uv_unrot = unrotate_block_uv(\n                GATE_CENTER_INPUT_UV,\n                gate_rotation\n            );\n            ivec2 icoord_center_input = ivec2(\n                input_uv_unrot * float(GATE_SIZE_PX)\n                + vec2(gate_icoord_bl) + .5\n            );\n            \n            int top_inp_state;\n            int bottom_inp_state;\n            int center_inp_state;\n            int dont_care_about_last_updated;\n            \n            dls_fetch(\n                icoord_top_input,\n                top_inp_state,\n                dont_care_about_last_updated\n            );\n            dls_fetch(\n                icoord_bottom_input,\n                bottom_inp_state,\n                dont_care_about_last_updated\n            );\n            dls_fetch(\n                icoord_center_input,\n                center_inp_state,\n                dont_care_about_last_updated\n            );\n            \n            // perform logic operations\n            if (gate_type == GATE_TYPE_AND)\n            {\n                if (top_inp_state == WIRE_STATE_LOW && bottom_inp_state == WIRE_STATE_LOW)\n                {\n                    wire_state = WIRE_STATE_LOW;\n                    last_updated = iter;\n                }\n                else if (top_inp_state == WIRE_STATE_LOW && bottom_inp_state == WIRE_STATE_HIGH)\n                {\n                    wire_state = WIRE_STATE_LOW;\n                    last_updated = iter;\n                }\n                else if (top_inp_state == WIRE_STATE_HIGH && bottom_inp_state == WIRE_STATE_LOW)\n                {\n                    wire_state = WIRE_STATE_LOW;\n                    last_updated = iter;\n                }\n                else if (top_inp_state == WIRE_STATE_HIGH && bottom_inp_state == WIRE_STATE_HIGH)\n                {\n                    wire_state = WIRE_STATE_HIGH;\n                    last_updated = iter;\n                }\n            }\n            else if (gate_type == GATE_TYPE_OR)\n            {\n                if (top_inp_state == WIRE_STATE_LOW && bottom_inp_state == WIRE_STATE_LOW)\n                {\n                    wire_state = WIRE_STATE_LOW;\n                    last_updated = iter;\n                }\n                else if (top_inp_state == WIRE_STATE_LOW && bottom_inp_state == WIRE_STATE_HIGH)\n                {\n                    wire_state = WIRE_STATE_HIGH;\n                    last_updated = iter;\n                }\n                else if (top_inp_state == WIRE_STATE_HIGH && bottom_inp_state == WIRE_STATE_LOW)\n                {\n                    wire_state = WIRE_STATE_HIGH;\n                    last_updated = iter;\n                }\n                else if (top_inp_state == WIRE_STATE_HIGH && bottom_inp_state == WIRE_STATE_HIGH)\n                {\n                    wire_state = WIRE_STATE_HIGH;\n                    last_updated = iter;\n                }\n            }\n            else if (gate_type == GATE_TYPE_XOR)\n            {\n                if (top_inp_state == WIRE_STATE_LOW && bottom_inp_state == WIRE_STATE_LOW)\n                {\n                    wire_state = WIRE_STATE_LOW;\n                    last_updated = iter;\n                }\n                else if (top_inp_state == WIRE_STATE_LOW && bottom_inp_state == WIRE_STATE_HIGH)\n                {\n                    wire_state = WIRE_STATE_HIGH;\n                    last_updated = iter;\n                }\n                else if (top_inp_state == WIRE_STATE_HIGH && bottom_inp_state == WIRE_STATE_LOW)\n                {\n                    wire_state = WIRE_STATE_HIGH;\n                    last_updated = iter;\n                }\n                else if (top_inp_state == WIRE_STATE_HIGH && bottom_inp_state == WIRE_STATE_HIGH)\n                {\n                    wire_state = WIRE_STATE_LOW;\n                    last_updated = iter;\n                }\n            }\n            else if (gate_type == GATE_TYPE_NOT)\n            {\n                if (center_inp_state == WIRE_STATE_LOW)\n                {\n                    wire_state = WIRE_STATE_HIGH;\n                    last_updated = iter;\n                }\n                else if (center_inp_state == WIRE_STATE_HIGH)\n                {\n                    wire_state = WIRE_STATE_LOW;\n                    last_updated = iter;\n                }\n            }\n            else if (gate_type == GATE_TYPE_NAND)\n            {\n                if (top_inp_state == WIRE_STATE_LOW && bottom_inp_state == WIRE_STATE_LOW)\n                {\n                    wire_state = WIRE_STATE_HIGH;\n                    last_updated = iter;\n                }\n                else if (top_inp_state == WIRE_STATE_LOW && bottom_inp_state == WIRE_STATE_HIGH)\n                {\n                    wire_state = WIRE_STATE_HIGH;\n                    last_updated = iter;\n                }\n                else if (top_inp_state == WIRE_STATE_HIGH && bottom_inp_state == WIRE_STATE_LOW)\n                {\n                    wire_state = WIRE_STATE_HIGH;\n                    last_updated = iter;\n                }\n                else if (top_inp_state == WIRE_STATE_HIGH && bottom_inp_state == WIRE_STATE_HIGH)\n                {\n                    wire_state = WIRE_STATE_LOW;\n                    last_updated = iter;\n                }\n            }\n            else if (gate_type == GATE_TYPE_NOR)\n            {\n                if (top_inp_state == WIRE_STATE_LOW && bottom_inp_state == WIRE_STATE_LOW)\n                {\n                    wire_state = WIRE_STATE_HIGH;\n                    last_updated = iter;\n                }\n                else if (top_inp_state == WIRE_STATE_LOW && bottom_inp_state == WIRE_STATE_HIGH)\n                {\n                    wire_state = WIRE_STATE_LOW;\n                    last_updated = iter;\n                }\n                else if (top_inp_state == WIRE_STATE_HIGH && bottom_inp_state == WIRE_STATE_LOW)\n                {\n                    wire_state = WIRE_STATE_LOW;\n                    last_updated = iter;\n                }\n                else if (top_inp_state == WIRE_STATE_HIGH && bottom_inp_state == WIRE_STATE_HIGH)\n                {\n                    wire_state = WIRE_STATE_LOW;\n                    last_updated = iter;\n                }\n            }\n            else if (gate_type == GATE_TYPE_XNOR)\n            {\n                if (top_inp_state == WIRE_STATE_LOW && bottom_inp_state == WIRE_STATE_LOW)\n                {\n                    wire_state = WIRE_STATE_HIGH;\n                    last_updated = iter;\n                }\n                else if (top_inp_state == WIRE_STATE_LOW && bottom_inp_state == WIRE_STATE_HIGH)\n                {\n                    wire_state = WIRE_STATE_LOW;\n                    last_updated = iter;\n                }\n                else if (top_inp_state == WIRE_STATE_HIGH && bottom_inp_state == WIRE_STATE_LOW)\n                {\n                    wire_state = WIRE_STATE_LOW;\n                    last_updated = iter;\n                }\n                else if (top_inp_state == WIRE_STATE_HIGH && bottom_inp_state == WIRE_STATE_HIGH)\n                {\n                    wire_state = WIRE_STATE_HIGH;\n                    last_updated = iter;\n                }\n            }\n            else if (gate_type == GATE_TYPE_SWITCH)\n            {\n                if (top_inp_state == WIRE_STATE_LOW && bottom_inp_state == WIRE_STATE_LOW)\n                {\n                    // do nothing\n                }\n                else if (top_inp_state == WIRE_STATE_LOW && bottom_inp_state == WIRE_STATE_HIGH)\n                {\n                    wire_state = WIRE_STATE_LOW;\n                    last_updated = iter;\n                }\n                else if (top_inp_state == WIRE_STATE_HIGH && bottom_inp_state == WIRE_STATE_LOW)\n                {\n                    // do nothing\n                }\n                else if (top_inp_state == WIRE_STATE_HIGH && bottom_inp_state == WIRE_STATE_HIGH)\n                {\n                    wire_state = WIRE_STATE_HIGH;\n                    last_updated = iter;\n                }\n            }\n            else if (gate_type == GATE_TYPE_CLOCK)\n            {\n                int interval = CLOCK_INTERV[clock_interval % N_CLOCK_INTERV];\n                wire_state =\n                    (iter % (2 * interval)) < interval\n                    ? WIRE_STATE_LOW\n                    : WIRE_STATE_HIGH;\n                last_updated = iter;\n            }\n            \n            break;\n        }\n        else if (point_inside_gate(block_uv, gate_type))\n        {\n            // we're inside a gate so don't run the simulation\n            inside_gate = true;\n            break;\n        }\n    }\n    \n    // only run the simulation for wire pixels, and not inside gates\n    if (wire_state != WIRE_STATE_NOT_WIRE && !inside_gate)\n    {\n        // check neighbors (5x5 window excluding the center)\n        for (int y_offs = -2; y_offs <= 2; y_offs++)\n        {\n            for (int x_offs = -2; x_offs <= 2; x_offs++)\n            {\n                // skip self (offset=0)\n                ivec2 offs = ivec2(x_offs, y_offs);\n                if (offs == ivec2(0))\n                {\n                    continue;\n                }\n                \n                // fetch neighbor's values\n                int neighbor_wire_state;\n                int neighbor_last_updated;\n                dls_fetch(\n                    icoord + offs,\n                    neighbor_wire_state,\n                    neighbor_last_updated\n                );\n                \n                // function name says everything\n                take_on_neighbor_value_if_needed(\n                    wire_state,\n                    last_updated,\n                    neighbor_wire_state,\n                    neighbor_last_updated\n                );\n            }\n        }\n        \n        // if mouse is down and on this pixel (and it's a wire)\n        if (iMouse.z > .5 && ivec2(iMouse.xy) == icoord && !mouse_in_toolbar)\n        {\n            // draw wire state\n            if (draw_mode == DRAW_MODE_WIRE_LOW)\n            {\n                wire_state = WIRE_STATE_LOW;\n                last_updated = iter;\n            }\n            else if (draw_mode == DRAW_MODE_WIRE_HIGH)\n            {\n                wire_state = WIRE_STATE_HIGH;\n                last_updated = iter;\n            }\n        }\n    }\n    \n    // on mouse down\n    if (iMouse.z > .5 && prev_mouse_down && !mouse_in_toolbar)\n    {\n        float line_segment_dist = sd_segment(\n            frag_coord,\n            vec2(prev_imouse) + .5,\n            iMouse.xy\n        );\n    \n        // draw wires\n        float brush_thick = brush_thickness_px(is_key_down(Key_Shift));\n        if (draw_mode == DRAW_MODE_WIRE\n            && line_segment_dist < brush_thick\n            && wire_state == WIRE_STATE_NOT_WIRE)\n        {\n            wire_state = WIRE_STATE_DISCONNECTED;\n            last_updated = -1;\n        }\n        \n        // erase wires\n        float eraser_thick = eraser_thickness_px(is_key_down(Key_Shift));\n        if (draw_mode == DRAW_MODE_ERASE\n            && line_segment_dist < eraser_thick)\n        {\n            wire_state = WIRE_STATE_NOT_WIRE;\n            last_updated = -1;\n        }\n    }\n    \n    // output the new values\n    frag_col = dls_encode(wire_state, last_updated);\n}\n",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [
      {
       "id": "4dXGRr",
       "filepath": "/presets/tex00.jpg",
       "type": "keyboard",
       "channel": 3,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4sXGR8",
       "filepath": "/media/previz/buffer02.png",
       "type": "buffer",
       "channel": 2,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "XsXGR8",
       "channel": 0
      }
     ],
     "code": "// gate buffer. this stores a fixed array of logic gates. by\n// default, the elements are initialized to represent no gates,\n// but they can change based on user input.\n\n// this buffer operates in the bottom left GATE_BUF_SIZE block\n// of pixels, so it stores a fixed array of\n// (GATE_BUF_SIZE.x * GATE_BUF_SIZE.y) gates. each pixel stores\n// a gate's type and its bottom left coordinates in pixel space.\n// the simulation buffer uses this info to perform boolean\n// operations at the gate outputs, and the image tab uses this\n// buffer to render the gates.\n\n#if SHADERTOY\n// iChannel3 must be set to Keyboard in Shadertoy\n#define SHADERTOY_KEYBOARD_CH iChannel3\n#else\n#iKeyboard\n#endif\n\ndefine_keyboard_utils\n\n#define ICHANNEL_SIM_BUF iChannel0\n#define ICHANNEL_SELF iChannel1\n#define ICHANNEL_DATA_BUF iChannel2\n\nvoid gate_fetch(\n    int idx,\n    out int gate_type,\n    out int rotation,\n    out int clock_interval,\n    out ivec2 icoord_bl\n)\n{\n    if (idx < 0 || idx >= N_GATES)\n    {\n        gate_type = GATE_TYPE_NONE;\n        icoord_bl = ivec2(0);\n        return;\n    }\n    \n    ivec2 icoord = idx_to_icoord(idx, GATE_BUF_SIZE);\n    vec4 data = texelFetch(ICHANNEL_SELF, icoord, 0);\n    gate_buf_decode(\n        data,\n        gate_type,\n        rotation,\n        clock_interval,\n        icoord_bl\n    );\n}\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    ivec2 icoord = ivec2(frag_coord);\n    \n    // only care about the bottom left block\n    if (!icoord_in_bounds(icoord, GATE_BUF_SIZE))\n    {\n        return;\n    }\n    \n    // 1D index of this pixel in the buffer\n    int my_idx = icoord_to_idx(icoord, GATE_BUF_SIZE);\n    \n    // values from the data buffer\n    ivec2 res;\n    int draw_mode;\n    bool prev_mouse_down;\n    ivec2 prev_imouse;\n    int iter;\n    data_buf_decode(\n        texelFetch(ICHANNEL_DATA_BUF, ivec2(0), 0),\n        res,\n        draw_mode,\n        prev_mouse_down,\n        prev_imouse,\n        iter\n    );\n    \n    // resolution changed since last frame?\n    bool res_changed = imax(\n        iabs(res.x - int(iResolution.x)),\n        iabs(res.y - int(iResolution.y))\n    ) > 0;\n    \n    // are we in the first frame?\n    bool first_frame = (iFrame < 1) || (iTime < .02);\n\n    // set initial values and return on resolution change or\n    // the first frame, or if C is pressed\n    if (res_changed || first_frame || is_key_pressed(Key_C))\n    {\n        frag_col = gate_buf_encode(\n            GATE_TYPE_NONE,\n            GATE_ROT_NONE,\n            0,\n            ivec2(0)\n        );\n        return;\n    }\n    \n    // see if mouse is in the toolbar\n    vec2 mouse_toolbar_uv = dls_toolbar_uv(iMouse.xy, iResolution.xy); \n    bool mouse_in_toolbar = point_inside_dls_toolbar(\n        mouse_toolbar_uv,\n        iResolution.xy\n    );\n    \n    // current values\n    int gate_type;\n    int rotation;\n    int clock_interval;\n    ivec2 icoord_bl;\n    gate_buf_decode(\n        texelFetch(ICHANNEL_SELF, icoord, 0),\n        gate_type,\n        rotation,\n        clock_interval,\n        icoord_bl\n    );\n    \n    // on mouse down and in erase mode\n    if (iMouse.z > .5\n        && prev_mouse_down\n        && !mouse_in_toolbar\n        && draw_mode == DRAW_MODE_ERASE)\n    {\n        // find the index of the gate under the mouse\n        int delete_idx = -1;\n        for (int i = 0; i < N_GATES; i++)\n        {\n            int elem_gate_type;\n            int elem_rotation;\n            int elem_clock_interval;\n            ivec2 elem_icoord_bl;\n            gate_fetch(\n                i,\n                elem_gate_type,\n                elem_rotation,\n                elem_clock_interval,\n                elem_icoord_bl\n            );\n            \n            // skip empty slots\n            if (elem_gate_type == GATE_TYPE_NONE)\n            {\n                continue;\n            }\n            \n            // is the gate under the mouse?\n            ivec2 elem_icoord_tr = elem_icoord_bl + GATE_SIZE_PX;\n            ivec2 imouse = ivec2(iMouse.xy);\n            bool under_mouse = false;\n            if (all(greaterThanEqual(imouse, elem_icoord_bl))\n                && all(lessThan(imouse, elem_icoord_tr)))\n            {\n                vec2 block_uv_norot =\n                    (iMouse.xy - vec2(elem_icoord_bl) - .5) / float(GATE_SIZE_PX);\n                vec2 block_uv = rotate_block_uv(block_uv_norot, elem_rotation);\n                under_mouse = point_inside_gate(block_uv, elem_gate_type);\n            }\n\n            if (!under_mouse)\n            {\n                continue;\n            }\n            \n            // found a gate under the mouse\n            delete_idx = i;\n            break;\n        }\n        \n        // if we found a gate to delete and it's exactly this pixel\n        if (delete_idx != -1 && delete_idx == my_idx)\n        {\n            // reset this pixel to delete the gate\n            gate_type = GATE_TYPE_NONE;\n            rotation = GATE_ROT_NONE;\n            clock_interval = 0;\n            icoord_bl = ivec2(0);\n        }\n    }\n    \n    // on mouse press\n    if (iMouse.z > .5\n        && !prev_mouse_down\n        && !mouse_in_toolbar)\n    {\n        // do we need to add a gate? and what type?\n        int gate_to_add = GATE_TYPE_NONE;\n        if (draw_mode == DRAW_MODE_GATE_AND)\n        {\n            gate_to_add = GATE_TYPE_AND;\n        }\n        else if (draw_mode == DRAW_MODE_GATE_OR)\n        {\n            gate_to_add = GATE_TYPE_OR;\n        }\n        else if (draw_mode == DRAW_MODE_GATE_XOR)\n        {\n            gate_to_add = GATE_TYPE_XOR;\n        }\n        else if (draw_mode == DRAW_MODE_GATE_NOT)\n        {\n            gate_to_add = GATE_TYPE_NOT;\n        }\n        else if (draw_mode == DRAW_MODE_GATE_NAND)\n        {\n            gate_to_add = GATE_TYPE_NAND;\n        }\n        else if (draw_mode == DRAW_MODE_GATE_NOR)\n        {\n            gate_to_add = GATE_TYPE_NOR;\n        }\n        else if (draw_mode == DRAW_MODE_GATE_XNOR)\n        {\n            gate_to_add = GATE_TYPE_XNOR;\n        }\n        else if (draw_mode == DRAW_MODE_GATE_SWITCH)\n        {\n            gate_to_add = GATE_TYPE_SWITCH;\n        }\n        else if (draw_mode == DRAW_MODE_GATE_CLOCK)\n        {\n            gate_to_add = GATE_TYPE_CLOCK;\n        }\n        else if (draw_mode == DRAW_MODE_GATE_CROSS)\n        {\n            gate_to_add = GATE_TYPE_CROSS;\n        }\n\n        // bounds of the new gate to add\n        ivec2 gate_to_add_bl = ivec2(iMouse.xy) - GATE_SIZE_PX / 2;\n        ivec2 gate_to_add_tr = gate_to_add_bl + GATE_SIZE_PX;\n        \n        // find the index of the first empty slot\n        int empty_idx = -1;\n        for (int i = 0; i < N_GATES; i++)\n        {\n            int elem_gate_type;\n            int elem_rotation;\n            int elem_clock_interval;\n            ivec2 elem_icoord_bl;\n            gate_fetch(\n                i,\n                elem_gate_type,\n                elem_rotation,\n                elem_clock_interval,\n                elem_icoord_bl\n            );\n            \n            // if slot already occupied\n            if (elem_gate_type != GATE_TYPE_NONE)\n            {\n                // does the gate in this slot intersect with the\n                // bounds of the new gate we wanna add?\n                ivec2 elem_icoord_tr = elem_icoord_bl + GATE_SIZE_PX;\n                bool intersects =\n                    elem_icoord_tr.x >= gate_to_add_bl.x\n                    && elem_icoord_bl.x <= gate_to_add_tr.x\n                    && elem_icoord_tr.y - GATE_VERT_PADDING >= gate_to_add_bl.y + GATE_VERT_PADDING\n                    && elem_icoord_bl.y + GATE_VERT_PADDING <= gate_to_add_tr.y - GATE_VERT_PADDING;\n                \n                // if so, just don't add the new gate (break the loop)\n                // actually this is a lie cuz we will replace the\n                // intersecting gate's type with the new one. keep\n                // reading.\n                if (intersects)\n                {\n                    // before we break, though, we'll rotate the gate\n                    // if the Alt key is down.\n                    // don't rotate crosses though!\n                    if (is_key_down(Key_Alt)\n                        && i == my_idx\n                        && gate_type != GATE_TYPE_CROSS\n                        && draw_mode != DRAW_MODE_ERASE)\n                    {\n                        rotation = (rotation + 1) % 4;\n                    }\n                    \n                    // if this is a clock gate, change its interval\n                    // if the Ctrl key is down.\n                    if (is_key_down(Key_Ctrl)\n                        && i == my_idx\n                        && draw_mode != DRAW_MODE_ERASE)\n                    {\n                        clock_interval = (clock_interval + 1) % N_CLOCK_INTERV;\n                    }\n                    \n                    // but wait! if we're in the pixel that represents\n                    // the intersecting gate, we'll update ourselves to\n                    // take the new type!\n                    if (i == my_idx\n                        && gate_to_add != GATE_TYPE_NONE\n                        && gate_type != gate_to_add)\n                    {\n                        gate_type = gate_to_add;\n                        clock_interval = 0;\n                    }\n                    \n                    break;\n                }\n                \n                // otherwise, skip this slot and continue looking\n                // for an empty slot\n                continue;\n            }\n            \n            // found an empty slot\n            empty_idx = i;\n            break;\n        }\n        \n        // if we found an empty slot and it's exactly this pixel,\n        // and we have a gate to add\n        if (empty_idx != -1\n            && empty_idx == my_idx\n            && gate_to_add != GATE_TYPE_NONE)\n        {\n            // update this pixel\n            gate_type = gate_to_add;\n            rotation = GATE_ROT_NONE;\n            clock_interval = 0;\n            icoord_bl = gate_to_add_bl;\n        }\n    }\n    \n    // output the new values\n    frag_col = gate_buf_encode(\n        gate_type,\n        rotation,\n        clock_interval,\n        icoord_bl\n    );\n}\n",
     "name": "Buffer B",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [
      {
       "id": "4sXGR8",
       "filepath": "/media/previz/buffer02.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4sXGR8",
       "channel": 0
      }
     ],
     "code": "// data buffer. this stores the last frame's resolution, the\n// current draw mode, whether the mouse button was down in\n// the previous frame, and the mouse coordinates in the\n// previous frame.\n\n#define ICHANNEL_SELF iChannel0\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    ivec2 icoord = ivec2(frag_coord);\n    \n    // only care about pixel (0, 0)\n    if (icoord != ivec2(0))\n    {\n        return;\n    }\n    \n    // current values\n    ivec2 res;\n    int draw_mode;\n    bool prev_mouse_down;\n    ivec2 prev_imouse;\n    int iter;\n    data_buf_decode(\n        texelFetch(ICHANNEL_SELF, icoord, 0),\n        res,\n        draw_mode,\n        prev_mouse_down,\n        prev_imouse,\n        iter\n    );\n    \n    // resolution changed since last frame?\n    bool res_changed = imax(\n        iabs(res.x - int(iResolution.x)),\n        iabs(res.y - int(iResolution.y))\n    ) > 0;\n    \n    // set resolution to the current resolution\n    res = ivec2(iResolution.xy);\n\n    // are we in the first frame?\n    bool first_frame = (iFrame < 1) || (iTime < .02);\n    \n    // reset on resolution change or the first frame\n    if (res_changed || first_frame)\n    {\n        frag_col = data_buf_encode(\n            ivec2(iResolution.xy),\n            DRAW_MODE_WIRE,\n            iMouse.z > .5,\n            ivec2(iMouse.xy),\n            0\n        );\n        return;\n    }\n    \n    // change draw mode with mouse\n    {\n        vec2 mouse_toolbar_uv = dls_toolbar_uv(iMouse.xy, iResolution.xy);\n        \n        bool mouse_in_toolbar = point_inside_dls_toolbar(\n            mouse_toolbar_uv,\n            iResolution.xy\n        );\n        \n        if (mouse_in_toolbar && iMouse.z > .5 && !prev_mouse_down)\n        {\n            int block_idx = dls_toolbar_block_idx(mouse_toolbar_uv);\n            draw_mode = block_idx;\n        }\n    }\n    \n    // output the new values\n    frag_col = data_buf_encode(\n        ivec2(iResolution.xy),\n        draw_mode,\n        iMouse.z > .5,\n        ivec2(iMouse.xy),\n        iter + 1\n    );\n}\n",
     "name": "Buffer C",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "lXdSRj",
    "date": "0",
    "viewed": 0,
    "name": "Next Target",
    "description": "landscape",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "3d",
     "raymarching",
     "terrain",
     "sdf",
     "landscape",
     "heightmap",
     "mountains",
     "scene",
     "nature"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// ASC CDL color grading\n// https://en.wikipedia.org/wiki/ASC_CDL\nvec3 asc_cdl(vec3 col, vec3 slope, vec3 offset, vec3 power)\n{\n    return pow(\n        max(\n            max(col, 0.) * slope + offset,\n            0.\n        ),\n        power\n    );\n}\n\nvec3 view_transform(vec3 col)\n{\n    // avoid negative values before using power functions\n    col = max(col, 0.);\n    \n    // color grading\n    col = asc_cdl(\n        col,\n        vec3(1, .94, .96),\n        vec3(0, .004, 0),\n        vec3(1, 1.042, 1.021)\n    );\n    \n    // flim\n    const float exposure = .2;\n    col = flim_transform(col, exposure, true);\n\n    return col;\n}\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    // read buf B\n    vec3 col = texelFetch(iChannel0, ivec2(frag_coord), 0).rgb;\n\n    // view transform\n    col = view_transform(col);\n\n    // output\n    frag_col = vec4(col, 1);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "#define SHADERTOY 1\n\nprecision highp float;\nprecision highp int;\n\n\n\n/*___________ math & integer utils ____________*/\n\nconst float PI = 3.141592653589793238462643383;\nconst float TAU = 6.283185307179586476925286767;\nconst float PI_OVER_2 = 1.570796326794896619231321692;\nconst float INV_PI = .318309886183790671537767527;\nconst float INV_TAU = .159154943091895335768883763;\n\n#define FUNC_WRAP(T) \\\nT wrap(T v, float start, float end) \\\n{ \\\n    return start + mod(v - start, end - start); \\\n}\n\n#define FUNC_REMAP(T) \\\nT remap(T v, float inp_start, float inp_end, float out_start, float out_end) \\\n{ \\\n    return out_start \\\n        + ((out_end - out_start) / (inp_end - inp_start)) * (v - inp_start); \\\n}\n\n#define FUNC_REMAP_CLAMP(T) \\\nT remap_clamp( \\\n    T v, \\\n    float inp_start, \\\n    float inp_end, \\\n    float out_start, \\\n    float out_end \\\n) \\\n{ \\\n    T t = clamp((v - inp_start) / (inp_end - inp_start), 0., 1.); \\\n    return out_start + t * (out_end - out_start); \\\n}\n\n#define FUNC_REMAP01(T) \\\nT remap01(T v, float inp_start, float inp_end) \\\n{ \\\n    return clamp((v - inp_start) / (inp_end - inp_start), 0., 1.); \\\n}\n\n#define FUNC_LENGTH_SQ(T) \\\nfloat length_sq(T v) \\\n{ \\\n    return dot(v, v); \\\n}\n\n#define FUNC_DIST_SQ(T) \\\nfloat dist_sq(T a, T b) \\\n{ \\\n    a -= b; \\\n    return dot(a, a); \\\n}\n\nFUNC_WRAP(float)\nFUNC_WRAP(vec2)\nFUNC_WRAP(vec3)\nFUNC_WRAP(vec4)\n\nFUNC_REMAP(float)\nFUNC_REMAP(vec2)\nFUNC_REMAP(vec3)\nFUNC_REMAP(vec4)\n\nFUNC_REMAP_CLAMP(float)\nFUNC_REMAP_CLAMP(vec2)\nFUNC_REMAP_CLAMP(vec3)\nFUNC_REMAP_CLAMP(vec4)\n\nFUNC_REMAP01(float)\nFUNC_REMAP01(vec2)\nFUNC_REMAP01(vec3)\nFUNC_REMAP01(vec4)\n\nFUNC_LENGTH_SQ(vec2)\nFUNC_LENGTH_SQ(vec3)\nFUNC_LENGTH_SQ(vec4)\n\nFUNC_DIST_SQ(vec2)\nFUNC_DIST_SQ(vec3)\nFUNC_DIST_SQ(vec4)\n\nfloat chebyshev_dist(vec2 a, vec2 b)\n{\n    return max(abs(a.x - b.x), abs(a.y - b.y));\n}\n\nfloat chebyshev_dist(vec3 a, vec3 b)\n{\n    return max(\n        max(abs(a.x - b.x), abs(a.y - b.y)),\n        abs(a.z - b.z)\n    );\n}\n\nfloat chebyshev_dist(vec4 a, vec4 b)\n{\n    return max(\n        max(\n            max(abs(a.x - b.x), abs(a.y - b.y)),\n            abs(a.z - b.z)\n        ),\n        abs(a.w - b.w)\n    );\n}\n\n#define idiv_ceil(a, b) ((a + b - 1) / b)\n\nint iabs(int v)\n{\n    if (v < 0)\n    {\n        return -v;\n    }\n    return v;\n}\n\nint imin(int a, int b)\n{\n    if (a < b)\n    {\n        return a;\n    }\n    return b;\n}\n\nint imax(int a, int b)\n{\n    if (a > b)\n    {\n        return a;\n    }\n    return b;\n}\n\nint iclamp(int v, int start, int end)\n{\n    if (v < start)\n    {\n        v = start;\n    }\n    if (v > end)\n    {\n        v = end;\n    }\n    return v;\n}\n\nfloat min_component(vec2 v)\n{\n    return min(v.x, v.y);\n}\n\nfloat min_component(vec3 v)\n{\n    return min(min(v.x, v.y), v.z);\n}\n\nfloat min_component(vec4 v)\n{\n    return min(min(min(v.x, v.y), v.z), v.w);\n}\n\nfloat max_component(vec2 v)\n{\n    return max(v.x, v.y);\n}\n\nfloat max_component(vec3 v)\n{\n    return max(max(v.x, v.y), v.z);\n}\n\nfloat max_component(vec4 v)\n{\n    return max(max(max(v.x, v.y), v.z), v.w);\n}\n\nint min_component(ivec2 v)\n{\n    return imin(v.x, v.y);\n}\n\nint min_component(ivec3 v)\n{\n    return imin(imin(v.x, v.y), v.z);\n}\n\nint min_component(ivec4 v)\n{\n    return imin(imin(imin(v.x, v.y), v.z), v.w);\n}\n\nint max_component(ivec2 v)\n{\n    return imax(v.x, v.y);\n}\n\nint max_component(ivec3 v)\n{\n    return imax(imax(v.x, v.y), v.z);\n}\n\nint max_component(ivec4 v)\n{\n    return imax(imax(imax(v.x, v.y), v.z), v.w);\n}\n\nfloat bilinear(\n    float val_bl,\n    float val_tl,\n    float val_tr,\n    float val_br,\n    vec2 offs\n)\n{\n    return mix(\n        mix(val_bl, val_br, offs.x),\n        mix(val_tl, val_tr, offs.x),\n        offs.y\n    );\n}\n\n// credits to AHSEN (https://www.shadertoy.com/user/01000001)\n// https://www.desmos.com/calculator/5d6ph151vi interactive :D\nfloat cubic_interp(float a, float b, float c, float d, float t)\n{\n    float one = t - 1.;\n    float two = t - 2.;\n    float three = t - 3.;\n    return (\n        (-one * two * three * a)\n        + (t * one * two * d)\n        + (3. * t * two * three * b)\n        - (3. * t * one * three * c)\n    ) / 6.;\n}\n\nfloat dist_along_line(vec2 p, vec2 line_start, vec2 line_end)\n{\n    vec2 dir = line_end - line_start;\n    \n    // normalize\n    float len_sqr = dot(dir, dir);\n    if (len_sqr < .0001)\n        return 1e9;\n    dir /= sqrt(len_sqr);\n    \n    return dot(\n        dir,\n        p - line_start\n    );\n}\n\nfloat relative_dist_along_line(vec2 p, vec2 line_start, vec2 line_end)\n{\n    vec2 dir = line_end - line_start;\n    return dot(\n        dir,\n        p - line_start\n    );\n}\n\n// |a| * |b| * sin(theta)\nfloat cross2d(vec2 a, vec2 b)\n{\n    return a.x * b.y - a.y * b.x;\n}\n\n// references for barycentric coordinates\n// https://www.desmos.com/calculator/8g8xjejuox\n// https://www.shadertoy.com/view/mdjBWK\n\nvec3 cartesian_to_barycentric(\n    vec2 p,\n    vec2 v0,\n    vec2 v1,\n    vec2 v2,\n    bool clamp_,\n    out bool p_is_outside\n)\n{\n    vec3 b = vec3(\n        cross2d(v1 - p, v2 - p),\n        cross2d(v2 - p, v0 - p),\n        cross2d(v0 - p, v1 - p)\n    ) / cross2d(v1 - v0, v2 - v0);\n    p_is_outside = min(min(b.x, b.y), b.z) < 0.;\n    if (clamp_)\n    {\n        b = max(b, 0.);\n        b /= (b.x + b.y + b.z);\n    }\n    return b;\n}\n\nvec3 cartesian_to_barycentric(\n    vec3 p,\n    vec3 v0,\n    vec3 v1,\n    vec3 v2,\n    bool clamp_,\n    out bool p_is_outside\n)\n{\n    vec3 b = vec3(\n        length(cross(v1 - p, v2 - p)),\n        length(cross(v2 - p, v0 - p)),\n        length(cross(v0 - p, v1 - p))\n    ) / length(cross(v1 - v0, v2 - v0));\n    p_is_outside = min(min(b.x, b.y), b.z) < 0.;\n    if (clamp_)\n    {\n        b = max(b, 0.);\n        b /= (b.x + b.y + b.z);\n    }\n    return b;\n}\n\nfloat barycentric_interpolate(vec3 b, float v0, float v1, float v2)\n{\n    return dot(b, vec3(v0, v1, v2));\n}\n\nvec2 barycentric_interpolate(vec3 b, vec2 v0, vec2 v1, vec2 v2)\n{\n    return b.x * v0 + b.y * v1 + b.z * v2;\n}\n\nvec3 barycentric_interpolate(vec3 b, vec3 v0, vec3 v1, vec3 v2)\n{\n    return b.x * v0 + b.y * v1 + b.z * v2;\n}\n\nvec4 barycentric_interpolate(vec3 b, vec4 v0, vec4 v1, vec4 v2)\n{\n    return b.x * v0 + b.y * v1 + b.z * v2;\n}\n\nfloat barycentric_interpolate(vec2 b, float v0, float v1, float v2)\n{\n    return barycentric_interpolate(\n        vec3(b.x, b.y, 1. - b.x - b.y),\n        v0, v1, v2\n    );\n}\n\nvec2 barycentric_interpolate(vec2 b, vec2 v0, vec2 v1, vec2 v2)\n{\n    return barycentric_interpolate(\n        vec3(b.x, b.y, 1. - b.x - b.y),\n        v0, v1, v2\n    );\n}\n\nvec3 barycentric_interpolate(vec2 b, vec3 v0, vec3 v1, vec3 v2)\n{\n    return barycentric_interpolate(\n        vec3(b.x, b.y, 1. - b.x - b.y),\n        v0, v1, v2\n    );\n}\n\nvec4 barycentric_interpolate(vec2 b, vec4 v0, vec4 v1, vec4 v2)\n{\n    return barycentric_interpolate(\n        vec3(b.x, b.y, 1. - b.x - b.y),\n        v0, v1, v2\n    );\n}\n\n// angle from 0 to TAU\nfloat get_angle(vec2 p)\n{\n    float a = atan(p.y, p.x);\n    if (a < 0.)\n    {\n        return a + TAU;\n    }\n    return a;\n}\n\nmat2 rotate_2d(float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(\n        c, s,\n        -s, c\n    );\n}\n\nvec2 perpendicular(vec2 v)\n{\n    return vec2(-v.y, v.x);\n}\n\n// s.x=theta\n// s.y=phi\n// (there's no r)\nvec3 spherical_to_cartesian(vec2 s)\n{\n    float sin_theta = sin(s.x);\n    return vec3(\n        sin_theta * cos(s.y),\n        sin_theta * sin(s.y),\n        cos(s.x)\n    );\n}\n\n// s.x=r\n// s.y=theta\n// s.z=phi\nvec3 spherical_to_cartesian(vec3 s)\n{\n    float sin_theta = sin(s.y);\n    return s.x * vec3(\n        sin_theta * cos(s.z),\n        sin_theta * sin(s.z),\n        cos(s.y)\n    );\n}\n\nvec2 screen_to_uv01(vec2 coord, vec2 res)\n{\n    return coord / res;\n}\n\nvec2 screen_to_uv_horizontal(vec2 coord, vec2 res)\n{\n    return (2. * coord - res) / res.x;\n}\n\nvec2 screen_to_uv_vertical(vec2 coord, vec2 res)\n{\n    return (2. * coord - res) / res.y;\n}\n\nvec2 screen_to_uv_fit(vec2 coord, vec2 res)\n{\n    return (2. * coord - res) / min_component(res);\n}\n\nvec2 screen_to_uv_fill(vec2 coord, vec2 res)\n{\n    return (2. * coord - res) / max_component(res);\n}\n\n// * idx starts at 1\nfloat halton(int base, int idx)\n{\n    float result = 0.;\n    float digit_weight = 1.;\n    while (idx > 0)\n    {\n        digit_weight /= float(base);\n        result += float(idx % base) * digit_weight;\n        idx /= base;\n    }\n    return result;\n}\n\n// * idx starts at 1\nvec2 halton_2d(int idx)\n{\n    return vec2(halton(2, idx), halton(3, idx));\n}\n\n// * idx starts at 1\nvec3 halton_3d(int idx)\n{\n    return vec3(halton(2, idx), halton(3, idx), halton(5, idx));\n}\n\n// * idx starts at 1\nvec4 halton_4d(int idx)\n{\n    return vec4(\n        halton(2, idx),\n        halton(3, idx),\n        halton(5, idx),\n        halton(7, idx)\n    );\n}\n\n// for some reason we can't use intBitsToFloat() or floatBitsToInt() to store\n// integers below this value in a buffer.\nconst int BUFFER_MIN_INTEGER = 8388608;\n\n// * x must not be higher than 4,286,578,688 (see BUFFER_MIN_INTEGER above)\n// * for your sanity, don't use negative values\nfloat encode_int_for_buffer(int v)\n{\n    return intBitsToFloat(v + BUFFER_MIN_INTEGER);\n}\n\nint decode_int_from_buffer(float v)\n{\n    return floatBitsToInt(v) - BUFFER_MIN_INTEGER;\n}\n\n// pack two 16-bit integers in a single 32-bit integer\n// * both arguments should be in the 0-65535 range\n// * a must be less than 65279 (see the functions above)\nint pack_i16(int a, int b)\n{\n    return (a << 16) | b;\n}\n\n// unpack two 16-bit integers from a single 32-bit integer\nvoid unpack_i16(int v, out int a, out int b)\n{\n    a = (v >> 16) & 65535;\n    b = v & 65535;\n}\n\n// unpack the first 16-bit integer from a 32-bit integer\nint unpack_i16_a(int v)\n{\n    return (v >> 16) & 65535;\n}\n\n// unpack the second 16-bit integer from a 32-bit integer\nint unpack_i16_b(int v)\n{\n    return v & 65535;\n}\n\nbool icoord_in_bounds(ivec2 icoord, ivec2 ires)\n{\n    return\n        icoord.x >= 0 &&\n        icoord.y >= 0 &&\n        icoord.x < ires.x &&\n        icoord.y < ires.y;\n}\n\nbool icoord_in_bounds(ivec3 icoord, ivec3 ires)\n{\n    return\n        icoord.x >= 0 &&\n        icoord.y >= 0 &&\n        icoord.z >= 0 &&\n        icoord.x < ires.x &&\n        icoord.y < ires.y &&\n        icoord.z < ires.z;\n}\n\nint icoord_to_idx(ivec2 icoord, ivec2 ires)\n{\n    return icoord.x + (icoord.y * ires.x);\n}\n\nint icoord_to_idx(ivec3 icoord, ivec3 ires)\n{\n    return icoord.x + (icoord.y * ires.x) + (icoord.z * ires.x * ires.y);\n}\n\nivec2 idx_to_icoord(int idx, ivec2 ires)\n{\n    return ivec2(idx % ires.x, idx / ires.x);\n}\n\nivec3 idx_to_icoord(int idx, ivec3 ires)\n{\n    return ivec3(\n        idx % ires.x,\n        (idx % (ires.x * ires.y)) / ires.x,\n        idx / (ires.x * ires.y)\n    );\n}\n\n// https://www.desmos.com/calculator/kfe07basy9\n\nint compress_float_to_int_linear(float f, float min_f, float max_f, int max_i)\n{\n    return int(floor(\n        float(max_i) * remap01(f, min_f, max_f)\n    ));\n}\n\nfloat decompress_float_from_int_linear(\n    int i,\n    int max_i,\n    float min_f,\n    float max_f\n)\n{\n    return remap_clamp(\n        float(i) / float(max_i),\n        0., 1.,\n        min_f, max_f\n    );\n}\n\nint compress_float_to_int_log(\n    float f,\n    float log2_zero_offset,\n    float max_log2_f,\n    int max_i\n)\n{\n    f = max(0., f);\n    f += pow(2., log2_zero_offset);\n    return int(floor(\n        float(max_i) * remap01(log2(f), log2_zero_offset, max_log2_f)\n    ));\n}\n\nfloat decompress_float_from_int_log(\n    int i,\n    int max_i,\n    float log2_zero_offset,\n    float max_log2_f\n)\n{\n    return pow(2., remap_clamp(\n        float(i) / float(max_i),\n        0., 1.,\n        log2_zero_offset, max_log2_f\n    )) - pow(2., log2_zero_offset);\n}\n\n\n\n/*_______ pseudo-random number generator ______*/\n// source: https://www.shadertoy.com/view/WdSSRt\n// (heavily modified)\n\n/* usage example:\n    void mainImage(out vec4 frag_col, in vec2 frag_coord)\n    {\n        // initialize PRNG\n        prng_init(vec3(frag_coord / iResolution.y, iTime));\n    \n        // use the function\n        float a = random();\n        vec3 b = vec3(random(), random(), random());\n        \n        ...\n    }\n*/\n\nuint prng_state[2];\n\nuint prng_rot(uint x, int k)\n{\n    return (x << k) | (x >> (32 - k));\n}\n\n// random uint from 0 to 2^32-1\nuint randomui()\n{\n    uint s0 = prng_state[0];\n    uint s1 = prng_state[1];\n    uint result = prng_rot(s0 * 2654435771u, 5) * 5u;\n    s1 ^= s0;\n    prng_state[0] = prng_rot(s0, 26) ^ s1 ^ (s1 << 9);\n    prng_state[1] = prng_rot(s1, 13);\n    return result;\n}\n\n// random int from 0 to 2^31-1\nint randomi()\n{\n    return int(randomui() % 0x7FFFFFFFu);\n}\n\n// random float from 0 to 1\nfloat random()\n{\n    return float(randomui()) / float(0xffffffffu);\n}\n\n// generate two normally distributed random numbers using the\n// Box-Muller transform\n// https://www.baeldung.com/cs/uniform-to-normal-distribution\nvec2 random_gauss()\n{\n    float u1 = random();\n    float u2 = random() * TAU;\n    float temp = sqrt(-2. * log(u1));\n    return temp * vec2(cos(u2), sin(u2));\n    \n    // unoptimized version\n    //float u1 = random();\n    //float u2 = random();\n    //return vec2(cos(TAU * u2), sin(TAU * u2)) * sqrt(-2. * log(u1));\n}\n\nvec2 random_on_circle()\n{\n    vec2 v = vec2(1);\n    float lensqr;\n\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec2(2. * random() - 1., 2. * random() - 1.);\n        lensqr = dot(v, v);\n        if (lensqr == 0.)\n            i--;\n        else if (lensqr <= 1.)\n            break;\n    }\n    return v / sqrt(lensqr);\n}\n\nvec3 random_on_sphere()\n{\n    vec3 v = vec3(1);\n    float lensqr;\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec3(2. * random() - 1., 2. * random() - 1., 2. * random() - 1.);\n        lensqr = dot(v, v);\n        if (lensqr == 0.)\n            i--;\n        else if (lensqr <= 1.)\n            break;\n    }\n    return v / sqrt(lensqr);\n}\n\nvec2 random_in_circle()\n{\n    vec2 v = vec2(1);\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec2(2. * random() - 1., 2. * random() - 1.);\n        if (dot(v, v) <= 1.)\n            return v;\n    }\n    return v;\n}\n\nvec3 random_in_sphere()\n{\n    vec3 v = vec3(1);\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec3(2. * random() - 1., 2. * random() - 1., 2. * random() - 1.);\n        if (dot(v, v) <= 1.)\n            return v;\n    }\n    return v;\n}\n\nvec3 random_on_hemisphere(vec3 normal)\n{\n    vec3 v = random_on_sphere();\n    return v * sign(dot(v, normal));\n}\n\nvec3 random_in_hemisphere(vec3 normal)\n{\n    vec3 v = random_in_sphere();\n    return v * sign(dot(v, normal));\n}\n\n// initialize with uvec2\nvoid prng_init(uvec2 seed)\n{\n    seed += uvec2(1317, 944573125);\n    seed *= 464973573u;\n    prng_state[0] = seed.x;\n    prng_state[1] = seed.y;\n    randomi();\n}\n\n// initialize with uint\nvoid prng_init(uint seed)\n{\n    prng_init(uvec2(seed, 1));\n}\n\n// initialize with vec3\nvoid prng_init(vec3 seed)\n{\n    seed += 3.49276101561702;\n    seed.xy *= (seed.z + 10.258);\n    prng_state[0] = floatBitsToUint(seed.x);\n    prng_state[1] = floatBitsToUint(seed.y);\n    randomui();\n}\n\n// initialize with vec2\nvoid prng_init(vec2 seed)\n{\n    prng_init(vec3(seed, 1));\n}\n\n// initialize with float\nvoid prng_init(float seed)\n{\n    prng_init(vec3(seed, 1, 1));\n}\n\n\n\n/*__________________ keyboard _________________*/\n\n// put this code in every buffer that uses the keyboard input:\n/*\n#if SHADERTOY\n// iChannelX must be set to Keyboard in Shadertoy\n#define SHADERTOY_KEYBOARD_CH iChannelX\n#else\n#iKeyboard\n#endif\n\ndefine_keyboard_utils\n*/\n\n#if SHADERTOY\n\n#define define_keyboard_utils \\\n \\\n/* https://github.com/stevensona/shader-toy/blob/c4833b972649d78a2ee090af60b79a3907e8e091/src/extensions/keyboard/keyboard_shader_extension.ts#L11 */ \\\nconst int \\\n    Key_Backspace = 8, Key_Tab = 9, Key_Enter = 13, Key_Shift = 16, \\\n    Key_Ctrl = 17, Key_Alt = 18, Key_Pause = 19, Key_Caps = 20, \\\n    Key_Escape = 27, Key_PageUp = 33, Key_PageDown = 34, Key_End = 35, \\\n    Key_Home = 36, Key_LeftArrow = 37, Key_UpArrow = 38, Key_RightArrow = 39, \\\n    Key_DownArrow = 40, Key_Insert = 45, Key_Delete = 46, Key_0 = 48, \\\n    Key_1 = 49, Key_2 = 50, Key_3 = 51, Key_4 = 52, Key_5 = 53, Key_6 = 54, \\\n    Key_7 = 55, Key_8 = 56, Key_9 = 57, Key_A = 65, Key_B = 66, Key_C = 67, \\\n    Key_D = 68, Key_E = 69, Key_F = 70, Key_G = 71, Key_H = 72, \\\n    Key_I = 73, Key_J = 74, Key_K = 75, Key_L = 76, Key_M = 77, Key_N = 78, \\\n    Key_O = 79, Key_P = 80, Key_Q = 81, Key_R = 82, Key_S = 83, Key_T = 84, \\\n    Key_U = 85, Key_V = 86, Key_W = 87, Key_X = 88, Key_Y = 89, Key_Z = 90, \\\n    Key_LeftWindow = 91, Key_RightWindows = 92, Key_Select = 93, \\\n    Key_Numpad0 = 96, Key_Numpad1 = 97, Key_Numpad2 = 98, Key_Numpad3 = 99, \\\n    Key_Numpad4 = 100, Key_Numpad5 = 101, Key_Numpad6 = 102, \\\n    Key_Numpad7 = 103, Key_Numpad8 = 104, Key_Numpad9 = 105, \\\n    Key_NumpadMultiply = 106, Key_NumpadAdd = 107, Key_NumpadSubtract = 109, \\\n    Key_NumpadPeriod = 110, Key_NumpadDivide = 111, Key_F1 = 112, \\\n    Key_F2 = 113, Key_F3 = 114, Key_F4 = 115, Key_F5 = 116, Key_F6 = 117, \\\n    Key_F7 = 118, Key_F8 = 119, Key_F9 = 120, Key_F10 = 121, Key_F11 = 122, \\\n    Key_F12 = 123, Key_NumLock = 144, Key_ScrollLock = 145, \\\n    Key_SemiColon = 186, Key_Equal = 187, Key_Comma = 188, Key_Dash = 189, \\\n    Key_Period = 190, Key_ForwardSlash = 191, Key_GraveAccent = 192, \\\n    Key_OpenBracket = 219, Key_BackSlash = 220, Key_CloseBraket = 221, \\\n    Key_SingleQuote = 222; \\\nconst int Key_Space = 32; \\\n \\\nbool is_key_pressed(int key) \\\n{ \\\n    return texelFetch(SHADERTOY_KEYBOARD_CH, ivec2(key, 1), 0).x > .5; \\\n} \\\n \\\nbool is_key_down(int key) \\\n{ \\\n    return texelFetch(SHADERTOY_KEYBOARD_CH, ivec2(key, 0), 0).x > .5; \\\n} \\\n \\\nbool is_key_toggled(int key) \\\n{ \\\n    return texelFetch(SHADERTOY_KEYBOARD_CH, ivec2(key, 2), 0).x > .5; \\\n}\n\n#else\n\n#define define_keyboard_utils \\\n \\\nconst int Key_Space = 32; \\\n \\\nbool is_key_pressed(int key) \\\n{ \\\n    return isKeyPressed(key); \\\n} \\\n \\\nbool is_key_down(int key) \\\n{ \\\n    return isKeyDown(key); \\\n} \\\n \\\nbool is_key_toggled(int key) \\\n{ \\\n    return isKeyToggled(key); \\\n}\n\n#endif\n\n\n\n/*_____________ camera jittering ______________*/\n\nvec2 jitter_offset(int frame_idx)\n{\n    const vec2 offsets[4] = vec2[4](\n        vec2(-.25, -.25),\n        vec2(.25, -.25),\n        vec2(.25, .25),\n        vec2(-.25, .25)\n    );\n    return offsets[frame_idx % 4];\n}\n\n// because every pixel in the render buffer turns into a 2x2\n// block of pixels when upscaled, we can do a tinier jitter in\n// the render buffer for AA\nvec2 subsubjitter_offset(int frame_idx)\n{\n    return .5 * (halton_2d((frame_idx % 17) + 1) - .5);\n}\n\n\n\n/*__________________ noise ____________________*/\n// https://www.shadertoy.com/view/Mcf3Dj\n// https://www.shadertoy.com/view/4fSGzR\n\n// random offset for a sample point inside a cell\nvec2 cell_corner_offs(ivec2 icell)\n{\n    prng_init(uvec2(icell));\n    return vec2(random(), random()) - .5;\n}\n\nfloat voronoi(vec2 coord)\n{\n    ivec2 icell = ivec2(floor(coord));\n    float dist = 1e9;\n    for (int y_offs = -1; y_offs <= 1; y_offs++)\n    {\n        for (int x_offs = -1; x_offs <= 1; x_offs++)\n        {\n            ivec2 icell_neighbor = icell + ivec2(x_offs, y_offs);\n            \n            vec2 p = vec2(icell_neighbor) + .5;\n            p += cell_corner_offs(icell_neighbor);\n            \n            dist = min(dist, dist_sq(coord, p));\n        }\n    }\n    return sqrt(dist) / 1.4142135624;\n}\n\nfloat voronoi_fractal(\n    vec2 coord,\n    int depth,\n    float roughness,\n    float lacunarity\n)\n{\n    float v = 0.;\n    float sum_fac = 0.;\n    \n    for (int i = 0; i < depth; i++)\n    {\n        // factor (impact of the current layer)\n        float fac = 0.;\n        roughness = clamp(roughness, -1., 1.);\n        if (roughness < 0.)\n        {\n            // roughness [-1, 0) will go from fully smooth to normal\n            fac = pow(\n                lacunarity / max(roughness + 1., .0001),\n                float(-i)\n            );\n        }\n        else\n        {\n            // roughness [0, 1] will go from normal to fully rough\n            fac = pow(\n                mix(lacunarity, 1., roughness),\n                float(-i)\n            );\n        }\n        sum_fac += fac;\n        \n        // scale of the current layer\n        float scale = pow(lacunarity, float(i));\n        \n        // add sample\n        v += fac * voronoi(coord * scale);\n        \n        // translate the next layer\n        coord += 100.;\n    }\n    \n    return v / sum_fac;\n}\n\nfloat perlin(vec2 coord)\n{\n    // cell indices\n    ivec2 icell = ivec2(floor(coord));\n    \n    // cell corners\n    vec2 cell_bl = vec2(icell);\n    vec2 cell_tl = cell_bl + vec2(0, 1);\n    vec2 cell_tr = cell_bl + vec2(1, 1);\n    vec2 cell_br = cell_bl + vec2(1, 0);\n    \n    // cell offset in [0, 1) range (vector pointing from the bottom\n    // left corner to coord)\n    vec2 cell_offs = coord - cell_bl;\n    \n    // generate a random unit vector at each cell corner and take\n    // the distance that coord has traveled along that line\n    \n    prng_init(uvec2(icell));\n    vec2 grad_bl = random_on_circle();\n    \n    prng_init(uvec2(icell) + uvec2(0, 1));\n    vec2 grad_tl = random_on_circle();\n    \n    prng_init(uvec2(icell) + uvec2(1, 1));\n    vec2 grad_tr = random_on_circle();\n    \n    prng_init(uvec2(icell) + uvec2(1, 0));\n    vec2 grad_br = random_on_circle();\n    \n    float dist_bl = relative_dist_along_line(coord, cell_bl, cell_bl + grad_bl);\n    float dist_tl = relative_dist_along_line(coord, cell_tl, cell_tl + grad_tl);\n    float dist_tr = relative_dist_along_line(coord, cell_tr, cell_tr + grad_tr);\n    float dist_br = relative_dist_along_line(coord, cell_br, cell_br + grad_br);\n    \n    // smoothstep the cell offset vector\n    cell_offs = smoothstep(0., 1., cell_offs);\n    \n    // bilinear interpolation between the four distances\n    float val = bilinear(\n        dist_bl,\n        dist_tl,\n        dist_tr,\n        dist_br,\n        cell_offs\n    );\n    \n    return val;\n}\n\nfloat perlin_fractal(\n    vec2 coord,\n    int depth,\n    float roughness,\n    float lacunarity\n)\n{\n    float v = 0.;\n    float sum_fac = 0.;\n    \n    for (int i = 0; i < depth; i++)\n    {\n        // factor (impact of the current layer)\n        float fac = 0.;\n        roughness = clamp(roughness, -1., 1.);\n        if (roughness < 0.)\n        {\n            // roughness [-1, 0) will go from fully smooth to normal\n            fac = pow(\n                lacunarity / max(roughness + 1., .0001),\n                float(-i)\n            );\n        }\n        else\n        {\n            // roughness [0, 1] will go from normal to fully rough\n            fac = pow(\n                mix(lacunarity, 1., roughness),\n                float(-i)\n            );\n        }\n        sum_fac += fac;\n        \n        // scale of the current layer\n        float scale = pow(lacunarity, float(i));\n        \n        // add sample\n        v += fac * perlin(coord * scale);\n        \n        // translate the next layer\n        coord += 100.;\n    }\n    \n    return v / sum_fac;\n}\n\n\n\n/*________________ constants __________________*/\n\n// for terrain ray marching, used in march_terrain()\n// and terrain_height_gradient()\nconst float EPS_TERRAIN_GRAD = .01;\nconst float TERRAIN_HIT_THRES = .01;\nconst int TERRAIN_MAX_STEPS = 800;\nconst float TERRAIN_MAX_DIST = 200.;\n\n// for ray marching, used in march_nonterrain()\nconst float EPS_SDF_NORMAL = .001;\nconst float RM_HIT_THRES = .01;\nconst int RM_MAX_STEPS = 256;\nconst float RM_MAX_DIST = 200.;\n\n\n\n/*__________________ scenes ___________________*/\n\nconst int MAT_NONE = 0;\nconst int MAT_TERRAIN = 1;\nconst int MAT_SPHERE = 2;\n\nconst vec3 SUN_DIR = normalize(vec3(.13, .2, .13));\n\nfloat transform_time(float t)\n{\n    return t;\n}\n\nfloat terrain_height(vec2 p, float time, float last_sd)\n{\n    int depth = 1;\n    if (last_sd < 5.)\n    {\n        depth = 2;\n    }\n    if (last_sd < 2.)\n    {\n        depth = 4;\n    }\n    if (last_sd < .6)\n    {\n        depth = 6;\n    }\n    if (last_sd < .2)\n    {\n        depth = 8;\n    }\n    if (last_sd < .1)\n    {\n        depth = 9;\n    }\n    if (last_sd < .02)\n    {\n        depth = 10;\n    }\n    \n    return 10. * perlin_fractal(\n        .1 * p.xy,\n        depth,\n        0.,\n        2.\n    ) + (.0017 * p.y * p.y);\n}\n\nvec2 terrain_height_gradient(vec2 p, float time, float height_at_p)\n{\n    return (\n        vec2(\n            terrain_height(p + vec2(EPS_TERRAIN_GRAD, 0), time, 0.),\n            terrain_height(p + vec2(0, EPS_TERRAIN_GRAD), time, 0.)\n        ) - height_at_p\n    ) / EPS_TERRAIN_GRAD;\n}\n\nfloat sd_scene(vec3 p, float time, out int mat_id)\n{\n    float final_sd = 1e9;\n    mat_id = 0;\n    \n    // sphere\n    {\n        const float xy_size = .03;\n        \n        ivec2 icell = ivec2(floor(p.xy / xy_size));\n        vec2 cell_center = vec2(icell) * xy_size + (.5 * xy_size);\n        float cell_height = terrain_height(cell_center, time, 0.);\n        \n        vec3 pt = vec3(\n            mod(p.xy, xy_size) - (.5 * xy_size), // tile and center\n            p.z\n        );\n        \n        float sd = length(pt - vec3(0, 0, cell_height + .04)) - .002;\n        if (sd < final_sd)\n        {\n            final_sd = sd;\n            mat_id = MAT_SPHERE;\n        }\n    }\n    \n    return final_sd;\n}\n\n// https://www.shadertoy.com/view/3sfyRB\nvec3 sky_gradient(float height01)\n{\n    const vec3 color = vec3(.0005, .015, .05);\n\n    vec3 blue = pow(color, vec3(height01 * 2.));\n    vec3 orange = 1. - blue;\n    vec3 sky = 32. * blue * pow(orange, vec3(8.));\n\n    sky = mix(\n        sky + vec3(.01, .01, .003),\n        sky,\n        min(1., 10. * height01)\n    );\n\n    return sky;\n}\n\n// sample the environment color\nvec3 env(vec3 dir)\n{\n    float vertical_angle = acos(.9999 * dir.z) * INV_PI;\n    float horizontal_angle = atan(dir.y, dir.x);\n    float height01 = smoothstep(\n        .523,\n        .05,\n        vertical_angle\n        + .002 * sin(10. * horizontal_angle)\n        + .002 * sin(13. * horizontal_angle)\n        + .002 * sin(7. * horizontal_angle)\n    );\n    vec3 col = .8 * sky_gradient(height01);\n    \n    float dsun = dot(dir, SUN_DIR);\n    col = mix(\n        col,\n        vec3(20, 10, 2),\n        pow(\n            remap01(\n                dsun,\n                .99,\n                1.\n            ),\n            16.\n        )\n    );\n    col *= 1. + vec3(3, .9, .6) * pow(\n        remap01(\n            dsun,\n            0.,\n            1.\n        ),\n        32.\n    );\n    \n    return col;\n}\n\n\n\n/*________________ ray marching _______________*/\n\nstruct Ray\n{\n    vec3 orig;\n    vec3 dir; // must be normalized\n};\n\nstruct OrthonormalBasis\n{\n    vec3 right;\n    vec3 forward;\n    vec3 up;\n};\n\n// * all three arguments must be normalized and perpendicular to each other\nOrthonormalBasis OrthonormalBasis_new(vec3 right, vec3 forward, vec3 up)\n{\n    OrthonormalBasis onb;\n    onb.right = right;\n    onb.forward = forward;\n    onb.up = up;\n    return onb;\n}\n\n// * forward must be normalized\nOrthonormalBasis OrthonormalBasis_from_forward_and_world_up(\n    vec3 forward,\n    vec3 world_up\n)\n{\n    OrthonormalBasis onb;\n    onb.forward = forward;\n    onb.right = normalize(cross(onb.forward, world_up));\n    onb.up = cross(onb.right, onb.forward);\n    return onb;\n}\n\nvec3 OrthonormalBasis_localize(in OrthonormalBasis self, vec3 p)\n{\n    return vec3(\n        dot(p, self.right),\n        dot(p, self.forward),\n        dot(p, self.up)\n    );\n}\n\nvec3 OrthonormalBasis_delocalize(in OrthonormalBasis self, vec3 p)\n{\n    return (p.x * self.right) + (p.y * self.forward) + (p.z * self.up);\n}\n\n// basic perspective camera\nstruct Camera\n{\n    vec3 pos;\n    float sensor_width;\n    float sensor_height;\n    float focal_length;\n\n    OrthonormalBasis _onb;\n};\n\n// FOV and focal length formula\n// https://www.desmos.com/calculator/5smpkhn02l\n\n// Camera: adjust focal length based on horizontal FOV and sensor width\nvoid Camera_set_fov_horizontal(inout Camera self, float fov)\n{\n    self.focal_length = .5 * self.sensor_width / tan(.5 * fov);\n}\n\n// Camera: calculate the horizontal FOV\nfloat Camera_get_fov_horizontal(in Camera self)\n{\n    return 2. * atan(.5 * self.sensor_width / self.focal_length);\n}\n\n// Camera: adjust focal length based on vertical FOV and sensor height\nvoid Camera_set_fov_vertical(inout Camera self, float fov)\n{\n    self.focal_length = .5 * self.sensor_height / tan(.5 * fov);\n}\n\n// Camera: calculate the vertical FOV\nfloat Camera_get_fov_vertical(in Camera self)\n{\n    return 2. * atan(.5 * self.sensor_height / self.focal_length);\n}\n\n// Camera: adjust focal length based on diagonal FOV and sensor size\nvoid Camera_set_fov_diagonal(inout Camera self, float fov)\n{\n    float sensor_size = length(vec2(self.sensor_width, self.sensor_height));\n    self.focal_length = .5 * sensor_size / tan(.5 * fov);\n}\n\n// Camera: calculate the diagonal FOV\nfloat Camera_get_fov_diagonal(in Camera self)\n{\n    float sensor_size = length(vec2(self.sensor_width, self.sensor_height));\n    return 2. * atan(.5 * sensor_size / self.focal_length);\n}\n\n// Camera: look at a point\nvoid Camera_look_at(inout Camera self, vec3 target, vec3 world_up)\n{\n    self._onb = OrthonormalBasis_from_forward_and_world_up(\n        normalize(target - self.pos),\n        world_up\n    );\n}\n\n// Camera: look along a direction\n// * dir must be normalized\nvoid Camera_look_along(inout Camera self, vec3 dir, vec3 world_up)\n{\n    self._onb = OrthonormalBasis_from_forward_and_world_up(\n        dir,\n        world_up\n    );\n}\n\n// Camera: generate a camera ray for given UV coordinates\nRay Camera_gen_ray(in Camera self, vec2 uv01)\n{\n    Ray r;\n    r.orig = self.pos + OrthonormalBasis_delocalize(self._onb, vec3(\n        (uv01.x - .5) * self.sensor_width,\n        self.focal_length,\n        (uv01.y - .5) * self.sensor_height\n    ));\n    r.dir = normalize(r.orig - self.pos);\n    return r;\n}\n\n// Camera: retrieve UV coordinates from a point in space\n// * returns vec2(-1e9) on failure\nvec2 Camera_retrieve_uv01_from_point(in Camera self, vec3 p)\n{\n    // project into camera space\n    vec3 world_space = p - self.pos;\n    vec3 cam_space = OrthonormalBasis_localize(self._onb, world_space);\n\n    // p is not in front of the sensor\n    if (cam_space.y < self.focal_length - .00001)\n    {\n        return vec2(-1e9);\n    }\n\n    // linearly normalize p so that it falls on the focal plane\n    cam_space /= cam_space.y;\n    cam_space *= self.focal_length;\n\n    // extract the UV coordinates\n    return (cam_space.xz / vec2(self.sensor_width, self.sensor_height)) + .5;\n}\n\n// Camera: retrieve UV coordinates from a direction towards the sky (used when\n// no object is hit)\n// * returns vec2(-1e9) on failure\nvec2 Camera_retrieve_uv01_from_dir(in Camera self, vec3 dir)\n{\n    // project into camera space\n    vec3 p = dir;\n    vec3 cam_space = OrthonormalBasis_localize(self._onb, p);\n\n    // p is not in front of the sensor\n    if (cam_space.y < .00001)\n    {\n        return vec2(-1e9);\n    }\n\n    // linearly normalize p so that it falls on the focal plane\n    cam_space /= cam_space.y;\n    cam_space *= self.focal_length;\n\n    // extract the UV coordinates\n    return (cam_space.xz / vec2(self.sensor_width, self.sensor_height)) + .5;\n}\n\n// Camera: generate a defocused camera ray for given UV coordinates\nRay Camera_gen_ray_defocused(\n    in Camera self,\n    vec2 uv01,\n    float focus_dist,\n    float jitter\n)\n{\n    // generate normal ray without normalizing the direction\n    Ray r;\n    vec3 r_dir_unnormalized = OrthonormalBasis_delocalize(self._onb, vec3(\n        (uv01.x - .5) * self.sensor_width,\n        self.focal_length,\n        (uv01.y - .5) * self.sensor_height\n    ));\n    r.orig = self.pos + r_dir_unnormalized;\n    \n    // point on the focus plane\n    vec3 fp = r.orig + focus_dist * (r_dir_unnormalized / self.focal_length);\n    \n    // randomly offset the ray origin\n    vec2 offs = jitter * random_in_circle();\n    r.orig += OrthonormalBasis_delocalize(self._onb, vec3(\n        offs.x,\n        0.,\n        offs.y\n    ));\n    \n    // look at the point on the focus plane\n    r.dir = normalize(fp - r.orig);\n    \n    return r;\n}\n\nstruct Hit\n{\n    Ray r; // ray that produced this hit\n    bool hit; // did we hit something?\n    vec3 p; // hit position\n    float dist; // hit distance\n    vec3 n; // normal\n    int mat_id; // material ID (0=none)\n};\n\n// ray march through the terrain\nvoid march_terrain(in Ray r, float time, inout Hit h)\n{\n    h.r = r;\n    h.hit = false;\n    h.p = r.orig;\n    h.dist = 0.;\n\n    float sd = h.p.z - terrain_height(h.p.xy, time, 0.);\n    for (\n        int i = 0;\n        i < TERRAIN_MAX_STEPS && sd > TERRAIN_HIT_THRES && h.dist < TERRAIN_MAX_DIST;\n        i++\n    )\n    {\n        h.dist += .2 * sd;\n        h.p = r.orig + (h.dist * r.dir);\n        sd = h.p.z - terrain_height(h.p.xy, time, sd);\n    }\n    \n    if (sd > TERRAIN_HIT_THRES)\n    {\n        return;\n    }\n    \n    h.hit = true;\n    \n    // terrain gradient (2D)\n    vec2 grad = terrain_height_gradient(h.p.xy, time, h.p.z - sd);\n    \n    // hit normal in 3D\n    h.n = normalize(vec3(-grad, 1));\n\n    h.mat_id = MAT_TERRAIN;\n}\n\n// ray marching for non-terrain objects\nvoid march_nonterrain(in Ray r, float time, inout Hit h)\n{\n    h.r = r;\n    h.hit = false;\n    h.p = r.orig;\n    h.dist = 0.;\n    \n    float sd = sd_scene(h.p, time, h.mat_id);\n    for (\n        int i = 0;\n        i < RM_MAX_STEPS && sd > RM_HIT_THRES && h.dist < RM_MAX_DIST;\n        i++\n    )\n    {\n        h.dist += sd;\n        h.p = r.orig + (h.dist * r.dir);\n        sd = sd_scene(h.p, time, h.mat_id);\n    }\n    \n    if (sd > RM_HIT_THRES)\n    {\n        return;\n    }\n\n    h.hit = true;\n    \n    int _unused;\n    h.n = normalize(vec3(\n        sd_scene(h.p + vec3(EPS_SDF_NORMAL, 0, 0), time, _unused),\n        sd_scene(h.p + vec3(0, EPS_SDF_NORMAL, 0), time, _unused),\n        sd_scene(h.p + vec3(0, 0, EPS_SDF_NORMAL), time, _unused)\n    ) - sd);\n}\n\n// combines march_terrain() and march_nonterrain()\nvoid march(in Ray r, float time, inout Hit h)\n{\n    march_terrain(r, time, h);\n    \n    Hit h_nonterrain;\n    march_nonterrain(r, time, h_nonterrain);\n    if ((!h.hit && h_nonterrain.hit)\n        || (h.hit && h_nonterrain.hit && h_nonterrain.dist < h.dist))\n    {\n        h = h_nonterrain;\n    }\n}\n\n\n\n/*-----------------------------------------------\n\nflim - Filmic Color Transform\n\nInput Color Space:   Linear BT.709 I-D65\nOutput Color Space:  Linear BT.709 I-D65 / sRGB 2.2 (depends on arguments)\n\nDescription:\n  Experimental port of flim for GLSL/Shadertoy\n  matching flim v1.1.0.\n\nAuthor:\n  Bean (beans_please on Shadertoy)\n\nOriginal Repo:\n  https://github.com/bean-mhm/flim\n\nOriginal Shader:\n  https://www.shadertoy.com/view/dd2yDz\n\n-----------------------------------------------*/\n\n// parameters\n\nconst float flim_pre_exposure = 4.3;\nconst vec3 flim_pre_formation_filter = vec3(1.);\nconst float flim_pre_formation_filter_strength = 0.;\n\nconst float flim_extended_gamut_red_scale = 1.05;\nconst float flim_extended_gamut_green_scale = 1.12;\nconst float flim_extended_gamut_blue_scale = 1.045;\nconst float flim_extended_gamut_red_rot = .5;\nconst float flim_extended_gamut_green_rot = 2.;\nconst float flim_extended_gamut_blue_rot = .1;\nconst float flim_extended_gamut_red_mul = 1.;\nconst float flim_extended_gamut_green_mul = 1.;\nconst float flim_extended_gamut_blue_mul = 1.;\n\nconst float flim_sigmoid_log2_min = -10.;\nconst float flim_sigmoid_log2_max = 22.;\nconst float flim_sigmoid_toe_x = .44;\nconst float flim_sigmoid_toe_y = .28;\nconst float flim_sigmoid_shoulder_x = .591;\nconst float flim_sigmoid_shoulder_y = .779;\n\nconst float flim_negative_film_exposure = 6.;\nconst float flim_negative_film_density = 5.;\n\nconst vec3 flim_print_backlight = vec3(1);\nconst float flim_print_film_exposure = 6.;\nconst float flim_print_film_density = 27.5;\n\nconst float flim_black_point = -1.; // -1 = auto\nconst vec3 flim_post_formation_filter = vec3(1);\nconst float flim_post_formation_filter_strength = 0.;\nconst float flim_midtone_saturation = 1.02;\n\n// color space conversions\n// the matrices below represent data in row-major, but GLSL matrices are in\n// column-major, so we need to multiply a vec3 by a matrix rather than\n// multiplying a matrix by a vec3.\n\nconst mat3 mat_bt2020_to_xyz = mat3(\n     0.6369580483,  0.1446169036,  0.1688809752,\n     0.2627002120,  0.6779980715,  0.0593017165,\n     0.0000000000,  0.0280726930,  1.0609850577\n);\n\nconst mat3 mat_xyz_to_bt2020 = mat3(\n     1.7166511880, -0.3556707838, -0.2533662814,\n    -0.6666843518,  1.6164812366,  0.0157685458,\n     0.0176398574, -0.0427706133,  0.9421031212\n);\n\nconst mat3 mat_bt709_to_xyz = mat3(\n     0.4123907993,  0.3575843394,  0.1804807884,\n     0.2126390059,  0.7151686788,  0.0721923154,\n     0.0193308187,  0.1191947798,  0.9505321522\n);\n\nconst mat3 mat_xyz_to_bt709 = mat3(\n     3.2409699419, -1.5373831776, -0.4986107603,\n    -0.9692436363,  1.8759675015,  0.0415550574,\n     0.0556300797, -0.2039769589,  1.0569715142\n);\n\nconst mat3 mat_dcip3_to_xyz = mat3(\n     0.4451698156,  0.2771344092,  0.1722826698,\n     0.2094916779,  0.7215952542,  0.0689130679,\n     0.0000000000,  0.0470605601,  0.9073553944\n);\n\nconst mat3 mat_xyz_to_dcip3 = mat3(\n     2.7253940305, -1.0180030062, -0.4401631952,\n    -0.7951680258,  1.6897320548,  0.0226471906,\n     0.0412418914, -0.0876390192,  1.1009293786\n);\n\nvec3 oetf_pow(vec3 col, float power)\n{\n    return pow(col, vec3(1. / power));\n}\n\nvec3 eotf_pow(vec3 col, float power)\n{\n    return pow(col, vec3(power));\n}\n\n// flim's utility functions\n\nfloat flim_wrap(float v, float start, float end)\n{\n    return start + mod(v - start, end - start);\n}\n\nfloat flim_remap(\n    float v,\n    float inp_start,\n    float inp_end,\n    float out_start,\n    float out_end\n)\n{\n    return out_start\n        + ((out_end - out_start) / (inp_end - inp_start)) * (v - inp_start);\n}\n\nfloat flim_remap_clamp(\n    float v,\n    float inp_start,\n    float inp_end,\n    float out_start,\n    float out_end\n)\n{\n    float t = clamp((v - inp_start) / (inp_end - inp_start), 0., 1.);\n    return out_start + t * (out_end - out_start);\n}\n\nfloat flim_remap01(\n    float v,\n    float inp_start,\n    float inp_end\n)\n{\n    return clamp((v - inp_start) / (inp_end - inp_start), 0., 1.);\n}\n\nvec3 flim_blender_rgb_to_hsv(vec3 rgb)\n{\n    float cmax, cmin, h, s, v, cdelta;\n    vec3 c;\n\n    cmax = max(rgb[0], max(rgb[1], rgb[2]));\n    cmin = min(rgb[0], min(rgb[1], rgb[2]));\n    cdelta = cmax - cmin;\n\n    v = cmax;\n    if (cmax != 0.)\n    {\n        s = cdelta / cmax;\n    }\n    else\n    {\n        s = 0.;\n        h = 0.;\n    }\n\n    if (s == 0.)\n    {\n        h = 0.;\n    }\n    else\n    {\n        c = (vec3(cmax) - rgb.xyz) / cdelta;\n\n        if (rgb.x == cmax)\n        {\n            h = c[2] - c[1];\n        }\n        else if (rgb.y == cmax)\n        {\n            h = 2. + c[0] - c[2];\n        }\n        else\n        {\n            h = 4. + c[1] - c[0];\n        }\n\n        h /= 6.;\n\n        if (h < 0.)\n        {\n            h += 1.;\n        }\n    }\n\n    return vec3(h, s, v);\n}\n\nvec3 flim_blender_hsv_to_rgb(vec3 hsv)\n{\n    float f, p, q, t, h, s, v;\n    vec3 rgb;\n\n    h = hsv[0];\n    s = hsv[1];\n    v = hsv[2];\n\n    if (s == 0.)\n    {\n        rgb = vec3(v, v, v);\n    }\n    else\n    {\n        if (h == 1.)\n        {\n            h = 0.;\n        }\n\n        h *= 6.;\n        int i = int(floor(h));\n        f = h - float(i);\n        rgb = vec3(f, f, f);\n        p = v * (1. - s);\n        q = v * (1. - (s * f));\n        t = v * (1. - (s * (1. - f)));\n\n        if (i == 0)\n        {\n            rgb = vec3(v, t, p);\n        }\n        else if (i == 1)\n        {\n            rgb = vec3(q, v, p);\n        }\n        else if (i == 2)\n        {\n            rgb = vec3(p, v, t);\n        }\n        else if (i == 3)\n        {\n            rgb = vec3(p, q, v);\n        }\n        else if (i == 4)\n        {\n            rgb = vec3(t, p, v);\n        }\n        else\n        {\n            rgb = vec3(v, p, q);\n        }\n    }\n\n    return rgb;\n}\n\nvec3 flim_blender_hue_sat(vec3 col, float hue, float sat, float value)\n{\n    vec3 hsv = flim_blender_rgb_to_hsv(col);\n\n    hsv[0] = fract(hsv[0] + hue + .5);\n    hsv[1] = clamp(hsv[1] * sat, 0., 1.);\n    hsv[2] = hsv[2] * value;\n\n    return flim_blender_hsv_to_rgb(hsv);\n}\n\nfloat flim_rgb_avg(vec3 col)\n{\n    return (col.x + col.y + col.z) / 3.;\n}\n\nfloat flim_rgb_sum(vec3 col)\n{\n    return col.x + col.y + col.z;\n}\n\nfloat flim_rgb_max(vec3 col)\n{\n    return max(max(col.x, col.y), col.z);\n}\n\nfloat flim_rgb_min(vec3 col)\n{\n    return min(min(col.x, col.y), col.z);\n}\n\nvec3 flim_rgb_uniform_offset(vec3 col, float black_point, float white_point)\n{\n    float mono = flim_rgb_avg(col);\n    float mono2 = flim_remap01(\n        mono, black_point / 1000.,\n        1. - (white_point / 1000.)\n    );\n    return col * (mono2 / mono);\n}\n\nvec3 flim_rgb_sweep(float hue)\n{\n    hue = flim_wrap(hue * 360., 0., 360.);\n\n    vec3 col = vec3(1, 0, 0);\n    col = mix(col, vec3(1, 1, 0), flim_remap01(hue, 0., 60.));\n    col = mix(col, vec3(0, 1, 0), flim_remap01(hue, 60., 120.));\n    col = mix(col, vec3(0, 1, 1), flim_remap01(hue, 120., 180.));\n    col = mix(col, vec3(0, 0, 1), flim_remap01(hue, 180., 240.));\n    col = mix(col, vec3(1, 0, 1), flim_remap01(hue, 240., 300.));\n    col = mix(col, vec3(1, 0, 0), flim_remap01(hue, 300., 360.));\n    \n    return col;\n}\n\nvec3 flim_rgb_exposure_sweep_test(vec2 uv0to1)\n{\n    float hue = 1. - uv0to1.y;\n    float exposure = flim_remap(uv0to1.x, 0., 1., -5., 10.);\n    return flim_rgb_sweep(hue) * pow(2., exposure);\n}\n\n// https://www.desmos.com/calculator/khkztixyeu\nfloat flim_super_sigmoid(\n    float v,\n    float toe_x,\n    float toe_y,\n    float shoulder_x,\n    float shoulder_y\n)\n{\n    // clip\n    v = clamp(v, 0., 1.);\n    toe_x = clamp(toe_x, 0., 1.);\n    toe_y = clamp(toe_y, 0., 1.);\n    shoulder_x = clamp(shoulder_x, 0., 1.);\n    shoulder_y = clamp(shoulder_y, 0., 1.);\n\n    // calculate straight line slope\n    float slope = (shoulder_y - toe_y) / (shoulder_x - toe_x);\n\n    // toe\n    if (v < toe_x)\n    {\n        float toe_pow = slope * toe_x / toe_y;\n        return toe_y * pow(v / toe_x, toe_pow);\n    }\n\n    // straight line\n    if (v < shoulder_x)\n    {\n        float intercept = toe_y - (slope * toe_x);\n        return slope * v + intercept;\n    }\n\n    // shoulder\n    float shoulder_pow =\n        -slope / (\n            ((shoulder_x - 1.) / pow(1. - shoulder_x, 2.))\n            * (1. - shoulder_y)\n        );\n    return\n        (1. - pow(1. - (v - shoulder_x) / (1. - shoulder_x), shoulder_pow))\n        * (1. - shoulder_y)\n        + shoulder_y;\n}\n\nfloat flim_dye_mix_factor(float mono, float max_density)\n{\n    // log2 and map range\n    float offset = pow(2., flim_sigmoid_log2_min);\n    float fac = flim_remap01(\n        log2(mono + offset),\n        flim_sigmoid_log2_min,\n        flim_sigmoid_log2_max\n    );\n\n    // calculate amount of exposure from 0 to 1\n    fac = flim_super_sigmoid(\n        fac,\n        flim_sigmoid_toe_x,\n        flim_sigmoid_toe_y,\n        flim_sigmoid_shoulder_x,\n        flim_sigmoid_shoulder_y\n    );\n\n    // calculate dye density\n    fac *= max_density;\n\n    // mix factor\n    fac = pow(2., -fac);\n\n    // clip and return\n    return clamp(fac, 0., 1.);\n}\n\nvec3 flim_rgb_color_layer(\n    vec3 col,\n    vec3 sensitivity_tone,\n    vec3 dye_tone,\n    float max_density\n)\n{\n    // normalize\n    vec3 sensitivity_tone_norm =\n        sensitivity_tone / flim_rgb_sum(sensitivity_tone);\n    vec3 dye_tone_norm = dye_tone / flim_rgb_max(dye_tone);\n\n    // dye mix factor\n    float mono = dot(col, sensitivity_tone_norm);\n    float mix_fac = flim_dye_mix_factor(mono, max_density);\n\n    // dye mixing\n    return mix(dye_tone_norm, vec3(1), mix_fac);\n}\n\nvec3 flim_rgb_develop(vec3 col, float exposure, float max_density)\n{\n    // exposure\n    col *= pow(2., exposure);\n\n    // blue-sensitive layer\n    vec3 result = flim_rgb_color_layer(\n        col,\n        vec3(0, 0, 1),\n        vec3(1, 1, 0),\n        max_density\n    );\n\n    // green-sensitive layer\n    result *= flim_rgb_color_layer(\n        col,\n        vec3(0, 1, 0),\n        vec3(1, 0, 1),\n        max_density\n    );\n\n    // red-sensitive layer\n    result *= flim_rgb_color_layer(\n        col,\n        vec3(1, 0, 0),\n        vec3(0, 1, 1),\n        max_density\n    );\n\n    return result;\n}\n\nvec3 flim_gamut_extension_mat_row(\n    float primary_hue,\n    float scale,\n    float rotate,\n    float mul\n)\n{\n    vec3 result = flim_blender_hsv_to_rgb(vec3(\n        flim_wrap(primary_hue + (rotate / 360.), 0., 1.),\n        1. / scale,\n        1.\n    ));\n    result /= flim_rgb_sum(result);\n    result *= mul;\n    return result;\n}\n\nmat3 flim_gamut_extension_mat(\n    float red_scale,\n    float green_scale,\n    float blue_scale,\n    float red_rot,\n    float green_rot,\n    float blue_rot,\n    float red_mul,\n    float green_mul,\n    float blue_mul\n)\n{\n    mat3 m;\n    m[0] = flim_gamut_extension_mat_row(\n        0.,\n        red_scale,\n        red_rot,\n        red_mul\n    );\n    m[1] = flim_gamut_extension_mat_row(\n        1. / 3.,\n        green_scale,\n        green_rot,\n        green_mul\n    );\n    m[2] = flim_gamut_extension_mat_row(\n        2. / 3.,\n        blue_scale,\n        blue_rot,\n        blue_mul\n    );\n    return m;\n}\n\nvec3 negative_and_print(vec3 col, vec3 backlight_ext)\n{\n    // develop negative\n    col = flim_rgb_develop(\n        col,\n        flim_negative_film_exposure,\n        flim_negative_film_density\n    );\n\n    // backlight\n    col *= backlight_ext;\n\n    // develop print\n    col = flim_rgb_develop(\n        col,\n        flim_print_film_exposure,\n        flim_print_film_density\n    );\n\n    return col;\n}\n\n// the flim transform\n\nvec3 flim_transform(vec3 col, float exposure, bool convert_to_srgb)\n{\n    // eliminate negative values\n    col = max(col, 0.);\n\n    // pre-Exposure\n    col *= pow(2., flim_pre_exposure + exposure);\n\n    // clip very large values for float precision issues\n    col = min(col, 5000.);\n\n    // gamut extension matrix (Linear BT.709)\n    mat3 extend_mat = flim_gamut_extension_mat(\n        flim_extended_gamut_red_scale,\n        flim_extended_gamut_green_scale,\n        flim_extended_gamut_blue_scale,\n        flim_extended_gamut_red_rot,\n        flim_extended_gamut_green_rot,\n        flim_extended_gamut_blue_rot,\n        flim_extended_gamut_red_mul,\n        flim_extended_gamut_green_mul,\n        flim_extended_gamut_blue_mul\n    );\n    mat3 extend_mat_inv = inverse(extend_mat);\n\n    // backlight in the extended gamut\n    vec3 backlight_ext = flim_print_backlight * extend_mat;\n\n    // upper limit in the print (highlight cap)\n    const float big = 10000000.;\n    vec3 white_cap = negative_and_print(vec3(big, big, big), backlight_ext);\n\n    // pre-formation filter\n    col = mix(\n        col,\n        col * flim_pre_formation_filter,\n        flim_pre_formation_filter_strength\n    );\n\n    // convert to the extended gamut\n    col *= extend_mat;\n\n    // negative & print\n    col = negative_and_print(col, backlight_ext);\n\n    // convert from the extended gamut\n    col *= extend_mat_inv;\n\n    // eliminate negative values\n    col = max(col, 0.);\n\n    // white cap\n    col /= white_cap;\n\n    // black cap (-1 = auto)\n    if (flim_black_point == -1.)\n    {\n        vec3 black_cap = negative_and_print(vec3(0.), backlight_ext);\n        black_cap /= white_cap;\n        col = flim_rgb_uniform_offset(\n            col,\n            flim_rgb_avg(black_cap) * 1000.,\n            0.\n        );\n    }\n    else\n    {\n        col = flim_rgb_uniform_offset(col, flim_black_point, 0.);\n    }\n\n    // post-formation filter\n    col = mix(\n        col,\n        col * flim_post_formation_filter,\n        flim_post_formation_filter_strength\n    );\n\n    // clip\n    col = clamp(col, 0., 1.);\n\n    // midtone saturation\n    float mono = flim_rgb_avg(col);\n    float mix_fac =\n        (mono < .5)\n        ? flim_remap01(mono, .05, .5)\n        : flim_remap01(mono, .95, .5);\n    col = mix(\n        col,\n        flim_blender_hue_sat(col, .5, flim_midtone_saturation, 1.),\n        mix_fac\n    );\n\n    // clip\n    col = clamp(col, 0., 1.);\n\n    // OETF\n    if (convert_to_srgb)\n    {\n        col = oetf_pow(col, 2.2);\n    }\n\n    return col;\n}\n\n/*____________________ end ____________________*/\n",
     "name": "Common",
     "description": "",
     "type": "common"
    },
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "// render buffer\n// render at half res. uniformly jitter the camera in a 2x2 grid pattern\n// (optionally add some sub-sub-jitter in that tiny cell for AA)\n\n\n\n// inspired by https://iquilezles.org/articles/fog/\nvec3 pretty_fog(\n    vec3 col,\n    float hit_dist,\n    vec3 ray_dir, // must be normalized\n    vec3 sun_dir, // must be normalized\n    float fog_start_dist, // normally 0\n    vec3 absorption_col, // RGB values below 1, or white to disable\n    float scatter_density, // usually near 0 like .04\n    vec3 scatter_col_sky, // normally a cold color\n    vec3 scatter_col_sun, // normally a warm color\n    float sun_sharpness // default=8\n)\n{\n    // subtract starting distance, return if depth is too low\n    hit_dist -= fog_start_dist;\n    if (hit_dist < .00001)\n    {\n        return col;\n    }\n   \n    // absorption\n    col *= pow(absorption_col, vec3(hit_dist));\n\n    // scatter color depends on view dir and sun dir\n    float sun_fac = pow(\n        max(dot(ray_dir, sun_dir), 0.),\n        sun_sharpness\n    );\n    vec3 scatter_col = mix(\n        scatter_col_sky,\n        scatter_col_sun,\n        sun_fac\n    );\n   \n    // scattering\n    col = mix(\n        col,\n        scatter_col,\n        1. - exp(-hit_dist * scatter_density)\n    );\n   \n    return col;\n}\n\nvec3 render(vec2 coord, vec2 render_res, in Camera cam, float time)\n{\n    vec2 uv01 = screen_to_uv01(coord, render_res.xy);\n    Ray r = Camera_gen_ray(cam, uv01);\n    \n    Hit h;\n    march(r, time, h);\n    \n    if (!h.hit)\n    {\n        return env(r.dir);\n    }\n    \n    vec3 col = vec3(0);\n    if (h.mat_id == MAT_TERRAIN)\n    {\n        // base color\n        vec3 base_col = vec3(.7, .4, .25);\n        base_col = mix(\n            base_col,\n            vec3(.12, .34, .03),\n            remap01(h.n.z, .55, .7)\n        );\n        \n        // lambert diffuse\n        float dl = dot(h.n, SUN_DIR);\n        col = max(0., dl) * base_col;\n        \n        // fake subsurface and GI\n        vec3 gi = .7 * pow(base_col, vec3(3));\n        col += pow(dl * .5 + .5, 2.) * gi;\n    }\n    else if (h.mat_id == MAT_SPHERE)\n    {\n        float dl = max(0., dot(h.n, SUN_DIR));\n        col = dl * vec3(.1, .45, .25);\n    }\n    \n    col = pretty_fog(\n        col,                 // col\n        h.dist,              // hit_dist\n        r.dir,               // ray_dir\n        SUN_DIR,             // sun_dir\n        0.,                  // fog_start_dist\n        vec3(.97, .98, 1),   // absorption_col\n        remap_clamp(         // scatter_density\n            h.p.z,\n            -2.5,\n            -1.2,\n            .3,\n            .2\n        ),\n        vec3(.05, .05, .09), // scatter_col_sky\n        vec3(.12, .03, .02), // scatter_col_sun\n        1.8                  // sun_sharpness\n    );\n    \n    return col;\n}\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    ivec2 icoord = ivec2(frag_coord);\n    vec2 render_res = ceil(.5 * iResolution.xy);\n\n    // render at half res (skip out-of-bounds pixels)\n    if (!icoord_in_bounds(\n        icoord,\n        ivec2(render_res)\n    ))\n    {\n        frag_col = vec4(0);\n        return;\n    }\n\n    // camera\n    Camera cam;\n    cam.sensor_height = .035;\n    cam.sensor_width = cam.sensor_height * (render_res.x / render_res.y);\n    cam.focal_length = .012;\n    cam.pos = vec3(5.2, 0, -.1);\n    cam.pos += vec3(0, .01 * iTime, 0);\n    Camera_look_along(cam, normalize(vec3(0, 1, .1)), vec3(0, 0, 1));\n    \n    // scene time\n    float time = transform_time(iTime);\n\n    // render with jittering\n    vec2 offs = jitter_offset(iFrame) + subsubjitter_offset(iFrame);\n    vec3 col = render(\n        frag_coord + offs,\n        render_res,\n        cam,\n        time\n    );\n\n    // output\n    frag_col = vec4(col, 1);\n}\n",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "XsXGR8",
       "channel": 0
      }
     ],
     "code": "// accumulation buffer\n// start with bilinearly sampling buf A or using a valid reprojection\n// from buf B (if the history is valid) (read the comments in the code). if the\n// new jitter offset (ignoring the sub-sub-jiter offset) falls on the current\n// pixel then blend towards it.\n// ghosting happens in this case because there's no reprojection. in real TAA\n// it wouldn't be this bad.\n// another reason for ghosting is because only 1/4 of the image has new samples\n// every frame so you need 4 frames to catch up (add that to the exponential\n// blending we do for AA)\n\n\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    ivec2 icoord = ivec2(frag_coord);\n    vec2 render_res = ceil(.5 * iResolution.xy);\n\n    vec2 buf_coord = clamp(\n        (frag_coord / iResolution.xy) * render_res,\n        vec2(.501),\n        render_res - .501\n    );\n    ivec2 buf_icoord = ivec2(buf_coord);\n    \n    vec2 sample_coord = vec2(buf_icoord) + .5 + jitter_offset(iFrame);\n    vec2 sample_coord_upscaled = (sample_coord / render_res) * iResolution.xy;\n    \n    // whether the jittered sample point falls inside the boundaries\n    // of the current pixel when upscaled\n    bool sample_inside_this_pixel =\n        sample_coord_upscaled.x >= float(icoord.x)\n        && sample_coord_upscaled.y >= float(icoord.y)\n        && sample_coord_upscaled.x < float(icoord.x + 1)\n        && sample_coord_upscaled.y < float(icoord.y + 1);\n    \n    // in real TAA, this would also make sure that the previous\n    // history (reprojected and accumulated color from the\n    // previous frame) is valid, for example, by checking the\n    // depth of the neighbors and whether the pixel has just\n    // entered the frame, and other factors. here, we always use\n    // the previous frame's value unless we're on the first frame.\n    // we also don't do any reprojection in this demo.\n    bool valid_history = iFrame > 0;\n    \n    // find the previous best candidate (the starting color)\n    vec3 col = vec3(0);\n    if (valid_history)\n    {\n        // we can use the (potentially reprojected)\n        // values from the previous frame\n        col = texelFetch(iChannel1, icoord, 0).rgb;\n    }\n    else\n    {\n        // we have nothing but the low res render buffer, so we'll\n        // just use bilinear interpolation over it\n        col = texture(iChannel0, buf_coord / iResolution.xy).rgb;\n    }\n    \n    // if the new offset falls in this pixel, blend toward the new\n    // sample\n    if (sample_inside_this_pixel)\n    {\n        // we have an exact sample to use\n        vec3 sample_col = texelFetch(iChannel0, buf_icoord, 0).rgb;\n        \n        // blend for accumulation (you could use more complex algorithms\n        // for the blend weight)\n        // NOTE: this blending would be useless if we didn't have the\n        // sub-sub-jitter.\n        col = mix(col, sample_col, .2);\n    }\n\n    frag_col = vec4(col, 1.);\n}\n",
     "name": "Buffer B",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "M3ySRK",
    "date": "1720202475",
    "viewed": 533,
    "name": "Parallax Occlusion Mapping X",
    "description": "layer count depends on the ray-surface angle\n",
    "likes": 23,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "3d",
     "raymarching",
     "parallax",
     "map",
     "heightmap",
     "bump",
     "occlusion",
     "mapping",
     "height",
     "depth",
     "pom"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "Xsf3Rr",
       "filepath": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg",
       "type": "texture",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4sf3Rr",
       "filepath": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png",
       "type": "texture",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "vec3 render(vec2 coord, vec2 render_res, in Camera cam, float time)\n{\n    vec2 uv01 = screen_to_uv01(coord, render_res.xy);\n    Ray r = Camera_gen_ray(cam, uv01);\n    \n    Hit h;\n    trace_ray(r, time, h, iChannel1);\n    \n    if (!h.hit)\n    {\n        return env(r.dir);\n    }\n    \n    // base color\n    vec3 base_col = 1.25 * pow(texture(iChannel0, h.uv).rgb, vec3(2.2));\n    \n    // lambert diffuse\n    float dl = dot(h.n, SUN_DIR);\n    vec3 col = max(0., dl) * base_col;\n    \n    // fake GI\n    vec3 gi = .3 * pow(base_col, vec3(2)) + vec3(0, .005, .01);\n    col += remap01(dl, -1., 0.) * gi;\n    \n    return col;\n}\n\n// ASC CDL color grading\n// https://en.wikipedia.org/wiki/ASC_CDL\nvec3 asc_cdl(vec3 col, vec3 slope, vec3 offset, vec3 power)\n{\n    return pow(max(col, 0.) * slope + offset, power);\n}\n\nvec3 view_transform(vec3 col)\n{\n    // avoid any negative values before using power functions\n    col = max(col, 0.);\n\n    // color grading\n    col = asc_cdl(\n        col,\n        1.1 * vec3(1, .903, .94),\n        vec3(0, 0, .007),\n        1.05 * vec3(1, .95, 1)\n    );\n    \n    // flim\n    const float exposure = 0.;\n    col = flim_transform(col, exposure, false);\n\n    // OETF (Linear BT.709 I-D65 to sRGB 2.2)\n    col = pow(col, vec3(1. / 2.2));\n    col = clamp(col, 0., 1.);\n\n    return col;\n}\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    ivec2 icoord = ivec2(frag_coord);\n\n    // camera\n    Camera cam;\n    cam.sensor_height = .035;\n    cam.sensor_width = cam.sensor_height * (iResolution.x / iResolution.y);\n    cam.focal_length = .021;\n    cam.pos = vec3(0, -1.4, .4 + .2 * cos(TAU * .4 * iTime));\n    Camera_look_at(cam, vec3(0, 0, -.15), vec3(0, 0, 1));\n    \n    // scene time\n    float time = transform_time(iTime);\n\n    // render with jittering\n    vec3 col = vec3(0);\n    const int n_samples = 8;\n    for (int i = 0; i < n_samples; i++)\n    {\n        vec2 offs = halton_2d(i + 1);\n        col += render(\n            frag_coord + offs,\n            iResolution.xy,\n            cam,\n            time\n        );\n    }\n    col /= float(n_samples);\n    \n    // view transform\n    col = view_transform(col);\n\n    // output\n    frag_col = vec4(col, 1);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "/*___________ math & integer utils ____________*/\n\nconst float PI = 3.141592653589793238462643383;\nconst float TAU = 6.283185307179586476925286767;\nconst float PI_OVER_2 = 1.570796326794896619231321692;\nconst float INV_PI = .318309886183790671537767527;\nconst float INV_TAU = .159154943091895335768883763;\n\n#define FUNC_WRAP(T) \\\nT wrap(T v, float start, float end) \\\n{ \\\n    return start + mod(v - start, end - start); \\\n}\n\n#define FUNC_REMAP(T) \\\nT remap(T v, float inp_start, float inp_end, float out_start, float out_end) \\\n{ \\\n    return out_start \\\n        + ((out_end - out_start) / (inp_end - inp_start)) * (v - inp_start); \\\n}\n\n#define FUNC_REMAP_CLAMP(T) \\\nT remap_clamp( \\\n    T v, \\\n    float inp_start, \\\n    float inp_end, \\\n    float out_start, \\\n    float out_end \\\n) \\\n{ \\\n    T t = clamp((v - inp_start) / (inp_end - inp_start), 0., 1.); \\\n    return out_start + t * (out_end - out_start); \\\n}\n\n#define FUNC_REMAP01(T) \\\nT remap01(T v, float inp_start, float inp_end) \\\n{ \\\n    return clamp((v - inp_start) / (inp_end - inp_start), 0., 1.); \\\n}\n\n#define FUNC_LENGTH_SQ(T) \\\nfloat length_sq(T v) \\\n{ \\\n    return dot(v, v); \\\n}\n\n#define FUNC_DIST_SQ(T) \\\nfloat dist_sq(T a, T b) \\\n{ \\\n    a -= b; \\\n    return dot(a, a); \\\n}\n\nFUNC_WRAP(float)\nFUNC_WRAP(vec2)\nFUNC_WRAP(vec3)\nFUNC_WRAP(vec4)\n\nFUNC_REMAP(float)\nFUNC_REMAP(vec2)\nFUNC_REMAP(vec3)\nFUNC_REMAP(vec4)\n\nFUNC_REMAP_CLAMP(float)\nFUNC_REMAP_CLAMP(vec2)\nFUNC_REMAP_CLAMP(vec3)\nFUNC_REMAP_CLAMP(vec4)\n\nFUNC_REMAP01(float)\nFUNC_REMAP01(vec2)\nFUNC_REMAP01(vec3)\nFUNC_REMAP01(vec4)\n\nFUNC_LENGTH_SQ(vec2)\nFUNC_LENGTH_SQ(vec3)\nFUNC_LENGTH_SQ(vec4)\n\nFUNC_DIST_SQ(vec2)\nFUNC_DIST_SQ(vec3)\nFUNC_DIST_SQ(vec4)\n\nfloat chebyshev_dist(vec2 a, vec2 b)\n{\n    return max(abs(a.x - b.x), abs(a.y - b.y));\n}\n\nfloat chebyshev_dist(vec3 a, vec3 b)\n{\n    return max(\n        max(abs(a.x - b.x), abs(a.y - b.y)),\n        abs(a.z - b.z)\n    );\n}\n\nfloat chebyshev_dist(vec4 a, vec4 b)\n{\n    return max(\n        max(\n            max(abs(a.x - b.x), abs(a.y - b.y)),\n            abs(a.z - b.z)\n        ),\n        abs(a.w - b.w)\n    );\n}\n\n#define idiv_ceil(a, b) ((a + b - 1) / b)\n\nint iabs(int v)\n{\n    if (v < 0)\n    {\n        return -v;\n    }\n    return v;\n}\n\nint imin(int a, int b)\n{\n    if (a < b)\n    {\n        return a;\n    }\n    return b;\n}\n\nint imax(int a, int b)\n{\n    if (a > b)\n    {\n        return a;\n    }\n    return b;\n}\n\nint iclamp(int v, int start, int end)\n{\n    if (v < start)\n    {\n        v = start;\n    }\n    if (v > end)\n    {\n        v = end;\n    }\n    return v;\n}\n\nfloat min_component(vec2 v)\n{\n    return min(v.x, v.y);\n}\n\nfloat min_component(vec3 v)\n{\n    return min(min(v.x, v.y), v.z);\n}\n\nfloat min_component(vec4 v)\n{\n    return min(min(min(v.x, v.y), v.z), v.w);\n}\n\nfloat max_component(vec2 v)\n{\n    return max(v.x, v.y);\n}\n\nfloat max_component(vec3 v)\n{\n    return max(max(v.x, v.y), v.z);\n}\n\nfloat max_component(vec4 v)\n{\n    return max(max(max(v.x, v.y), v.z), v.w);\n}\n\nint min_component(ivec2 v)\n{\n    return imin(v.x, v.y);\n}\n\nint min_component(ivec3 v)\n{\n    return imin(imin(v.x, v.y), v.z);\n}\n\nint min_component(ivec4 v)\n{\n    return imin(imin(imin(v.x, v.y), v.z), v.w);\n}\n\nint max_component(ivec2 v)\n{\n    return imax(v.x, v.y);\n}\n\nint max_component(ivec3 v)\n{\n    return imax(imax(v.x, v.y), v.z);\n}\n\nint max_component(ivec4 v)\n{\n    return imax(imax(imax(v.x, v.y), v.z), v.w);\n}\n\nfloat bilinear(\n    float val_bl,\n    float val_tl,\n    float val_tr,\n    float val_br,\n    vec2 offs\n)\n{\n    return mix(\n        mix(val_bl, val_br, offs.x),\n        mix(val_tl, val_tr, offs.x),\n        offs.y\n    );\n}\n\n// credits to AHSEN (https://www.shadertoy.com/user/01000001)\n// https://www.desmos.com/calculator/5d6ph151vi interactive :D\nfloat cubic_interp(float a, float b, float c, float d, float t)\n{\n    float one = t - 1.;\n    float two = t - 2.;\n    float three = t - 3.;\n    return (\n        (-one * two * three * a)\n        + (t * one * two * d)\n        + (3. * t * two * three * b)\n        - (3. * t * one * three * c)\n    ) / 6.;\n}\n\nfloat dist_along_line(vec2 p, vec2 line_start, vec2 line_end)\n{\n    vec2 dir = line_end - line_start;\n    \n    // normalize\n    float len_sqr = dot(dir, dir);\n    if (len_sqr < .0001)\n        return 1e9;\n    dir /= sqrt(len_sqr);\n    \n    return dot(\n        dir,\n        p - line_start\n    );\n}\n\nfloat relative_dist_along_line(vec2 p, vec2 line_start, vec2 line_end)\n{\n    vec2 dir = line_end - line_start;\n    return dot(\n        dir,\n        p - line_start\n    );\n}\n\n// |a| * |b| * sin(theta)\nfloat cross2d(vec2 a, vec2 b)\n{\n    return a.x * b.y - a.y * b.x;\n}\n\n// references for barycentric coordinates\n// https://www.desmos.com/calculator/8g8xjejuox\n// https://www.shadertoy.com/view/mdjBWK\n\nvec3 cartesian_to_barycentric(\n    vec2 p,\n    vec2 v0,\n    vec2 v1,\n    vec2 v2,\n    bool clamp_,\n    out bool p_is_outside\n)\n{\n    vec3 b = vec3(\n        cross2d(v1 - p, v2 - p),\n        cross2d(v2 - p, v0 - p),\n        cross2d(v0 - p, v1 - p)\n    ) / cross2d(v1 - v0, v2 - v0);\n    p_is_outside = min(min(b.x, b.y), b.z) < 0.;\n    if (clamp_)\n    {\n        b = max(b, 0.);\n        b /= (b.x + b.y + b.z);\n    }\n    return b;\n}\n\nvec3 cartesian_to_barycentric(\n    vec3 p,\n    vec3 v0,\n    vec3 v1,\n    vec3 v2,\n    bool clamp_,\n    out bool p_is_outside\n)\n{\n    vec3 b = vec3(\n        length(cross(v1 - p, v2 - p)),\n        length(cross(v2 - p, v0 - p)),\n        length(cross(v0 - p, v1 - p))\n    ) / length(cross(v1 - v0, v2 - v0));\n    p_is_outside = min(min(b.x, b.y), b.z) < 0.;\n    if (clamp_)\n    {\n        b = max(b, 0.);\n        b /= (b.x + b.y + b.z);\n    }\n    return b;\n}\n\nfloat barycentric_interpolate(vec3 b, float v0, float v1, float v2)\n{\n    return dot(b, vec3(v0, v1, v2));\n}\n\nvec2 barycentric_interpolate(vec3 b, vec2 v0, vec2 v1, vec2 v2)\n{\n    return b.x * v0 + b.y * v1 + b.z * v2;\n}\n\nvec3 barycentric_interpolate(vec3 b, vec3 v0, vec3 v1, vec3 v2)\n{\n    return b.x * v0 + b.y * v1 + b.z * v2;\n}\n\nvec4 barycentric_interpolate(vec3 b, vec4 v0, vec4 v1, vec4 v2)\n{\n    return b.x * v0 + b.y * v1 + b.z * v2;\n}\n\nfloat barycentric_interpolate(vec2 b, float v0, float v1, float v2)\n{\n    return barycentric_interpolate(\n        vec3(b.x, b.y, 1. - b.x - b.y),\n        v0, v1, v2\n    );\n}\n\nvec2 barycentric_interpolate(vec2 b, vec2 v0, vec2 v1, vec2 v2)\n{\n    return barycentric_interpolate(\n        vec3(b.x, b.y, 1. - b.x - b.y),\n        v0, v1, v2\n    );\n}\n\nvec3 barycentric_interpolate(vec2 b, vec3 v0, vec3 v1, vec3 v2)\n{\n    return barycentric_interpolate(\n        vec3(b.x, b.y, 1. - b.x - b.y),\n        v0, v1, v2\n    );\n}\n\nvec4 barycentric_interpolate(vec2 b, vec4 v0, vec4 v1, vec4 v2)\n{\n    return barycentric_interpolate(\n        vec3(b.x, b.y, 1. - b.x - b.y),\n        v0, v1, v2\n    );\n}\n\n// angle from 0 to TAU\nfloat get_angle(vec2 p)\n{\n    float a = atan(p.y, p.x);\n    if (a < 0.)\n    {\n        return a + TAU;\n    }\n    return a;\n}\n\nmat2 rotate_2d(float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(\n        c, s,\n        -s, c\n    );\n}\n\nvec2 perpendicular(vec2 v)\n{\n    return vec2(-v.y, v.x);\n}\n\n// s.x=theta\n// s.y=phi\n// (there's no r)\nvec3 spherical_to_cartesian(vec2 s)\n{\n    float sin_theta = sin(s.x);\n    return vec3(\n        sin_theta * cos(s.y),\n        sin_theta * sin(s.y),\n        cos(s.x)\n    );\n}\n\n// s.x=r\n// s.y=theta\n// s.z=phi\nvec3 spherical_to_cartesian(vec3 s)\n{\n    float sin_theta = sin(s.y);\n    return s.x * vec3(\n        sin_theta * cos(s.z),\n        sin_theta * sin(s.z),\n        cos(s.y)\n    );\n}\n\nvec2 screen_to_uv01(vec2 coord, vec2 res)\n{\n    return coord / res;\n}\n\nvec2 screen_to_uv_horizontal(vec2 coord, vec2 res)\n{\n    return (2. * coord - res) / res.x;\n}\n\nvec2 screen_to_uv_vertical(vec2 coord, vec2 res)\n{\n    return (2. * coord - res) / res.y;\n}\n\nvec2 screen_to_uv_fit(vec2 coord, vec2 res)\n{\n    return (2. * coord - res) / min_component(res);\n}\n\nvec2 screen_to_uv_fill(vec2 coord, vec2 res)\n{\n    return (2. * coord - res) / max_component(res);\n}\n\n// * idx starts at 1\nfloat halton(int base, int idx)\n{\n    float result = 0.;\n    float digit_weight = 1.;\n    while (idx > 0)\n    {\n        digit_weight /= float(base);\n        result += float(idx % base) * digit_weight;\n        idx /= base;\n    }\n    return result;\n}\n\n// * idx starts at 1\nvec2 halton_2d(int idx)\n{\n    return vec2(halton(2, idx), halton(3, idx));\n}\n\n// * idx starts at 1\nvec3 halton_3d(int idx)\n{\n    return vec3(halton(2, idx), halton(3, idx), halton(5, idx));\n}\n\n// * idx starts at 1\nvec4 halton_4d(int idx)\n{\n    return vec4(\n        halton(2, idx),\n        halton(3, idx),\n        halton(5, idx),\n        halton(7, idx)\n    );\n}\n\n// for some reason we can't use intBitsToFloat() or floatBitsToInt() to store\n// integers below this value in a buffer.\nconst int BUFFER_MIN_INTEGER = 8388608;\n\n// * x must not be higher than 4,286,578,688 (see BUFFER_MIN_INTEGER above)\n// * for your sanity, don't use negative values\nfloat encode_int_for_buffer(int v)\n{\n    return intBitsToFloat(v + BUFFER_MIN_INTEGER);\n}\n\nint decode_int_from_buffer(float v)\n{\n    return floatBitsToInt(v) - BUFFER_MIN_INTEGER;\n}\n\n// pack two 16-bit integers in a single 32-bit integer\n// * both arguments should be in the 0-65535 range\n// * a must be less than 65279 (see the functions above)\nint pack_i16(int a, int b)\n{\n    return (a << 16) | b;\n}\n\n// unpack two 16-bit integers from a single 32-bit integer\nvoid unpack_i16(int v, out int a, out int b)\n{\n    a = (v >> 16) & 65535;\n    b = v & 65535;\n}\n\n// unpack the first 16-bit integer from a 32-bit integer\nint unpack_i16_a(int v)\n{\n    return (v >> 16) & 65535;\n}\n\n// unpack the second 16-bit integer from a 32-bit integer\nint unpack_i16_b(int v)\n{\n    return v & 65535;\n}\n\nbool icoord_in_bounds(ivec2 icoord, ivec2 ires)\n{\n    return\n        icoord.x >= 0 &&\n        icoord.y >= 0 &&\n        icoord.x < ires.x &&\n        icoord.y < ires.y;\n}\n\nbool icoord_in_bounds(ivec3 icoord, ivec3 ires)\n{\n    return\n        icoord.x >= 0 &&\n        icoord.y >= 0 &&\n        icoord.z >= 0 &&\n        icoord.x < ires.x &&\n        icoord.y < ires.y &&\n        icoord.z < ires.z;\n}\n\nint icoord_to_idx(ivec2 icoord, ivec2 ires)\n{\n    return icoord.x + (icoord.y * ires.x);\n}\n\nint icoord_to_idx(ivec3 icoord, ivec3 ires)\n{\n    return icoord.x + (icoord.y * ires.x) + (icoord.z * ires.x * ires.y);\n}\n\nivec2 idx_to_icoord(int idx, ivec2 ires)\n{\n    return ivec2(idx % ires.x, idx / ires.x);\n}\n\nivec3 idx_to_icoord(int idx, ivec3 ires)\n{\n    return ivec3(\n        idx % ires.x,\n        (idx % (ires.x * ires.y)) / ires.x,\n        idx / (ires.x * ires.y)\n    );\n}\n\n// https://www.desmos.com/calculator/kfe07basy9\n\nint compress_float_to_int_linear(float f, float min_f, float max_f, int max_i)\n{\n    return int(floor(\n        float(max_i) * remap01(f, min_f, max_f)\n    ));\n}\n\nfloat decompress_float_from_int_linear(\n    int i,\n    int max_i,\n    float min_f,\n    float max_f\n)\n{\n    return remap_clamp(\n        float(i) / float(max_i),\n        0., 1.,\n        min_f, max_f\n    );\n}\n\nint compress_float_to_int_log(\n    float f,\n    float log2_zero_offset,\n    float max_log2_f,\n    int max_i\n)\n{\n    f = max(0., f);\n    f += pow(2., log2_zero_offset);\n    return int(floor(\n        float(max_i) * remap01(log2(f), log2_zero_offset, max_log2_f)\n    ));\n}\n\nfloat decompress_float_from_int_log(\n    int i,\n    int max_i,\n    float log2_zero_offset,\n    float max_log2_f\n)\n{\n    return pow(2., remap_clamp(\n        float(i) / float(max_i),\n        0., 1.,\n        log2_zero_offset, max_log2_f\n    )) - pow(2., log2_zero_offset);\n}\n\n\n\n/*_______ pseudo-random number generator ______*/\n// source: https://www.shadertoy.com/view/WdSSRt\n// (heavily modified)\n\n/* usage example:\n    void mainImage(out vec4 frag_col, in vec2 frag_coord)\n    {\n        // initialize PRNG\n        prng_init(vec3(frag_coord / iResolution.y, iTime));\n    \n        // use the function\n        float a = random();\n        vec3 b = vec3(random(), random(), random());\n        \n        ...\n    }\n*/\n\nuint prng_state[2];\n\nuint prng_rot(uint x, int k)\n{\n    return (x << k) | (x >> (32 - k));\n}\n\n// random uint from 0 to 2^32-1\nuint randomui()\n{\n    uint s0 = prng_state[0];\n    uint s1 = prng_state[1];\n    uint result = prng_rot(s0 * 2654435771u, 5) * 5u;\n    s1 ^= s0;\n    prng_state[0] = prng_rot(s0, 26) ^ s1 ^ (s1 << 9);\n    prng_state[1] = prng_rot(s1, 13);\n    return result;\n}\n\n// random int from 0 to 2^31-1\nint randomi()\n{\n    return int(randomui() % 0x7FFFFFFFu);\n}\n\n// random float from 0 to 1\nfloat random()\n{\n    return float(randomui()) / float(0xffffffffu);\n}\n\n// generate two normally distributed random numbers using the\n// Box-Muller transform\n// https://www.baeldung.com/cs/uniform-to-normal-distribution\nvec2 random_gauss()\n{\n    float u1 = random();\n    float u2 = random() * TAU;\n    float temp = sqrt(-2. * log(u1));\n    return temp * vec2(cos(u2), sin(u2));\n    \n    // unoptimized version\n    //float u1 = random();\n    //float u2 = random();\n    //return vec2(cos(TAU * u2), sin(TAU * u2)) * sqrt(-2. * log(u1));\n}\n\nvec2 random_on_circle()\n{\n    vec2 v = vec2(1);\n    float lensqr;\n\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec2(2. * random() - 1., 2. * random() - 1.);\n        lensqr = dot(v, v);\n        if (lensqr == 0.)\n            i--;\n        else if (lensqr <= 1.)\n            break;\n    }\n    return v / sqrt(lensqr);\n}\n\nvec3 random_on_sphere()\n{\n    vec3 v = vec3(1);\n    float lensqr;\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec3(2. * random() - 1., 2. * random() - 1., 2. * random() - 1.);\n        lensqr = dot(v, v);\n        if (lensqr == 0.)\n            i--;\n        else if (lensqr <= 1.)\n            break;\n    }\n    return v / sqrt(lensqr);\n}\n\nvec2 random_in_circle()\n{\n    vec2 v = vec2(1);\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec2(2. * random() - 1., 2. * random() - 1.);\n        if (dot(v, v) <= 1.)\n            return v;\n    }\n    return v;\n}\n\nvec3 random_in_sphere()\n{\n    vec3 v = vec3(1);\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec3(2. * random() - 1., 2. * random() - 1., 2. * random() - 1.);\n        if (dot(v, v) <= 1.)\n            return v;\n    }\n    return v;\n}\n\nvec3 random_on_hemisphere(vec3 normal)\n{\n    vec3 v = random_on_sphere();\n    return v * sign(dot(v, normal));\n}\n\nvec3 random_in_hemisphere(vec3 normal)\n{\n    vec3 v = random_in_sphere();\n    return v * sign(dot(v, normal));\n}\n\n// initialize with uvec2\nvoid prng_init(uvec2 seed)\n{\n    seed += uvec2(1317, 944573125);\n    seed *= 464973573u;\n    prng_state[0] = seed.x;\n    prng_state[1] = seed.y;\n    randomi();\n}\n\n// initialize with uint\nvoid prng_init(uint seed)\n{\n    prng_init(uvec2(seed, 1));\n}\n\n// initialize with vec3\nvoid prng_init(vec3 seed)\n{\n    seed += 3.49276101561702;\n    seed.xy *= (seed.z + 10.258);\n    prng_state[0] = floatBitsToUint(seed.x);\n    prng_state[1] = floatBitsToUint(seed.y);\n    randomui();\n}\n\n// initialize with vec2\nvoid prng_init(vec2 seed)\n{\n    prng_init(vec3(seed, 1));\n}\n\n// initialize with float\nvoid prng_init(float seed)\n{\n    prng_init(vec3(seed, 1, 1));\n}\n\n\n\n/*___________________ scene ___________________*/\n\nconst vec3 SUN_DIR = normalize(vec3(.13, .2, .13));\n\nfloat transform_time(float t)\n{\n    return t;\n}\n\n// sample the environment color\nvec3 env(vec3 dir)\n{\n    float vertical_angle = degrees(acos(.9999 * dir.z));\n    vec3 col = mix(\n        vec3(.2, .5, .8),\n        vec3(.05, .2, .5),\n        smoothstep(90., 30., vertical_angle)\n    );\n    col = mix(\n        col,\n        vec3(.05, .04, .02),\n        float(vertical_angle > 90.)\n    );\n    return col;\n}\n\nconst float POM_MAX_HEIGHT = .3;\nconst float POM_MIN_LAYERS = 20.;\nconst float POM_MAX_LAYERS = 80.;\nconst float POM_EPS_NORMAL = .001;\nconst bool POM_CUT_EDGES = false;\n\nfloat pom_heightmap01(vec2 uv, in sampler2D tex)\n{\n    return pow(texture(tex, uv).r, 2.2);\n}\n\n\n\n/*________________ ray tracing ________________*/\n\nstruct Ray\n{\n    vec3 orig;\n    vec3 dir; // must be normalized\n};\n\nstruct OrthonormalBasis\n{\n    vec3 right;\n    vec3 forward;\n    vec3 up;\n};\n\n// * all three arguments must be normalized and perpendicular to each other\nOrthonormalBasis OrthonormalBasis_new(vec3 right, vec3 forward, vec3 up)\n{\n    OrthonormalBasis onb;\n    onb.right = right;\n    onb.forward = forward;\n    onb.up = up;\n    return onb;\n}\n\n// * forward must be normalized\nOrthonormalBasis OrthonormalBasis_from_forward_and_world_up(\n    vec3 forward,\n    vec3 world_up\n)\n{\n    OrthonormalBasis onb;\n    onb.forward = forward;\n    onb.right = normalize(cross(onb.forward, world_up));\n    onb.up = cross(onb.right, onb.forward);\n    return onb;\n}\n\nvec3 OrthonormalBasis_localize(in OrthonormalBasis self, vec3 p)\n{\n    return vec3(\n        dot(p, self.right),\n        dot(p, self.forward),\n        dot(p, self.up)\n    );\n}\n\nvec3 OrthonormalBasis_delocalize(in OrthonormalBasis self, vec3 p)\n{\n    return (p.x * self.right) + (p.y * self.forward) + (p.z * self.up);\n}\n\n// basic perspective camera\nstruct Camera\n{\n    vec3 pos;\n    float sensor_width;\n    float sensor_height;\n    float focal_length;\n\n    OrthonormalBasis _onb;\n};\n\n// FOV and focal length formula\n// https://www.desmos.com/calculator/5smpkhn02l\n\n// Camera: adjust focal length based on horizontal FOV and sensor width\nvoid Camera_set_fov_horizontal(inout Camera self, float fov)\n{\n    self.focal_length = .5 * self.sensor_width / tan(.5 * fov);\n}\n\n// Camera: calculate the horizontal FOV\nfloat Camera_get_fov_horizontal(in Camera self)\n{\n    return 2. * atan(.5 * self.sensor_width / self.focal_length);\n}\n\n// Camera: adjust focal length based on vertical FOV and sensor height\nvoid Camera_set_fov_vertical(inout Camera self, float fov)\n{\n    self.focal_length = .5 * self.sensor_height / tan(.5 * fov);\n}\n\n// Camera: calculate the vertical FOV\nfloat Camera_get_fov_vertical(in Camera self)\n{\n    return 2. * atan(.5 * self.sensor_height / self.focal_length);\n}\n\n// Camera: adjust focal length based on diagonal FOV and sensor size\nvoid Camera_set_fov_diagonal(inout Camera self, float fov)\n{\n    float sensor_size = length(vec2(self.sensor_width, self.sensor_height));\n    self.focal_length = .5 * sensor_size / tan(.5 * fov);\n}\n\n// Camera: calculate the diagonal FOV\nfloat Camera_get_fov_diagonal(in Camera self)\n{\n    float sensor_size = length(vec2(self.sensor_width, self.sensor_height));\n    return 2. * atan(.5 * sensor_size / self.focal_length);\n}\n\n// Camera: look at a point\nvoid Camera_look_at(inout Camera self, vec3 target, vec3 world_up)\n{\n    self._onb = OrthonormalBasis_from_forward_and_world_up(\n        normalize(target - self.pos),\n        world_up\n    );\n}\n\n// Camera: look along a direction\n// * dir must be normalized\nvoid Camera_look_along(inout Camera self, vec3 dir, vec3 world_up)\n{\n    self._onb = OrthonormalBasis_from_forward_and_world_up(\n        dir,\n        world_up\n    );\n}\n\n// Camera: generate a camera ray for given UV coordinates\nRay Camera_gen_ray(in Camera self, vec2 uv01)\n{\n    Ray r;\n    r.orig = self.pos + OrthonormalBasis_delocalize(self._onb, vec3(\n        (uv01.x - .5) * self.sensor_width,\n        self.focal_length,\n        (uv01.y - .5) * self.sensor_height\n    ));\n    r.dir = normalize(r.orig - self.pos);\n    return r;\n}\n\n// Camera: retrieve UV coordinates from a point in space\n// * returns vec2(-1e9) on failure\nvec2 Camera_retrieve_uv01_from_point(in Camera self, vec3 p)\n{\n    // project into camera space\n    vec3 world_space = p - self.pos;\n    vec3 cam_space = OrthonormalBasis_localize(self._onb, world_space);\n\n    // p is not in front of the sensor\n    if (cam_space.y < self.focal_length - .00001)\n    {\n        return vec2(-1e9);\n    }\n\n    // linearly normalize p so that it falls on the focal plane\n    cam_space /= cam_space.y;\n    cam_space *= self.focal_length;\n\n    // extract the UV coordinates\n    return (cam_space.xz / vec2(self.sensor_width, self.sensor_height)) + .5;\n}\n\n// Camera: retrieve UV coordinates from a direction towards the sky (used when\n// no object is hit)\n// * returns vec2(-1e9) on failure\nvec2 Camera_retrieve_uv01_from_dir(in Camera self, vec3 dir)\n{\n    // project into camera space\n    vec3 p = dir;\n    vec3 cam_space = OrthonormalBasis_localize(self._onb, p);\n\n    // p is not in front of the sensor\n    if (cam_space.y < .00001)\n    {\n        return vec2(-1e9);\n    }\n\n    // linearly normalize p so that it falls on the focal plane\n    cam_space /= cam_space.y;\n    cam_space *= self.focal_length;\n\n    // extract the UV coordinates\n    return (cam_space.xz / vec2(self.sensor_width, self.sensor_height)) + .5;\n}\n\n// Camera: generate a defocused camera ray for given UV coordinates\nRay Camera_gen_ray_defocused(\n    in Camera self,\n    vec2 uv01,\n    float focus_dist,\n    float jitter\n)\n{\n    // generate normal ray without normalizing the direction\n    Ray r;\n    vec3 r_dir_unnormalized = OrthonormalBasis_delocalize(self._onb, vec3(\n        (uv01.x - .5) * self.sensor_width,\n        self.focal_length,\n        (uv01.y - .5) * self.sensor_height\n    ));\n    r.orig = self.pos + r_dir_unnormalized;\n    \n    // point on the focus plane\n    vec3 fp = r.orig + focus_dist * (r_dir_unnormalized / self.focal_length);\n    \n    // randomly offset the ray origin\n    vec2 offs = jitter * random_in_circle();\n    r.orig += OrthonormalBasis_delocalize(self._onb, vec3(\n        offs.x,\n        0.,\n        offs.y\n    ));\n    \n    // look at the point on the focus plane\n    r.dir = normalize(fp - r.orig);\n    \n    return r;\n}\n\nstruct Hit\n{\n    Ray r; // ray that produced this hit\n    bool hit; // did we hit something?\n    vec3 p; // hit position\n    float t; // hit distance\n    vec3 n; // normal\n    vec2 uv;\n};\n\n// front face is counterclockwise\nstruct Triangle\n{\n    vec3 v0;\n    vec3 v1;\n    vec3 v2;\n};\n\n// front face is counterclockwise\nstruct Quad\n{\n    vec3 orig;\n    vec3 u;\n    vec3 v;\n};\n\nvec3 triangle_normal(in Triangle tri)\n{\n    return normalize(cross(tri.v1 - tri.v0, tri.v2 - tri.v0));\n}\n\nvec3 quad_normal(in Quad q)\n{\n    return normalize(cross(q.u, q.v));\n}\n\n// https://en.wikipedia.org/wiki/M%C3%B6ller%E2%80%93Trumbore_intersection_algorithm\nvoid ray_triangle(\n    in Triangle tri,\n    in Ray r,\n    out Hit h\n)\n{\n    h.r = r;\n    h.hit = false;\n\n    const float eps = .0001;\n\n    vec3 edge1 = tri.v1 - tri.v0;\n    vec3 edge2 = tri.v2 - tri.v0;\n    vec3 ray_cross_e2 = cross(r.dir, edge2);\n    float det = dot(edge1, ray_cross_e2);\n\n    if (abs(det) < eps)\n    {\n        // ray is parallel to the triangle\n        return;\n    }\n\n    float inv_det = 1. / det;\n    vec3 s = r.orig - tri.v0;\n    float u = inv_det * dot(s, ray_cross_e2);\n\n    if (u < 0. || u > 1.)\n    {\n        return;\n    }\n\n    vec3 s_cross_e1 = cross(s, edge1);\n    float v = inv_det * dot(r.dir, s_cross_e1);\n\n    if (v < 0. || u + v > 1.)\n    {\n        return;\n    }\n\n    // at this stage we can compute t to find out where the intersection point\n    // is on the line\n    h.t = inv_det * dot(edge2, s_cross_e1);\n\n    // this means that there is a line intersection but not a ray intersection\n    if (h.t < 0.)\n    {\n        return;\n    }\n    \n    h.hit = true;\n    h.p = r.orig + (h.t * r.dir);\n    h.n = normalize(cross(edge1, edge2));\n    h.uv = vec2(u, v);\n}\n\nvoid ray_quad(\n    in Quad q,\n    in Ray r,\n    out Hit h\n)\n{\n    Triangle tri;\n    tri.v0 = q.orig;\n    tri.v1 = q.orig + q.u;\n    tri.v2 = q.orig + q.u + q.v;\n    ray_triangle(tri, r, h);\n    if (h.hit)\n    {\n        h.uv = vec2(h.uv.x + h.uv.y, h.uv.y);\n        return;\n    }\n\n    tri.v0 = q.orig;\n    tri.v1 = q.orig + q.u + q.v;\n    tri.v2 = q.orig + q.v;\n    ray_triangle(tri, r, h);\n    if (h.hit)\n    {\n        h.uv = vec2(h.uv.x, h.uv.x + h.uv.y);\n    }\n}\n\nvoid trace_ray(\n    in Ray r,\n    float time,\n    inout Hit h,\n    in sampler2D tex\n)\n{\n    Quad q;\n    q.orig = vec3(-1, -1, 0);\n    q.u = vec3(2, 0, 0);\n    q.v = vec3(0, 2, 0);\n    \n    ray_quad(q, r, h);\n    \n    if (!h.hit)\n    {\n        return;\n    }\n    \n    // parallax occlusion mapping\n    \n    float cos_view_angle = abs(dot(h.n, r.dir));\n    \n    float n_layers = mix(\n        POM_MAX_LAYERS,\n        POM_MIN_LAYERS,\n        cos_view_angle\n    );\n    float layer_depth = 1. / n_layers;\n    float curr_layer_depth = 0.;\n    \n    vec3 step_ray = -r.dir * POM_MAX_HEIGHT * layer_depth;\n    vec2 delta_uv = vec2(\n        dot(step_ray, q.u) / length_sq(q.u),\n        dot(step_ray, q.v) / length_sq(q.v)\n    ) / dot(h.n, r.dir);\n\n    vec2 uv = h.uv;\n    float curr_depth = 1. - pom_heightmap01(uv, tex);\n    \n    // loop until we're below the surface\n    // * don't loop if we're looking direcly from above\n    if (cos_view_angle < .9999)\n    {\n        while (curr_layer_depth < curr_depth)\n        {\n            curr_layer_depth += layer_depth;\n            uv += delta_uv;\n            curr_depth = 1. - pom_heightmap01(uv, tex);\n            \n            h.t += POM_MAX_HEIGHT / n_layers;\n        }\n    }\n    \n    // update hit position\n    h.p = r.orig + h.t * r.dir;\n    \n    // apply occlusion (blend with the previous value)\n    vec2 prev_uv = uv - delta_uv;\n    float after_depth = curr_depth - curr_layer_depth;\n    float before_depth =\n        (1. - pom_heightmap01(prev_uv, tex))\n        - (curr_layer_depth - layer_depth);\n    float mix_fac = after_depth / (after_depth - before_depth);\n    uv = mix(uv, prev_uv, mix_fac);\n    \n    // if UV is out of range, then we haven't hit the surface\n    if (POM_CUT_EDGES && max(abs(uv.x - .5), abs(uv.y - .5)) > .5)\n    {\n        h.hit = false;\n        return;\n    }\n    \n    // otherwise, we update the hit info\n    h.uv = uv;\n    \n    // and calculate the normal\n    float height = pom_heightmap01(uv, tex);\n    vec2 gradient = POM_MAX_HEIGHT * (\n        vec2(\n            pom_heightmap01(uv + vec2(POM_EPS_NORMAL, 0), tex),\n            pom_heightmap01(uv + vec2(0, POM_EPS_NORMAL), tex)\n        ) - height\n    ) / POM_EPS_NORMAL;\n    h.n = normalize(\n        -gradient.x * normalize(q.u)\n        + -gradient.y * normalize(q.v)\n        + h.n\n    );\n}\n\n\n\n/*-----------------------------------------------\n\nflim - Filmic Color Transform\n\nInput Color Space:   Linear BT.709 I-D65\nOutput Color Space:  Linear BT.709 I-D65 / sRGB 2.2 (depends on arguments)\n\nDescription:\n  Experimental port of flim for GLSL/Shadertoy\n  matching flim v1.1.0.\n\nAuthor:\n  Bean (beans_please on Shadertoy)\n\nOriginal Repo:\n  https://github.com/bean-mhm/flim\n\nOriginal Shader:\n  https://www.shadertoy.com/view/dd2yDz\n\n-----------------------------------------------*/\n\n// parameters\n\nconst float flim_pre_exposure = 4.3;\nconst vec3 flim_pre_formation_filter = vec3(1.);\nconst float flim_pre_formation_filter_strength = 0.;\n\nconst float flim_extended_gamut_red_scale = 1.05;\nconst float flim_extended_gamut_green_scale = 1.12;\nconst float flim_extended_gamut_blue_scale = 1.045;\nconst float flim_extended_gamut_red_rot = .5;\nconst float flim_extended_gamut_green_rot = 2.;\nconst float flim_extended_gamut_blue_rot = .1;\nconst float flim_extended_gamut_red_mul = 1.;\nconst float flim_extended_gamut_green_mul = 1.;\nconst float flim_extended_gamut_blue_mul = 1.;\n\nconst float flim_sigmoid_log2_min = -10.;\nconst float flim_sigmoid_log2_max = 22.;\nconst float flim_sigmoid_toe_x = .44;\nconst float flim_sigmoid_toe_y = .28;\nconst float flim_sigmoid_shoulder_x = .591;\nconst float flim_sigmoid_shoulder_y = .779;\n\nconst float flim_negative_film_exposure = 6.;\nconst float flim_negative_film_density = 5.;\n\nconst vec3 flim_print_backlight = vec3(1);\nconst float flim_print_film_exposure = 6.;\nconst float flim_print_film_density = 27.5;\n\nconst float flim_black_point = -1.; // -1 = auto\nconst vec3 flim_post_formation_filter = vec3(1);\nconst float flim_post_formation_filter_strength = 0.;\nconst float flim_midtone_saturation = 1.02;\n\n// color space conversions\n// the matrices below represent data in row-major, but GLSL matrices are in\n// column-major, so we need to multiply a vec3 by a matrix rather than\n// multiplying a matrix by a vec3.\n\nconst mat3 mat_bt2020_to_xyz = mat3(\n     0.6369580483,  0.1446169036,  0.1688809752,\n     0.2627002120,  0.6779980715,  0.0593017165,\n     0.0000000000,  0.0280726930,  1.0609850577\n);\n\nconst mat3 mat_xyz_to_bt2020 = mat3(\n     1.7166511880, -0.3556707838, -0.2533662814,\n    -0.6666843518,  1.6164812366,  0.0157685458,\n     0.0176398574, -0.0427706133,  0.9421031212\n);\n\nconst mat3 mat_bt709_to_xyz = mat3(\n     0.4123907993,  0.3575843394,  0.1804807884,\n     0.2126390059,  0.7151686788,  0.0721923154,\n     0.0193308187,  0.1191947798,  0.9505321522\n);\n\nconst mat3 mat_xyz_to_bt709 = mat3(\n     3.2409699419, -1.5373831776, -0.4986107603,\n    -0.9692436363,  1.8759675015,  0.0415550574,\n     0.0556300797, -0.2039769589,  1.0569715142\n);\n\nconst mat3 mat_dcip3_to_xyz = mat3(\n     0.4451698156,  0.2771344092,  0.1722826698,\n     0.2094916779,  0.7215952542,  0.0689130679,\n     0.0000000000,  0.0470605601,  0.9073553944\n);\n\nconst mat3 mat_xyz_to_dcip3 = mat3(\n     2.7253940305, -1.0180030062, -0.4401631952,\n    -0.7951680258,  1.6897320548,  0.0226471906,\n     0.0412418914, -0.0876390192,  1.1009293786\n);\n\nvec3 oetf_pow(vec3 col, float power)\n{\n    return pow(col, vec3(1. / power));\n}\n\nvec3 eotf_pow(vec3 col, float power)\n{\n    return pow(col, vec3(power));\n}\n\n// flim's utility functions\n\nfloat flim_wrap(float v, float start, float end)\n{\n    return start + mod(v - start, end - start);\n}\n\nfloat flim_remap(\n    float v,\n    float inp_start,\n    float inp_end,\n    float out_start,\n    float out_end\n)\n{\n    return out_start\n        + ((out_end - out_start) / (inp_end - inp_start)) * (v - inp_start);\n}\n\nfloat flim_remap_clamp(\n    float v,\n    float inp_start,\n    float inp_end,\n    float out_start,\n    float out_end\n)\n{\n    float t = clamp((v - inp_start) / (inp_end - inp_start), 0., 1.);\n    return out_start + t * (out_end - out_start);\n}\n\nfloat flim_remap01(\n    float v,\n    float inp_start,\n    float inp_end\n)\n{\n    return clamp((v - inp_start) / (inp_end - inp_start), 0., 1.);\n}\n\nvec3 flim_blender_rgb_to_hsv(vec3 rgb)\n{\n    float cmax, cmin, h, s, v, cdelta;\n    vec3 c;\n\n    cmax = max(rgb[0], max(rgb[1], rgb[2]));\n    cmin = min(rgb[0], min(rgb[1], rgb[2]));\n    cdelta = cmax - cmin;\n\n    v = cmax;\n    if (cmax != 0.)\n    {\n        s = cdelta / cmax;\n    }\n    else\n    {\n        s = 0.;\n        h = 0.;\n    }\n\n    if (s == 0.)\n    {\n        h = 0.;\n    }\n    else\n    {\n        c = (vec3(cmax) - rgb.xyz) / cdelta;\n\n        if (rgb.x == cmax)\n        {\n            h = c[2] - c[1];\n        }\n        else if (rgb.y == cmax)\n        {\n            h = 2. + c[0] - c[2];\n        }\n        else\n        {\n            h = 4. + c[1] - c[0];\n        }\n\n        h /= 6.;\n\n        if (h < 0.)\n        {\n            h += 1.;\n        }\n    }\n\n    return vec3(h, s, v);\n}\n\nvec3 flim_blender_hsv_to_rgb(vec3 hsv)\n{\n    float f, p, q, t, h, s, v;\n    vec3 rgb;\n\n    h = hsv[0];\n    s = hsv[1];\n    v = hsv[2];\n\n    if (s == 0.)\n    {\n        rgb = vec3(v, v, v);\n    }\n    else\n    {\n        if (h == 1.)\n        {\n            h = 0.;\n        }\n\n        h *= 6.;\n        int i = int(floor(h));\n        f = h - float(i);\n        rgb = vec3(f, f, f);\n        p = v * (1. - s);\n        q = v * (1. - (s * f));\n        t = v * (1. - (s * (1. - f)));\n\n        if (i == 0)\n        {\n            rgb = vec3(v, t, p);\n        }\n        else if (i == 1)\n        {\n            rgb = vec3(q, v, p);\n        }\n        else if (i == 2)\n        {\n            rgb = vec3(p, v, t);\n        }\n        else if (i == 3)\n        {\n            rgb = vec3(p, q, v);\n        }\n        else if (i == 4)\n        {\n            rgb = vec3(t, p, v);\n        }\n        else\n        {\n            rgb = vec3(v, p, q);\n        }\n    }\n\n    return rgb;\n}\n\nvec3 flim_blender_hue_sat(vec3 col, float hue, float sat, float value)\n{\n    vec3 hsv = flim_blender_rgb_to_hsv(col);\n\n    hsv[0] = fract(hsv[0] + hue + .5);\n    hsv[1] = clamp(hsv[1] * sat, 0., 1.);\n    hsv[2] = hsv[2] * value;\n\n    return flim_blender_hsv_to_rgb(hsv);\n}\n\nfloat flim_rgb_avg(vec3 col)\n{\n    return (col.x + col.y + col.z) / 3.;\n}\n\nfloat flim_rgb_sum(vec3 col)\n{\n    return col.x + col.y + col.z;\n}\n\nfloat flim_rgb_max(vec3 col)\n{\n    return max(max(col.x, col.y), col.z);\n}\n\nfloat flim_rgb_min(vec3 col)\n{\n    return min(min(col.x, col.y), col.z);\n}\n\nvec3 flim_rgb_uniform_offset(vec3 col, float black_point, float white_point)\n{\n    float mono = flim_rgb_avg(col);\n    float mono2 = flim_remap01(\n        mono, black_point / 1000.,\n        1. - (white_point / 1000.)\n    );\n    return col * (mono2 / mono);\n}\n\nvec3 flim_rgb_sweep(float hue)\n{\n    hue = flim_wrap(hue * 360., 0., 360.);\n\n    vec3 col = vec3(1, 0, 0);\n    col = mix(col, vec3(1, 1, 0), flim_remap01(hue, 0., 60.));\n    col = mix(col, vec3(0, 1, 0), flim_remap01(hue, 60., 120.));\n    col = mix(col, vec3(0, 1, 1), flim_remap01(hue, 120., 180.));\n    col = mix(col, vec3(0, 0, 1), flim_remap01(hue, 180., 240.));\n    col = mix(col, vec3(1, 0, 1), flim_remap01(hue, 240., 300.));\n    col = mix(col, vec3(1, 0, 0), flim_remap01(hue, 300., 360.));\n    \n    return col;\n}\n\nvec3 flim_rgb_exposure_sweep_test(vec2 uv0to1)\n{\n    float hue = 1. - uv0to1.y;\n    float exposure = flim_remap(uv0to1.x, 0., 1., -5., 10.);\n    return flim_rgb_sweep(hue) * pow(2., exposure);\n}\n\n// https://www.desmos.com/calculator/khkztixyeu\nfloat flim_super_sigmoid(\n    float v,\n    float toe_x,\n    float toe_y,\n    float shoulder_x,\n    float shoulder_y\n)\n{\n    // clip\n    v = clamp(v, 0., 1.);\n    toe_x = clamp(toe_x, 0., 1.);\n    toe_y = clamp(toe_y, 0., 1.);\n    shoulder_x = clamp(shoulder_x, 0., 1.);\n    shoulder_y = clamp(shoulder_y, 0., 1.);\n\n    // calculate straight line slope\n    float slope = (shoulder_y - toe_y) / (shoulder_x - toe_x);\n\n    // toe\n    if (v < toe_x)\n    {\n        float toe_pow = slope * toe_x / toe_y;\n        return toe_y * pow(v / toe_x, toe_pow);\n    }\n\n    // straight line\n    if (v < shoulder_x)\n    {\n        float intercept = toe_y - (slope * toe_x);\n        return slope * v + intercept;\n    }\n\n    // shoulder\n    float shoulder_pow =\n        -slope / (\n            ((shoulder_x - 1.) / pow(1. - shoulder_x, 2.))\n            * (1. - shoulder_y)\n        );\n    return\n        (1. - pow(1. - (v - shoulder_x) / (1. - shoulder_x), shoulder_pow))\n        * (1. - shoulder_y)\n        + shoulder_y;\n}\n\nfloat flim_dye_mix_factor(float mono, float max_density)\n{\n    // log2 and map range\n    float offset = pow(2., flim_sigmoid_log2_min);\n    float fac = flim_remap01(\n        log2(mono + offset),\n        flim_sigmoid_log2_min,\n        flim_sigmoid_log2_max\n    );\n\n    // calculate amount of exposure from 0 to 1\n    fac = flim_super_sigmoid(\n        fac,\n        flim_sigmoid_toe_x,\n        flim_sigmoid_toe_y,\n        flim_sigmoid_shoulder_x,\n        flim_sigmoid_shoulder_y\n    );\n\n    // calculate dye density\n    fac *= max_density;\n\n    // mix factor\n    fac = pow(2., -fac);\n\n    // clip and return\n    return clamp(fac, 0., 1.);\n}\n\nvec3 flim_rgb_color_layer(\n    vec3 col,\n    vec3 sensitivity_tone,\n    vec3 dye_tone,\n    float max_density\n)\n{\n    // normalize\n    vec3 sensitivity_tone_norm =\n        sensitivity_tone / flim_rgb_sum(sensitivity_tone);\n    vec3 dye_tone_norm = dye_tone / flim_rgb_max(dye_tone);\n\n    // dye mix factor\n    float mono = dot(col, sensitivity_tone_norm);\n    float mix_fac = flim_dye_mix_factor(mono, max_density);\n\n    // dye mixing\n    return mix(dye_tone_norm, vec3(1), mix_fac);\n}\n\nvec3 flim_rgb_develop(vec3 col, float exposure, float max_density)\n{\n    // exposure\n    col *= pow(2., exposure);\n\n    // blue-sensitive layer\n    vec3 result = flim_rgb_color_layer(\n        col,\n        vec3(0, 0, 1),\n        vec3(1, 1, 0),\n        max_density\n    );\n\n    // green-sensitive layer\n    result *= flim_rgb_color_layer(\n        col,\n        vec3(0, 1, 0),\n        vec3(1, 0, 1),\n        max_density\n    );\n\n    // red-sensitive layer\n    result *= flim_rgb_color_layer(\n        col,\n        vec3(1, 0, 0),\n        vec3(0, 1, 1),\n        max_density\n    );\n\n    return result;\n}\n\nvec3 flim_gamut_extension_mat_row(\n    float primary_hue,\n    float scale,\n    float rotate,\n    float mul\n)\n{\n    vec3 result = flim_blender_hsv_to_rgb(vec3(\n        flim_wrap(primary_hue + (rotate / 360.), 0., 1.),\n        1. / scale,\n        1.\n    ));\n    result /= flim_rgb_sum(result);\n    result *= mul;\n    return result;\n}\n\nmat3 flim_gamut_extension_mat(\n    float red_scale,\n    float green_scale,\n    float blue_scale,\n    float red_rot,\n    float green_rot,\n    float blue_rot,\n    float red_mul,\n    float green_mul,\n    float blue_mul\n)\n{\n    mat3 m;\n    m[0] = flim_gamut_extension_mat_row(\n        0.,\n        red_scale,\n        red_rot,\n        red_mul\n    );\n    m[1] = flim_gamut_extension_mat_row(\n        1. / 3.,\n        green_scale,\n        green_rot,\n        green_mul\n    );\n    m[2] = flim_gamut_extension_mat_row(\n        2. / 3.,\n        blue_scale,\n        blue_rot,\n        blue_mul\n    );\n    return m;\n}\n\nvec3 negative_and_print(vec3 col, vec3 backlight_ext)\n{\n    // develop negative\n    col = flim_rgb_develop(\n        col,\n        flim_negative_film_exposure,\n        flim_negative_film_density\n    );\n\n    // backlight\n    col *= backlight_ext;\n\n    // develop print\n    col = flim_rgb_develop(\n        col,\n        flim_print_film_exposure,\n        flim_print_film_density\n    );\n\n    return col;\n}\n\n// the flim transform\n\nvec3 flim_transform(vec3 col, float exposure, bool convert_to_srgb)\n{\n    // eliminate negative values\n    col = max(col, 0.);\n\n    // pre-Exposure\n    col *= pow(2., flim_pre_exposure + exposure);\n\n    // clip very large values for float precision issues\n    col = min(col, 5000.);\n\n    // gamut extension matrix (Linear BT.709)\n    mat3 extend_mat = flim_gamut_extension_mat(\n        flim_extended_gamut_red_scale,\n        flim_extended_gamut_green_scale,\n        flim_extended_gamut_blue_scale,\n        flim_extended_gamut_red_rot,\n        flim_extended_gamut_green_rot,\n        flim_extended_gamut_blue_rot,\n        flim_extended_gamut_red_mul,\n        flim_extended_gamut_green_mul,\n        flim_extended_gamut_blue_mul\n    );\n    mat3 extend_mat_inv = inverse(extend_mat);\n\n    // backlight in the extended gamut\n    vec3 backlight_ext = flim_print_backlight * extend_mat;\n\n    // upper limit in the print (highlight cap)\n    const float big = 10000000.;\n    vec3 white_cap = negative_and_print(vec3(big, big, big), backlight_ext);\n\n    // pre-formation filter\n    col = mix(\n        col,\n        col * flim_pre_formation_filter,\n        flim_pre_formation_filter_strength\n    );\n\n    // convert to the extended gamut\n    col *= extend_mat;\n\n    // negative & print\n    col = negative_and_print(col, backlight_ext);\n\n    // convert from the extended gamut\n    col *= extend_mat_inv;\n\n    // eliminate negative values\n    col = max(col, 0.);\n\n    // white cap\n    col /= white_cap;\n\n    // black cap (-1 = auto)\n    if (flim_black_point == -1.)\n    {\n        vec3 black_cap = negative_and_print(vec3(0.), backlight_ext);\n        black_cap /= white_cap;\n        col = flim_rgb_uniform_offset(\n            col,\n            flim_rgb_avg(black_cap) * 1000.,\n            0.\n        );\n    }\n    else\n    {\n        col = flim_rgb_uniform_offset(col, flim_black_point, 0.);\n    }\n\n    // post-formation filter\n    col = mix(\n        col,\n        col * flim_post_formation_filter,\n        flim_post_formation_filter_strength\n    );\n\n    // clip\n    col = clamp(col, 0., 1.);\n\n    // midtone saturation\n    float mono = flim_rgb_avg(col);\n    float mix_fac =\n        (mono < .5)\n        ? flim_remap01(mono, .05, .5)\n        : flim_remap01(mono, .95, .5);\n    col = mix(\n        col,\n        flim_blender_hue_sat(col, .5, flim_midtone_saturation, 1.),\n        mix_fac\n    );\n\n    // clip\n    col = clamp(col, 0., 1.);\n\n    // OETF\n    if (convert_to_srgb)\n    {\n        col = oetf_pow(col, 2.2);\n    }\n\n    return col;\n}\n\n/*____________________ end ____________________*/\n",
     "name": "Common",
     "description": "",
     "type": "common"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "XcBBWW",
    "date": "1724905810",
    "viewed": 145,
    "name": "Follow Edge Antialiasing? (Bad)",
    "description": "[url=https://www.shadertoy.com/view/M33cD7]SEE BETTER VERSION[/url]\nidk if this is FXAA or SMAA or whatever but screen space methods are still better than TAA\nhold mouse for before/after comparison\n",
    "likes": 2,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "antialiasing",
     "edge",
     "aa",
     "fxaa",
     "smaa",
     "mlaa"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// fetch color from buffer A\nvec3 fetch(vec2 coord)\n{\n    return texture(iChannel0, coord / iResolution.xy).rgb;\n}\n\n// fetch tangent from buffer B\nvec2 fetch_tangent(vec2 coord)\n{\n    return texture(iChannel1, coord / iResolution.xy).xy;\n}\n\nvec3 view_transform(vec3 col)\n{\n    // avoid any negative values before using power functions\n    col = max(col, 0.);\n    \n    // OETF (Linear BT.709 I-D65 to sRGB 2.2)\n    col = pow(col, vec3(1. / 2.2));\n    col = clamp(col, 0., 1.);\n\n    return col;\n}\n\nvec3 render(vec2 coord)\n{\n    // before/after divider\n    if (iMouse.z > .5)\n    {\n        if (abs(coord.x - iMouse.x) < 1.1)\n        {\n            return vec3(.8, .05, .02);\n        }\n        if (coord.x < iMouse.x)\n        {\n            return fetch(coord);\n        }\n    }\n\n    // keep following the tangent on both sides and average out the\n    // colors along the path\n    vec2 curr_coord = coord;\n    vec3 col = fetch(curr_coord);\n    for (int i = 0; i < 3; i++)\n    {\n        curr_coord += fetch_tangent(curr_coord);\n        col += fetch(curr_coord);\n    }\n    curr_coord = coord;\n    for (int i = 0; i < 3; i++)\n    {\n        curr_coord -= fetch_tangent(curr_coord);\n        col += fetch(curr_coord);\n    }\n    col /= 7.;\n    return col;\n}\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    frag_col = vec4(\n        view_transform(render(frag_coord)),\n        1\n    );\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "/*___________ math & integer utils ____________*/\n\nconst float PI = 3.141592653589793238462643383;\nconst float TAU = 6.283185307179586476925286767;\nconst float PI_OVER_2 = 1.570796326794896619231321692;\nconst float INV_PI = .318309886183790671537767527;\nconst float INV_TAU = .159154943091895335768883763;\n\n#define FUNC_WRAP(T) \\\nT wrap(T v, float start, float end) \\\n{ \\\n    return start + mod(v - start, end - start); \\\n}\n\n#define FUNC_REMAP(T) \\\nT remap(T v, float inp_start, float inp_end, float out_start, float out_end) \\\n{ \\\n    return out_start \\\n        + ((out_end - out_start) / (inp_end - inp_start)) * (v - inp_start); \\\n}\n\n#define FUNC_REMAP_CLAMP(T) \\\nT remap_clamp( \\\n    T v, \\\n    float inp_start, \\\n    float inp_end, \\\n    float out_start, \\\n    float out_end \\\n) \\\n{ \\\n    T t = clamp((v - inp_start) / (inp_end - inp_start), 0., 1.); \\\n    return out_start + t * (out_end - out_start); \\\n}\n\n#define FUNC_REMAP01(T) \\\nT remap01(T v, float inp_start, float inp_end) \\\n{ \\\n    return clamp((v - inp_start) / (inp_end - inp_start), 0., 1.); \\\n}\n\n#define FUNC_LENGTH_SQ(T) \\\nfloat length_sq(T v) \\\n{ \\\n    return dot(v, v); \\\n}\n\n#define FUNC_DIST_SQ(T) \\\nfloat dist_sq(T a, T b) \\\n{ \\\n    a -= b; \\\n    return dot(a, a); \\\n}\n\nFUNC_WRAP(float)\nFUNC_WRAP(vec2)\nFUNC_WRAP(vec3)\nFUNC_WRAP(vec4)\n\nFUNC_REMAP(float)\nFUNC_REMAP(vec2)\nFUNC_REMAP(vec3)\nFUNC_REMAP(vec4)\n\nFUNC_REMAP_CLAMP(float)\nFUNC_REMAP_CLAMP(vec2)\nFUNC_REMAP_CLAMP(vec3)\nFUNC_REMAP_CLAMP(vec4)\n\nFUNC_REMAP01(float)\nFUNC_REMAP01(vec2)\nFUNC_REMAP01(vec3)\nFUNC_REMAP01(vec4)\n\nFUNC_LENGTH_SQ(vec2)\nFUNC_LENGTH_SQ(vec3)\nFUNC_LENGTH_SQ(vec4)\n\nFUNC_DIST_SQ(vec2)\nFUNC_DIST_SQ(vec3)\nFUNC_DIST_SQ(vec4)\n\nfloat chebyshev_dist(vec2 a, vec2 b)\n{\n    return max(abs(a.x - b.x), abs(a.y - b.y));\n}\n\nfloat chebyshev_dist(vec3 a, vec3 b)\n{\n    return max(\n        max(abs(a.x - b.x), abs(a.y - b.y)),\n        abs(a.z - b.z)\n    );\n}\n\nfloat chebyshev_dist(vec4 a, vec4 b)\n{\n    return max(\n        max(\n            max(abs(a.x - b.x), abs(a.y - b.y)),\n            abs(a.z - b.z)\n        ),\n        abs(a.w - b.w)\n    );\n}\n\n#define idiv_ceil(a, b) ((a + b - 1) / b)\n\nint iabs(int v)\n{\n    if (v < 0)\n    {\n        return -v;\n    }\n    return v;\n}\n\nint imin(int a, int b)\n{\n    if (a < b)\n    {\n        return a;\n    }\n    return b;\n}\n\nint imax(int a, int b)\n{\n    if (a > b)\n    {\n        return a;\n    }\n    return b;\n}\n\nint iclamp(int v, int start, int end)\n{\n    if (v < start)\n    {\n        v = start;\n    }\n    if (v > end)\n    {\n        v = end;\n    }\n    return v;\n}\n\nfloat min_component(vec2 v)\n{\n    return min(v.x, v.y);\n}\n\nfloat min_component(vec3 v)\n{\n    return min(min(v.x, v.y), v.z);\n}\n\nfloat min_component(vec4 v)\n{\n    return min(min(min(v.x, v.y), v.z), v.w);\n}\n\nfloat max_component(vec2 v)\n{\n    return max(v.x, v.y);\n}\n\nfloat max_component(vec3 v)\n{\n    return max(max(v.x, v.y), v.z);\n}\n\nfloat max_component(vec4 v)\n{\n    return max(max(max(v.x, v.y), v.z), v.w);\n}\n\nint min_component(ivec2 v)\n{\n    return imin(v.x, v.y);\n}\n\nint min_component(ivec3 v)\n{\n    return imin(imin(v.x, v.y), v.z);\n}\n\nint min_component(ivec4 v)\n{\n    return imin(imin(imin(v.x, v.y), v.z), v.w);\n}\n\nint max_component(ivec2 v)\n{\n    return imax(v.x, v.y);\n}\n\nint max_component(ivec3 v)\n{\n    return imax(imax(v.x, v.y), v.z);\n}\n\nint max_component(ivec4 v)\n{\n    return imax(imax(imax(v.x, v.y), v.z), v.w);\n}\n\nfloat bilinear(\n    float val_bl,\n    float val_tl,\n    float val_tr,\n    float val_br,\n    vec2 offs\n)\n{\n    return mix(\n        mix(val_bl, val_br, offs.x),\n        mix(val_tl, val_tr, offs.x),\n        offs.y\n    );\n}\n\n// credits to AHSEN (https://www.shadertoy.com/user/01000001)\n// https://www.desmos.com/calculator/5d6ph151vi interactive :D\nfloat cubic_interp(float a, float b, float c, float d, float t)\n{\n    float one = t - 1.;\n    float two = t - 2.;\n    float three = t - 3.;\n    return (\n        (-one * two * three * a)\n        + (t * one * two * d)\n        + (3. * t * two * three * b)\n        - (3. * t * one * three * c)\n    ) / 6.;\n}\n\nfloat dist_along_line(vec2 p, vec2 line_start, vec2 line_end)\n{\n    vec2 dir = line_end - line_start;\n    \n    // normalize\n    float len_sqr = dot(dir, dir);\n    if (len_sqr < .0001)\n        return 1e9;\n    dir /= sqrt(len_sqr);\n    \n    return dot(\n        dir,\n        p - line_start\n    );\n}\n\nfloat relative_dist_along_line(vec2 p, vec2 line_start, vec2 line_end)\n{\n    vec2 dir = line_end - line_start;\n    return dot(\n        dir,\n        p - line_start\n    );\n}\n\n// |a| * |b| * sin(theta)\nfloat cross2d(vec2 a, vec2 b)\n{\n    return a.x * b.y - a.y * b.x;\n}\n\n// angle from 0 to TAU\nfloat get_angle(vec2 p)\n{\n    float a = atan(p.y, p.x);\n    if (a < 0.)\n    {\n        return a + TAU;\n    }\n    return a;\n}\n\nmat2 rotate_2d(float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(\n        c, s,\n        -s, c\n    );\n}\n\nvec2 perpendicular(vec2 v)\n{\n    return vec2(-v.y, v.x);\n}\n\n// s.x=theta\n// s.y=phi\n// (there's no r)\nvec3 spherical_to_cartesian(vec2 s)\n{\n    float sin_theta = sin(s.x);\n    return vec3(\n        sin_theta * cos(s.y),\n        sin_theta * sin(s.y),\n        cos(s.x)\n    );\n}\n\n// s.x=r\n// s.y=theta\n// s.z=phi\nvec3 spherical_to_cartesian(vec3 s)\n{\n    float sin_theta = sin(s.y);\n    return s.x * vec3(\n        sin_theta * cos(s.z),\n        sin_theta * sin(s.z),\n        cos(s.y)\n    );\n}\n\nvec2 screen_to_uv01(vec2 coord, vec2 res)\n{\n    return coord / res;\n}\n\nvec2 screen_to_uv_horizontal(vec2 coord, vec2 res)\n{\n    return (2. * coord - res) / res.x;\n}\n\nvec2 screen_to_uv_vertical(vec2 coord, vec2 res)\n{\n    return (2. * coord - res) / res.y;\n}\n\nvec2 screen_to_uv_fit(vec2 coord, vec2 res)\n{\n    return (2. * coord - res) / min_component(res);\n}\n\nvec2 screen_to_uv_fill(vec2 coord, vec2 res)\n{\n    return (2. * coord - res) / max_component(res);\n}\n\n// * idx starts at 1\nfloat halton(int base, int idx)\n{\n    float result = 0.;\n    float digit_weight = 1.;\n    while (idx > 0)\n    {\n        digit_weight /= float(base);\n        result += float(idx % base) * digit_weight;\n        idx /= base;\n    }\n    return result;\n}\n\n// * idx starts at 1\nvec2 halton_2d(int idx)\n{\n    return vec2(halton(2, idx), halton(3, idx));\n}\n\n// * idx starts at 1\nvec3 halton_3d(int idx)\n{\n    return vec3(halton(2, idx), halton(3, idx), halton(5, idx));\n}\n\n// * idx starts at 1\nvec4 halton_4d(int idx)\n{\n    return vec4(\n        halton(2, idx),\n        halton(3, idx),\n        halton(5, idx),\n        halton(7, idx)\n    );\n}\n",
     "name": "Common",
     "description": "",
     "type": "common"
    },
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "// this buffer renders some basic 2D shapes with no AA\n\nvec3 render(vec2 coord)\n{\n    vec2 uv = screen_to_uv_fit(coord, iResolution.xy);\n    \n    vec3 col = vec3(.015, .02, .04);\n    if (abs(dot(uv, normalize(vec2(-.06, 1))) - .6) < .01)\n    {\n        col = vec3(.3, .5, .7);\n    }\n    if (abs(sin(uv.x * TAU) - 32. * (uv.y - .1)) < .5)\n    {\n        col = vec3(.8, .6, .2);\n    }\n    \n    if (abs(dot(uv, uv) - .2) < .03)\n    {\n        col = vec3(.3, .6, .1);\n    }\n    if (max(abs(uv.x), abs(uv.y + .15)) < .15)\n    {\n        col = vec3(.8);\n    }\n    \n    return col;\n}\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    vec3 col = render(frag_coord);\n    frag_col = vec4(col, 1);\n}\n",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "XsXGR8",
       "channel": 0
      }
     ],
     "code": "// this buffer stores a tangent vector for every pixel\n// (calculated with a custom method)\n\nfloat lum(vec3 col)\n{\n    return dot(col, vec3(.3, .5, .2));\n}\n\nvec3 fetch(vec2 coord)\n{\n    return texture(iChannel0, coord / iResolution.xy).rgb;\n}\n\nvec2 fetch_gradient(vec2 coord)\n{\n    return vec2(\n        lum(fetch(coord + vec2(.5, 0))) - lum(fetch(coord + vec2(-.5, 0))),\n        lum(fetch(coord + vec2(0, .5))) - lum(fetch(coord + vec2(0, -.5)))\n    );\n}\n\nvec2 figure_out_tangent(vec2 coord)\n{\n    float lum_center = lum(fetch(coord));\n    float min_lum_diff = 1e9;\n    vec2 dir_with_lowest_lum_diff = vec2(1, 0);\n    \n    for (float angle = 0.; angle < 360.; angle += 10.)\n    {\n        float rad = radians(angle);\n        vec2 dir = vec2(cos(rad), sin(rad));\n        \n        float lum_moved = lum(fetch(coord + dir));\n        float lum_diff = abs(lum_moved - lum_center);\n        if (lum_diff < min_lum_diff)\n        {\n            min_lum_diff = lum_diff;\n            dir_with_lowest_lum_diff = dir;\n        }\n    }\n    \n    return dir_with_lowest_lum_diff;\n}\n\nvec2 figure_out_tangent2(vec2 coord)\n{\n    float lum_center = lum(fetch(coord));\n    float min_lum_diff = 1e9;\n    vec2 dir_with_lowest_lum_diff = vec2(1, 0);\n    \n    vec2 dir = vec2(1, 0);\n    float lum_moved = lum(fetch(coord + dir));\n    float lum_diff = abs(lum_moved - lum_center);\n    if (lum_diff < min_lum_diff)\n    {\n        min_lum_diff = lum_diff;\n        dir_with_lowest_lum_diff = dir;\n    }\n    \n    dir = vec2(1, 1);\n    lum_moved = lum(fetch(coord + dir));\n    lum_diff = abs(lum_moved - lum_center);\n    if (lum_diff < min_lum_diff)\n    {\n        min_lum_diff = lum_diff;\n        dir_with_lowest_lum_diff = dir;\n    }\n    \n    dir = vec2(0, 1);\n    lum_moved = lum(fetch(coord + dir));\n    lum_diff = abs(lum_moved - lum_center);\n    if (lum_diff < min_lum_diff)\n    {\n        min_lum_diff = lum_diff;\n        dir_with_lowest_lum_diff = dir;\n    }\n    \n    dir = vec2(-1, 1);\n    lum_moved = lum(fetch(coord + dir));\n    lum_diff = abs(lum_moved - lum_center);\n    if (lum_diff < min_lum_diff)\n    {\n        min_lum_diff = lum_diff;\n        dir_with_lowest_lum_diff = dir;\n    }\n    \n    dir = vec2(-1, 0);\n    lum_moved = lum(fetch(coord + dir));\n    lum_diff = abs(lum_moved - lum_center);\n    if (lum_diff < min_lum_diff)\n    {\n        min_lum_diff = lum_diff;\n        dir_with_lowest_lum_diff = dir;\n    }\n    \n    dir = vec2(-1, -1);\n    lum_moved = lum(fetch(coord + dir));\n    lum_diff = abs(lum_moved - lum_center);\n    if (lum_diff < min_lum_diff)\n    {\n        min_lum_diff = lum_diff;\n        dir_with_lowest_lum_diff = dir;\n    }\n    \n    dir = vec2(0, -1);\n    lum_moved = lum(fetch(coord + dir));\n    lum_diff = abs(lum_moved - lum_center);\n    if (lum_diff < min_lum_diff)\n    {\n        min_lum_diff = lum_diff;\n        dir_with_lowest_lum_diff = dir;\n    }\n    \n    dir = vec2(1, -1);\n    lum_moved = lum(fetch(coord + dir));\n    lum_diff = abs(lum_moved - lum_center);\n    if (lum_diff < min_lum_diff)\n    {\n        min_lum_diff = lum_diff;\n        dir_with_lowest_lum_diff = dir;\n    }\n    \n    return dir_with_lowest_lum_diff;\n}\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    vec2 tangent = figure_out_tangent2(frag_coord);\n    tangent *= step(.05, length(fetch_gradient(frag_coord)));\n    \n    frag_col = vec4(tangent, 0, 0);\n}\n",
     "name": "Buffer B",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "MfjBDV",
    "date": "1725542638",
    "viewed": 94,
    "name": "Pretty Colormap (-1, +1)",
    "description": "See the Desmos graphs, play with v",
    "likes": 5,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "colormap",
     "exponential"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// https://www.desmos.com/calculator/n4mfhffj1n\nfloat colormap_expf(float x, float v)\n{\n    if (abs(v) < .0001) v = .0001;\n    float p = pow(2., v);\n    return (1. - pow(p, -x)) / (1. - 1. / p);\n}\n\nvec3 colormap(float x)\n{\n    float t = .18 * abs(x);\n    if (x < 0.)\n    {\n        x = -x;\n        t = -.37 - .14 * x;\n    }\n    \n    // https://www.desmos.com/calculator/sdqk904uu9\n    vec3 tone = 8. * vec3(\n        cos(6.283 * t),\n        cos(6.283 * (t - .3333)),\n        cos(6.283 * (t - .6667))\n    );\n    \n    x = smoothstep(0., 1., x);\n    vec3 c = vec3(\n        colormap_expf(x, tone.r),\n        colormap_expf(x, tone.g),\n        colormap_expf(x, tone.b)\n    );\n    \n    c = mix(c, c + vec3(.03, 0, .03), smoothstep(.1, 0., x));\n    \n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = colormap(uv.x * 2. - 1.);\n    col = pow(col, vec3(.45));\n    fragColor = vec4(col,1.0);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "M32cWV",
    "date": "0",
    "viewed": 0,
    "name": "Glass UI Card",
    "description": "a",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "2d",
     "blur",
     "glass",
     "ui"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dfGRn",
       "filepath": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg",
       "type": "texture",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// https://iquilezles.org/articles/distfunctions2d/\nfloat sd_rounded_box( in vec2 p, in vec2 b, in vec4 r )\n{\n    r.xy = (p.x>0.0)?r.xy : r.zw;\n    r.x  = (p.y>0.0)?r.x  : r.y;\n    vec2 q = abs(p)-b+r.x;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r.x;\n}\n\nvec3 render(vec2 coord)\n{\n    vec2 uv = screen_to_uv_fit(coord, iResolution.xy);\n    float px2uv = 2. / min_component(iResolution.xy);\n    float half_px = 2. / min_component(iResolution.xy);\n\n    float sd = sd_rounded_box(uv, vec2(.9, .55), vec4(.16));\n    float inside = remap01(sd, half_px, -half_px);\n    \n    float lod = 3.5 * inside;\n    vec3 col = pow(texture(iChannel0, coord / iResolution.xy, lod).rgb, vec3(2.2));\n    \n    col = mix(col, vec3(1), .05 * inside);\n    \n    return col;\n}\n\nvec3 view_transform(vec3 col)\n{\n    col = max(col, 0.);\n    col = pow(col, vec3(1. / 2.2));\n    return clamp(col, 0., 1.);\n}\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    // render\n    vec3 col = render(frag_coord);\n\n    // view transform\n    col = view_transform(col);\n\n    // output\n    frag_col = vec4(col, 1);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "#define SHADERTOY 1\n\nprecision highp float;\nprecision highp int;\n\n\n\n/*___________ math & integer utils ____________*/\n\nconst float PI = 3.141592653589793238462643383;\nconst float TAU = 6.283185307179586476925286767;\nconst float PI_OVER_2 = 1.570796326794896619231321692;\nconst float INV_PI = .318309886183790671537767527;\nconst float INV_TAU = .159154943091895335768883763;\n\n#define FUNC_WRAP(T) \\\nT wrap(T v, float start, float end) \\\n{ \\\n    return start + mod(v - start, end - start); \\\n}\n\n#define FUNC_REMAP(T) \\\nT remap(T v, float inp_start, float inp_end, float out_start, float out_end) \\\n{ \\\n    return out_start \\\n        + ((out_end - out_start) / (inp_end - inp_start)) * (v - inp_start); \\\n}\n\n#define FUNC_REMAP_CLAMP(T) \\\nT remap_clamp( \\\n    T v, \\\n    float inp_start, \\\n    float inp_end, \\\n    float out_start, \\\n    float out_end \\\n) \\\n{ \\\n    T t = clamp((v - inp_start) / (inp_end - inp_start), 0., 1.); \\\n    return out_start + t * (out_end - out_start); \\\n}\n\n#define FUNC_REMAP01(T) \\\nT remap01(T v, float inp_start, float inp_end) \\\n{ \\\n    return clamp((v - inp_start) / (inp_end - inp_start), 0., 1.); \\\n}\n\n#define FUNC_LENGTH_SQ(T) \\\nfloat length_sq(T v) \\\n{ \\\n    return dot(v, v); \\\n}\n\n#define FUNC_DIST_SQ(T) \\\nfloat dist_sq(T a, T b) \\\n{ \\\n    a -= b; \\\n    return dot(a, a); \\\n}\n\nFUNC_WRAP(float)\nFUNC_WRAP(vec2)\nFUNC_WRAP(vec3)\nFUNC_WRAP(vec4)\n\nFUNC_REMAP(float)\nFUNC_REMAP(vec2)\nFUNC_REMAP(vec3)\nFUNC_REMAP(vec4)\n\nFUNC_REMAP_CLAMP(float)\nFUNC_REMAP_CLAMP(vec2)\nFUNC_REMAP_CLAMP(vec3)\nFUNC_REMAP_CLAMP(vec4)\n\nFUNC_REMAP01(float)\nFUNC_REMAP01(vec2)\nFUNC_REMAP01(vec3)\nFUNC_REMAP01(vec4)\n\nFUNC_LENGTH_SQ(vec2)\nFUNC_LENGTH_SQ(vec3)\nFUNC_LENGTH_SQ(vec4)\n\nFUNC_DIST_SQ(vec2)\nFUNC_DIST_SQ(vec3)\nFUNC_DIST_SQ(vec4)\n\nfloat chebyshev_dist(vec2 a, vec2 b)\n{\n    return max(abs(a.x - b.x), abs(a.y - b.y));\n}\n\nfloat chebyshev_dist(vec3 a, vec3 b)\n{\n    return max(\n        max(abs(a.x - b.x), abs(a.y - b.y)),\n        abs(a.z - b.z)\n    );\n}\n\nfloat chebyshev_dist(vec4 a, vec4 b)\n{\n    return max(\n        max(\n            max(abs(a.x - b.x), abs(a.y - b.y)),\n            abs(a.z - b.z)\n        ),\n        abs(a.w - b.w)\n    );\n}\n\n#define idiv_ceil(a, b) ((a + b - 1) / b)\n\nint iabs(int v)\n{\n    if (v < 0)\n    {\n        return -v;\n    }\n    return v;\n}\n\nint imin(int a, int b)\n{\n    if (a < b)\n    {\n        return a;\n    }\n    return b;\n}\n\nint imax(int a, int b)\n{\n    if (a > b)\n    {\n        return a;\n    }\n    return b;\n}\n\nint iclamp(int v, int start, int end)\n{\n    if (v < start)\n    {\n        v = start;\n    }\n    if (v > end)\n    {\n        v = end;\n    }\n    return v;\n}\n\nfloat min_component(vec2 v)\n{\n    return min(v.x, v.y);\n}\n\nfloat min_component(vec3 v)\n{\n    return min(min(v.x, v.y), v.z);\n}\n\nfloat min_component(vec4 v)\n{\n    return min(min(min(v.x, v.y), v.z), v.w);\n}\n\nfloat max_component(vec2 v)\n{\n    return max(v.x, v.y);\n}\n\nfloat max_component(vec3 v)\n{\n    return max(max(v.x, v.y), v.z);\n}\n\nfloat max_component(vec4 v)\n{\n    return max(max(max(v.x, v.y), v.z), v.w);\n}\n\nint min_component(ivec2 v)\n{\n    return imin(v.x, v.y);\n}\n\nint min_component(ivec3 v)\n{\n    return imin(imin(v.x, v.y), v.z);\n}\n\nint min_component(ivec4 v)\n{\n    return imin(imin(imin(v.x, v.y), v.z), v.w);\n}\n\nint max_component(ivec2 v)\n{\n    return imax(v.x, v.y);\n}\n\nint max_component(ivec3 v)\n{\n    return imax(imax(v.x, v.y), v.z);\n}\n\nint max_component(ivec4 v)\n{\n    return imax(imax(imax(v.x, v.y), v.z), v.w);\n}\n\nfloat bilinear(\n    float val_bl,\n    float val_tl,\n    float val_tr,\n    float val_br,\n    vec2 offs\n)\n{\n    return mix(\n        mix(val_bl, val_br, offs.x),\n        mix(val_tl, val_tr, offs.x),\n        offs.y\n    );\n}\n\n// credits to AHSEN (https://www.shadertoy.com/user/01000001)\n// https://www.desmos.com/calculator/5d6ph151vi interactive :D\nfloat cubic_interp(float a, float b, float c, float d, float t)\n{\n    float one = t - 1.;\n    float two = t - 2.;\n    float three = t - 3.;\n    return (\n        (-one * two * three * a)\n        + (t * one * two * d)\n        + (3. * t * two * three * b)\n        - (3. * t * one * three * c)\n    ) / 6.;\n}\n\nfloat dist_along_line(vec2 p, vec2 line_start, vec2 line_end)\n{\n    vec2 dir = line_end - line_start;\n    \n    // normalize\n    float len_sqr = dot(dir, dir);\n    if (len_sqr < .0001)\n        return 1e9;\n    dir /= sqrt(len_sqr);\n    \n    return dot(\n        dir,\n        p - line_start\n    );\n}\n\nfloat relative_dist_along_line(vec2 p, vec2 line_start, vec2 line_end)\n{\n    vec2 dir = line_end - line_start;\n    return dot(\n        dir,\n        p - line_start\n    );\n}\n\n// |a| * |b| * sin(theta)\nfloat cross2d(vec2 a, vec2 b)\n{\n    return a.x * b.y - a.y * b.x;\n}\n\n// references for barycentric coordinates\n// https://www.desmos.com/calculator/8g8xjejuox\n// https://www.shadertoy.com/view/mdjBWK\n\nvec3 cartesian_to_barycentric(\n    vec2 p,\n    vec2 v0,\n    vec2 v1,\n    vec2 v2,\n    bool clamp_,\n    out bool p_is_outside\n)\n{\n    vec3 b = vec3(\n        cross2d(v1 - p, v2 - p),\n        cross2d(v2 - p, v0 - p),\n        cross2d(v0 - p, v1 - p)\n    ) / cross2d(v1 - v0, v2 - v0);\n    p_is_outside = min(min(b.x, b.y), b.z) < 0.;\n    if (clamp_)\n    {\n        b = max(b, 0.);\n        b /= (b.x + b.y + b.z);\n    }\n    return b;\n}\n\nvec3 cartesian_to_barycentric(\n    vec3 p,\n    vec3 v0,\n    vec3 v1,\n    vec3 v2,\n    bool clamp_,\n    out bool p_is_outside\n)\n{\n    vec3 b = vec3(\n        length(cross(v1 - p, v2 - p)),\n        length(cross(v2 - p, v0 - p)),\n        length(cross(v0 - p, v1 - p))\n    ) / length(cross(v1 - v0, v2 - v0));\n    p_is_outside = min(min(b.x, b.y), b.z) < 0.;\n    if (clamp_)\n    {\n        b = max(b, 0.);\n        b /= (b.x + b.y + b.z);\n    }\n    return b;\n}\n\nfloat barycentric_interpolate(vec3 b, float v0, float v1, float v2)\n{\n    return dot(b, vec3(v0, v1, v2));\n}\n\nvec2 barycentric_interpolate(vec3 b, vec2 v0, vec2 v1, vec2 v2)\n{\n    return b.x * v0 + b.y * v1 + b.z * v2;\n}\n\nvec3 barycentric_interpolate(vec3 b, vec3 v0, vec3 v1, vec3 v2)\n{\n    return b.x * v0 + b.y * v1 + b.z * v2;\n}\n\nvec4 barycentric_interpolate(vec3 b, vec4 v0, vec4 v1, vec4 v2)\n{\n    return b.x * v0 + b.y * v1 + b.z * v2;\n}\n\nfloat barycentric_interpolate(vec2 b, float v0, float v1, float v2)\n{\n    return barycentric_interpolate(\n        vec3(b.x, b.y, 1. - b.x - b.y),\n        v0, v1, v2\n    );\n}\n\nvec2 barycentric_interpolate(vec2 b, vec2 v0, vec2 v1, vec2 v2)\n{\n    return barycentric_interpolate(\n        vec3(b.x, b.y, 1. - b.x - b.y),\n        v0, v1, v2\n    );\n}\n\nvec3 barycentric_interpolate(vec2 b, vec3 v0, vec3 v1, vec3 v2)\n{\n    return barycentric_interpolate(\n        vec3(b.x, b.y, 1. - b.x - b.y),\n        v0, v1, v2\n    );\n}\n\nvec4 barycentric_interpolate(vec2 b, vec4 v0, vec4 v1, vec4 v2)\n{\n    return barycentric_interpolate(\n        vec3(b.x, b.y, 1. - b.x - b.y),\n        v0, v1, v2\n    );\n}\n\n// angle from 0 to TAU\nfloat get_angle(vec2 p)\n{\n    float a = atan(p.y, p.x);\n    if (a < 0.)\n    {\n        return a + TAU;\n    }\n    return a;\n}\n\nmat2 rotate_2d(float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(\n        c, s,\n        -s, c\n    );\n}\n\nvec2 perpendicular(vec2 v)\n{\n    return vec2(-v.y, v.x);\n}\n\n// s.x=theta\n// s.y=phi\n// (there's no r)\nvec3 spherical_to_cartesian(vec2 s)\n{\n    float sin_theta = sin(s.x);\n    return vec3(\n        sin_theta * cos(s.y),\n        sin_theta * sin(s.y),\n        cos(s.x)\n    );\n}\n\n// s.x=r\n// s.y=theta\n// s.z=phi\nvec3 spherical_to_cartesian(vec3 s)\n{\n    float sin_theta = sin(s.y);\n    return s.x * vec3(\n        sin_theta * cos(s.z),\n        sin_theta * sin(s.z),\n        cos(s.y)\n    );\n}\n\nvec2 screen_to_uv01(vec2 coord, vec2 res)\n{\n    return coord / res;\n}\n\nvec2 screen_to_uv_horizontal(vec2 coord, vec2 res)\n{\n    return (2. * coord - res) / res.x;\n}\n\nvec2 screen_to_uv_vertical(vec2 coord, vec2 res)\n{\n    return (2. * coord - res) / res.y;\n}\n\nvec2 screen_to_uv_fit(vec2 coord, vec2 res)\n{\n    return (2. * coord - res) / min_component(res);\n}\n\nvec2 screen_to_uv_fill(vec2 coord, vec2 res)\n{\n    return (2. * coord - res) / max_component(res);\n}\n\n// * idx starts at 1\nfloat halton(int base, int idx)\n{\n    float result = 0.;\n    float digit_weight = 1.;\n    while (idx > 0)\n    {\n        digit_weight /= float(base);\n        result += float(idx % base) * digit_weight;\n        idx /= base;\n    }\n    return result;\n}\n\n// * idx starts at 1\nvec2 halton_2d(int idx)\n{\n    return vec2(halton(2, idx), halton(3, idx));\n}\n\n// * idx starts at 1\nvec3 halton_3d(int idx)\n{\n    return vec3(halton(2, idx), halton(3, idx), halton(5, idx));\n}\n\n// * idx starts at 1\nvec4 halton_4d(int idx)\n{\n    return vec4(\n        halton(2, idx),\n        halton(3, idx),\n        halton(5, idx),\n        halton(7, idx)\n    );\n}\n\n// for some reason we can't use intBitsToFloat() or floatBitsToInt() to store\n// integers below this value in a buffer.\nconst int BUFFER_MIN_INTEGER = 8388608;\n\n// * x must not be higher than 4,286,578,688 (see BUFFER_MIN_INTEGER above)\n// * for your sanity, don't use negative values\nfloat encode_int_for_buffer(int v)\n{\n    return intBitsToFloat(v + BUFFER_MIN_INTEGER);\n}\n\nint decode_int_from_buffer(float v)\n{\n    return floatBitsToInt(v) - BUFFER_MIN_INTEGER;\n}\n\n// pack two 16-bit integers in a single 32-bit integer\n// * both arguments should be in the 0-65535 range\n// * a must be less than 65279 (see the functions above)\nint pack_i16(int a, int b)\n{\n    return (a << 16) | b;\n}\n\n// unpack two 16-bit integers from a single 32-bit integer\nvoid unpack_i16(int v, out int a, out int b)\n{\n    a = (v >> 16) & 65535;\n    b = v & 65535;\n}\n\n// unpack the first 16-bit integer from a 32-bit integer\nint unpack_i16_a(int v)\n{\n    return (v >> 16) & 65535;\n}\n\n// unpack the second 16-bit integer from a 32-bit integer\nint unpack_i16_b(int v)\n{\n    return v & 65535;\n}\n\nbool icoord_in_bounds(ivec2 icoord, ivec2 ires)\n{\n    return\n        icoord.x >= 0 &&\n        icoord.y >= 0 &&\n        icoord.x < ires.x &&\n        icoord.y < ires.y;\n}\n\nbool icoord_in_bounds(ivec3 icoord, ivec3 ires)\n{\n    return\n        icoord.x >= 0 &&\n        icoord.y >= 0 &&\n        icoord.z >= 0 &&\n        icoord.x < ires.x &&\n        icoord.y < ires.y &&\n        icoord.z < ires.z;\n}\n\nint icoord_to_idx(ivec2 icoord, ivec2 ires)\n{\n    return icoord.x + (icoord.y * ires.x);\n}\n\nint icoord_to_idx(ivec3 icoord, ivec3 ires)\n{\n    return icoord.x + (icoord.y * ires.x) + (icoord.z * ires.x * ires.y);\n}\n\nivec2 idx_to_icoord(int idx, ivec2 ires)\n{\n    return ivec2(idx % ires.x, idx / ires.x);\n}\n\nivec3 idx_to_icoord(int idx, ivec3 ires)\n{\n    return ivec3(\n        idx % ires.x,\n        (idx % (ires.x * ires.y)) / ires.x,\n        idx / (ires.x * ires.y)\n    );\n}\n\n// https://www.desmos.com/calculator/kfe07basy9\n\nint compress_float_to_int_linear(float f, float min_f, float max_f, int max_i)\n{\n    return int(floor(\n        float(max_i) * remap01(f, min_f, max_f)\n    ));\n}\n\nfloat decompress_float_from_int_linear(\n    int i,\n    int max_i,\n    float min_f,\n    float max_f\n)\n{\n    return remap_clamp(\n        float(i) / float(max_i),\n        0., 1.,\n        min_f, max_f\n    );\n}\n\nint compress_float_to_int_log(\n    float f,\n    float log2_zero_offset,\n    float max_log2_f,\n    int max_i\n)\n{\n    f = max(0., f);\n    f += pow(2., log2_zero_offset);\n    return int(floor(\n        float(max_i) * remap01(log2(f), log2_zero_offset, max_log2_f)\n    ));\n}\n\nfloat decompress_float_from_int_log(\n    int i,\n    int max_i,\n    float log2_zero_offset,\n    float max_log2_f\n)\n{\n    return pow(2., remap_clamp(\n        float(i) / float(max_i),\n        0., 1.,\n        log2_zero_offset, max_log2_f\n    )) - pow(2., log2_zero_offset);\n}\n\n\n\n/*_______ pseudo-random number generator ______*/\n// source: https://www.shadertoy.com/view/WdSSRt\n// (heavily modified)\n\n/* usage example:\n    void mainImage(out vec4 frag_col, in vec2 frag_coord)\n    {\n        // initialize PRNG\n        prng_init(vec3(frag_coord / iResolution.y, iTime));\n    \n        // use the function\n        float a = random();\n        vec3 b = vec3(random(), random(), random());\n        \n        ...\n    }\n*/\n\nuint prng_state[2];\n\nuint prng_rot(uint x, int k)\n{\n    return (x << k) | (x >> (32 - k));\n}\n\n// random uint from 0 to 2^32-1\nuint randomui()\n{\n    uint s0 = prng_state[0];\n    uint s1 = prng_state[1];\n    uint result = prng_rot(s0 * 2654435771u, 5) * 5u;\n    s1 ^= s0;\n    prng_state[0] = prng_rot(s0, 26) ^ s1 ^ (s1 << 9);\n    prng_state[1] = prng_rot(s1, 13);\n    return result;\n}\n\n// random int from 0 to 2^31-1\nint randomi()\n{\n    return int(randomui() % 0x7FFFFFFFu);\n}\n\n// random float from 0 to 1\nfloat random()\n{\n    return float(randomui()) / float(0xffffffffu);\n}\n\n// generate two normally distributed random numbers using the\n// Box-Muller transform\n// https://www.baeldung.com/cs/uniform-to-normal-distribution\nvec2 random_gauss()\n{\n    float u1 = random();\n    float u2 = random() * TAU;\n    float temp = sqrt(-2. * log(u1));\n    return temp * vec2(cos(u2), sin(u2));\n    \n    // unoptimized version\n    //float u1 = random();\n    //float u2 = random();\n    //return vec2(cos(TAU * u2), sin(TAU * u2)) * sqrt(-2. * log(u1));\n}\n\nvec2 random_on_circle()\n{\n    vec2 v = vec2(1);\n    float lensqr;\n\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec2(2. * random() - 1., 2. * random() - 1.);\n        lensqr = dot(v, v);\n        if (lensqr == 0.)\n            i--;\n        else if (lensqr <= 1.)\n            break;\n    }\n    return v / sqrt(lensqr);\n}\n\nvec3 random_on_sphere()\n{\n    vec3 v = vec3(1);\n    float lensqr;\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec3(2. * random() - 1., 2. * random() - 1., 2. * random() - 1.);\n        lensqr = dot(v, v);\n        if (lensqr == 0.)\n            i--;\n        else if (lensqr <= 1.)\n            break;\n    }\n    return v / sqrt(lensqr);\n}\n\nvec2 random_in_circle()\n{\n    vec2 v = vec2(1);\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec2(2. * random() - 1., 2. * random() - 1.);\n        if (dot(v, v) <= 1.)\n            return v;\n    }\n    return v;\n}\n\nvec3 random_in_sphere()\n{\n    vec3 v = vec3(1);\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec3(2. * random() - 1., 2. * random() - 1., 2. * random() - 1.);\n        if (dot(v, v) <= 1.)\n            return v;\n    }\n    return v;\n}\n\nvec3 random_on_hemisphere(vec3 normal)\n{\n    vec3 v = random_on_sphere();\n    return v * sign(dot(v, normal));\n}\n\nvec3 random_in_hemisphere(vec3 normal)\n{\n    vec3 v = random_in_sphere();\n    return v * sign(dot(v, normal));\n}\n\n// initialize with uvec2\nvoid prng_init(uvec2 seed)\n{\n    seed += uvec2(1317, 944573125);\n    seed *= 464973573u;\n    prng_state[0] = seed.x;\n    prng_state[1] = seed.y;\n    randomi();\n}\n\n// initialize with uint\nvoid prng_init(uint seed)\n{\n    prng_init(uvec2(seed, 1));\n}\n\n// initialize with vec3\nvoid prng_init(vec3 seed)\n{\n    seed += 3.49276101561702;\n    seed.xy *= (seed.z + 10.258);\n    prng_state[0] = floatBitsToUint(seed.x);\n    prng_state[1] = floatBitsToUint(seed.y);\n    randomui();\n}\n\n// initialize with vec2\nvoid prng_init(vec2 seed)\n{\n    prng_init(vec3(seed, 1));\n}\n\n// initialize with float\nvoid prng_init(float seed)\n{\n    prng_init(vec3(seed, 1, 1));\n}\n\n\n\n/*__________________ keyboard _________________*/\n\n// put this code in every buffer that uses the keyboard input:\n/*\n#if SHADERTOY\n// iChannelX must be set to Keyboard in Shadertoy\n#define SHADERTOY_KEYBOARD_CH iChannelX\n#else\n#iKeyboard\n#endif\n\ndefine_keyboard_utils\n*/\n\n#if SHADERTOY\n\n#define define_keyboard_utils \\\n \\\n/* https://github.com/stevensona/shader-toy/blob/c4833b972649d78a2ee090af60b79a3907e8e091/src/extensions/keyboard/keyboard_shader_extension.ts#L11 */ \\\nconst int \\\n    Key_Backspace = 8, Key_Tab = 9, Key_Enter = 13, Key_Shift = 16, \\\n    Key_Ctrl = 17, Key_Alt = 18, Key_Pause = 19, Key_Caps = 20, \\\n    Key_Escape = 27, Key_PageUp = 33, Key_PageDown = 34, Key_End = 35, \\\n    Key_Home = 36, Key_LeftArrow = 37, Key_UpArrow = 38, Key_RightArrow = 39, \\\n    Key_DownArrow = 40, Key_Insert = 45, Key_Delete = 46, Key_0 = 48, \\\n    Key_1 = 49, Key_2 = 50, Key_3 = 51, Key_4 = 52, Key_5 = 53, Key_6 = 54, \\\n    Key_7 = 55, Key_8 = 56, Key_9 = 57, Key_A = 65, Key_B = 66, Key_C = 67, \\\n    Key_D = 68, Key_E = 69, Key_F = 70, Key_G = 71, Key_H = 72, \\\n    Key_I = 73, Key_J = 74, Key_K = 75, Key_L = 76, Key_M = 77, Key_N = 78, \\\n    Key_O = 79, Key_P = 80, Key_Q = 81, Key_R = 82, Key_S = 83, Key_T = 84, \\\n    Key_U = 85, Key_V = 86, Key_W = 87, Key_X = 88, Key_Y = 89, Key_Z = 90, \\\n    Key_LeftWindow = 91, Key_RightWindows = 92, Key_Select = 93, \\\n    Key_Numpad0 = 96, Key_Numpad1 = 97, Key_Numpad2 = 98, Key_Numpad3 = 99, \\\n    Key_Numpad4 = 100, Key_Numpad5 = 101, Key_Numpad6 = 102, \\\n    Key_Numpad7 = 103, Key_Numpad8 = 104, Key_Numpad9 = 105, \\\n    Key_NumpadMultiply = 106, Key_NumpadAdd = 107, Key_NumpadSubtract = 109, \\\n    Key_NumpadPeriod = 110, Key_NumpadDivide = 111, Key_F1 = 112, \\\n    Key_F2 = 113, Key_F3 = 114, Key_F4 = 115, Key_F5 = 116, Key_F6 = 117, \\\n    Key_F7 = 118, Key_F8 = 119, Key_F9 = 120, Key_F10 = 121, Key_F11 = 122, \\\n    Key_F12 = 123, Key_NumLock = 144, Key_ScrollLock = 145, \\\n    Key_SemiColon = 186, Key_Equal = 187, Key_Comma = 188, Key_Dash = 189, \\\n    Key_Period = 190, Key_ForwardSlash = 191, Key_GraveAccent = 192, \\\n    Key_OpenBracket = 219, Key_BackSlash = 220, Key_CloseBraket = 221, \\\n    Key_SingleQuote = 222; \\\nconst int Key_Space = 32; \\\n \\\nbool is_key_pressed(int key) \\\n{ \\\n    return texelFetch(SHADERTOY_KEYBOARD_CH, ivec2(key, 1), 0).x > .5; \\\n} \\\n \\\nbool is_key_down(int key) \\\n{ \\\n    return texelFetch(SHADERTOY_KEYBOARD_CH, ivec2(key, 0), 0).x > .5; \\\n} \\\n \\\nbool is_key_toggled(int key) \\\n{ \\\n    return texelFetch(SHADERTOY_KEYBOARD_CH, ivec2(key, 2), 0).x > .5; \\\n}\n\n#else\n\n#define define_keyboard_utils \\\n \\\nconst int Key_Space = 32; \\\n \\\nbool is_key_pressed(int key) \\\n{ \\\n    return isKeyPressed(key); \\\n} \\\n \\\nbool is_key_down(int key) \\\n{ \\\n    return isKeyDown(key); \\\n} \\\n \\\nbool is_key_toggled(int key) \\\n{ \\\n    return isKeyToggled(key); \\\n}\n\n#endif\n\n\n\n/*-----------------------------------------------\n\nflim - Filmic Color Transform\n\nInput Color Space:   Linear BT.709 I-D65\nOutput Color Space:  Linear BT.709 I-D65 / sRGB 2.2 (depends on arguments)\n\nDescription:\n  Experimental port of flim for GLSL/Shadertoy\n  matching flim v1.1.0.\n\nAuthor:\n  Bean (beans_please on Shadertoy)\n\nOriginal Repo:\n  https://github.com/bean-mhm/flim\n\nOriginal Shader:\n  https://www.shadertoy.com/view/dd2yDz\n\n-----------------------------------------------*/\n\n// parameters\n\nconst float flim_pre_exposure = 4.3;\nconst vec3 flim_pre_formation_filter = vec3(1.);\nconst float flim_pre_formation_filter_strength = 0.;\n\nconst float flim_extended_gamut_red_scale = 1.05;\nconst float flim_extended_gamut_green_scale = 1.12;\nconst float flim_extended_gamut_blue_scale = 1.045;\nconst float flim_extended_gamut_red_rot = .5;\nconst float flim_extended_gamut_green_rot = 2.;\nconst float flim_extended_gamut_blue_rot = .1;\nconst float flim_extended_gamut_red_mul = 1.;\nconst float flim_extended_gamut_green_mul = 1.;\nconst float flim_extended_gamut_blue_mul = 1.;\n\nconst float flim_sigmoid_log2_min = -10.;\nconst float flim_sigmoid_log2_max = 22.;\nconst float flim_sigmoid_toe_x = .44;\nconst float flim_sigmoid_toe_y = .28;\nconst float flim_sigmoid_shoulder_x = .591;\nconst float flim_sigmoid_shoulder_y = .779;\n\nconst float flim_negative_film_exposure = 6.;\nconst float flim_negative_film_density = 5.;\n\nconst vec3 flim_print_backlight = vec3(1);\nconst float flim_print_film_exposure = 6.;\nconst float flim_print_film_density = 27.5;\n\nconst float flim_black_point = -1.; // -1 = auto\nconst vec3 flim_post_formation_filter = vec3(1);\nconst float flim_post_formation_filter_strength = 0.;\nconst float flim_midtone_saturation = 1.02;\n\n// color space conversions\n// the matrices below represent data in row-major, but GLSL matrices are in\n// column-major, so we need to multiply a vec3 by a matrix rather than\n// multiplying a matrix by a vec3.\n\nconst mat3 mat_bt2020_to_xyz = mat3(\n     0.6369580483,  0.1446169036,  0.1688809752,\n     0.2627002120,  0.6779980715,  0.0593017165,\n     0.0000000000,  0.0280726930,  1.0609850577\n);\n\nconst mat3 mat_xyz_to_bt2020 = mat3(\n     1.7166511880, -0.3556707838, -0.2533662814,\n    -0.6666843518,  1.6164812366,  0.0157685458,\n     0.0176398574, -0.0427706133,  0.9421031212\n);\n\nconst mat3 mat_bt709_to_xyz = mat3(\n     0.4123907993,  0.3575843394,  0.1804807884,\n     0.2126390059,  0.7151686788,  0.0721923154,\n     0.0193308187,  0.1191947798,  0.9505321522\n);\n\nconst mat3 mat_xyz_to_bt709 = mat3(\n     3.2409699419, -1.5373831776, -0.4986107603,\n    -0.9692436363,  1.8759675015,  0.0415550574,\n     0.0556300797, -0.2039769589,  1.0569715142\n);\n\nconst mat3 mat_dcip3_to_xyz = mat3(\n     0.4451698156,  0.2771344092,  0.1722826698,\n     0.2094916779,  0.7215952542,  0.0689130679,\n     0.0000000000,  0.0470605601,  0.9073553944\n);\n\nconst mat3 mat_xyz_to_dcip3 = mat3(\n     2.7253940305, -1.0180030062, -0.4401631952,\n    -0.7951680258,  1.6897320548,  0.0226471906,\n     0.0412418914, -0.0876390192,  1.1009293786\n);\n\nvec3 oetf_pow(vec3 col, float power)\n{\n    return pow(col, vec3(1. / power));\n}\n\nvec3 eotf_pow(vec3 col, float power)\n{\n    return pow(col, vec3(power));\n}\n\n// flim's utility functions\n\nfloat flim_wrap(float v, float start, float end)\n{\n    return start + mod(v - start, end - start);\n}\n\nfloat flim_remap(\n    float v,\n    float inp_start,\n    float inp_end,\n    float out_start,\n    float out_end\n)\n{\n    return out_start\n        + ((out_end - out_start) / (inp_end - inp_start)) * (v - inp_start);\n}\n\nfloat flim_remap_clamp(\n    float v,\n    float inp_start,\n    float inp_end,\n    float out_start,\n    float out_end\n)\n{\n    float t = clamp((v - inp_start) / (inp_end - inp_start), 0., 1.);\n    return out_start + t * (out_end - out_start);\n}\n\nfloat flim_remap01(\n    float v,\n    float inp_start,\n    float inp_end\n)\n{\n    return clamp((v - inp_start) / (inp_end - inp_start), 0., 1.);\n}\n\nvec3 flim_blender_rgb_to_hsv(vec3 rgb)\n{\n    float cmax, cmin, h, s, v, cdelta;\n    vec3 c;\n\n    cmax = max(rgb[0], max(rgb[1], rgb[2]));\n    cmin = min(rgb[0], min(rgb[1], rgb[2]));\n    cdelta = cmax - cmin;\n\n    v = cmax;\n    if (cmax != 0.)\n    {\n        s = cdelta / cmax;\n    }\n    else\n    {\n        s = 0.;\n        h = 0.;\n    }\n\n    if (s == 0.)\n    {\n        h = 0.;\n    }\n    else\n    {\n        c = (vec3(cmax) - rgb.xyz) / cdelta;\n\n        if (rgb.x == cmax)\n        {\n            h = c[2] - c[1];\n        }\n        else if (rgb.y == cmax)\n        {\n            h = 2. + c[0] - c[2];\n        }\n        else\n        {\n            h = 4. + c[1] - c[0];\n        }\n\n        h /= 6.;\n\n        if (h < 0.)\n        {\n            h += 1.;\n        }\n    }\n\n    return vec3(h, s, v);\n}\n\nvec3 flim_blender_hsv_to_rgb(vec3 hsv)\n{\n    float f, p, q, t, h, s, v;\n    vec3 rgb;\n\n    h = hsv[0];\n    s = hsv[1];\n    v = hsv[2];\n\n    if (s == 0.)\n    {\n        rgb = vec3(v, v, v);\n    }\n    else\n    {\n        if (h == 1.)\n        {\n            h = 0.;\n        }\n\n        h *= 6.;\n        int i = int(floor(h));\n        f = h - float(i);\n        rgb = vec3(f, f, f);\n        p = v * (1. - s);\n        q = v * (1. - (s * f));\n        t = v * (1. - (s * (1. - f)));\n\n        if (i == 0)\n        {\n            rgb = vec3(v, t, p);\n        }\n        else if (i == 1)\n        {\n            rgb = vec3(q, v, p);\n        }\n        else if (i == 2)\n        {\n            rgb = vec3(p, v, t);\n        }\n        else if (i == 3)\n        {\n            rgb = vec3(p, q, v);\n        }\n        else if (i == 4)\n        {\n            rgb = vec3(t, p, v);\n        }\n        else\n        {\n            rgb = vec3(v, p, q);\n        }\n    }\n\n    return rgb;\n}\n\nvec3 flim_blender_hue_sat(vec3 col, float hue, float sat, float value)\n{\n    vec3 hsv = flim_blender_rgb_to_hsv(col);\n\n    hsv[0] = fract(hsv[0] + hue + .5);\n    hsv[1] = clamp(hsv[1] * sat, 0., 1.);\n    hsv[2] = hsv[2] * value;\n\n    return flim_blender_hsv_to_rgb(hsv);\n}\n\nfloat flim_rgb_avg(vec3 col)\n{\n    return (col.x + col.y + col.z) / 3.;\n}\n\nfloat flim_rgb_sum(vec3 col)\n{\n    return col.x + col.y + col.z;\n}\n\nfloat flim_rgb_max(vec3 col)\n{\n    return max(max(col.x, col.y), col.z);\n}\n\nfloat flim_rgb_min(vec3 col)\n{\n    return min(min(col.x, col.y), col.z);\n}\n\nvec3 flim_rgb_uniform_offset(vec3 col, float black_point, float white_point)\n{\n    float mono = flim_rgb_avg(col);\n    float mono2 = flim_remap01(\n        mono, black_point / 1000.,\n        1. - (white_point / 1000.)\n    );\n    return col * (mono2 / mono);\n}\n\nvec3 flim_rgb_sweep(float hue)\n{\n    hue = flim_wrap(hue * 360., 0., 360.);\n\n    vec3 col = vec3(1, 0, 0);\n    col = mix(col, vec3(1, 1, 0), flim_remap01(hue, 0., 60.));\n    col = mix(col, vec3(0, 1, 0), flim_remap01(hue, 60., 120.));\n    col = mix(col, vec3(0, 1, 1), flim_remap01(hue, 120., 180.));\n    col = mix(col, vec3(0, 0, 1), flim_remap01(hue, 180., 240.));\n    col = mix(col, vec3(1, 0, 1), flim_remap01(hue, 240., 300.));\n    col = mix(col, vec3(1, 0, 0), flim_remap01(hue, 300., 360.));\n    \n    return col;\n}\n\nvec3 flim_rgb_exposure_sweep_test(vec2 uv0to1)\n{\n    float hue = 1. - uv0to1.y;\n    float exposure = flim_remap(uv0to1.x, 0., 1., -5., 10.);\n    return flim_rgb_sweep(hue) * pow(2., exposure);\n}\n\n// https://www.desmos.com/calculator/khkztixyeu\nfloat flim_super_sigmoid(\n    float v,\n    float toe_x,\n    float toe_y,\n    float shoulder_x,\n    float shoulder_y\n)\n{\n    // clip\n    v = clamp(v, 0., 1.);\n    toe_x = clamp(toe_x, 0., 1.);\n    toe_y = clamp(toe_y, 0., 1.);\n    shoulder_x = clamp(shoulder_x, 0., 1.);\n    shoulder_y = clamp(shoulder_y, 0., 1.);\n\n    // calculate straight line slope\n    float slope = (shoulder_y - toe_y) / (shoulder_x - toe_x);\n\n    // toe\n    if (v < toe_x)\n    {\n        float toe_pow = slope * toe_x / toe_y;\n        return toe_y * pow(v / toe_x, toe_pow);\n    }\n\n    // straight line\n    if (v < shoulder_x)\n    {\n        float intercept = toe_y - (slope * toe_x);\n        return slope * v + intercept;\n    }\n\n    // shoulder\n    float shoulder_pow =\n        -slope / (\n            ((shoulder_x - 1.) / pow(1. - shoulder_x, 2.))\n            * (1. - shoulder_y)\n        );\n    return\n        (1. - pow(1. - (v - shoulder_x) / (1. - shoulder_x), shoulder_pow))\n        * (1. - shoulder_y)\n        + shoulder_y;\n}\n\nfloat flim_dye_mix_factor(float mono, float max_density)\n{\n    // log2 and map range\n    float offset = pow(2., flim_sigmoid_log2_min);\n    float fac = flim_remap01(\n        log2(mono + offset),\n        flim_sigmoid_log2_min,\n        flim_sigmoid_log2_max\n    );\n\n    // calculate amount of exposure from 0 to 1\n    fac = flim_super_sigmoid(\n        fac,\n        flim_sigmoid_toe_x,\n        flim_sigmoid_toe_y,\n        flim_sigmoid_shoulder_x,\n        flim_sigmoid_shoulder_y\n    );\n\n    // calculate dye density\n    fac *= max_density;\n\n    // mix factor\n    fac = pow(2., -fac);\n\n    // clip and return\n    return clamp(fac, 0., 1.);\n}\n\nvec3 flim_rgb_color_layer(\n    vec3 col,\n    vec3 sensitivity_tone,\n    vec3 dye_tone,\n    float max_density\n)\n{\n    // normalize\n    vec3 sensitivity_tone_norm =\n        sensitivity_tone / flim_rgb_sum(sensitivity_tone);\n    vec3 dye_tone_norm = dye_tone / flim_rgb_max(dye_tone);\n\n    // dye mix factor\n    float mono = dot(col, sensitivity_tone_norm);\n    float mix_fac = flim_dye_mix_factor(mono, max_density);\n\n    // dye mixing\n    return mix(dye_tone_norm, vec3(1), mix_fac);\n}\n\nvec3 flim_rgb_develop(vec3 col, float exposure, float max_density)\n{\n    // exposure\n    col *= pow(2., exposure);\n\n    // blue-sensitive layer\n    vec3 result = flim_rgb_color_layer(\n        col,\n        vec3(0, 0, 1),\n        vec3(1, 1, 0),\n        max_density\n    );\n\n    // green-sensitive layer\n    result *= flim_rgb_color_layer(\n        col,\n        vec3(0, 1, 0),\n        vec3(1, 0, 1),\n        max_density\n    );\n\n    // red-sensitive layer\n    result *= flim_rgb_color_layer(\n        col,\n        vec3(1, 0, 0),\n        vec3(0, 1, 1),\n        max_density\n    );\n\n    return result;\n}\n\nvec3 flim_gamut_extension_mat_row(\n    float primary_hue,\n    float scale,\n    float rotate,\n    float mul\n)\n{\n    vec3 result = flim_blender_hsv_to_rgb(vec3(\n        flim_wrap(primary_hue + (rotate / 360.), 0., 1.),\n        1. / scale,\n        1.\n    ));\n    result /= flim_rgb_sum(result);\n    result *= mul;\n    return result;\n}\n\nmat3 flim_gamut_extension_mat(\n    float red_scale,\n    float green_scale,\n    float blue_scale,\n    float red_rot,\n    float green_rot,\n    float blue_rot,\n    float red_mul,\n    float green_mul,\n    float blue_mul\n)\n{\n    mat3 m;\n    m[0] = flim_gamut_extension_mat_row(\n        0.,\n        red_scale,\n        red_rot,\n        red_mul\n    );\n    m[1] = flim_gamut_extension_mat_row(\n        1. / 3.,\n        green_scale,\n        green_rot,\n        green_mul\n    );\n    m[2] = flim_gamut_extension_mat_row(\n        2. / 3.,\n        blue_scale,\n        blue_rot,\n        blue_mul\n    );\n    return m;\n}\n\nvec3 negative_and_print(vec3 col, vec3 backlight_ext)\n{\n    // develop negative\n    col = flim_rgb_develop(\n        col,\n        flim_negative_film_exposure,\n        flim_negative_film_density\n    );\n\n    // backlight\n    col *= backlight_ext;\n\n    // develop print\n    col = flim_rgb_develop(\n        col,\n        flim_print_film_exposure,\n        flim_print_film_density\n    );\n\n    return col;\n}\n\n// the flim transform\n\nvec3 flim_transform(vec3 col, float exposure, bool convert_to_srgb)\n{\n    // eliminate negative values\n    col = max(col, 0.);\n\n    // pre-Exposure\n    col *= pow(2., flim_pre_exposure + exposure);\n\n    // clip very large values for float precision issues\n    col = min(col, 5000.);\n\n    // gamut extension matrix (Linear BT.709)\n    mat3 extend_mat = flim_gamut_extension_mat(\n        flim_extended_gamut_red_scale,\n        flim_extended_gamut_green_scale,\n        flim_extended_gamut_blue_scale,\n        flim_extended_gamut_red_rot,\n        flim_extended_gamut_green_rot,\n        flim_extended_gamut_blue_rot,\n        flim_extended_gamut_red_mul,\n        flim_extended_gamut_green_mul,\n        flim_extended_gamut_blue_mul\n    );\n    mat3 extend_mat_inv = inverse(extend_mat);\n\n    // backlight in the extended gamut\n    vec3 backlight_ext = flim_print_backlight * extend_mat;\n\n    // upper limit in the print (highlight cap)\n    const float big = 10000000.;\n    vec3 white_cap = negative_and_print(vec3(big, big, big), backlight_ext);\n\n    // pre-formation filter\n    col = mix(\n        col,\n        col * flim_pre_formation_filter,\n        flim_pre_formation_filter_strength\n    );\n\n    // convert to the extended gamut\n    col *= extend_mat;\n\n    // negative & print\n    col = negative_and_print(col, backlight_ext);\n\n    // convert from the extended gamut\n    col *= extend_mat_inv;\n\n    // eliminate negative values\n    col = max(col, 0.);\n\n    // white cap\n    col /= white_cap;\n\n    // black cap (-1 = auto)\n    if (flim_black_point == -1.)\n    {\n        vec3 black_cap = negative_and_print(vec3(0.), backlight_ext);\n        black_cap /= white_cap;\n        col = flim_rgb_uniform_offset(\n            col,\n            flim_rgb_avg(black_cap) * 1000.,\n            0.\n        );\n    }\n    else\n    {\n        col = flim_rgb_uniform_offset(col, flim_black_point, 0.);\n    }\n\n    // post-formation filter\n    col = mix(\n        col,\n        col * flim_post_formation_filter,\n        flim_post_formation_filter_strength\n    );\n\n    // clip\n    col = clamp(col, 0., 1.);\n\n    // midtone saturation\n    float mono = flim_rgb_avg(col);\n    float mix_fac =\n        (mono < .5)\n        ? flim_remap01(mono, .05, .5)\n        : flim_remap01(mono, .95, .5);\n    col = mix(\n        col,\n        flim_blender_hue_sat(col, .5, flim_midtone_saturation, 1.),\n        mix_fac\n    );\n\n    // clip\n    col = clamp(col, 0., 1.);\n\n    // OETF\n    if (convert_to_srgb)\n    {\n        col = oetf_pow(col, 2.2);\n    }\n\n    return col;\n}\n\n/*____________________ end ____________________*/\n",
     "name": "Common",
     "description": "",
     "type": "common"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "X3ffR7",
    "date": "0",
    "viewed": 0,
    "name": "bad atmosphere",
    "description": "hm",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "atmosphere"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "XsBSR3",
       "filepath": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png",
       "type": "texture",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "const float EARTH_RADIUS = 6.371;\nconst float ATMOSPHERE_RADIUS = 6.470;\n\nvec3 render(vec2 coord)\n{\n    vec2 uv = screen_to_uv_fit(coord, iResolution.xy);\n\n    Ray r;\n    r.orig = vec3(0, 0, EARTH_RADIUS + .0001);\n    r.dir = vec3(0, 1, 0) + vec3(uv.x, 0, uv.y + .2);\n    \n    Sphere atmo;\n    atmo.center = vec3(0);\n    atmo.radius = ATMOSPHERE_RADIUS;\n    \n    Sphere earth;\n    earth.center = vec3(0);\n    earth.radius = EARTH_RADIUS;\n    \n    Hit h_atmo;\n    Hit h_earth;\n    ray_sphere(atmo, r, h_atmo);\n    ray_sphere(earth, r, h_earth);\n    \n    if (h_earth.hit)\n    {\n        return vec3(.06, .2, .03);\n    }\n    if (!h_atmo.hit)\n    {\n        return vec3(0);\n    }\n    \n    vec3 col = vec3(.6, 1.5, 5.);\n    col *= pow(vec3(1, .15, .002), vec3(h_atmo.t));\n    \n    return vec3(col);\n}\n\n// ASC CDL color grading\n// https://en.wikipedia.org/wiki/ASC_CDL\nvec3 asc_cdl(vec3 col, vec3 slope, vec3 offset, vec3 power)\n{\n    return pow(max(col, 0.) * slope + offset, power);\n}\n\nvec3 view_transform(vec3 col)\n{\n    // avoid any negative values before using power functions\n    col = max(col, 0.);\n\n    // color grading\n    col = asc_cdl(\n        col,\n        1.1 * vec3(1, .903, .94),\n        vec3(0, 0, .007),\n        1.05 * vec3(1, .95, 1)\n    );\n    \n    // flim\n    const float exposure = -.9;\n    col = flim_transform(col, exposure, false);\n\n    // OETF (Linear BT.709 I-D65 to sRGB 2.2)\n    col = pow(col, vec3(1. / 2.2));\n    col = clamp(col, 0., 1.);\n\n    return col;\n}\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    // render\n    // (you could implement supersampling here for example)\n    vec3 col = render(frag_coord);\n\n    // view transform\n    col = view_transform(col);\n\n    // blue noise dithering (iChannel0 contains BN texture)\n    float bn = texelFetch(\n        iChannel0,\n        (ivec2(frag_coord) + 10000 * iFrame) % textureSize(iChannel0, 0),\n        0\n    ).x * 2. - 1.;\n    col = clamp(col + bn / 250., 0., 1.);\n\n    // output\n    frag_col = vec4(col, 1);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "#define SHADERTOY 1\n\nprecision highp float;\nprecision highp int;\n\n\n\n/*___________ math & integer utils ____________*/\n\nconst float PI = 3.141592653589793238462643383;\nconst float TAU = 6.283185307179586476925286767;\nconst float PI_OVER_2 = 1.570796326794896619231321692;\nconst float INV_PI = .318309886183790671537767527;\nconst float INV_TAU = .159154943091895335768883763;\n\n#define FUNC_WRAP(T) \\\nT wrap(T v, float start, float end) \\\n{ \\\n    return start + mod(v - start, end - start); \\\n}\n\n#define FUNC_REMAP(T) \\\nT remap(T v, float inp_start, float inp_end, float out_start, float out_end) \\\n{ \\\n    return out_start \\\n        + ((out_end - out_start) / (inp_end - inp_start)) * (v - inp_start); \\\n}\n\n#define FUNC_REMAP_CLAMP(T) \\\nT remap_clamp( \\\n    T v, \\\n    float inp_start, \\\n    float inp_end, \\\n    float out_start, \\\n    float out_end \\\n) \\\n{ \\\n    T t = clamp((v - inp_start) / (inp_end - inp_start), 0., 1.); \\\n    return out_start + t * (out_end - out_start); \\\n}\n\n#define FUNC_REMAP01(T) \\\nT remap01(T v, float inp_start, float inp_end) \\\n{ \\\n    return clamp((v - inp_start) / (inp_end - inp_start), 0., 1.); \\\n}\n\n#define FUNC_LENGTH_SQ(T) \\\nfloat length_sq(T v) \\\n{ \\\n    return dot(v, v); \\\n}\n\n#define FUNC_DIST_SQ(T) \\\nfloat dist_sq(T a, T b) \\\n{ \\\n    a -= b; \\\n    return dot(a, a); \\\n}\n\nFUNC_WRAP(float)\nFUNC_WRAP(vec2)\nFUNC_WRAP(vec3)\nFUNC_WRAP(vec4)\n\nFUNC_REMAP(float)\nFUNC_REMAP(vec2)\nFUNC_REMAP(vec3)\nFUNC_REMAP(vec4)\n\nFUNC_REMAP_CLAMP(float)\nFUNC_REMAP_CLAMP(vec2)\nFUNC_REMAP_CLAMP(vec3)\nFUNC_REMAP_CLAMP(vec4)\n\nFUNC_REMAP01(float)\nFUNC_REMAP01(vec2)\nFUNC_REMAP01(vec3)\nFUNC_REMAP01(vec4)\n\nFUNC_LENGTH_SQ(vec2)\nFUNC_LENGTH_SQ(vec3)\nFUNC_LENGTH_SQ(vec4)\n\nFUNC_DIST_SQ(vec2)\nFUNC_DIST_SQ(vec3)\nFUNC_DIST_SQ(vec4)\n\nfloat chebyshev_dist(vec2 a, vec2 b)\n{\n    return max(abs(a.x - b.x), abs(a.y - b.y));\n}\n\nfloat chebyshev_dist(vec3 a, vec3 b)\n{\n    return max(\n        max(abs(a.x - b.x), abs(a.y - b.y)),\n        abs(a.z - b.z)\n    );\n}\n\nfloat chebyshev_dist(vec4 a, vec4 b)\n{\n    return max(\n        max(\n            max(abs(a.x - b.x), abs(a.y - b.y)),\n            abs(a.z - b.z)\n        ),\n        abs(a.w - b.w)\n    );\n}\n\n#define idiv_ceil(a, b) ((a + b - 1) / b)\n\nint iabs(int v)\n{\n    if (v < 0)\n    {\n        return -v;\n    }\n    return v;\n}\n\nint imin(int a, int b)\n{\n    if (a < b)\n    {\n        return a;\n    }\n    return b;\n}\n\nint imax(int a, int b)\n{\n    if (a > b)\n    {\n        return a;\n    }\n    return b;\n}\n\nint iclamp(int v, int start, int end)\n{\n    if (v < start)\n    {\n        v = start;\n    }\n    if (v > end)\n    {\n        v = end;\n    }\n    return v;\n}\n\nfloat min_component(vec2 v)\n{\n    return min(v.x, v.y);\n}\n\nfloat min_component(vec3 v)\n{\n    return min(min(v.x, v.y), v.z);\n}\n\nfloat min_component(vec4 v)\n{\n    return min(min(min(v.x, v.y), v.z), v.w);\n}\n\nfloat max_component(vec2 v)\n{\n    return max(v.x, v.y);\n}\n\nfloat max_component(vec3 v)\n{\n    return max(max(v.x, v.y), v.z);\n}\n\nfloat max_component(vec4 v)\n{\n    return max(max(max(v.x, v.y), v.z), v.w);\n}\n\nint min_component(ivec2 v)\n{\n    return imin(v.x, v.y);\n}\n\nint min_component(ivec3 v)\n{\n    return imin(imin(v.x, v.y), v.z);\n}\n\nint min_component(ivec4 v)\n{\n    return imin(imin(imin(v.x, v.y), v.z), v.w);\n}\n\nint max_component(ivec2 v)\n{\n    return imax(v.x, v.y);\n}\n\nint max_component(ivec3 v)\n{\n    return imax(imax(v.x, v.y), v.z);\n}\n\nint max_component(ivec4 v)\n{\n    return imax(imax(imax(v.x, v.y), v.z), v.w);\n}\n\nfloat bilinear(\n    float val_bl,\n    float val_tl,\n    float val_tr,\n    float val_br,\n    vec2 offs\n)\n{\n    return mix(\n        mix(val_bl, val_br, offs.x),\n        mix(val_tl, val_tr, offs.x),\n        offs.y\n    );\n}\n\n// credits to AHSEN (https://www.shadertoy.com/user/01000001)\n// https://www.desmos.com/calculator/5d6ph151vi interactive :D\nfloat cubic_interp(float a, float b, float c, float d, float t)\n{\n    float one = t - 1.;\n    float two = t - 2.;\n    float three = t - 3.;\n    return (\n        (-one * two * three * a)\n        + (t * one * two * d)\n        + (3. * t * two * three * b)\n        - (3. * t * one * three * c)\n    ) / 6.;\n}\n\nfloat dist_along_line(vec2 p, vec2 line_start, vec2 line_end)\n{\n    vec2 dir = line_end - line_start;\n    \n    // normalize\n    float len_sqr = dot(dir, dir);\n    if (len_sqr < .0001)\n        return 1e9;\n    dir /= sqrt(len_sqr);\n    \n    return dot(\n        dir,\n        p - line_start\n    );\n}\n\nfloat relative_dist_along_line(vec2 p, vec2 line_start, vec2 line_end)\n{\n    vec2 dir = line_end - line_start;\n    return dot(\n        dir,\n        p - line_start\n    );\n}\n\n// |a| * |b| * sin(theta)\nfloat cross2d(vec2 a, vec2 b)\n{\n    return a.x * b.y - a.y * b.x;\n}\n\n// references for barycentric coordinates\n// https://www.desmos.com/calculator/8g8xjejuox\n// https://www.shadertoy.com/view/mdjBWK\n\nvec3 cartesian_to_barycentric(\n    vec2 p,\n    vec2 v0,\n    vec2 v1,\n    vec2 v2,\n    bool clamp_,\n    out bool p_is_outside\n)\n{\n    vec3 b = vec3(\n        cross2d(v1 - p, v2 - p),\n        cross2d(v2 - p, v0 - p),\n        cross2d(v0 - p, v1 - p)\n    ) / cross2d(v1 - v0, v2 - v0);\n    p_is_outside = min(min(b.x, b.y), b.z) < 0.;\n    if (clamp_)\n    {\n        b = max(b, 0.);\n        b /= (b.x + b.y + b.z);\n    }\n    return b;\n}\n\nvec3 cartesian_to_barycentric(\n    vec3 p,\n    vec3 v0,\n    vec3 v1,\n    vec3 v2,\n    bool clamp_,\n    out bool p_is_outside\n)\n{\n    vec3 b = vec3(\n        length(cross(v1 - p, v2 - p)),\n        length(cross(v2 - p, v0 - p)),\n        length(cross(v0 - p, v1 - p))\n    ) / length(cross(v1 - v0, v2 - v0));\n    p_is_outside = min(min(b.x, b.y), b.z) < 0.;\n    if (clamp_)\n    {\n        b = max(b, 0.);\n        b /= (b.x + b.y + b.z);\n    }\n    return b;\n}\n\nfloat barycentric_interpolate(vec3 b, float v0, float v1, float v2)\n{\n    return dot(b, vec3(v0, v1, v2));\n}\n\nvec2 barycentric_interpolate(vec3 b, vec2 v0, vec2 v1, vec2 v2)\n{\n    return b.x * v0 + b.y * v1 + b.z * v2;\n}\n\nvec3 barycentric_interpolate(vec3 b, vec3 v0, vec3 v1, vec3 v2)\n{\n    return b.x * v0 + b.y * v1 + b.z * v2;\n}\n\nvec4 barycentric_interpolate(vec3 b, vec4 v0, vec4 v1, vec4 v2)\n{\n    return b.x * v0 + b.y * v1 + b.z * v2;\n}\n\nfloat barycentric_interpolate(vec2 b, float v0, float v1, float v2)\n{\n    return barycentric_interpolate(\n        vec3(b.x, b.y, 1. - b.x - b.y),\n        v0, v1, v2\n    );\n}\n\nvec2 barycentric_interpolate(vec2 b, vec2 v0, vec2 v1, vec2 v2)\n{\n    return barycentric_interpolate(\n        vec3(b.x, b.y, 1. - b.x - b.y),\n        v0, v1, v2\n    );\n}\n\nvec3 barycentric_interpolate(vec2 b, vec3 v0, vec3 v1, vec3 v2)\n{\n    return barycentric_interpolate(\n        vec3(b.x, b.y, 1. - b.x - b.y),\n        v0, v1, v2\n    );\n}\n\nvec4 barycentric_interpolate(vec2 b, vec4 v0, vec4 v1, vec4 v2)\n{\n    return barycentric_interpolate(\n        vec3(b.x, b.y, 1. - b.x - b.y),\n        v0, v1, v2\n    );\n}\n\n// angle from 0 to TAU\nfloat get_angle(vec2 p)\n{\n    float a = atan(p.y, p.x);\n    if (a < 0.)\n    {\n        return a + TAU;\n    }\n    return a;\n}\n\nmat2 rotate_2d(float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(\n        c, s,\n        -s, c\n    );\n}\n\nvec2 perpendicular(vec2 v)\n{\n    return vec2(-v.y, v.x);\n}\n\n// s.x=theta\n// s.y=phi\n// (there's no r)\nvec3 spherical_to_cartesian(vec2 s)\n{\n    float sin_theta = sin(s.x);\n    return vec3(\n        sin_theta * cos(s.y),\n        sin_theta * sin(s.y),\n        cos(s.x)\n    );\n}\n\n// s.x=r\n// s.y=theta\n// s.z=phi\nvec3 spherical_to_cartesian(vec3 s)\n{\n    float sin_theta = sin(s.y);\n    return s.x * vec3(\n        sin_theta * cos(s.z),\n        sin_theta * sin(s.z),\n        cos(s.y)\n    );\n}\n\nvec2 screen_to_uv01(vec2 coord, vec2 res)\n{\n    return coord / res;\n}\n\nvec2 screen_to_uv_horizontal(vec2 coord, vec2 res)\n{\n    return (2. * coord - res) / res.x;\n}\n\nvec2 screen_to_uv_vertical(vec2 coord, vec2 res)\n{\n    return (2. * coord - res) / res.y;\n}\n\nvec2 screen_to_uv_fit(vec2 coord, vec2 res)\n{\n    return (2. * coord - res) / min_component(res);\n}\n\nvec2 screen_to_uv_fill(vec2 coord, vec2 res)\n{\n    return (2. * coord - res) / max_component(res);\n}\n\n// * idx starts at 1\nfloat halton(int base, int idx)\n{\n    float result = 0.;\n    float digit_weight = 1.;\n    while (idx > 0)\n    {\n        digit_weight /= float(base);\n        result += float(idx % base) * digit_weight;\n        idx /= base;\n    }\n    return result;\n}\n\n// * idx starts at 1\nvec2 halton_2d(int idx)\n{\n    return vec2(halton(2, idx), halton(3, idx));\n}\n\n// * idx starts at 1\nvec3 halton_3d(int idx)\n{\n    return vec3(halton(2, idx), halton(3, idx), halton(5, idx));\n}\n\n// * idx starts at 1\nvec4 halton_4d(int idx)\n{\n    return vec4(\n        halton(2, idx),\n        halton(3, idx),\n        halton(5, idx),\n        halton(7, idx)\n    );\n}\n\n// for some reason we can't use intBitsToFloat() or floatBitsToInt() to store\n// integers below this value in a buffer.\nconst int BUFFER_MIN_INTEGER = 8388608;\n\n// * x must not be higher than 4,286,578,688 (see BUFFER_MIN_INTEGER above)\n// * for your sanity, don't use negative values\nfloat encode_int_for_buffer(int v)\n{\n    return intBitsToFloat(v + BUFFER_MIN_INTEGER);\n}\n\nint decode_int_from_buffer(float v)\n{\n    return floatBitsToInt(v) - BUFFER_MIN_INTEGER;\n}\n\n// pack two 16-bit integers in a single 32-bit integer\n// * both arguments should be in the 0-65535 range\n// * a must be less than 65279 (see the functions above)\nint pack_i16(int a, int b)\n{\n    return (a << 16) | b;\n}\n\n// unpack two 16-bit integers from a single 32-bit integer\nvoid unpack_i16(int v, out int a, out int b)\n{\n    a = (v >> 16) & 65535;\n    b = v & 65535;\n}\n\n// unpack the first 16-bit integer from a 32-bit integer\nint unpack_i16_a(int v)\n{\n    return (v >> 16) & 65535;\n}\n\n// unpack the second 16-bit integer from a 32-bit integer\nint unpack_i16_b(int v)\n{\n    return v & 65535;\n}\n\nbool icoord_in_bounds(ivec2 icoord, ivec2 ires)\n{\n    return\n        icoord.x >= 0 &&\n        icoord.y >= 0 &&\n        icoord.x < ires.x &&\n        icoord.y < ires.y;\n}\n\nbool icoord_in_bounds(ivec3 icoord, ivec3 ires)\n{\n    return\n        icoord.x >= 0 &&\n        icoord.y >= 0 &&\n        icoord.z >= 0 &&\n        icoord.x < ires.x &&\n        icoord.y < ires.y &&\n        icoord.z < ires.z;\n}\n\nint icoord_to_idx(ivec2 icoord, ivec2 ires)\n{\n    return icoord.x + (icoord.y * ires.x);\n}\n\nint icoord_to_idx(ivec3 icoord, ivec3 ires)\n{\n    return icoord.x + (icoord.y * ires.x) + (icoord.z * ires.x * ires.y);\n}\n\nivec2 idx_to_icoord(int idx, ivec2 ires)\n{\n    return ivec2(idx % ires.x, idx / ires.x);\n}\n\nivec3 idx_to_icoord(int idx, ivec3 ires)\n{\n    return ivec3(\n        idx % ires.x,\n        (idx % (ires.x * ires.y)) / ires.x,\n        idx / (ires.x * ires.y)\n    );\n}\n\n// https://www.desmos.com/calculator/kfe07basy9\n\nint compress_float_to_int_linear(float f, float min_f, float max_f, int max_i)\n{\n    return int(floor(\n        float(max_i) * remap01(f, min_f, max_f)\n    ));\n}\n\nfloat decompress_float_from_int_linear(\n    int i,\n    int max_i,\n    float min_f,\n    float max_f\n)\n{\n    return remap_clamp(\n        float(i) / float(max_i),\n        0., 1.,\n        min_f, max_f\n    );\n}\n\nint compress_float_to_int_log(\n    float f,\n    float log2_zero_offset,\n    float max_log2_f,\n    int max_i\n)\n{\n    f = max(0., f);\n    f += pow(2., log2_zero_offset);\n    return int(floor(\n        float(max_i) * remap01(log2(f), log2_zero_offset, max_log2_f)\n    ));\n}\n\nfloat decompress_float_from_int_log(\n    int i,\n    int max_i,\n    float log2_zero_offset,\n    float max_log2_f\n)\n{\n    return pow(2., remap_clamp(\n        float(i) / float(max_i),\n        0., 1.,\n        log2_zero_offset, max_log2_f\n    )) - pow(2., log2_zero_offset);\n}\n\n\n\n/*_______ pseudo-random number generator ______*/\n// source: https://www.shadertoy.com/view/WdSSRt\n// (heavily modified)\n\n/* usage example:\n    void mainImage(out vec4 frag_col, in vec2 frag_coord)\n    {\n        // initialize PRNG\n        prng_init(vec3(frag_coord / iResolution.y, iTime));\n    \n        // use the function\n        float a = random();\n        vec3 b = vec3(random(), random(), random());\n        \n        ...\n    }\n*/\n\nuint prng_state[2];\n\nuint prng_rot(uint x, int k)\n{\n    return (x << k) | (x >> (32 - k));\n}\n\n// random uint from 0 to 2^32-1\nuint randomui()\n{\n    uint s0 = prng_state[0];\n    uint s1 = prng_state[1];\n    uint result = prng_rot(s0 * 2654435771u, 5) * 5u;\n    s1 ^= s0;\n    prng_state[0] = prng_rot(s0, 26) ^ s1 ^ (s1 << 9);\n    prng_state[1] = prng_rot(s1, 13);\n    return result;\n}\n\n// random int from 0 to 2^31-1\nint randomi()\n{\n    return int(randomui() % 0x7FFFFFFFu);\n}\n\n// random float from 0 to 1\nfloat random()\n{\n    return float(randomui()) / float(0xffffffffu);\n}\n\n// generate two normally distributed random numbers using the\n// Box-Muller transform\n// https://www.baeldung.com/cs/uniform-to-normal-distribution\nvec2 random_gauss()\n{\n    float u1 = random();\n    float u2 = random() * TAU;\n    float temp = sqrt(-2. * log(u1));\n    return temp * vec2(cos(u2), sin(u2));\n    \n    // unoptimized version\n    //float u1 = random();\n    //float u2 = random();\n    //return vec2(cos(TAU * u2), sin(TAU * u2)) * sqrt(-2. * log(u1));\n}\n\nvec2 random_on_circle()\n{\n    vec2 v = vec2(1);\n    float lensqr;\n\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec2(2. * random() - 1., 2. * random() - 1.);\n        lensqr = dot(v, v);\n        if (lensqr == 0.)\n            i--;\n        else if (lensqr <= 1.)\n            break;\n    }\n    return v / sqrt(lensqr);\n}\n\nvec3 random_on_sphere()\n{\n    vec3 v = vec3(1);\n    float lensqr;\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec3(2. * random() - 1., 2. * random() - 1., 2. * random() - 1.);\n        lensqr = dot(v, v);\n        if (lensqr == 0.)\n            i--;\n        else if (lensqr <= 1.)\n            break;\n    }\n    return v / sqrt(lensqr);\n}\n\nvec2 random_in_circle()\n{\n    vec2 v = vec2(1);\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec2(2. * random() - 1., 2. * random() - 1.);\n        if (dot(v, v) <= 1.)\n            return v;\n    }\n    return v;\n}\n\nvec3 random_in_sphere()\n{\n    vec3 v = vec3(1);\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec3(2. * random() - 1., 2. * random() - 1., 2. * random() - 1.);\n        if (dot(v, v) <= 1.)\n            return v;\n    }\n    return v;\n}\n\nvec3 random_on_hemisphere(vec3 normal)\n{\n    vec3 v = random_on_sphere();\n    return v * sign(dot(v, normal));\n}\n\nvec3 random_in_hemisphere(vec3 normal)\n{\n    vec3 v = random_in_sphere();\n    return v * sign(dot(v, normal));\n}\n\n// initialize with uvec2\nvoid prng_init(uvec2 seed)\n{\n    seed += uvec2(1317, 944573125);\n    seed *= 464973573u;\n    prng_state[0] = seed.x;\n    prng_state[1] = seed.y;\n    randomi();\n}\n\n// initialize with uint\nvoid prng_init(uint seed)\n{\n    prng_init(uvec2(seed, 1));\n}\n\n// initialize with vec3\nvoid prng_init(vec3 seed)\n{\n    seed += 3.49276101561702;\n    seed.xy *= (seed.z + 10.258);\n    prng_state[0] = floatBitsToUint(seed.x);\n    prng_state[1] = floatBitsToUint(seed.y);\n    randomui();\n}\n\n// initialize with vec2\nvoid prng_init(vec2 seed)\n{\n    prng_init(vec3(seed, 1));\n}\n\n// initialize with float\nvoid prng_init(float seed)\n{\n    prng_init(vec3(seed, 1, 1));\n}\n\n\n\n/*__________________ keyboard _________________*/\n\n// put this code in every buffer that uses the keyboard input:\n/*\n#if SHADERTOY\n// iChannelX must be set to Keyboard in Shadertoy\n#define SHADERTOY_KEYBOARD_CH iChannelX\n#else\n#iKeyboard\n#endif\n\ndefine_keyboard_utils\n*/\n\n#if SHADERTOY\n\n#define define_keyboard_utils \\\n \\\n/* https://github.com/stevensona/shader-toy/blob/c4833b972649d78a2ee090af60b79a3907e8e091/src/extensions/keyboard/keyboard_shader_extension.ts#L11 */ \\\nconst int \\\n    Key_Backspace = 8, Key_Tab = 9, Key_Enter = 13, Key_Shift = 16, \\\n    Key_Ctrl = 17, Key_Alt = 18, Key_Pause = 19, Key_Caps = 20, \\\n    Key_Escape = 27, Key_PageUp = 33, Key_PageDown = 34, Key_End = 35, \\\n    Key_Home = 36, Key_LeftArrow = 37, Key_UpArrow = 38, Key_RightArrow = 39, \\\n    Key_DownArrow = 40, Key_Insert = 45, Key_Delete = 46, Key_0 = 48, \\\n    Key_1 = 49, Key_2 = 50, Key_3 = 51, Key_4 = 52, Key_5 = 53, Key_6 = 54, \\\n    Key_7 = 55, Key_8 = 56, Key_9 = 57, Key_A = 65, Key_B = 66, Key_C = 67, \\\n    Key_D = 68, Key_E = 69, Key_F = 70, Key_G = 71, Key_H = 72, \\\n    Key_I = 73, Key_J = 74, Key_K = 75, Key_L = 76, Key_M = 77, Key_N = 78, \\\n    Key_O = 79, Key_P = 80, Key_Q = 81, Key_R = 82, Key_S = 83, Key_T = 84, \\\n    Key_U = 85, Key_V = 86, Key_W = 87, Key_X = 88, Key_Y = 89, Key_Z = 90, \\\n    Key_LeftWindow = 91, Key_RightWindows = 92, Key_Select = 93, \\\n    Key_Numpad0 = 96, Key_Numpad1 = 97, Key_Numpad2 = 98, Key_Numpad3 = 99, \\\n    Key_Numpad4 = 100, Key_Numpad5 = 101, Key_Numpad6 = 102, \\\n    Key_Numpad7 = 103, Key_Numpad8 = 104, Key_Numpad9 = 105, \\\n    Key_NumpadMultiply = 106, Key_NumpadAdd = 107, Key_NumpadSubtract = 109, \\\n    Key_NumpadPeriod = 110, Key_NumpadDivide = 111, Key_F1 = 112, \\\n    Key_F2 = 113, Key_F3 = 114, Key_F4 = 115, Key_F5 = 116, Key_F6 = 117, \\\n    Key_F7 = 118, Key_F8 = 119, Key_F9 = 120, Key_F10 = 121, Key_F11 = 122, \\\n    Key_F12 = 123, Key_NumLock = 144, Key_ScrollLock = 145, \\\n    Key_SemiColon = 186, Key_Equal = 187, Key_Comma = 188, Key_Dash = 189, \\\n    Key_Period = 190, Key_ForwardSlash = 191, Key_GraveAccent = 192, \\\n    Key_OpenBracket = 219, Key_BackSlash = 220, Key_CloseBraket = 221, \\\n    Key_SingleQuote = 222; \\\nconst int Key_Space = 32; \\\n \\\nbool is_key_pressed(int key) \\\n{ \\\n    return texelFetch(SHADERTOY_KEYBOARD_CH, ivec2(key, 1), 0).x > .5; \\\n} \\\n \\\nbool is_key_down(int key) \\\n{ \\\n    return texelFetch(SHADERTOY_KEYBOARD_CH, ivec2(key, 0), 0).x > .5; \\\n} \\\n \\\nbool is_key_toggled(int key) \\\n{ \\\n    return texelFetch(SHADERTOY_KEYBOARD_CH, ivec2(key, 2), 0).x > .5; \\\n}\n\n#else\n\n#define define_keyboard_utils \\\n \\\nconst int Key_Space = 32; \\\n \\\nbool is_key_pressed(int key) \\\n{ \\\n    return isKeyPressed(key); \\\n} \\\n \\\nbool is_key_down(int key) \\\n{ \\\n    return isKeyDown(key); \\\n} \\\n \\\nbool is_key_toggled(int key) \\\n{ \\\n    return isKeyToggled(key); \\\n}\n\n#endif\n\n\n\n/*-----------------------------------------------\n\nflim - Filmic Color Transform\n\nInput Color Space:   Linear BT.709 I-D65\nOutput Color Space:  Linear BT.709 I-D65 / sRGB 2.2 (depends on arguments)\n\nDescription:\n  Experimental port of flim for GLSL/Shadertoy\n  matching flim v1.1.0.\n\nAuthor:\n  Bean (beans_please on Shadertoy)\n\nOriginal Repo:\n  https://github.com/bean-mhm/flim\n\nOriginal Shader:\n  https://www.shadertoy.com/view/dd2yDz\n\n-----------------------------------------------*/\n\n// parameters\n\nconst float flim_pre_exposure = 4.3;\nconst vec3 flim_pre_formation_filter = vec3(1.);\nconst float flim_pre_formation_filter_strength = 0.;\n\nconst float flim_extended_gamut_red_scale = 1.05;\nconst float flim_extended_gamut_green_scale = 1.12;\nconst float flim_extended_gamut_blue_scale = 1.045;\nconst float flim_extended_gamut_red_rot = .5;\nconst float flim_extended_gamut_green_rot = 2.;\nconst float flim_extended_gamut_blue_rot = .1;\nconst float flim_extended_gamut_red_mul = 1.;\nconst float flim_extended_gamut_green_mul = 1.;\nconst float flim_extended_gamut_blue_mul = 1.;\n\nconst float flim_sigmoid_log2_min = -10.;\nconst float flim_sigmoid_log2_max = 22.;\nconst float flim_sigmoid_toe_x = .44;\nconst float flim_sigmoid_toe_y = .28;\nconst float flim_sigmoid_shoulder_x = .591;\nconst float flim_sigmoid_shoulder_y = .779;\n\nconst float flim_negative_film_exposure = 6.;\nconst float flim_negative_film_density = 5.;\n\nconst vec3 flim_print_backlight = vec3(1);\nconst float flim_print_film_exposure = 6.;\nconst float flim_print_film_density = 27.5;\n\nconst float flim_black_point = -1.; // -1 = auto\nconst vec3 flim_post_formation_filter = vec3(1);\nconst float flim_post_formation_filter_strength = 0.;\nconst float flim_midtone_saturation = 1.02;\n\n// color space conversions\n// the matrices below represent data in row-major, but GLSL matrices are in\n// column-major, so we need to multiply a vec3 by a matrix rather than\n// multiplying a matrix by a vec3.\n\nconst mat3 mat_bt2020_to_xyz = mat3(\n     0.6369580483,  0.1446169036,  0.1688809752,\n     0.2627002120,  0.6779980715,  0.0593017165,\n     0.0000000000,  0.0280726930,  1.0609850577\n);\n\nconst mat3 mat_xyz_to_bt2020 = mat3(\n     1.7166511880, -0.3556707838, -0.2533662814,\n    -0.6666843518,  1.6164812366,  0.0157685458,\n     0.0176398574, -0.0427706133,  0.9421031212\n);\n\nconst mat3 mat_bt709_to_xyz = mat3(\n     0.4123907993,  0.3575843394,  0.1804807884,\n     0.2126390059,  0.7151686788,  0.0721923154,\n     0.0193308187,  0.1191947798,  0.9505321522\n);\n\nconst mat3 mat_xyz_to_bt709 = mat3(\n     3.2409699419, -1.5373831776, -0.4986107603,\n    -0.9692436363,  1.8759675015,  0.0415550574,\n     0.0556300797, -0.2039769589,  1.0569715142\n);\n\nconst mat3 mat_dcip3_to_xyz = mat3(\n     0.4451698156,  0.2771344092,  0.1722826698,\n     0.2094916779,  0.7215952542,  0.0689130679,\n     0.0000000000,  0.0470605601,  0.9073553944\n);\n\nconst mat3 mat_xyz_to_dcip3 = mat3(\n     2.7253940305, -1.0180030062, -0.4401631952,\n    -0.7951680258,  1.6897320548,  0.0226471906,\n     0.0412418914, -0.0876390192,  1.1009293786\n);\n\nvec3 oetf_pow(vec3 col, float power)\n{\n    return pow(col, vec3(1. / power));\n}\n\nvec3 eotf_pow(vec3 col, float power)\n{\n    return pow(col, vec3(power));\n}\n\n// flim's utility functions\n\nfloat flim_wrap(float v, float start, float end)\n{\n    return start + mod(v - start, end - start);\n}\n\nfloat flim_remap(\n    float v,\n    float inp_start,\n    float inp_end,\n    float out_start,\n    float out_end\n)\n{\n    return out_start\n        + ((out_end - out_start) / (inp_end - inp_start)) * (v - inp_start);\n}\n\nfloat flim_remap_clamp(\n    float v,\n    float inp_start,\n    float inp_end,\n    float out_start,\n    float out_end\n)\n{\n    float t = clamp((v - inp_start) / (inp_end - inp_start), 0., 1.);\n    return out_start + t * (out_end - out_start);\n}\n\nfloat flim_remap01(\n    float v,\n    float inp_start,\n    float inp_end\n)\n{\n    return clamp((v - inp_start) / (inp_end - inp_start), 0., 1.);\n}\n\nvec3 flim_blender_rgb_to_hsv(vec3 rgb)\n{\n    float cmax, cmin, h, s, v, cdelta;\n    vec3 c;\n\n    cmax = max(rgb[0], max(rgb[1], rgb[2]));\n    cmin = min(rgb[0], min(rgb[1], rgb[2]));\n    cdelta = cmax - cmin;\n\n    v = cmax;\n    if (cmax != 0.)\n    {\n        s = cdelta / cmax;\n    }\n    else\n    {\n        s = 0.;\n        h = 0.;\n    }\n\n    if (s == 0.)\n    {\n        h = 0.;\n    }\n    else\n    {\n        c = (vec3(cmax) - rgb.xyz) / cdelta;\n\n        if (rgb.x == cmax)\n        {\n            h = c[2] - c[1];\n        }\n        else if (rgb.y == cmax)\n        {\n            h = 2. + c[0] - c[2];\n        }\n        else\n        {\n            h = 4. + c[1] - c[0];\n        }\n\n        h /= 6.;\n\n        if (h < 0.)\n        {\n            h += 1.;\n        }\n    }\n\n    return vec3(h, s, v);\n}\n\nvec3 flim_blender_hsv_to_rgb(vec3 hsv)\n{\n    float f, p, q, t, h, s, v;\n    vec3 rgb;\n\n    h = hsv[0];\n    s = hsv[1];\n    v = hsv[2];\n\n    if (s == 0.)\n    {\n        rgb = vec3(v, v, v);\n    }\n    else\n    {\n        if (h == 1.)\n        {\n            h = 0.;\n        }\n\n        h *= 6.;\n        int i = int(floor(h));\n        f = h - float(i);\n        rgb = vec3(f, f, f);\n        p = v * (1. - s);\n        q = v * (1. - (s * f));\n        t = v * (1. - (s * (1. - f)));\n\n        if (i == 0)\n        {\n            rgb = vec3(v, t, p);\n        }\n        else if (i == 1)\n        {\n            rgb = vec3(q, v, p);\n        }\n        else if (i == 2)\n        {\n            rgb = vec3(p, v, t);\n        }\n        else if (i == 3)\n        {\n            rgb = vec3(p, q, v);\n        }\n        else if (i == 4)\n        {\n            rgb = vec3(t, p, v);\n        }\n        else\n        {\n            rgb = vec3(v, p, q);\n        }\n    }\n\n    return rgb;\n}\n\nvec3 flim_blender_hue_sat(vec3 col, float hue, float sat, float value)\n{\n    vec3 hsv = flim_blender_rgb_to_hsv(col);\n\n    hsv[0] = fract(hsv[0] + hue + .5);\n    hsv[1] = clamp(hsv[1] * sat, 0., 1.);\n    hsv[2] = hsv[2] * value;\n\n    return flim_blender_hsv_to_rgb(hsv);\n}\n\nfloat flim_rgb_avg(vec3 col)\n{\n    return (col.x + col.y + col.z) / 3.;\n}\n\nfloat flim_rgb_sum(vec3 col)\n{\n    return col.x + col.y + col.z;\n}\n\nfloat flim_rgb_max(vec3 col)\n{\n    return max(max(col.x, col.y), col.z);\n}\n\nfloat flim_rgb_min(vec3 col)\n{\n    return min(min(col.x, col.y), col.z);\n}\n\nvec3 flim_rgb_uniform_offset(vec3 col, float black_point, float white_point)\n{\n    float mono = flim_rgb_avg(col);\n    float mono2 = flim_remap01(\n        mono, black_point / 1000.,\n        1. - (white_point / 1000.)\n    );\n    return col * (mono2 / mono);\n}\n\nvec3 flim_rgb_sweep(float hue)\n{\n    hue = flim_wrap(hue * 360., 0., 360.);\n\n    vec3 col = vec3(1, 0, 0);\n    col = mix(col, vec3(1, 1, 0), flim_remap01(hue, 0., 60.));\n    col = mix(col, vec3(0, 1, 0), flim_remap01(hue, 60., 120.));\n    col = mix(col, vec3(0, 1, 1), flim_remap01(hue, 120., 180.));\n    col = mix(col, vec3(0, 0, 1), flim_remap01(hue, 180., 240.));\n    col = mix(col, vec3(1, 0, 1), flim_remap01(hue, 240., 300.));\n    col = mix(col, vec3(1, 0, 0), flim_remap01(hue, 300., 360.));\n    \n    return col;\n}\n\nvec3 flim_rgb_exposure_sweep_test(vec2 uv0to1)\n{\n    float hue = 1. - uv0to1.y;\n    float exposure = flim_remap(uv0to1.x, 0., 1., -5., 10.);\n    return flim_rgb_sweep(hue) * pow(2., exposure);\n}\n\n// https://www.desmos.com/calculator/khkztixyeu\nfloat flim_super_sigmoid(\n    float v,\n    float toe_x,\n    float toe_y,\n    float shoulder_x,\n    float shoulder_y\n)\n{\n    // clip\n    v = clamp(v, 0., 1.);\n    toe_x = clamp(toe_x, 0., 1.);\n    toe_y = clamp(toe_y, 0., 1.);\n    shoulder_x = clamp(shoulder_x, 0., 1.);\n    shoulder_y = clamp(shoulder_y, 0., 1.);\n\n    // calculate straight line slope\n    float slope = (shoulder_y - toe_y) / (shoulder_x - toe_x);\n\n    // toe\n    if (v < toe_x)\n    {\n        float toe_pow = slope * toe_x / toe_y;\n        return toe_y * pow(v / toe_x, toe_pow);\n    }\n\n    // straight line\n    if (v < shoulder_x)\n    {\n        float intercept = toe_y - (slope * toe_x);\n        return slope * v + intercept;\n    }\n\n    // shoulder\n    float shoulder_pow =\n        -slope / (\n            ((shoulder_x - 1.) / pow(1. - shoulder_x, 2.))\n            * (1. - shoulder_y)\n        );\n    return\n        (1. - pow(1. - (v - shoulder_x) / (1. - shoulder_x), shoulder_pow))\n        * (1. - shoulder_y)\n        + shoulder_y;\n}\n\nfloat flim_dye_mix_factor(float mono, float max_density)\n{\n    // log2 and map range\n    float offset = pow(2., flim_sigmoid_log2_min);\n    float fac = flim_remap01(\n        log2(mono + offset),\n        flim_sigmoid_log2_min,\n        flim_sigmoid_log2_max\n    );\n\n    // calculate amount of exposure from 0 to 1\n    fac = flim_super_sigmoid(\n        fac,\n        flim_sigmoid_toe_x,\n        flim_sigmoid_toe_y,\n        flim_sigmoid_shoulder_x,\n        flim_sigmoid_shoulder_y\n    );\n\n    // calculate dye density\n    fac *= max_density;\n\n    // mix factor\n    fac = pow(2., -fac);\n\n    // clip and return\n    return clamp(fac, 0., 1.);\n}\n\nvec3 flim_rgb_color_layer(\n    vec3 col,\n    vec3 sensitivity_tone,\n    vec3 dye_tone,\n    float max_density\n)\n{\n    // normalize\n    vec3 sensitivity_tone_norm =\n        sensitivity_tone / flim_rgb_sum(sensitivity_tone);\n    vec3 dye_tone_norm = dye_tone / flim_rgb_max(dye_tone);\n\n    // dye mix factor\n    float mono = dot(col, sensitivity_tone_norm);\n    float mix_fac = flim_dye_mix_factor(mono, max_density);\n\n    // dye mixing\n    return mix(dye_tone_norm, vec3(1), mix_fac);\n}\n\nvec3 flim_rgb_develop(vec3 col, float exposure, float max_density)\n{\n    // exposure\n    col *= pow(2., exposure);\n\n    // blue-sensitive layer\n    vec3 result = flim_rgb_color_layer(\n        col,\n        vec3(0, 0, 1),\n        vec3(1, 1, 0),\n        max_density\n    );\n\n    // green-sensitive layer\n    result *= flim_rgb_color_layer(\n        col,\n        vec3(0, 1, 0),\n        vec3(1, 0, 1),\n        max_density\n    );\n\n    // red-sensitive layer\n    result *= flim_rgb_color_layer(\n        col,\n        vec3(1, 0, 0),\n        vec3(0, 1, 1),\n        max_density\n    );\n\n    return result;\n}\n\nvec3 flim_gamut_extension_mat_row(\n    float primary_hue,\n    float scale,\n    float rotate,\n    float mul\n)\n{\n    vec3 result = flim_blender_hsv_to_rgb(vec3(\n        flim_wrap(primary_hue + (rotate / 360.), 0., 1.),\n        1. / scale,\n        1.\n    ));\n    result /= flim_rgb_sum(result);\n    result *= mul;\n    return result;\n}\n\nmat3 flim_gamut_extension_mat(\n    float red_scale,\n    float green_scale,\n    float blue_scale,\n    float red_rot,\n    float green_rot,\n    float blue_rot,\n    float red_mul,\n    float green_mul,\n    float blue_mul\n)\n{\n    mat3 m;\n    m[0] = flim_gamut_extension_mat_row(\n        0.,\n        red_scale,\n        red_rot,\n        red_mul\n    );\n    m[1] = flim_gamut_extension_mat_row(\n        1. / 3.,\n        green_scale,\n        green_rot,\n        green_mul\n    );\n    m[2] = flim_gamut_extension_mat_row(\n        2. / 3.,\n        blue_scale,\n        blue_rot,\n        blue_mul\n    );\n    return m;\n}\n\nvec3 negative_and_print(vec3 col, vec3 backlight_ext)\n{\n    // develop negative\n    col = flim_rgb_develop(\n        col,\n        flim_negative_film_exposure,\n        flim_negative_film_density\n    );\n\n    // backlight\n    col *= backlight_ext;\n\n    // develop print\n    col = flim_rgb_develop(\n        col,\n        flim_print_film_exposure,\n        flim_print_film_density\n    );\n\n    return col;\n}\n\n// the flim transform\n\nvec3 flim_transform(vec3 col, float exposure, bool convert_to_srgb)\n{\n    // eliminate negative values\n    col = max(col, 0.);\n\n    // pre-Exposure\n    col *= pow(2., flim_pre_exposure + exposure);\n\n    // clip very large values for float precision issues\n    col = min(col, 5000.);\n\n    // gamut extension matrix (Linear BT.709)\n    mat3 extend_mat = flim_gamut_extension_mat(\n        flim_extended_gamut_red_scale,\n        flim_extended_gamut_green_scale,\n        flim_extended_gamut_blue_scale,\n        flim_extended_gamut_red_rot,\n        flim_extended_gamut_green_rot,\n        flim_extended_gamut_blue_rot,\n        flim_extended_gamut_red_mul,\n        flim_extended_gamut_green_mul,\n        flim_extended_gamut_blue_mul\n    );\n    mat3 extend_mat_inv = inverse(extend_mat);\n\n    // backlight in the extended gamut\n    vec3 backlight_ext = flim_print_backlight * extend_mat;\n\n    // upper limit in the print (highlight cap)\n    const float big = 10000000.;\n    vec3 white_cap = negative_and_print(vec3(big, big, big), backlight_ext);\n\n    // pre-formation filter\n    col = mix(\n        col,\n        col * flim_pre_formation_filter,\n        flim_pre_formation_filter_strength\n    );\n\n    // convert to the extended gamut\n    col *= extend_mat;\n\n    // negative & print\n    col = negative_and_print(col, backlight_ext);\n\n    // convert from the extended gamut\n    col *= extend_mat_inv;\n\n    // eliminate negative values\n    col = max(col, 0.);\n\n    // white cap\n    col /= white_cap;\n\n    // black cap (-1 = auto)\n    if (flim_black_point == -1.)\n    {\n        vec3 black_cap = negative_and_print(vec3(0.), backlight_ext);\n        black_cap /= white_cap;\n        col = flim_rgb_uniform_offset(\n            col,\n            flim_rgb_avg(black_cap) * 1000.,\n            0.\n        );\n    }\n    else\n    {\n        col = flim_rgb_uniform_offset(col, flim_black_point, 0.);\n    }\n\n    // post-formation filter\n    col = mix(\n        col,\n        col * flim_post_formation_filter,\n        flim_post_formation_filter_strength\n    );\n\n    // clip\n    col = clamp(col, 0., 1.);\n\n    // midtone saturation\n    float mono = flim_rgb_avg(col);\n    float mix_fac =\n        (mono < .5)\n        ? flim_remap01(mono, .05, .5)\n        : flim_remap01(mono, .95, .5);\n    col = mix(\n        col,\n        flim_blender_hue_sat(col, .5, flim_midtone_saturation, 1.),\n        mix_fac\n    );\n\n    // clip\n    col = clamp(col, 0., 1.);\n\n    // OETF\n    if (convert_to_srgb)\n    {\n        col = oetf_pow(col, 2.2);\n    }\n\n    return col;\n}\n\n/*____________________ end ____________________*/\n\n\n\nstruct Ray\n{\n    vec3 orig;\n    vec3 dir;\n};\n\nstruct Hit\n{\n    bool hit;\n    float t;\n    vec3 pos;\n    vec3 normal;\n    vec2 uv; // only works with triangles and quads\n};\n\nHit Hit_new()\n{\n    Hit h;\n    h.hit = false;\n    h.t = 1e9;\n    h.uv = vec2(-1e9);\n    return h;\n}\n\nstruct Sphere\n{\n    int obj_id;\n    int mat_id;\n    vec3 center;\n    float radius;\n    bool backface_culling;\n};\n\nvoid ray_sphere(\n    in Sphere s,\n    in Ray r,\n    out Hit h\n)\n{\n    h = Hit_new();\n\n    vec3 ro = r.orig - s.center;\n\n    float a = dot(r.dir, r.dir);\n    float b = 2. * dot(ro, r.dir);\n    float c = dot(ro, ro) - s.radius * s.radius;\n    float discriminant = (b * b) - (4. * a * c);\n    \n    if (discriminant < 0.)\n    {\n        return;\n    }\n    \n    float sqrt_d = sqrt(discriminant);\n    float one_over_2a = .5 / a;\n    float t0 = (-b - sqrt_d) * one_over_2a;\n    float t1 = (-b + sqrt_d) * one_over_2a;\n\n    h.t = t0;\n    if (s.backface_culling && t0 < 0.)\n    {\n        return;\n    }\n    else if (!s.backface_culling && t0 < 0.)\n    {\n        if (t1 < 0.)\n        {\n            return;\n        }\n        h.t = t1;\n    }\n    \n    h.hit = true;\n    h.pos = r.orig + (h.t * r.dir);\n    h.normal = (h.pos - s.center) / s.radius;\n}\n",
     "name": "Common",
     "description": "",
     "type": "common"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "XXlBDH",
    "date": "1728333908",
    "viewed": 119,
    "name": "Diffraction Through 5 Slits",
    "description": "inspired by 3b1b's new video",
    "likes": 4,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "waves",
     "wave",
     "sine",
     "diffraction"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// colormap source:\n// https://www.shadertoy.com/view/MfjBDV\n\n// https://www.desmos.com/calculator/n4mfhffj1n\nfloat colormap_expf(float x, float v)\n{\n    if (abs(v) < .0001) v = .0001;\n    float p = pow(2., v);\n    return (1. - pow(p, -x)) / (1. - 1. / p);\n}\n\nvec3 colormap(float x)\n{\n    float t = .18 * abs(x);\n    if (x < 0.)\n    {\n        x = -x;\n        t = -.37 - .14 * x;\n    }\n    \n    // https://www.desmos.com/calculator/sdqk904uu9\n    vec3 tone = 8. * vec3(\n        cos(6.283 * t),\n        cos(6.283 * (t - .3333)),\n        cos(6.283 * (t - .6667))\n    );\n    \n    x = smoothstep(0., 1., x);\n    vec3 c = vec3(\n        colormap_expf(x, tone.r),\n        colormap_expf(x, tone.g),\n        colormap_expf(x, tone.b)\n    );\n    \n    c = mix(c, c + vec3(.04, 0, .03), smoothstep(.1, 0., x));\n    \n    return c;\n}\n\nfloat spow(float a, float b)\n{\n    return sign(a) * pow(abs(a), b);\n}\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    vec2 uv = (2. * frag_coord - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    float v = 0.;\n    for (float x = -2.; x <= 2.; x++)\n    {\n        vec2 center = vec2(.2 * x, -.9);\n        float dist = distance(uv, center);\n        v += sin(100. * dist - 5. * iTime) / (dist + .05);\n    }\n    \n    vec3 col = vec3(colormap(.05 * v));\n    \n    col = pow(col, vec3(1. / 2.2));\n    frag_col = vec4(col, 1);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "XccyW2",
    "date": "0",
    "viewed": 0,
    "name": "Oscillations",
    "description": "Hello",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "procedural",
     "2d",
     "oscilloscope",
     "sound",
     "music",
     "audio",
     "crt",
     "progression",
     "laser",
     "song",
     "chord"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "XsBSR3",
       "filepath": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png",
       "type": "texture",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// input signal (2-channel)\nvec2 signal(float t)\n{\n    return audio_signal(t);\n    float l = 0.;\n    float r = 0.;\n    \n    l += .8 * cos_taylor(TAU * 200. * t);\n    r += .8 * sin_taylor(TAU * 400. * t);\n    \n    return vec2(l, r);\n}\n\nfloat sd_segment(vec2 p, vec2 a, vec2 b)\n{\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0., 1.);\n    return length(pa - ba * h);\n}\n\nvec3 render_pointer(vec2 uv, vec2 pointer_pos)\n{\n    float dist2 = dist_sq(uv, pointer_pos);\n    \n    const float standard_deviation = .006;\n    const float inv2dev2 = .5 / (standard_deviation * standard_deviation);\n    const float gaussian_scale = 1. / (standard_deviation * sqrt(TAU));\n    \n    float fac = gaussian_scale * exp(-dist2 * inv2dev2);\n    fac += .0001 / (100. * dist2 * dist2 + .001) * smoothstep(.06, .0, dist2);\n    return 7. * fac * vec3(.22, 1, .02);\n}\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    // pseudo-random number generator\n    prng_init(vec3(frag_coord, iFrame));\n    \n    // UV and initial color\n    vec2 uv = (2. * frag_coord - iResolution.xy) / min(iResolution.x, iResolution.y);\n    vec3 col = vec3(0);\n    \n    // how much the pointer gets blurred over time\n    const float temporal_persistance = .02;\n    \n    #define SEGMENT_OPTIMIZATION 0\n    #if SEGMENT_OPTIMIZATION\n    \n        // how the optimization works:\n        // we're gonna divide the entire time range [iTime - temporal_persistance]\n        // into n_segments line segments. for each linge segment, if uv is too far\n        // away from it (farther than segment_dist_threshold) then we won't sample\n        // from that time range at all. otherwise, we'll take n_samples_per_segment\n        // samples from the time range associated with that segment.\n        const int n_segments = 128;\n        const int n_samples_per_segment = 8;\n        const float segment_dist_threshold = .25;\n        \n        // go through the segments\n        for (int i = 0; i < n_segments; i++)\n        {\n            // calculate the time range for this segment\n            float time_range_start = mix(\n                iTime - temporal_persistance,\n                iTime,\n                float(i) / float(n_segments)\n            );\n            float time_range_end = mix(\n                iTime - temporal_persistance,\n                iTime,\n                float(i + 1) / float(n_segments)\n            );\n            \n            // get the endpoints of the line segment directly from the output of\n            // signal() at the endpoints of the corresponding time range.\n            vec2 endpoint0 = signal(time_range_start);\n            vec2 endpoint1 = signal(time_range_end);\n            \n            // if uv is too far away from the segment, skip this segment.\n            if (sd_segment(uv, endpoint0, endpoint1) > segment_dist_threshold)\n            {\n                continue;\n            }\n            \n            // take random samples within the corresponding time range\n            for (int j = 0; j < n_samples_per_segment; j++)\n            {\n                float sample_time = mix(\n                    time_range_start,\n                    time_range_end,\n                    random()\n                );\n                col += render_pointer(uv, signal(sample_time));\n            }\n        }\n        \n        // average out the samples\n        col /= float(n_segments * n_samples_per_segment);\n    \n    #else\n    \n        // this is the normal method with no optimizations.\n        // just randomly sample the entire time range.\n        const int n_samples = 48;\n        for (int i = 0; i < n_samples; i++)\n        {\n            float sample_time = iTime - random() * temporal_persistance;\n            col += render_pointer(uv, signal(sample_time));\n        }\n        col /= float(n_samples);\n    \n    #endif\n    \n    // background\n    col += vec3(0, .017, .044);\n    \n    // vignette\n    col *= exp(-.05 * length_sq(uv));\n\n    // flim and output\n    col = flim_transform(col, 0., true);\n    frag_col = vec4(col, 1);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "/*___________ math & integer utils ____________*/\n\nconst float PI = 3.141592653589793238462643383;\nconst float TAU = 6.283185307179586476925286767;\nconst float HALF_PI = 1.570796326794896619231321692;\nconst float THREE_PI_HALF = 4.7123889803846898576939650749193;\nconst float INV_PI = .318309886183790671537767527;\nconst float INV_TAU = .159154943091895335768883763;\n\n#define FUNC_WRAP(T) \\\nT wrap(T v, float start, float end) \\\n{ \\\n    return start + mod(v - start, end - start); \\\n}\n\n#define FUNC_REMAP(T) \\\nT remap(T v, float inp_start, float inp_end, float out_start, float out_end) \\\n{ \\\n    return out_start \\\n        + ((out_end - out_start) / (inp_end - inp_start)) * (v - inp_start); \\\n}\n\n#define FUNC_REMAP_CLAMP(T) \\\nT remap_clamp( \\\n    T v, \\\n    float inp_start, \\\n    float inp_end, \\\n    float out_start, \\\n    float out_end \\\n) \\\n{ \\\n    T t = clamp((v - inp_start) / (inp_end - inp_start), 0., 1.); \\\n    return out_start + t * (out_end - out_start); \\\n}\n\n#define FUNC_REMAP01(T) \\\nT remap01(T v, float inp_start, float inp_end) \\\n{ \\\n    return clamp((v - inp_start) / (inp_end - inp_start), 0., 1.); \\\n}\n\n#define FUNC_LENGTH_SQ(T) \\\nfloat length_sq(T v) \\\n{ \\\n    return dot(v, v); \\\n}\n\n#define FUNC_DIST_SQ(T) \\\nfloat dist_sq(T a, T b) \\\n{ \\\n    a -= b; \\\n    return dot(a, a); \\\n}\n\nFUNC_WRAP(float)\nFUNC_WRAP(vec2)\nFUNC_WRAP(vec3)\nFUNC_WRAP(vec4)\n\nFUNC_REMAP(float)\nFUNC_REMAP(vec2)\nFUNC_REMAP(vec3)\nFUNC_REMAP(vec4)\n\nFUNC_REMAP_CLAMP(float)\nFUNC_REMAP_CLAMP(vec2)\nFUNC_REMAP_CLAMP(vec3)\nFUNC_REMAP_CLAMP(vec4)\n\nFUNC_REMAP01(float)\nFUNC_REMAP01(vec2)\nFUNC_REMAP01(vec3)\nFUNC_REMAP01(vec4)\n\nFUNC_LENGTH_SQ(vec2)\nFUNC_LENGTH_SQ(vec3)\nFUNC_LENGTH_SQ(vec4)\n\nFUNC_DIST_SQ(vec2)\nFUNC_DIST_SQ(vec3)\nFUNC_DIST_SQ(vec4)\n\nfloat cos_taylor_imprecise(float x)\n{\n    const float INV_2FAC = .5;\n    const float INV_4FAC = .04166666666666666666666666666667;\n    const float INV_6FAC = .00138888888888888888888888888889;\n    const float INV_8FAC = 2.4801587301587301587301587301587e-5;\n    const float INV_10FAC = 2.7557319223985890652557319223986e-7;\n\n    float x2 = x * x;\n    float x4 = x2 * x2;\n    float x6 = x4 * x2;\n    float x8 = x6 * x2;\n    //float x10 = x8 * x2;\n    \n    return 1. - (x2 * INV_2FAC) + (x4 * INV_4FAC) - (x6 * INV_6FAC) + (x8 * INV_8FAC) /*- (x10 * INV_10FAC)*/;\n}\n\nfloat cos_taylor(float x)\n{\n    x = mod(x, TAU);\n    if (x > THREE_PI_HALF) return cos_taylor_imprecise(TAU - x);\n    if (x > PI) return -cos_taylor_imprecise(x - PI);\n    if (x > HALF_PI) return -cos_taylor_imprecise(PI - x);\n    return cos_taylor_imprecise(x);\n}\n\nfloat sin_taylor(float x)\n{\n    x = mod(x, TAU);\n    if (x > THREE_PI_HALF) return -cos_taylor_imprecise(x - THREE_PI_HALF);\n    if (x > PI) return -cos_taylor_imprecise(THREE_PI_HALF - x);\n    if (x > HALF_PI) return cos_taylor_imprecise(x-  HALF_PI);\n    return cos_taylor_imprecise(HALF_PI - x);\n}\n\nfloat tri_wave(float x)\n{\n    x *= INV_PI;\n    return float(int(x) % 2 * 2 - 1) * (abs(mod(x, 2.)) - 1.) * -2. + 1.;\n}\n\n\n\n/*_______ pseudo-random number generator ______*/\n// source: https://www.shadertoy.com/view/WdSSRt\n// (heavily modified)\n\n/* usage example:\n    void mainImage(out vec4 frag_col, in vec2 frag_coord)\n    {\n        // initialize PRNG\n        prng_init(vec3(frag_coord / iResolution.y, iTime));\n    \n        // use the function\n        float a = random();\n        vec3 b = vec3(random(), random(), random());\n        \n        ...\n    }\n*/\n\nuint prng_state[2];\n\nuint prng_rot(uint x, int k)\n{\n    return (x << k) | (x >> (32 - k));\n}\n\n// random uint from 0 to 2^32-1\nuint randomui()\n{\n    uint s0 = prng_state[0];\n    uint s1 = prng_state[1];\n    uint result = prng_rot(s0 * 2654435771u, 5) * 5u;\n    s1 ^= s0;\n    prng_state[0] = prng_rot(s0, 26) ^ s1 ^ (s1 << 9);\n    prng_state[1] = prng_rot(s1, 13);\n    return result;\n}\n\n// random int from 0 to 2^31-1\nint randomi()\n{\n    return int(randomui() % 0x7FFFFFFFu);\n}\n\n// random float from 0 to 1\nfloat random()\n{\n    return float(randomui()) / float(0xffffffffu);\n}\n\n// generate two normally distributed random numbers using the\n// Box-Muller transform\n// https://www.baeldung.com/cs/uniform-to-normal-distribution\nvec2 random_gauss()\n{\n    float u1 = random();\n    float u2 = random() * TAU;\n    float temp = sqrt(-2. * log(u1));\n    return temp * vec2(cos(u2), sin(u2));\n    \n    // unoptimized version\n    //float u1 = random();\n    //float u2 = random();\n    //return vec2(cos(TAU * u2), sin(TAU * u2)) * sqrt(-2. * log(u1));\n}\n\nvec2 random_on_circle()\n{\n    vec2 v = vec2(1);\n    float lensqr;\n\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec2(2. * random() - 1., 2. * random() - 1.);\n        lensqr = dot(v, v);\n        if (lensqr == 0.)\n            i--;\n        else if (lensqr <= 1.)\n            break;\n    }\n    return v / sqrt(lensqr);\n}\n\nvec3 random_on_sphere()\n{\n    vec3 v = vec3(1);\n    float lensqr;\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec3(2. * random() - 1., 2. * random() - 1., 2. * random() - 1.);\n        lensqr = dot(v, v);\n        if (lensqr == 0.)\n            i--;\n        else if (lensqr <= 1.)\n            break;\n    }\n    return v / sqrt(lensqr);\n}\n\nvec2 random_in_circle()\n{\n    vec2 v = vec2(1);\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec2(2. * random() - 1., 2. * random() - 1.);\n        if (dot(v, v) <= 1.)\n            return v;\n    }\n    return v;\n}\n\nvec3 random_in_sphere()\n{\n    vec3 v = vec3(1);\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec3(2. * random() - 1., 2. * random() - 1., 2. * random() - 1.);\n        if (dot(v, v) <= 1.)\n            return v;\n    }\n    return v;\n}\n\nvec3 random_on_hemisphere(vec3 normal)\n{\n    vec3 v = random_on_sphere();\n    return v * sign(dot(v, normal));\n}\n\nvec3 random_in_hemisphere(vec3 normal)\n{\n    vec3 v = random_in_sphere();\n    return v * sign(dot(v, normal));\n}\n\n// initialize with uvec2\nvoid prng_init(uvec2 seed)\n{\n    seed += uvec2(1317, 944573125);\n    seed *= 464973573u;\n    prng_state[0] = seed.x;\n    prng_state[1] = seed.y;\n    randomi();\n}\n\n// initialize with uint\nvoid prng_init(uint seed)\n{\n    prng_init(uvec2(seed, 1));\n}\n\n// initialize with vec3\nvoid prng_init(vec3 seed)\n{\n    seed += 3.49276101561702;\n    seed.xy *= (seed.z + 10.258);\n    prng_state[0] = floatBitsToUint(seed.x);\n    prng_state[1] = floatBitsToUint(seed.y);\n    randomui();\n}\n\n// initialize with vec2\nvoid prng_init(vec2 seed)\n{\n    prng_init(vec3(seed, 1));\n}\n\n// initialize with float\nvoid prng_init(float seed)\n{\n    prng_init(vec3(seed, 1, 1));\n}\n\n\n\n/*___________________ audio ___________________*/\n// https://www.shadertoy.com/view/M3VGRK\n\n// C0 = 0, C5 = 60\nfloat note_to_freq(float note)\n{\n    const float a = 440.;\n    return (a / 32.) * pow(2., (note - 9.) / 12.);\n}\n\nconst float NOTE_C0 = 0.;\nconst float NOTE_CS0 = 1.;\nconst float NOTE_D0 = 2.;\nconst float NOTE_DS0 = 3.;\nconst float NOTE_E0 = 4.;\nconst float NOTE_F0 = 5.;\nconst float NOTE_FS0 = 6.;\nconst float NOTE_G0 = 7.;\nconst float NOTE_GS0 = 8.;\nconst float NOTE_A0 = 9.;\nconst float NOTE_AS0 = 10.;\nconst float NOTE_B0 = 11.;\nconst float NOTE_C1 = 12.;\nconst float NOTE_CS1 = 13.;\nconst float NOTE_D1 = 14.;\nconst float NOTE_DS1 = 15.;\nconst float NOTE_E1 = 16.;\nconst float NOTE_F1 = 17.;\nconst float NOTE_FS1 = 18.;\nconst float NOTE_G1 = 19.;\nconst float NOTE_GS1 = 20.;\nconst float NOTE_A1 = 21.;\nconst float NOTE_AS1 = 22.;\nconst float NOTE_B1 = 23.;\nconst float NOTE_C2 = 24.;\nconst float NOTE_CS2 = 25.;\nconst float NOTE_D2 = 26.;\nconst float NOTE_DS2 = 27.;\nconst float NOTE_E2 = 28.;\nconst float NOTE_F2 = 29.;\nconst float NOTE_FS2 = 30.;\nconst float NOTE_G2 = 31.;\nconst float NOTE_GS2 = 32.;\nconst float NOTE_A2 = 33.;\nconst float NOTE_AS2 = 34.;\nconst float NOTE_B2 = 35.;\nconst float NOTE_C3 = 36.;\nconst float NOTE_CS3 = 37.;\nconst float NOTE_D3 = 38.;\nconst float NOTE_DS3 = 39.;\nconst float NOTE_E3 = 40.;\nconst float NOTE_F3 = 41.;\nconst float NOTE_FS3 = 42.;\nconst float NOTE_G3 = 43.;\nconst float NOTE_GS3 = 44.;\nconst float NOTE_A3 = 45.;\nconst float NOTE_AS3 = 46.;\nconst float NOTE_B3 = 47.;\nconst float NOTE_C4 = 48.;\nconst float NOTE_CS4 = 49.;\nconst float NOTE_D4 = 50.;\nconst float NOTE_DS4 = 51.;\nconst float NOTE_E4 = 52.;\nconst float NOTE_F4 = 53.;\nconst float NOTE_FS4 = 54.;\nconst float NOTE_G4 = 55.;\nconst float NOTE_GS4 = 56.;\nconst float NOTE_A4 = 57.;\nconst float NOTE_AS4 = 58.;\nconst float NOTE_B4 = 59.;\nconst float NOTE_C5 = 60.;\nconst float NOTE_CS5 = 61.;\nconst float NOTE_D5 = 62.;\nconst float NOTE_DS5 = 63.;\nconst float NOTE_E5 = 64.;\nconst float NOTE_F5 = 65.;\nconst float NOTE_FS5 = 66.;\nconst float NOTE_G5 = 67.;\nconst float NOTE_GS5 = 68.;\nconst float NOTE_A5 = 69.;\nconst float NOTE_AS5 = 70.;\nconst float NOTE_B5 = 71.;\nconst float NOTE_C6 = 72.;\nconst float NOTE_CS6 = 73.;\nconst float NOTE_D6 = 74.;\nconst float NOTE_DS6 = 75.;\nconst float NOTE_E6 = 76.;\nconst float NOTE_F6 = 77.;\nconst float NOTE_FS6 = 78.;\nconst float NOTE_G6 = 79.;\nconst float NOTE_GS6 = 80.;\nconst float NOTE_A6 = 81.;\nconst float NOTE_AS6 = 82.;\nconst float NOTE_B6 = 83.;\nconst float NOTE_C7 = 84.;\nconst float NOTE_CS7 = 85.;\nconst float NOTE_D7 = 86.;\nconst float NOTE_DS7 = 87.;\nconst float NOTE_E7 = 88.;\nconst float NOTE_F7 = 89.;\nconst float NOTE_FS7 = 90.;\nconst float NOTE_G7 = 91.;\nconst float NOTE_GS7 = 92.;\nconst float NOTE_A7 = 93.;\nconst float NOTE_AS7 = 94.;\nconst float NOTE_B7 = 95.;\nconst float NOTE_C8 = 96.;\nconst float NOTE_CS8 = 97.;\nconst float NOTE_D8 = 98.;\nconst float NOTE_DS8 = 99.;\nconst float NOTE_E8 = 100.;\nconst float NOTE_F8 = 101.;\nconst float NOTE_FS8 = 102.;\nconst float NOTE_G8 = 103.;\nconst float NOTE_GS8 = 104.;\nconst float NOTE_A8 = 105.;\nconst float NOTE_AS8 = 106.;\nconst float NOTE_B8 = 107.;\nconst float NOTE_C9 = 108.;\nconst float NOTE_CS9 = 109.;\nconst float NOTE_D9 = 110.;\nconst float NOTE_DS9 = 111.;\nconst float NOTE_E9 = 112.;\nconst float NOTE_F9 = 113.;\nconst float NOTE_FS9 = 114.;\nconst float NOTE_G9 = 115.;\nconst float NOTE_GS9 = 116.;\nconst float NOTE_A9 = 117.;\nconst float NOTE_AS9 = 118.;\nconst float NOTE_B9 = 119.;\nconst float NOTE_C10 = 120.;\nconst float NOTE_CS10 = 121.;\nconst float NOTE_D10 = 122.;\nconst float NOTE_DS10 = 123.;\nconst float NOTE_E10 = 124.;\nconst float NOTE_F10 = 125.;\nconst float NOTE_FS10 = 126.;\nconst float NOTE_G10 = 127.;\nconst float NOTE_GS10 = 128.;\nconst float NOTE_A10 = 129.;\nconst float NOTE_AS10 = 130.;\nconst float NOTE_B10 = 131.;\n\nfloat db_to_mul(float db)\n{\n    return pow(10., .05 * db);\n}\n\nfloat mul_to_db(float mul)\n{\n    return 8.68588963808 * log(mul);\n}\n\n// curve similar to ones used in automation and envelope curves in most VSTs and\n// DAWs\n// https://www.desmos.com/calculator/kvkzogpxjk\nfloat expow(float t, float p)\n{\n    t = clamp(t, 0., 1.);\n    if (p >= 0.)\n    {\n        return pow(t, pow(2., p));\n    }\n    return 1. - pow(1. - t, pow(2., -p));\n}\n\nstruct Adsr\n{\n    float delay;        // >=0\n    float attack;       // >=0\n    float attack_pow;   // any\n    float hold;         // >=0\n    float decay;        // >=0\n    float decay_pow;    // any\n    float sustain;      // 0-1\n    float release;      // >=0\n    float release_pow;  // any\n};\n\nfloat Adsr_internal_ads(in Adsr self, float t)\n{\n    if (t < 0.)\n    {\n        return 0.;\n    }\n    if (t < self.attack)\n    {\n        return expow(t / self.attack, -self.attack_pow);\n    }\n    t -= self.attack;\n    if (t < self.hold)\n    {\n        return 1.;\n    }\n    t -= self.hold;\n    if (t < self.decay)\n    {\n        return remap(\n            expow(t / self.decay, self.decay_pow),\n            0., 1.,\n            1., self.sustain\n        );\n    }\n    return self.sustain;\n}\n\nfloat Adsr_internal_release(in Adsr self, float t, float v_before_release)\n{\n    if (t < self.release)\n    {\n        return remap(\n            expow(t / self.release, self.release_pow),\n            0., 1.,\n            v_before_release, 0.\n        );\n    }\n    return 0.;\n}\n\nfloat Adsr_eval(in Adsr self, float t, float note_length)\n{\n    t -= self.delay;\n    note_length -= self.delay;\n    if (t < note_length)\n    {\n        return Adsr_internal_ads(self, t);\n    }\n    else\n    {\n        float t_before_release = min(\n            note_length,\n            self.delay + self.attack + self.hold + self.decay\n        );\n        float v_before_release = Adsr_internal_ads(\n            self,\n            t_before_release\n        );\n        return Adsr_internal_release(\n            self,\n            t - note_length,\n            v_before_release\n        );\n    }\n}\n\nfloat adsr_1(float t, float note_length)\n{\n    Adsr adsr;\n    adsr.delay = 0.02;      // start with 20 ms of delay\n    adsr.attack = .03;      // rise to full volume in 30 ms\n    adsr.attack_pow = 0.;   // rise to full volume linearly\n    adsr.hold = 0.05;       // stay at full volume for 50 ms\n    adsr.decay = .5;        // decay to 65% volume in 0.5 s\n    adsr.decay_pow = -.9;   // start decaying quickly and then slow down\n    adsr.sustain = .65;     // volume to decay to: 65%\n    adsr.release = .2;      // when the key is released, go to 0% in 200 ms\n    adsr.release_pow = -1.; // start going to 0% quickly and then slow down\n\n    return Adsr_eval(\n        adsr,\n        t,\n        note_length\n    );\n}\n\nfloat adsr_2(float t, float note_length)\n{\n    Adsr adsr;\n    adsr.delay = 0.0;      // start with 20 ms of delay\n    adsr.attack = .01;      // rise to full volume in 30 ms\n    adsr.attack_pow = 0.;   // rise to full volume linearly\n    adsr.hold = 0.;       // stay at full volume for 50 ms\n    adsr.decay = .18;        // decay to 65% volume in 0.5 s\n    adsr.decay_pow = -.9;   // start decaying quickly and then slow down\n    adsr.sustain = .65;     // volume to decay to: 65%\n    adsr.release = .1;      // when the key is released, go to 0% in 200 ms\n    adsr.release_pow = -1.; // start going to 0% quickly and then slow down\n\n    return Adsr_eval(\n        adsr,\n        t,\n        note_length\n    );\n}\n\nfloat inst1(float t, float note, float phase)\n{\n    float a = TAU * note_to_freq(note) * t + radians(phase);\n    return sin_taylor(a);\n}\n\nfloat inst2(float t, float note, float phase)\n{\n    float a = TAU * note_to_freq(note) * t + radians(phase);\n    return tri_wave(a);\n}\n\nconst float KEY = 60.;\nconst float BPM = 130.;\nconst float BEAT_LENGTH = 60. / BPM;\n\nconst int N_CHORDS = 4;\nconst vec4 CHORDS[N_CHORDS] = vec4[](\n    vec4(NOTE_B3, NOTE_FS4, NOTE_B4, NOTE_DS5),\n    vec4(NOTE_DS4, NOTE_GS4, NOTE_B4, NOTE_DS5),\n    vec4(NOTE_DS4, NOTE_FS4, NOTE_AS4, NOTE_DS5),\n    vec4(NOTE_F4, NOTE_GS4, NOTE_CS5, NOTE_DS5)\n);\n\nconst int N_TRI_NOTES = 5;\nconst vec4 TRI_NOTES[N_TRI_NOTES] = vec4[](\n    // note, starting beat, length (seconds), gain\n    vec4(NOTE_DS5, 0., .16, 1.),\n    vec4(NOTE_FS5, 3. / 4., .16, 1.),\n    vec4(NOTE_GS5, 6. / 4., .16, 1.),\n    vec4(NOTE_CS5, 10. / 4., .16, 1.),\n    vec4(NOTE_CS5, 14. / 4., .16, 1.)\n);\n\nvec2 pattern_chords(float t)\n{\n    float beat = t / BEAT_LENGTH;\n    float beat_t = mod(t, BEAT_LENGTH);\n\n    vec4 chord = CHORDS[int(beat) / 4 % N_CHORDS];\n    \n    vec2 lr = vec2(.12, 0.) * inst1(t, chord.x, 0.);\n    lr += vec2(0., .12) * inst1(t, chord.y, 90.);\n    lr += vec2(.12, 0.) * inst1(t, chord.z, 180.);\n    lr += vec2(0., .12) * inst1(t, chord.w, 270.);\n    lr *= adsr_1(beat_t, .32);\n    \n    return lr;\n}\n\nvec2 pattern_counter(float t)\n{\n    float beat = t / BEAT_LENGTH;\n    float beat_t = mod(t, BEAT_LENGTH);\n    \n    vec2 lr = vec2(0);\n    for (int i = 0; i < N_TRI_NOTES; i++)\n    {\n        vec4 note_data = TRI_NOTES[i];\n        float note = note_data.x;\n        float start_beat = note_data.y;\n        float note_len = note_data.z;\n        float gain = note_data.w;\n        \n        if (beat < start_beat\n            || t > (start_beat * BEAT_LENGTH + note_len + .3))\n        {\n            continue;\n        }\n        \n        vec2 pan_fac = mix(\n            vec2(i % 2, (i + 1) % 2),\n            vec2(.5),\n            .3\n        );\n        \n        lr +=\n            .18\n            * pan_fac\n            * inst2(t, note, 0.)\n            * adsr_2(t - start_beat * BEAT_LENGTH, note_len);\n    }\n    return lr;\n}\n\nvec2 audio_signal(float t)\n{    \n    vec2 lr = vec2(0);\n    lr += pattern_chords(t);\n    lr += pattern_counter(t) + .5 * pattern_counter(t - BEAT_LENGTH / 2.);\n    return lr;\n}\n\n\n\n/*-----------------------------------------------\n\nflim - Filmic Color Transform\n\nInput Color Space:   Linear BT.709 I-D65\nOutput Color Space:  Linear BT.709 I-D65 / sRGB 2.2 (depends on arguments)\n\nDescription:\n  Experimental port of flim for GLSL/Shadertoy\n  matching flim v1.1.0.\n\nAuthor:\n  Bean (beans_please on Shadertoy)\n\nOriginal Repo:\n  https://github.com/bean-mhm/flim\n\nOriginal Shader:\n  https://www.shadertoy.com/view/dd2yDz\n\n-----------------------------------------------*/\n\n// parameters\n\nconst float flim_pre_exposure = 4.3;\nconst vec3 flim_pre_formation_filter = vec3(1.);\nconst float flim_pre_formation_filter_strength = 0.;\n\nconst float flim_extended_gamut_red_scale = 1.05;\nconst float flim_extended_gamut_green_scale = 1.12;\nconst float flim_extended_gamut_blue_scale = 1.045;\nconst float flim_extended_gamut_red_rot = .5;\nconst float flim_extended_gamut_green_rot = 2.;\nconst float flim_extended_gamut_blue_rot = .1;\nconst float flim_extended_gamut_red_mul = 1.;\nconst float flim_extended_gamut_green_mul = 1.;\nconst float flim_extended_gamut_blue_mul = 1.;\n\nconst float flim_sigmoid_log2_min = -10.;\nconst float flim_sigmoid_log2_max = 22.;\nconst float flim_sigmoid_toe_x = .44;\nconst float flim_sigmoid_toe_y = .28;\nconst float flim_sigmoid_shoulder_x = .591;\nconst float flim_sigmoid_shoulder_y = .779;\n\nconst float flim_negative_film_exposure = 6.;\nconst float flim_negative_film_density = 5.;\n\nconst vec3 flim_print_backlight = vec3(1);\nconst float flim_print_film_exposure = 6.;\nconst float flim_print_film_density = 27.5;\n\nconst float flim_black_point = -1.; // -1 = auto\nconst vec3 flim_post_formation_filter = vec3(1);\nconst float flim_post_formation_filter_strength = 0.;\nconst float flim_midtone_saturation = 1.02;\n\n// color space conversions\n// the matrices below represent data in row-major, but GLSL matrices are in\n// column-major, so we need to multiply a vec3 by a matrix rather than\n// multiplying a matrix by a vec3.\n\nconst mat3 mat_bt2020_to_xyz = mat3(\n     0.6369580483,  0.1446169036,  0.1688809752,\n     0.2627002120,  0.6779980715,  0.0593017165,\n     0.0000000000,  0.0280726930,  1.0609850577\n);\n\nconst mat3 mat_xyz_to_bt2020 = mat3(\n     1.7166511880, -0.3556707838, -0.2533662814,\n    -0.6666843518,  1.6164812366,  0.0157685458,\n     0.0176398574, -0.0427706133,  0.9421031212\n);\n\nconst mat3 mat_bt709_to_xyz = mat3(\n     0.4123907993,  0.3575843394,  0.1804807884,\n     0.2126390059,  0.7151686788,  0.0721923154,\n     0.0193308187,  0.1191947798,  0.9505321522\n);\n\nconst mat3 mat_xyz_to_bt709 = mat3(\n     3.2409699419, -1.5373831776, -0.4986107603,\n    -0.9692436363,  1.8759675015,  0.0415550574,\n     0.0556300797, -0.2039769589,  1.0569715142\n);\n\nconst mat3 mat_dcip3_to_xyz = mat3(\n     0.4451698156,  0.2771344092,  0.1722826698,\n     0.2094916779,  0.7215952542,  0.0689130679,\n     0.0000000000,  0.0470605601,  0.9073553944\n);\n\nconst mat3 mat_xyz_to_dcip3 = mat3(\n     2.7253940305, -1.0180030062, -0.4401631952,\n    -0.7951680258,  1.6897320548,  0.0226471906,\n     0.0412418914, -0.0876390192,  1.1009293786\n);\n\nvec3 oetf_pow(vec3 col, float power)\n{\n    return pow(col, vec3(1. / power));\n}\n\nvec3 eotf_pow(vec3 col, float power)\n{\n    return pow(col, vec3(power));\n}\n\n// flim's utility functions\n\nfloat flim_wrap(float v, float start, float end)\n{\n    return start + mod(v - start, end - start);\n}\n\nfloat flim_remap(\n    float v,\n    float inp_start,\n    float inp_end,\n    float out_start,\n    float out_end\n)\n{\n    return out_start\n        + ((out_end - out_start) / (inp_end - inp_start)) * (v - inp_start);\n}\n\nfloat flim_remap_clamp(\n    float v,\n    float inp_start,\n    float inp_end,\n    float out_start,\n    float out_end\n)\n{\n    float t = clamp((v - inp_start) / (inp_end - inp_start), 0., 1.);\n    return out_start + t * (out_end - out_start);\n}\n\nfloat flim_remap01(\n    float v,\n    float inp_start,\n    float inp_end\n)\n{\n    return clamp((v - inp_start) / (inp_end - inp_start), 0., 1.);\n}\n\nvec3 flim_blender_rgb_to_hsv(vec3 rgb)\n{\n    float cmax, cmin, h, s, v, cdelta;\n    vec3 c;\n\n    cmax = max(rgb[0], max(rgb[1], rgb[2]));\n    cmin = min(rgb[0], min(rgb[1], rgb[2]));\n    cdelta = cmax - cmin;\n\n    v = cmax;\n    if (cmax != 0.)\n    {\n        s = cdelta / cmax;\n    }\n    else\n    {\n        s = 0.;\n        h = 0.;\n    }\n\n    if (s == 0.)\n    {\n        h = 0.;\n    }\n    else\n    {\n        c = (vec3(cmax) - rgb.xyz) / cdelta;\n\n        if (rgb.x == cmax)\n        {\n            h = c[2] - c[1];\n        }\n        else if (rgb.y == cmax)\n        {\n            h = 2. + c[0] - c[2];\n        }\n        else\n        {\n            h = 4. + c[1] - c[0];\n        }\n\n        h /= 6.;\n\n        if (h < 0.)\n        {\n            h += 1.;\n        }\n    }\n\n    return vec3(h, s, v);\n}\n\nvec3 flim_blender_hsv_to_rgb(vec3 hsv)\n{\n    float f, p, q, t, h, s, v;\n    vec3 rgb;\n\n    h = hsv[0];\n    s = hsv[1];\n    v = hsv[2];\n\n    if (s == 0.)\n    {\n        rgb = vec3(v, v, v);\n    }\n    else\n    {\n        if (h == 1.)\n        {\n            h = 0.;\n        }\n\n        h *= 6.;\n        int i = int(floor(h));\n        f = h - float(i);\n        rgb = vec3(f, f, f);\n        p = v * (1. - s);\n        q = v * (1. - (s * f));\n        t = v * (1. - (s * (1. - f)));\n\n        if (i == 0)\n        {\n            rgb = vec3(v, t, p);\n        }\n        else if (i == 1)\n        {\n            rgb = vec3(q, v, p);\n        }\n        else if (i == 2)\n        {\n            rgb = vec3(p, v, t);\n        }\n        else if (i == 3)\n        {\n            rgb = vec3(p, q, v);\n        }\n        else if (i == 4)\n        {\n            rgb = vec3(t, p, v);\n        }\n        else\n        {\n            rgb = vec3(v, p, q);\n        }\n    }\n\n    return rgb;\n}\n\nvec3 flim_blender_hue_sat(vec3 col, float hue, float sat, float value)\n{\n    vec3 hsv = flim_blender_rgb_to_hsv(col);\n\n    hsv[0] = fract(hsv[0] + hue + .5);\n    hsv[1] = clamp(hsv[1] * sat, 0., 1.);\n    hsv[2] = hsv[2] * value;\n\n    return flim_blender_hsv_to_rgb(hsv);\n}\n\nfloat flim_rgb_avg(vec3 col)\n{\n    return (col.x + col.y + col.z) / 3.;\n}\n\nfloat flim_rgb_sum(vec3 col)\n{\n    return col.x + col.y + col.z;\n}\n\nfloat flim_rgb_max(vec3 col)\n{\n    return max(max(col.x, col.y), col.z);\n}\n\nfloat flim_rgb_min(vec3 col)\n{\n    return min(min(col.x, col.y), col.z);\n}\n\nvec3 flim_rgb_uniform_offset(vec3 col, float black_point, float white_point)\n{\n    float mono = flim_rgb_avg(col);\n    float mono2 = flim_remap01(\n        mono, black_point / 1000.,\n        1. - (white_point / 1000.)\n    );\n    return col * (mono2 / mono);\n}\n\nvec3 flim_rgb_sweep(float hue)\n{\n    hue = flim_wrap(hue * 360., 0., 360.);\n\n    vec3 col = vec3(1, 0, 0);\n    col = mix(col, vec3(1, 1, 0), flim_remap01(hue, 0., 60.));\n    col = mix(col, vec3(0, 1, 0), flim_remap01(hue, 60., 120.));\n    col = mix(col, vec3(0, 1, 1), flim_remap01(hue, 120., 180.));\n    col = mix(col, vec3(0, 0, 1), flim_remap01(hue, 180., 240.));\n    col = mix(col, vec3(1, 0, 1), flim_remap01(hue, 240., 300.));\n    col = mix(col, vec3(1, 0, 0), flim_remap01(hue, 300., 360.));\n    \n    return col;\n}\n\nvec3 flim_rgb_exposure_sweep_test(vec2 uv0to1)\n{\n    float hue = 1. - uv0to1.y;\n    float exposure = flim_remap(uv0to1.x, 0., 1., -5., 10.);\n    return flim_rgb_sweep(hue) * pow(2., exposure);\n}\n\n// https://www.desmos.com/calculator/khkztixyeu\nfloat flim_super_sigmoid(\n    float v,\n    float toe_x,\n    float toe_y,\n    float shoulder_x,\n    float shoulder_y\n)\n{\n    // clip\n    v = clamp(v, 0., 1.);\n    toe_x = clamp(toe_x, 0., 1.);\n    toe_y = clamp(toe_y, 0., 1.);\n    shoulder_x = clamp(shoulder_x, 0., 1.);\n    shoulder_y = clamp(shoulder_y, 0., 1.);\n\n    // calculate straight line slope\n    float slope = (shoulder_y - toe_y) / (shoulder_x - toe_x);\n\n    // toe\n    if (v < toe_x)\n    {\n        float toe_pow = slope * toe_x / toe_y;\n        return toe_y * pow(v / toe_x, toe_pow);\n    }\n\n    // straight line\n    if (v < shoulder_x)\n    {\n        float intercept = toe_y - (slope * toe_x);\n        return slope * v + intercept;\n    }\n\n    // shoulder\n    float shoulder_pow =\n        -slope / (\n            ((shoulder_x - 1.) / pow(1. - shoulder_x, 2.))\n            * (1. - shoulder_y)\n        );\n    return\n        (1. - pow(1. - (v - shoulder_x) / (1. - shoulder_x), shoulder_pow))\n        * (1. - shoulder_y)\n        + shoulder_y;\n}\n\nfloat flim_dye_mix_factor(float mono, float max_density)\n{\n    // log2 and map range\n    float offset = pow(2., flim_sigmoid_log2_min);\n    float fac = flim_remap01(\n        log2(mono + offset),\n        flim_sigmoid_log2_min,\n        flim_sigmoid_log2_max\n    );\n\n    // calculate amount of exposure from 0 to 1\n    fac = flim_super_sigmoid(\n        fac,\n        flim_sigmoid_toe_x,\n        flim_sigmoid_toe_y,\n        flim_sigmoid_shoulder_x,\n        flim_sigmoid_shoulder_y\n    );\n\n    // calculate dye density\n    fac *= max_density;\n\n    // mix factor\n    fac = pow(2., -fac);\n\n    // clip and return\n    return clamp(fac, 0., 1.);\n}\n\nvec3 flim_rgb_color_layer(\n    vec3 col,\n    vec3 sensitivity_tone,\n    vec3 dye_tone,\n    float max_density\n)\n{\n    // normalize\n    vec3 sensitivity_tone_norm =\n        sensitivity_tone / flim_rgb_sum(sensitivity_tone);\n    vec3 dye_tone_norm = dye_tone / flim_rgb_max(dye_tone);\n\n    // dye mix factor\n    float mono = dot(col, sensitivity_tone_norm);\n    float mix_fac = flim_dye_mix_factor(mono, max_density);\n\n    // dye mixing\n    return mix(dye_tone_norm, vec3(1), mix_fac);\n}\n\nvec3 flim_rgb_develop(vec3 col, float exposure, float max_density)\n{\n    // exposure\n    col *= pow(2., exposure);\n\n    // blue-sensitive layer\n    vec3 result = flim_rgb_color_layer(\n        col,\n        vec3(0, 0, 1),\n        vec3(1, 1, 0),\n        max_density\n    );\n\n    // green-sensitive layer\n    result *= flim_rgb_color_layer(\n        col,\n        vec3(0, 1, 0),\n        vec3(1, 0, 1),\n        max_density\n    );\n\n    // red-sensitive layer\n    result *= flim_rgb_color_layer(\n        col,\n        vec3(1, 0, 0),\n        vec3(0, 1, 1),\n        max_density\n    );\n\n    return result;\n}\n\nvec3 flim_gamut_extension_mat_row(\n    float primary_hue,\n    float scale,\n    float rotate,\n    float mul\n)\n{\n    vec3 result = flim_blender_hsv_to_rgb(vec3(\n        flim_wrap(primary_hue + (rotate / 360.), 0., 1.),\n        1. / scale,\n        1.\n    ));\n    result /= flim_rgb_sum(result);\n    result *= mul;\n    return result;\n}\n\nmat3 flim_gamut_extension_mat(\n    float red_scale,\n    float green_scale,\n    float blue_scale,\n    float red_rot,\n    float green_rot,\n    float blue_rot,\n    float red_mul,\n    float green_mul,\n    float blue_mul\n)\n{\n    mat3 m;\n    m[0] = flim_gamut_extension_mat_row(\n        0.,\n        red_scale,\n        red_rot,\n        red_mul\n    );\n    m[1] = flim_gamut_extension_mat_row(\n        1. / 3.,\n        green_scale,\n        green_rot,\n        green_mul\n    );\n    m[2] = flim_gamut_extension_mat_row(\n        2. / 3.,\n        blue_scale,\n        blue_rot,\n        blue_mul\n    );\n    return m;\n}\n\nvec3 negative_and_print(vec3 col, vec3 backlight_ext)\n{\n    // develop negative\n    col = flim_rgb_develop(\n        col,\n        flim_negative_film_exposure,\n        flim_negative_film_density\n    );\n\n    // backlight\n    col *= backlight_ext;\n\n    // develop print\n    col = flim_rgb_develop(\n        col,\n        flim_print_film_exposure,\n        flim_print_film_density\n    );\n\n    return col;\n}\n\n// the flim transform\n\nvec3 flim_transform(vec3 col, float exposure, bool convert_to_srgb)\n{\n    // eliminate negative values\n    col = max(col, 0.);\n\n    // pre-Exposure\n    col *= pow(2., flim_pre_exposure + exposure);\n\n    // clip very large values for float precision issues\n    col = min(col, 5000.);\n\n    // gamut extension matrix (Linear BT.709)\n    mat3 extend_mat = flim_gamut_extension_mat(\n        flim_extended_gamut_red_scale,\n        flim_extended_gamut_green_scale,\n        flim_extended_gamut_blue_scale,\n        flim_extended_gamut_red_rot,\n        flim_extended_gamut_green_rot,\n        flim_extended_gamut_blue_rot,\n        flim_extended_gamut_red_mul,\n        flim_extended_gamut_green_mul,\n        flim_extended_gamut_blue_mul\n    );\n    mat3 extend_mat_inv = inverse(extend_mat);\n\n    // backlight in the extended gamut\n    vec3 backlight_ext = flim_print_backlight * extend_mat;\n\n    // upper limit in the print (highlight cap)\n    const float big = 10000000.;\n    vec3 white_cap = negative_and_print(vec3(big, big, big), backlight_ext);\n\n    // pre-formation filter\n    col = mix(\n        col,\n        col * flim_pre_formation_filter,\n        flim_pre_formation_filter_strength\n    );\n\n    // convert to the extended gamut\n    col *= extend_mat;\n\n    // negative & print\n    col = negative_and_print(col, backlight_ext);\n\n    // convert from the extended gamut\n    col *= extend_mat_inv;\n\n    // eliminate negative values\n    col = max(col, 0.);\n\n    // white cap\n    col /= white_cap;\n\n    // black cap (-1 = auto)\n    if (flim_black_point == -1.)\n    {\n        vec3 black_cap = negative_and_print(vec3(0.), backlight_ext);\n        black_cap /= white_cap;\n        col = flim_rgb_uniform_offset(\n            col,\n            flim_rgb_avg(black_cap) * 1000.,\n            0.\n        );\n    }\n    else\n    {\n        col = flim_rgb_uniform_offset(col, flim_black_point, 0.);\n    }\n\n    // post-formation filter\n    col = mix(\n        col,\n        col * flim_post_formation_filter,\n        flim_post_formation_filter_strength\n    );\n\n    // clip\n    col = clamp(col, 0., 1.);\n\n    // midtone saturation\n    float mono = flim_rgb_avg(col);\n    float mix_fac =\n        (mono < .5)\n        ? flim_remap01(mono, .05, .5)\n        : flim_remap01(mono, .95, .5);\n    col = mix(\n        col,\n        flim_blender_hue_sat(col, .5, flim_midtone_saturation, 1.),\n        mix_fac\n    );\n\n    // clip\n    col = clamp(col, 0., 1.);\n\n    // OETF\n    if (convert_to_srgb)\n    {\n        col = oetf_pow(col, 2.2);\n    }\n\n    return col;\n}\n\n/*____________________ end ____________________*/\n",
     "name": "Common",
     "description": "",
     "type": "common"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "vec2 mainSound(int samp, float t)\n{\n    return audio_signal(t);\n}\n",
     "name": "Sound",
     "description": "",
     "type": "sound"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "4cVcR1",
    "date": "1731504376",
    "viewed": 106,
    "name": "Color Transformation Utilities",
    "description": "The \"Image\" tab simply alternates between mixing different colors in Oklab vs Linear BT.709 I-D65.\n\nThe \"Common\" tab contains transformations for common gamuts, white points, and transfer functions. Also includes Oklab.\n",
    "likes": 4,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "color",
     "rgb",
     "function",
     "gamma",
     "linear",
     "xyz",
     "matrix",
     "transform",
     "srgb",
     "p3",
     "transfer",
     "rec709",
     "bt2020",
     "rec",
     "709",
     "bt709"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGRn",
       "filepath": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg",
       "type": "texture",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4dfGRn",
       "filepath": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg",
       "type": "texture",
       "channel": 1,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "void mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    vec2 uv01 = frag_coord / iResolution.xy;\n\n    vec3 a_bt709 = mix(\n        vec3(1, 0, 1),\n        vec3(0, 0, 1),\n        step(1. / 6., uv01.x)\n    );\n    a_bt709 = mix(a_bt709, vec3(1, 0, 0), step(2. / 6., uv01.x));\n    a_bt709 = mix(a_bt709, vec3(0, 1, 0), step(3. / 6., uv01.x));\n    a_bt709 = mix(a_bt709, vec3(1, 1, 0), step(4. / 6., uv01.x));\n    a_bt709 = mix(a_bt709, vec3(1, 0, 0), step(5. / 6., uv01.x));\n    \n    vec3 b_bt709 = mix(\n        vec3(0, 0, 1),\n        vec3(1),\n        step(1. / 6., uv01.x)\n    );\n    b_bt709 = mix(b_bt709, vec3(1, 0, 1), step(2. / 6., uv01.x));\n    b_bt709 = mix(b_bt709, vec3(1), step(3. / 6., uv01.x));\n    b_bt709 = mix(b_bt709, vec3(0, 0, 1), step(4. / 6., uv01.x));\n    b_bt709 = mix(b_bt709, vec3(0, 1, 1), step(5. / 6., uv01.x));\n    \n    float mix_fac = smoothstep(.05, .95, uv01.y);\n    \n    vec3 col_bt709 = vec3(0);\n    if (mod(iTime, 1.8) > .9)\n    {\n        // mix in Linear BT.709 I-D65\n        col_bt709 = mix(a_bt709, b_bt709, mix_fac);\n    }\n    else\n    {\n        // mix in Oklab\n        \n        vec3 a_oklab = linear_xyz_id65_to_oklab(\n            a_bt709 * bt709_id65_to_xyz_id65\n        );\n        \n        vec3 b_oklab = linear_xyz_id65_to_oklab(\n            b_bt709 * bt709_id65_to_xyz_id65\n        );\n        \n        vec3 col_oklab = mix(\n            a_oklab,\n            b_oklab,\n            mix_fac\n        );\n        \n        col_bt709 =\n            oklab_to_linear_xyz_id65(col_oklab)\n            * xyz_id65_to_bt709_id65;\n    }\n    \n    vec3 col_srgb = linear_bt709_id65_to_srgb(col_bt709);\n    frag_col = vec4(col_srgb, 1);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "// color transformation utilities\n// source: https://www.shadertoy.com/view/4cVcR1\n// ------------------------------------------------------------\n\n// transformation matrices between gamuts or whitepoints\n// * these matrices are row-major but GLSL and OpenGL use\n//   column-major. to fix this you can just multiply your\n//   vector by the matrix (v * mat) instead of the opposite\n//   (mat * v).\n// ------------------------------------------------------------\n\n// Linear BT.709 I-D65 <-> Linear CIE-XYZ I-D65\nconst mat3 xyz_id65_to_bt709_id65 = mat3(\n    3.2410032329763587, -1.5373989694887855, -.4986158819963629,\n    -.9692242522025164, 1.8759299836951759, .0415542263400847,\n    .0556394198519755, -.2040112061239099, 1.0571489771875333\n);\nconst mat3 bt709_id65_to_xyz_id65 = inverse(xyz_id65_to_bt709_id65);\n\n// Linear BT.709 I-E <-> Linear CIE-XYZ I-E\nconst mat3 xyz_ie_to_bt709_ie = mat3(\n    2.6896551724137931, -1.2758620689655173, -.4137931034482757,\n    -1.0221081721279115, 1.9782866166600865, .0438215554678247,\n    .0612244897959184, -.2244897959183672, 1.1632653061224481\n);\nconst mat3 bt709_ie_to_xyz_ie = inverse(xyz_ie_to_bt709_ie);\n\n// Linear Linear DCI-P3 I-D65 <-> Linear CIE-XYZ I-D65\nconst mat3 xyz_id65_to_dcip3_id65 = mat3(\n    2.4935091239346101, -.9313881794047790, -.4027127567416516,\n    -.8294732139295544, 1.7626305796003032, .0236242371055886,\n    .0358512644339181, -.0761839369220759, .9570295866943110\n);\nconst mat3 dcip3_id65_to_xyz_id65 = inverse(xyz_id65_to_dcip3_id65);\n\n// Linear Linear DCI-P3 I-E <-> Linear CIE-XYZ I-E\nconst mat3 xyz_ie_to_dcip3_ie = mat3(\n    2.1506740681998422, -.8033306899286285, -.3473433782712135,\n    -.8669410150891632, 1.8422496570644722, .0246913580246913,\n    .0391091797935906, -.0831070070613798, 1.0439978272677890\n);\nconst mat3 dcip3_ie_to_xyz_ie = inverse(xyz_ie_to_dcip3_ie);\n\n// Linear BT.2020 I-D65 <-> Linear CIE-XYZ I-D65\nconst mat3 xyz_id65_to_bt2020_id65 = mat3(\n    1.7166634277958805, -.3556733197301399, -.2533680878902478,\n    -.6666738361988869, 1.6164557398246981, .0157682970961337,\n    .0176424817849772, -.0427769763827532, .9422432810184308\n);\nconst mat3 bt2020_id65_to_xyz_id65 = inverse(xyz_id65_to_bt2020_id65);\n\n// Linear BT.2020 I-E <-> Linear CIE-XYZ I-E\nconst mat3 xyz_ie_to_bt2020_ie = mat3(\n    1.5498639396171363, -.3211143451931252, -.2287495944240111,\n    -.6904600461999933, 1.6741291531150519, .0163308930849413,\n    .0192370654890717, -.0466432957748727, 1.0274062302858002\n);\nconst mat3 bt2020_ie_to_xyz_ie = inverse(xyz_ie_to_bt2020_ie);\n\n// Linear CIE-XYZ I-D65 <-> Linear CIE-XYZ I-E\nconst mat3 xyz_id65_to_xyz_ie = mat3(\n    1.0502616, .0270757, -.0232523,\n    .0390650, .9729502, -.0092579,\n    -.0024047,.0026446, .9180873\n);\nconst mat3 xyz_ie_to_xyz_id65 = inverse(xyz_id65_to_xyz_ie);\n\n// transfer functions for non-linear color spaces:\n// opto-electronic transfer function (OETF) to go from scene\n// to display, and electro-optical transfer function (EOTF) for\n// the opposite.\n// ------------------------------------------------------------\n\n// OETF: Linear BT.709 I-D65 -> sRGB\nvec3 linear_bt709_id65_to_srgb(vec3 v)\n{\n    v = clamp(v, 0., 1.);\n    return mix(\n        12.92 * v,\n        pow(v, vec3(1. / 2.4) * 1.055 - .055),\n        step(.0031308, v)\n    );\n}\n\n// EOTF: sRGB -> Linear BT.709 I-D65\nvec3 srgb_to_linear_bt709_id65(vec3 v)\n{\n    v = clamp(v, 0., 1.);\n    return mix(\n        v * .07739938080495356,\n        pow((v + .055) * .9478672985781990521327, vec3(2.4)),\n        step(.040449936, v)\n    );\n}\n\n// OETF: Linear DCI-P3 I-D65 -> Display P3\nvec3 linear_dcip3_id65_to_displayp3(vec3 v)\n{\n    return linear_bt709_id65_to_srgb(v);\n}\n\n// EOTF: Display P3 -> Linear DCI-P3 I-D65\nvec3 displayp3_to_linear_dcip3_id65(vec3 v)\n{\n    return srgb_to_linear_bt709_id65(v);\n}\n\n// OETF: Linear BT.2020 I-D65 -> BT.2020\nvec3 linear_bt2020_id65_to_bt2020(vec3 v)\n{\n    const float alpha = 1.09929682680944;\n    const float beta = .018053968510807;\n    \n    v = clamp(v, 0., 1.);\n    return mix(\n        4.5 * v,\n        alpha * pow(v, vec3(.45)) - (alpha - 1.),\n        step(beta, v)\n    );\n}\n\n// EOTF: BT.2020 -> Linear BT.2020 I-D65\nvec3 bt2020_to_linear_bt2020_id65(vec3 v)\n{\n    const float alpha = 1.09929682680944;\n    const float beta = .018053968510807;\n    \n    v = clamp(v, 0., 1.);\n    return mix(\n        v / 4.5,\n        pow((v + alpha - 1.) / alpha, vec3(1. / .45)),\n        step(4.5 * beta, v)\n    );\n}\n\n// Oklab: perceptual color space for image processing\n// https://bottosson.github.io/posts/oklab/\n// ------------------------------------------------------------\n\n// Linear CIE-XYZ I-D65 -> Oklab\nvec3 linear_xyz_id65_to_oklab(vec3 v)\n{\n    const mat3 m1 = mat3(\n        .8189330101, .3618667424, -.1288597137,\n        .0329845436, .9293118715, .0361456387,\n        .0482003018, .2643662691, .6338517070\n    );\n    \n    const mat3 m2 = mat3(\n        .2104542553, .7936177850, -.0040720468,\n        1.9779984951, -2.4285922050, .4505937099,\n        .0259040371, .7827717662, -.8086757660\n    );\n    \n    return pow(v * m1, vec3(1. / 3.)) * m2;\n}\n\n// Oklab -> Linear CIE-XYZ I-D65\nvec3 oklab_to_linear_xyz_id65(vec3 v)\n{\n    const mat3 m1_inv = mat3(\n        1.22701, -.5578, .281256,\n        -.0405802, 1.11226, -.0716767,\n        -.0763813, -.421482, 1.58616\n    );\n    \n    const mat3 m2_inv = mat3(\n        1., .396338, .215804,\n        1., -.105561, -.0638542,\n        1., -.0894842, -1.29149\n    );\n    \n    return pow(v * m2_inv, vec3(3.)) * m1_inv;\n}\n\n// end of color transformation utilities\n// ------------------------------------------------------------\n",
     "name": "Common",
     "description": "",
     "type": "common"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "lctBRn",
    "date": "1732646179",
    "viewed": 172,
    "name": "Springy Ball (Pos Vel Acc Jerk)",
    "description": "drag mouse.\nplay with INTEGRATION_MODE in Buffer A.",
    "likes": 4,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "mouse",
     "fun",
     "ball",
     "derivative",
     "position",
     "velocity",
     "spring",
     "integration",
     "euler",
     "acceleration",
     "springy"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "const vec3 col_bg = vec3(.95, .8, .6);\nconst vec3 col_ball = vec3(.8, .06, .04);\nconst float ball_radius = .18;\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    // UV\n    vec2 uv = (2. * frag_coord - iResolution.xy) / min(iResolution.x, iResolution.y);\n    float uv2px = 2. / min(iResolution.x, iResolution.y);\n    \n    // get ball position\n    vec2 ball_pos = texelFetch(iChannel0, ivec2(0, 0), 0).xy;\n    \n    // render\n    float sd = distance(uv, ball_pos) - ball_radius;\n    vec3 col = mix(col_bg, col_ball, remap01(sd, uv2px, 0.));\n    \n    // output\n    col = pow(col, vec3(1. / 2.2));\n    frag_col = vec4(col, 1);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "float remap01(float x, float start, float end)\n{\n    return clamp((x - start) / (end - start), 0., 1.);\n}\n",
     "name": "Common",
     "description": "",
     "type": "common"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "// pixel (0, 0) stores ball position, (1, 0) stores velocity,\n// (2, 0) stores acceleration, (3, 0) stores jerk.\n\n// possible values for integration mode\n#define POS 0              /* 0th order */\n#define VELOCITY 1         /* 1st order */\n#define ACCELERATION 2     /* 2nd order */\n#define JERK 3             /* 3rd order */\n\n// change integration mode here\n#define INTEGRATION_MODE 3\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    // reset to 0 in the first frame\n    if (iFrame < 2 || iTime < .02)\n    {\n        frag_col = vec4(0);\n        return;\n    }\n    \n    // skip out-of-bounds pixels\n    if (int(frag_coord.x) > 3 || int(frag_coord.y) > 0)\n    {\n        return;\n    }\n    \n    // retrieve previous values\n    vec2 pos = texelFetch(iChannel0, ivec2(0, 0), 0).xy;\n    vec2 vel = texelFetch(iChannel0, ivec2(1, 0), 0).xy;\n    vec2 acc = texelFetch(iChannel0, ivec2(2, 0), 0).xy;\n    vec2 jerk = texelFetch(iChannel0, ivec2(3, 0), 0).xy;\n    \n    // get mouse position, (0, 0) if mouse isn't pressed.\n    vec2 mouse_uv = vec2(0);\n    if (iMouse.z > .5)\n    {\n        mouse_uv = (2. * iMouse.xy - iResolution.xy) / min(iResolution.x, iResolution.y);\n    }\n    \n    // update and integrate\n    #if INTEGRATION_MODE == POS\n        pos = mouse_uv;\n    #elif INTEGRATION_MODE == VELOCITY\n        vel = 10. * (mouse_uv - pos);\n        pos += vel * iTimeDelta;\n    #elif INTEGRATION_MODE == ACCELERATION\n        acc = 80. * (mouse_uv - pos);\n        vel += acc * iTimeDelta;\n        vel *= pow(.01, iTimeDelta); // velocity damping\n        pos += vel * iTimeDelta;\n    #elif INTEGRATION_MODE == JERK\n        jerk = 1600. * (mouse_uv - pos);\n        acc += jerk * iTimeDelta;\n        acc *= pow(.000001, iTimeDelta); // acceleration damping\n        vel += acc * iTimeDelta;\n        vel *= pow(.0001, iTimeDelta); // velocity damping\n        pos += vel * iTimeDelta;\n    #endif\n    \n    // store new values\n    ivec2 icoord = ivec2(frag_coord);\n    if (icoord == ivec2(0, 0)) frag_col = vec4(pos, 0, 0);\n    if (icoord == ivec2(1, 0)) frag_col = vec4(vel, 0, 0);\n    if (icoord == ivec2(2, 0)) frag_col = vec4(acc, 0, 0);\n    if (icoord == ivec2(3, 0)) frag_col = vec4(jerk, 0, 0);\n}\n",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "4cyfRV",
    "date": "1734325673",
    "viewed": 2870,
    "name": "Neural Cat",
    "description": "deep neural network trained to produce cat meme video",
    "likes": 34,
    "published": "Public API",
    "usePreview": 1,
    "tags": [
     "learning",
     "cat",
     "deep",
     "ai",
     "machine",
     "neural",
     "network",
     "ann",
     "dnn"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// 267498000 training steps\n\n// the following code is generated by a custom C++ program.\n// ********************************************************\n\n#define NN_FLOAT_FROM_VEC4_ARR(arr, idx) ((arr)[(idx) / 4][(idx) % 4])\n\nfloat nn_activation_layer1(float v)\n{\n    return max(v, v * .01);\n}\n\nfloat nn_activation_layer2(float v)\n{\n    return max(v, v * .01);\n}\n\nfloat nn_activation_layer3(float v)\n{\n    return max(v, v * .01);\n}\n\nfloat nn_activation_layer4(float v)\n{\n    return max(v, v * .01);\n}\n\nfloat nn_activation_layer5(float v)\n{\n    return max(v, v * .01);\n}\n\nfloat nn_activation_layer6(float v)\n{\n    return max(v, v * .01);\n}\n\nfloat nn_activation_layer7(float v)\n{\n    return max(v, v * .01);\n}\n\nfloat nn_activation_layer8(float v)\n{\n    return tanh(v);\n}\n\nconst float nn_layer1_biases[20] = float[](-.3611,-2.0311,4.1073,4.5148,-.706,-7.4206,.4229,.6671,-1.3021,-.1018,-.2504,3.0776,-3.5487,-.3458,.8638,-.2039,1.1917,-.5629,-1.9945,-.1258);\nconst vec4 nn_layer1_weights[15] = vec4[](vec4(5.8009,-4.825,-.0281,-4.7525),vec4(13.0144,.0217,-15.1145,1.3382),vec4(.0112,.1276,-8.8556,.0149),vec4(-.8878,-.2363,.7505,11.2985),vec4(2.4499,-.0379,-2.0342,.6499),vec4(-.4999,-3.5248,-1.5821,.0024),vec4(.9412,1.6246,-.2985,-.6615),vec4(.2449,-.4542,-8.7376,7.3295),vec4(.0768,-3.6369,-7.0764,0.),vec4(3.7905,7.1298,.0132,-.0745),vec4(-.3039,-1.3436,5.1134,-9.1721),vec4(-.0123,-.5792,-.2984,-.6741),vec4(1.857,-14.7906,.0091,.3655),vec4(-.1887,-.8804,8.1218,-6.7568),vec4(.0052,.1642,-.7212,-2.8365));\n\nconst float nn_layer2_biases[20] = float[](-13.9675,-4.1089,-8.9789,3.4968,3.481,-.2818,-10.5206,-3.2406,2.6992,-6.6669,-.7749,6.7832,-2.3729,-6.0968,.8974,2.6362,-11.7608,-.096,-5.0265,-.392);\nconst vec4 nn_layer2_weights[100] = vec4[](vec4(1.8023,3.4692,-2.4552,5.177),vec4(-.1798,1.8319,.462,1.0783),vec4(-.458,-.491,2.6178,.5036),vec4(.9198,.7822,-1.2003,.7973),vec4(1.5684,-.0579,-.4338,.1684),vec4(-.4039,-2.074,3.0218,-.1329),vec4(-1.6819,-3.5798,-.1101,.2086),vec4(-.7245,.267,-.2187,-2.1443),vec4(-3.4143,-.267,.2926,-.0348),vec4(1.2899,-.4864,2.9813,.9246),vec4(-2.4054,1.3823,.1249,1.1372),vec4(-.7686,2.0707,.3704,-.5784),vec4(-.7758,.597,2.6984,1.6283),vec4(-.2749,.718,.8429,.2308),vec4(-1.999,1.5965,1.9275,.1208),vec4(.1401,-.6942,-.7551,-1.3639),vec4(.7218,-1.303,.0202,.3639),vec4(.1354,-.1007,.749,-.5252),vec4(1.5909,-.7738,1.3673,-.659),vec4(.93,-.01,3.3848,.1986),vec4(-.7524,2.0784,-2.7851,.0569),vec4(-.3662,-2.644,-.1227,1.2104),vec4(-.2518,-.9764,-.6387,2.0914),vec4(.7005,.6638,1.1029,.5785),vec4(4.6423,-.411,-.4638,.9322),vec4(-.6413,-1.2302,-.0594,-.3057),vec4(1.0275,.3879,1.4757,.8321),vec4(.2688,-.6845,-.9359,.2354),vec4(-.5209,.2913,.1705,.116),vec4(.0216,.3964,.086,1.3033),vec4(-.7404,1.7915,.213,1.0841),vec4(-.7687,-.4673,.099,-2.4883),vec4(-.6059,-.3938,.2376,3.5655),vec4(2.9047,.2703,-1.0808,1.0339),vec4(3.2539,.9278,-1.6352,.3097),vec4(-2.6071,1.0057,-2.3221,2.1477),vec4(1.0373,.3187,.1835,-.1981),vec4(.4038,.2202,-3.356,-1.9391),vec4(1.7819,.0814,1.2468,.6297),vec4(-2.5321,.4066,-1.1189,.3796),vec4(4.1084,-3.7418,2.7609,-.6676),vec4(-.296,-1.1956,.2207,.7659),vec4(-.7964,.5363,3.1521,-.7553),vec4(-1.021,.329,.7914,.3154),vec4(2.3032,.0463,1.0087,1.083),vec4(.5817,-.1,-1.9374,-.1276),vec4(-.2253,-3.8443,.6966,.5821),vec4(-.6507,.2525,2.4979,1.2004),vec4(1.4229,-.2599,-.0614,.7059),vec4(-1.3931,-.1553,-.6478,-1.1919),vec4(1.3667,.1911,.3258,.6008),vec4(.4631,-1.9048,-.1303,-.5206),vec4(-.6842,-.5442,-1.2528,-.7986),vec4(-2.9819,-.7966,1.5688,.2691),vec4(-3.6334,-.4715,3.2226,.2824),vec4(-.4588,.4076,.8051,-2.0478),vec4(.3656,-.3125,-.0478,-.8464),vec4(-.1668,-.2372,.1123,-1.3909),vec4(-1.037,.2548,1.5228,-.3202),vec4(2.0939,.5486,-.9198,-.1296),vec4(1.129,-.7886,-7.9139,-1.8342),vec4(-.438,-5.5665,1.5321,.1691),vec4(-.8203,-.2245,.2706,.5296),vec4(4.4748,.2918,-1.93,-.6363),vec4(.0558,-.3136,-1.9822,.6535),vec4(-2.4349,-.8862,1.1956,-.6207),vec4(.7702,1.8548,.2005,.8187),vec4(.3872,-1.3947,-.474,1.189),vec4(.4877,1.2008,.6133,-.9296),vec4(4.5358,-.1603,3.4481,-.9425),vec4(-1.1213,-.317,.941,-1.8369),vec4(-.2191,-.4682,-.0508,-.0594),vec4(.8166,-.1545,-.3591,.1212),vec4(-4.8228,.4088,.0808,.2636),vec4(-.7757,.5791,.5134,-.1934),vec4(-.8984,-1.6263,1.3236,-1.5573),vec4(-1.2842,-5.3267,.2059,-1.0744),vec4(-1.0064,-.3344,1.0602,-4.3234),vec4(3.2126,.2469,-1.2031,-.6531),vec4(.139,-.8149,-1.2761,1.0022),vec4(3.6522,1.8944,2.6728,-.9494),vec4(.8568,.6459,.305,-1.6808),vec4(-.9019,.3145,.9152,.9641),vec4(.7383,.4581,-.294,-.1347),vec4(-.2376,.3402,2.3611,.994),vec4(-.2528,.0495,.9307,.5325),vec4(.4286,.8298,.1739,.5851),vec4(-.5622,.582,1.4355,-1.2397),vec4(-1.5047,.4932,1.9741,.2017),vec4(-5.0004,-.4941,3.1887,-.2162),vec4(2.8355,-.3964,-.0169,-3.5853),vec4(1.0343,1.8795,-.3517,-.7225),vec4(-.3213,-.3721,-.2261,-.3157),vec4(-.1429,-.3562,.6736,-.2324),vec4(-1.6117,.1527,1.1327,-2.4103),vec4(-2.1097,.3782,-1.4002,2.7897),vec4(-.4862,.3338,.0584,.8288),vec4(.5269,-.0668,.984,-1.9645),vec4(1.9234,.2683,.1898,-.5814),vec4(-1.9123,-1.0291,-1.0989,1.5998));\n\nconst float nn_layer3_biases[20] = float[](-2.1351,-1.9443,2.1868,-2.0107,-.5219,-3.7355,.3967,-.7176,-2.3665,-3.2388,-1.0154,-.2478,2.8007,.1974,-.5521,-.6989,-1.6749,-1.6259,-1.4038,-.7335);\nconst vec4 nn_layer3_weights[100] = vec4[](vec4(-1.4272,.5486,-.1632,-1.8111),vec4(.1674,-.4648,-1.2111,-4.7977),vec4(-4.7404,.5732,.0338,-1.1594),vec4(.0286,1.2493,.1631,-.2648),vec4(2.0332,-2.3815,4.1024,-.3242),vec4(1.4847,-1.3065,.5898,2.7499),vec4(-5.0812,-.0358,2.043,-.6694),vec4(.2028,-.94,-1.5241,-3.1554),vec4(-.7443,1.0395,-.1082,-.4289),vec4(.8672,-1.7595,-.8323,-.5962),vec4(.7059,.0855,-2.1196,.353),vec4(.4275,-.4983,-1.1844,-.3122),vec4(.4129,-1.6141,-1.3087,1.0353),vec4(.0165,-.8631,-.7065,-.7608),vec4(1.3268,.3957,-1.5789,.1472),vec4(.4387,-1.3834,4.5737,-1.0133),vec4(-.4199,1.0892,1.6884,1.371),vec4(.6494,.2005,3.4659,-2.6787),vec4(-2.7882,-1.8702,-.6498,-1.0147),vec4(-2.8253,-.9166,-2.4447,-2.3012),vec4(-.445,-.1286,.397,-.2593),vec4(-.7924,-.3839,-.6292,-1.0396),vec4(-1.7594,.031,-.0382,-2.2757),vec4(-1.2745,.1008,.4863,-1.047),vec4(1.2645,-1.0827,-.2765,-1.9021),vec4(-.8813,-1.3567,.3533,-.9346),vec4(.0103,1.1165,-.4366,1.3364),vec4(.662,-2.0883,.9723,1.2216),vec4(-.0852,.8206,1.3844,.4941),vec4(1.4541,.0614,-.0063,.6533),vec4(.0719,1.2238,.1456,.69),vec4(-1.7123,.5447,-1.3241,.5363),vec4(-.386,-.3638,3.1181,.2926),vec4(-.0717,-1.7378,1.0853,.1105),vec4(-.9908,-.246,-.1436,-.3641),vec4(-.1703,-.5378,-1.1565,2.0873),vec4(-.5416,-.2303,.7598,-.6233),vec4(.465,-2.5013,-.2003,.2469),vec4(-.3463,-.563,.0516,-1.4698),vec4(-.109,-1.1517,-.4425,1.1136),vec4(-1.4487,-1.1824,-1.3413,-.3302),vec4(.2536,.0978,1.1801,2.4359),vec4(1.0992,.4791,-.0041,-3.071),vec4(.2652,-.3302,-.1225,-1.53),vec4(-1.5218,2.187,.7587,-.9676),vec4(.3368,3.6519,.7607,.4893),vec4(.6033,-.0368,.7218,-1.3781),vec4(-.8712,-2.5275,2.5199,.4726),vec4(-.0823,-.2498,-1.3404,-1.7295),vec4(1.9763,-1.4874,.1679,.5906),vec4(-.9851,2.2962,2.6063,-1.1131),vec4(.4349,.4728,-2.4785,-.5334),vec4(.0013,.3235,-.7672,-.3521),vec4(-1.1675,4.2866,.5235,-.4754),vec4(.6127,-2.2304,-.1174,-1.3223),vec4(-.3015,-.2302,-.4261,-.4679),vec4(.4579,-.6023,-.3315,-.0003),vec4(-.8017,.0166,.0965,-1.4877),vec4(-.522,1.0323,-.2183,.1514),vec4(-.8344,.3043,.3007,.0672),vec4(-.1277,-.9923,.1961,-.0204),vec4(.2051,-.999,-.2153,.7864),vec4(-.1877,-.7787,-.1162,1.0111),vec4(2.1898,.7328,.4566,-.7524),vec4(.7687,-.3107,-.0894,.0932),vec4(-1.1,-.8364,.6809,-2.9044),vec4(1.9402,.0598,-2.2546,1.4083),vec4(.5159,.7032,-.7434,-1.5073),vec4(-1.682,-.3013,.1712,-1.051),vec4(-.971,-.6303,-1.0734,-1.0405),vec4(.4719,1.1935,2.1067,2.3105),vec4(-3.2754,-.7791,-.3368,.0617),vec4(-1.2104,-1.8516,1.2089,-2.1359),vec4(-.309,-1.3949,-.4529,2.419),vec4(1.5439,.352,-1.4029,1.7094),vec4(-.0319,-2.2996,.261,2.3068),vec4(1.359,.1579,.2905,-.6557),vec4(.263,-1.859,.5915,-.2931),vec4(-2.3285,-1.9259,-.0592,1.4526),vec4(.4356,-.693,-.9157,-.9636),vec4(1.7209,2.839,-1.2719,-1.6752),vec4(-.5439,-.5619,-1.5731,-1.8132),vec4(-.7509,2.7415,-2.0527,.6626),vec4(-1.0708,-1.0412,-2.8386,.4352),vec4(2.137,.8553,-.5577,.5451),vec4(-5.285,1.2666,-.1116,-.0364),vec4(-.1618,-.195,-4.9815,2.151),vec4(-.481,.7595,.2192,.3343),vec4(-.5273,.6554,1.0977,.3129),vec4(1.5772,.0559,2.146,-.9916),vec4(.8755,-.8557,2.0361,-2.4182),vec4(.1558,-.1007,1.1913,-1.0151),vec4(-.3392,-.5612,-1.8459,-2.7666),vec4(.2602,-.7249,1.149,-1.2684),vec4(-.847,-1.7839,-1.9118,-1.2063),vec4(-.2117,-.5178,.8336,-1.319),vec4(-.4719,.0658,1.066,-.1782),vec4(-.0144,-.8705,-.7035,-1.0048),vec4(-1.0876,1.7471,.1277,.0082),vec4(.2663,.416,.3249,-2.7031));\n\nconst float nn_layer4_biases[20] = float[](-.3238,.0479,-1.3015,-1.1098,-4.6034,.1028,-1.9551,-4.9769,-1.9071,-3.0101,-7.2682,-2.6194,7.3633,-2.4327,-1.552,-1.0557,-4.311,1.8969,1.0542,-.7656);\nconst vec4 nn_layer4_weights[100] = vec4[](vec4(.3311,1.2941,-1.0945,-.2184),vec4(.7823,1.2264,1.0745,-.3203),vec4(-.4455,-.3446,.7721,-1.4181),vec4(-1.9318,-.1321,-.6219,-.4464),vec4(.2152,1.5772,-.0077,.6985),vec4(.457,-.036,.4859,.0727),vec4(1.4362,.3268,-.3477,-2.4247),vec4(-.6788,-1.211,.2654,.0952),vec4(-3.3889,-.408,1.9589,-2.3704),vec4(1.2513,.2363,-.4892,-.0949),vec4(-.7143,.7037,-.1645,.2046),vec4(-1.2194,.647,-.1649,.1977),vec4(.6366,1.1021,.8548,-.3459),vec4(.7761,.9901,-1.0678,.0515),vec4(-.2956,.0542,.0669,-1.1054),vec4(-1.2665,2.6061,-2.2448,1.0551),vec4(-.1817,.0997,-1.0414,-.8459),vec4(.3706,-1.7581,-.7578,.938),vec4(-.407,-.9309,-.8767,1.5304),vec4(.671,-.1693,-.7012,-.3068),vec4(-3.2612,-.3443,-.5558,-.3105),vec4(1.2039,-.167,.3367,1.3094),vec4(1.4536,-.5997,1.9903,-1.167),vec4(.1148,-.3966,-.5098,.5032),vec4(.0592,1.1652,-.2544,-1.1316),vec4(-.1633,.3672,-.2295,-.1495),vec4(-.1584,.7092,-1.3025,.5044),vec4(-.4699,.4969,.3441,1.1041),vec4(-.5626,1.6585,.4266,-.257),vec4(1.7195,-.1934,.2921,.3205),vec4(1.3689,.1628,1.0273,-.7378),vec4(.0967,.9617,1.4806,.4827),vec4(-.4372,1.124,2.5245,.4199),vec4(-.4423,1.3773,1.0384,-1.2797),vec4(-.4152,-1.3128,.1024,.4889),vec4(.3117,.3401,1.303,1.0214),vec4(1.4885,-.6708,.896,-.5971),vec4(-.4635,.0505,.9497,.7242),vec4(-2.4775,.3522,.9179,-.2052),vec4(-.0753,-1.053,-.7907,.677),vec4(-1.9605,-.1218,.7427,-1.1204),vec4(-.8255,1.5351,.9816,1.1392),vec4(.2396,.4045,-.8282,.1414),vec4(-3.244,-1.052,1.2555,-2.6272),vec4(.4654,-.0298,.886,-.5982),vec4(-1.7041,-.0006,-1.3919,-1.9882),vec4(.5421,.2933,-.1778,.3712),vec4(.8694,1.1794,-1.0439,.0794),vec4(.3113,1.7187,.0977,-1.6004),vec4(-1.6398,.5084,3.0392,1.1505),vec4(1.1935,-1.1697,-.0396,.0778),vec4(.8753,1.9103,-.1422,-1.4074),vec4(-1.4193,.0897,-1.4298,.3982),vec4(-.2113,-.2283,-.5145,-.199),vec4(.6034,.635,-.4692,.4515),vec4(2.7195,1.5837,-.841,-.0468),vec4(.0643,.9019,-3.1116,.1091),vec4(.2876,-.0515,1.647,-.3925),vec4(.7426,.2986,-.2407,-2.0122),vec4(.5999,.404,1.54,-1.5833),vec4(-.8387,1.1889,1.3228,-.95),vec4(-.7494,1.2139,1.9759,-2.1863),vec4(.9949,-2.5412,1.6318,-.0385),vec4(-1.0278,1.5483,-.6588,-1.4742),vec4(-1.254,.7451,.0361,-.1578),vec4(-.3481,-.9699,-.4486,.937),vec4(.3371,-1.6647,1.0929,-.1201),vec4(-1.5955,-1.793,-1.502,.2337),vec4(-.0312,-.105,.2478,1.5238),vec4(.5918,-1.4118,.6533,.5433),vec4(.0228,2.3206,-.0197,.7775),vec4(-.2371,.922,1.1034,-2.6894),vec4(-.2,.3558,2.1246,-.1054),vec4(-1.4755,-.1896,-.9196,-1.1153),vec4(-.6977,.0955,.3915,-1.7188),vec4(-.4977,.6182,-2.2036,.658),vec4(.7432,.0173,.0831,.0084),vec4(-3.5867,.5533,.54,.9604),vec4(-.4502,.4073,-.1888,-1.1344),vec4(.3026,2.4335,-1.3194,-.7927),vec4(.1084,-.4381,.2055,-.4621),vec4(1.1274,.1633,-1.3446,-.8101),vec4(.9251,.983,1.3195,-.6184),vec4(-.9555,-.3481,.3878,.9248),vec4(.4443,-2.4605,-.7386,-.1242),vec4(.3156,1.8992,.4055,-1.4141),vec4(-.3424,1.3265,.8365,.3699),vec4(.3227,-.1484,-.3417,.1698),vec4(-.6749,-.44,-1.3526,.5439),vec4(-2.0379,-1.7244,-1.0788,-.1782),vec4(1.2705,-.523,1.0732,.6848),vec4(1.9485,-.1047,.1114,-.2091),vec4(.1,-.4888,1.0456,.613),vec4(-.3388,-.6368,.4948,.4988),vec4(.9804,.8616,.4159,-.5001),vec4(-.6758,.5693,1.0232,-.6979),vec4(-.6269,.1389,.3389,-.0291),vec4(-.8571,-.3759,-3.2632,-.5023),vec4(.181,-1.3096,-.273,1.0621),vec4(-.3064,-1.2667,-.5514,.3412));\n\nconst float nn_layer5_biases[20] = float[](-1.6373,.391,-1.1819,1.0817,-.9721,-.4432,.5637,-.5738,-.2967,-2.5513,7.9286,4.0455,-5.0623,-1.4453,-1.4508,-.1383,.6532,-.6526,-.2272,-.1388);\nconst vec4 nn_layer5_weights[100] = vec4[](vec4(.1535,-.5078,-.2234,.2687),vec4(.9174,.2065,.6813,-.5889),vec4(.313,-.1117,.7155,-.2964),vec4(-.4909,.7137,-.2641,.7567),vec4(-.1161,.6637,.141,-.7406),vec4(-1.2427,-.6409,-.859,-.7373),vec4(-1.045,-.6784,1.2393,-.9135),vec4(-.4665,-1.2951,1.2778,-.6766),vec4(-.4913,.7688,-.4085,-1.1482),vec4(-1.2974,-2.2851,.2467,-1.4068),vec4(-1.0899,-.083,-1.1216,.5664),vec4(.2911,.6371,-2.4201,-1.5054),vec4(-1.2356,1.7166,-.0219,.982),vec4(-.823,-.4389,-1.0606,.4909),vec4(-1.1583,-1.6697,-1.458,1.4517),vec4(.0034,.9655,-.7964,-.2911),vec4(-.4278,.8438,-1.7434,-.2246),vec4(-2.5522,-1.2035,.0629,.9106),vec4(-2.8277,-.3512,-3.2324,-.8573),vec4(.0022,.424,.648,-.3424),vec4(.2355,.5347,-1.675,-.4258),vec4(.2679,-3.4371,-.4157,.8387),vec4(.2643,-.3037,.3875,.5718),vec4(.9891,-.7224,.8062,-.935),vec4(-1.3532,-.8137,-1.9284,2.2856),vec4(-.3623,.9327,-.0734,-.4777),vec4(.4495,-.0496,.3634,.1218),vec4(-.1196,-1.2648,1.0713,-1.2081),vec4(.5538,.7483,-.0556,.6416),vec4(-2.7964,-.3412,-1.2854,-.3328),vec4(.6227,-.0017,-.2377,-.6808),vec4(1.8486,-.9915,.2549,-.0048),vec4(.6013,.9313,1.47,-2.2378),vec4(.7255,.3101,.4078,-.8034),vec4(-1.3766,-1.1628,-1.8904,-.3898),vec4(1.1451,-1.4665,.43,-2.2963),vec4(.8162,.3623,.5045,-.3263),vec4(1.0085,-.9277,-.5036,-2.2346),vec4(.6664,-.3454,-.554,.9336),vec4(-1.8449,-.9181,.4772,-1.8118),vec4(.3055,-.2441,-2.2377,-.2443),vec4(.6419,-1.9088,.2035,-.1696),vec4(1.021,1.5522,.5234,-3.4979),vec4(-.0071,1.0587,-.5959,.197),vec4(-.4584,.2703,-.9976,-1.7274),vec4(-.0461,.1676,-1.4707,1.7017),vec4(-.3818,.3477,-.0785,-.8236),vec4(-.7271,-.5936,.2512,-1.4662),vec4(.2848,-1.0103,.5303,.9797),vec4(1.3647,-.6499,.8815,-1.4737),vec4(-1.0368,-1.9628,.5566,.4266),vec4(-.9303,-.6505,-.0337,-1.8194),vec4(1.3759,-.0406,1.2794,-.8616),vec4(-2.2837,1.2096,-1.0106,1.6153),vec4(-2.8681,.4167,.2145,-.1867),vec4(1.568,-1.4386,.2449,.1391),vec4(-.4515,1.0426,.2503,-.5257),vec4(-.3257,.148,-1.4649,-.4564),vec4(-.4122,-.5041,-.8164,-.9667),vec4(-.0281,-.0751,1.2147,-.3177),vec4(.5231,.2909,.4662,-.3266),vec4(.979,-.227,.5878,-.5051),vec4(-.0811,.3126,.1335,-.1732),vec4(-.1165,.1645,.0912,-.5272),vec4(-.0741,-.3049,.2691,.1937),vec4(.2335,1.6542,.9601,1.0277),vec4(-.618,-1.0005,-.4875,-1.7016),vec4(.3378,.1247,.7307,.3102),vec4(-1.8426,-.3711,-.1573,-.1731),vec4(-.3477,1.1488,.41,-1.8673),vec4(.8203,-.4214,1.5387,-.0468),vec4(.1002,.7375,-.5432,.9899),vec4(.8505,-1.0287,-.8105,.4785),vec4(.8769,.249,.1455,-1.2603),vec4(-.7676,-.0593,-.0921,-.062),vec4(.2947,-.0136,-1.3228,.7247),vec4(-1.357,1.376,-.1511,2.1083),vec4(-1.6383,-.643,.1451,-.7375),vec4(-.4991,-.87,.7007,.7742),vec4(-.3164,-.2016,-.3058,-.3123),vec4(.0972,1.4419,1.0834,-.0756),vec4(-.8687,-.2191,-1.5768,.991),vec4(-.723,-.8447,-.2235,-.6715),vec4(.407,-1.437,-.6312,.6481),vec4(.1415,.8658,-.2528,-2.0591),vec4(.7857,.5376,-.1918,-1.4574),vec4(-.3379,.1449,-5.1687,-1.1814),vec4(1.2281,-1.0143,-3.0804,.8131),vec4(.4616,-.8964,-1.2944,.1793),vec4(-.7243,-1.4013,-1.7638,.4489),vec4(-.3494,1.9023,-1.4255,.0877),vec4(-1.3448,-.6299,.2283,-.3757),vec4(-1.0053,-.8966,1.8931,.1261),vec4(-2.6043,-.3099,.113,-.2571),vec4(-.8919,-.2095,-.8243,.9984),vec4(-2.477,-.775,-.0031,-1.3297),vec4(.2292,.7962,-1.9675,.5564),vec4(.7827,1.1988,1.3075,-.29),vec4(-.1306,-.3523,.1091,-.2309),vec4(-.4204,.5161,-.7981,.4563));\n\nconst float nn_layer6_biases[20] = float[](-1.1818,-.3173,-.1664,5.2154,.0427,-3.1139,1.3828,-1.1546,-.0077,-1.6457,-.6838,2.8506,4.2215,-.9794,2.4433,-.0003,3.6427,-1.3001,.3791,-1.3122);\nconst vec4 nn_layer6_weights[100] = vec4[](vec4(.3977,-.1329,-1.0332,.0324),vec4(.9753,.8613,-1.0419,.7619),vec4(.0907,.5134,.2495,-.9843),vec4(-.753,.359,-.4813,-1.1491),vec4(.8161,-.3343,-.7904,.0703),vec4(-.7178,.1965,.4124,1.2161),vec4(.0392,.2173,-.144,.3689),vec4(.6059,1.0434,-.0711,-1.7769),vec4(.6733,1.7289,-3.4992,-.8009),vec4(.0699,-.1552,-.562,.3159),vec4(-1.3136,.2795,-.6413,.0339),vec4(-.8084,.0309,-.7504,-.8047),vec4(-.62,.4049,-1.6821,-.2746),vec4(-1.4755,1.3863,-.6341,-.7291),vec4(.5447,-.4736,-1.5837,.8868),vec4(-.0792,-1.0222,-.7123,.2572),vec4(.5476,-1.522,-.0401,.1399),vec4(-.215,.3421,-.3723,-.3241),vec4(.1483,.451,.1828,-.0467),vec4(-.0053,-.7123,-.3762,.0104),vec4(-.1679,.7778,-.3176,-.8608),vec4(.4206,-1.1702,.2,.7157),vec4(-.2934,.6514,-1.1213,-1.0015),vec4(-.418,-.1614,-.7392,.4513),vec4(-.3377,-.5722,-.5856,-1.1321),vec4(.2192,-.2834,.051,.0962),vec4(-.036,1.1281,.3507,-.1633),vec4(-.5686,.1938,-.2391,.242),vec4(-.1622,.5349,.2731,-.5395),vec4(-.5769,-.6159,.3986,.2011),vec4(-1.675,-1.2091,-.6794,.2986),vec4(-.7123,-.3814,-.318,-1.0059),vec4(-.1526,.8328,.8341,-.7282),vec4(.9814,.3157,-1.0261,-.5471),vec4(-.724,.335,.4856,.2777),vec4(-.2989,.0659,-.0096,-.3965),vec4(.4873,.6371,.2641,-.2586),vec4(-1.7965,-.2503,-.0361,.3222),vec4(.2995,.0879,.2029,.4885),vec4(.0124,-.3718,-.3967,.4708),vec4(-1.4434,.9301,-1.7165,-.3865),vec4(1.2929,.8574,.5392,-.5459),vec4(2.9098,1.3843,-.1416,-1.3129),vec4(-.8138,-.0942,.7253,.652),vec4(.6246,.3263,-1.0655,-.0346),vec4(.2626,-.31,-.4392,-.3942),vec4(.8161,.1266,-.5506,.2871),vec4(.0531,-.3497,.099,.3088),vec4(.1839,-.2304,-.4719,.506),vec4(.5648,1.2209,.0433,.4169),vec4(.2932,-.9497,.4183,.4455),vec4(.2497,.0741,-.3216,-.3499),vec4(-1.4151,.5765,-.0266,-.6828),vec4(-.9185,-.417,.1752,-.8686),vec4(.1315,-1.8533,-.5609,.3952),vec4(.0264,-1.5454,-.6833,.3833),vec4(-.3309,-.6738,.1811,.0261),vec4(.6515,.1022,.2038,-.2169),vec4(-2.9104,-.3203,.5005,-1.0583),vec4(-.2502,.6107,.2984,.5851),vec4(.5224,-.0031,.4995,-.5484),vec4(.4856,.9085,.6431,.0762),vec4(-.3598,-.3482,-.556,.364),vec4(-.3014,-.3253,-.8222,.4826),vec4(1.0179,-.5774,.5895,-.2099),vec4(-.7938,-.8829,.2242,-.1765),vec4(-.6422,1.1187,.8386,.2855),vec4(-.9686,.6237,1.1733,-1.0753),vec4(-.6098,.1761,-.95,-.1953),vec4(.6917,.6009,-.0556,.4474),vec4(-1.8777,-1.5751,.1169,.1512),vec4(.6409,-.7738,-1.6786,1.0111),vec4(.4413,-1.4267,1.0337,1.5155),vec4(-.9859,1.1014,-1.2467,.5413),vec4(.681,-.862,-.6672,-1.5116),vec4(-.7772,.7193,-1.0003,-.3259),vec4(-.3752,-1.327,-.1119,.5173),vec4(.2842,.0102,.3872,-1.0412),vec4(-1.5224,.6364,.0682,1.0548),vec4(-.0241,.5662,.2766,-1.0831),vec4(.3698,-.8321,.9477,.2458),vec4(-.4409,1.0743,-.3159,.412),vec4(-.3012,-.3209,.3319,.0579),vec4(-.4719,.091,.1327,.4288),vec4(-.241,-1.7166,.907,-.2707),vec4(-1.7995,.1529,.5301,-.7423),vec4(-1.1727,-.2256,.3474,-.983),vec4(.3296,.2523,1.503,.5226),vec4(-1.6265,.6622,-.4735,-.659),vec4(.4025,.2684,-.4405,-.4708),vec4(.4538,-.3311,.2084,-.535),vec4(.4277,-.5975,.1283,-.0698),vec4(.045,.5005,.2553,.3231),vec4(-.3946,-.0665,.2105,-.9099),vec4(.6567,1.0636,.5456,.182),vec4(.3274,-.2511,-.5732,-.3533),vec4(1.2133,-.1215,.632,.5769),vec4(.7831,-.258,.7749,-.0113),vec4(-1.5083,.1176,-1.1316,-.3496),vec4(.2842,-.0133,.0205,.4771));\n\nconst float nn_layer7_biases[20] = float[](-.6147,-2.2302,.5188,-1.4794,.7686,-.7765,.196,-.3564,.6664,-1.0028,3.1203,2.2729,-.4188,1.3959,-.9423,.1024,.768,-1.9623,.3232,-.1179);\nconst vec4 nn_layer7_weights[100] = vec4[](vec4(.6008,1.8764,.3664,-.299),vec4(-.0759,.9471,.0615,-.3586),vec4(-.1263,.3884,-.3082,-.263),vec4(-.0669,.3014,.0157,.0425),vec4(-.7451,-.0072,-.7527,-.2051),vec4(-1.3753,-.2764,-.0037,-.3751),vec4(-.5398,-.4803,-.3421,-.1514),vec4(-.2015,-1.8356,.0617,.5274),vec4(-.3133,-.0084,.505,-.2001),vec4(-.2022,-.6722,.1521,1.1008),vec4(.2019,.5271,.3512,-.2375),vec4(-.0923,-.049,-.236,.3407),vec4(.1949,-.0718,-.3678,.3082),vec4(-.2284,.5627,.2768,-.4833),vec4(-.3173,-.1517,-.1825,-.5261),vec4(-.2977,-2.3869,-1.5113,-.2588),vec4(-.287,.0301,.0067,-.3468),vec4(-1.3941,.3565,.0974,-.2148),vec4(-.1784,.2151,-.1589,-.93),vec4(-.3915,.0439,.0019,-.0416),vec4(-.496,-.069,-.1044,-.1541),vec4(-.3171,-.9875,.0487,-.0524),vec4(-.1266,-.1441,.003,.1631),vec4(-.6357,-.9292,-.1408,-.4378),vec4(-.0729,-.6304,-.0125,-.6838),vec4(-.6072,.2187,.3464,-.8561),vec4(.0751,-.2408,.8007,-.8663),vec4(-1.6141,.2893,-.3403,.3165),vec4(-.6033,-1.2109,.1594,.0979),vec4(.3047,-.4664,-.0123,-.0929),vec4(-.3384,-.7285,.6466,-.1502),vec4(-1.2615,.0211,.2225,-.1735),vec4(.2011,.2698,-.0411,-.033),vec4(-.2451,-.5938,.0727,-.1743),vec4(.0658,-.1379,.0866,.294),vec4(.2534,.6147,.1774,-.2141),vec4(.4485,.6254,-1.0358,-.504),vec4(-.8678,-.0494,.0117,.0781),vec4(.0079,1.3003,-.21,.2994),vec4(-.3325,-.2042,-.5611,.297),vec4(-.3617,.9549,.38,-.1571),vec4(-1.9093,-1.1896,.1284,.1968),vec4(-.0472,.3423,.7511,.3386),vec4(.0816,-.129,-.026,-.4863),vec4(.2184,-.1593,-.8593,-.0211),vec4(-.0027,.6413,.426,.0441),vec4(.0076,.3519,.0649,-.2969),vec4(-.6097,-.5208,-1.3331,-1.0074),vec4(.2838,-.0677,-.0164,-.0421),vec4(-.7533,-.1955,-.67,.4217),vec4(-.0471,-1.0638,-1.2337,-.1004),vec4(-.0522,.0425,-.3442,-.2346),vec4(.1519,-.0227,-.6802,-.5067),vec4(.2356,-.5879,.1431,.3564),vec4(-.213,-.074,-.2208,.3384),vec4(-.0119,1.8237,-.453,.1353),vec4(.1324,-.1558,.0923,-.4723),vec4(-.1759,-.0809,-.2262,-1.3797),vec4(.1287,.2603,.0265,-.2423),vec4(-.0942,-2.1223,-.0877,-.1092),vec4(-.4077,-1.2289,1.6646,-.0383),vec4(.1717,-.3471,-.7847,-.2296),vec4(-.4344,-.5067,.1351,-1.9288),vec4(.1797,-.5418,-.7472,1.1881),vec4(-.0916,-.1449,-.5128,.2067),vec4(-.036,.9398,.3782,.3373),vec4(.5649,-.4862,.1625,-.5568),vec4(-.7854,.0163,-.0814,-.0631),vec4(-.0676,.1011,-.5333,-.5129),vec4(-.2779,.024,-.0473,.1058),vec4(.2746,.3652,.8415,.134),vec4(-.3637,-.3515,-.0958,-.2731),vec4(-.0145,-.185,-.8115,.5031),vec4(.3016,-.2202,.3377,-.3889),vec4(-.1197,-.0295,-.022,-.3962),vec4(-.521,.1807,.481,.266),vec4(.1361,-.3126,.039,-.3364),vec4(.3315,.3281,.3318,.5711),vec4(.1193,.2507,.028,-.5562),vec4(.0075,.2753,-.819,-.8067),vec4(-.1275,-.4593,-.0666,.2489),vec4(1.0903,-.4913,-.6063,.1817),vec4(0.,-.4519,-.447,-.0036),vec4(.1774,.2234,-.0876,-.1928),vec4(-.1504,.3826,-.4938,.1282),vec4(-.1894,1.6804,.7341,-.0643),vec4(.9668,-.3329,-.2892,.3248),vec4(.1606,-.0373,-.112,.6346),vec4(-.4428,-.2626,.3028,-.325),vec4(-.2424,-1.6273,-.1865,.3404),vec4(-.0273,-.6879,1.5784,.4401),vec4(.1171,-.3529,.3802,-.8824),vec4(-.944,-.1606,.0406,-.0942),vec4(.1642,-.4051,-.543,.4952),vec4(-.073,.8301,-.1026,-.0807),vec4(.2872,-.5357,-.8453,.3492),vec4(.0652,-.5143,-.2217,-.4505),vec4(-.4705,-.1736,-.086,.1691),vec4(-.0439,1.1776,-.4684,.3263),vec4(-.4074,.4233,-.0978,-.5536));\n\nconst float nn_layer8_biases[3] = float[](.0035,-.0044,-.0055);\nconst vec4 nn_layer8_weights[15] = vec4[](vec4(.0957,.1283,.1161,-.0446),vec4(.1878,.0735,.048,.0357),vec4(.1,-.1049,.0511,.0709),vec4(-1.2025,.1849,-.0644,.0731),vec4(.0923,-.0361,.0868,-.1521),vec4(.0405,.0867,.0499,-.0499),vec4(-.0096,.0555,.0479,.2528),vec4(.0731,-.0909,.0569,.0609),vec4(-.8781,.0171,-.0476,.088),vec4(.0525,-.0695,-.1692,.2865),vec4(.029,.0426,.03,-.0582),vec4(.0038,.0435,.0431,.3384),vec4(.0461,-.0747,.0488,.0798),vec4(-.7446,.0223,-.0377,.0997),vec4(.0372,-.0597,-.1744,.1613));\n\nvec3 sample_nn(vec2 uv, float time)\n{\n    #define nn_input arr0\n    #define nn_output arr0\n\n    float arr0[20], arr1[20];\n\n    // put input layer values in the first 3 elements in the nn_input array.\n    nn_input[0] = uv.x;\nnn_input[1] = uv.y;\nnn_input[2] = time;\n\n    // layer 0 to 1 (sizes: 3 -> 20)\n    for (int n = 0; n < 20; n++)\n    {\n        float sum = 0.;\n        for (int pn = 0; pn < 3; pn++)\n        {\n            sum += arr0[pn] * NN_FLOAT_FROM_VEC4_ARR(\n                nn_layer1_weights,\n                pn + (n * 3)\n            );\n        }\n        sum += nn_layer1_biases[n];\n        arr1[n] = nn_activation_layer1(sum);\n    }\n\n    // layer 1 to 2 (sizes: 20 -> 20)\n    for (int n = 0; n < 20; n++)\n    {\n        float sum = 0.;\n        for (int pn = 0; pn < 20; pn++)\n        {\n            sum += arr1[pn] * NN_FLOAT_FROM_VEC4_ARR(\n                nn_layer2_weights,\n                pn + (n * 20)\n            );\n        }\n        sum += nn_layer2_biases[n];\n        arr0[n] = nn_activation_layer2(sum);\n    }\n\n    // layer 2 to 3 (sizes: 20 -> 20)\n    for (int n = 0; n < 20; n++)\n    {\n        float sum = 0.;\n        for (int pn = 0; pn < 20; pn++)\n        {\n            sum += arr0[pn] * NN_FLOAT_FROM_VEC4_ARR(\n                nn_layer3_weights,\n                pn + (n * 20)\n            );\n        }\n        sum += nn_layer3_biases[n];\n        arr1[n] = nn_activation_layer3(sum);\n    }\n\n    // layer 3 to 4 (sizes: 20 -> 20)\n    for (int n = 0; n < 20; n++)\n    {\n        float sum = 0.;\n        for (int pn = 0; pn < 20; pn++)\n        {\n            sum += arr1[pn] * NN_FLOAT_FROM_VEC4_ARR(\n                nn_layer4_weights,\n                pn + (n * 20)\n            );\n        }\n        sum += nn_layer4_biases[n];\n        arr0[n] = nn_activation_layer4(sum);\n    }\n\n    // layer 4 to 5 (sizes: 20 -> 20)\n    for (int n = 0; n < 20; n++)\n    {\n        float sum = 0.;\n        for (int pn = 0; pn < 20; pn++)\n        {\n            sum += arr0[pn] * NN_FLOAT_FROM_VEC4_ARR(\n                nn_layer5_weights,\n                pn + (n * 20)\n            );\n        }\n        sum += nn_layer5_biases[n];\n        arr1[n] = nn_activation_layer5(sum);\n    }\n\n    // layer 5 to 6 (sizes: 20 -> 20)\n    for (int n = 0; n < 20; n++)\n    {\n        float sum = 0.;\n        for (int pn = 0; pn < 20; pn++)\n        {\n            sum += arr1[pn] * NN_FLOAT_FROM_VEC4_ARR(\n                nn_layer6_weights,\n                pn + (n * 20)\n            );\n        }\n        sum += nn_layer6_biases[n];\n        arr0[n] = nn_activation_layer6(sum);\n    }\n\n    // layer 6 to 7 (sizes: 20 -> 20)\n    for (int n = 0; n < 20; n++)\n    {\n        float sum = 0.;\n        for (int pn = 0; pn < 20; pn++)\n        {\n            sum += arr0[pn] * NN_FLOAT_FROM_VEC4_ARR(\n                nn_layer7_weights,\n                pn + (n * 20)\n            );\n        }\n        sum += nn_layer7_biases[n];\n        arr1[n] = nn_activation_layer7(sum);\n    }\n\n    // layer 7 to 8 (sizes: 20 -> 3)\n    for (int n = 0; n < 3; n++)\n    {\n        float sum = 0.;\n        for (int pn = 0; pn < 20; pn++)\n        {\n            sum += arr1[pn] * NN_FLOAT_FROM_VEC4_ARR(\n                nn_layer8_weights,\n                pn + (n * 20)\n            );\n        }\n        sum += nn_layer8_biases[n];\n        arr0[n] = nn_activation_layer8(sum);\n    }\n\n    // the first 3 values in the nn_output array contain the output values in the last \n    // layer.\n    return vec3(nn_output[0], nn_output[1], nn_output[2]);\n\n    #undef nn_input\n    #undef nn_output\n}\n\n// end of generated code\n// ********************************************************\n\n\n\nfloat triangle_wave(float x)\n{\n    float m = mod(x, 1.);\n    if (mod(x, 2.) >= 1.)\n        return 1. - m;\n    else\n        return m;\n}\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    vec2 uv = (2. * frag_coord - iResolution.xy) / iResolution.y;\n    \n    // UV to use for the NN\n    vec2 uv01 = vec2(\n        remap(uv.x, -1.333, 1.333, 0., 1.),\n        remap(uv.y, -1., 1., 0., 1.)\n    );\n    if (any(lessThan(uv01, vec2(0.))) || any(greaterThan(uv01, vec2(1.))))\n    {\n        frag_col = vec4(vec3(0), 1);\n        return;\n    }\n    \n    // sample the neural network\n    vec3 col = sample_nn(\n        uv01,\n        1. - (cos(6.2831853 * iTime / 2.5) * .5 + .5)//triangle_wave(iTime / 2.)\n    );\n    col = max(col, 0.);\n    \n    // OETF (Linear BT.709 I-D65 -> sRGB 2.2)\n    col = pow(col, vec3(1. / 2.2));\n    \n    // output\n    frag_col = vec4(col, 1);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "#define FUNC_REMAP(T) \\\nT remap(T v, float inp_start, float inp_end, float out_start, float out_end) \\\n{ \\\n    return out_start \\\n        + ((out_end - out_start) / (inp_end - inp_start)) * (v - inp_start); \\\n}\n\n#define FUNC_REMAP_CLAMP(T) \\\nT remap_clamp( \\\n    T v, \\\n    float inp_start, \\\n    float inp_end, \\\n    float out_start, \\\n    float out_end \\\n) \\\n{ \\\n    T t = clamp((v - inp_start) / (inp_end - inp_start), 0., 1.); \\\n    return out_start + t * (out_end - out_start); \\\n}\n\n#define FUNC_REMAP01(T) \\\nT remap01(T v, float inp_start, float inp_end) \\\n{ \\\n    return clamp((v - inp_start) / (inp_end - inp_start), 0., 1.); \\\n}\n\nFUNC_REMAP(float)\nFUNC_REMAP(vec2)\nFUNC_REMAP(vec3)\nFUNC_REMAP(vec4)\n\nFUNC_REMAP_CLAMP(float)\nFUNC_REMAP_CLAMP(vec2)\nFUNC_REMAP_CLAMP(vec3)\nFUNC_REMAP_CLAMP(vec4)\n\nFUNC_REMAP01(float)\nFUNC_REMAP01(vec2)\nFUNC_REMAP01(vec3)\nFUNC_REMAP01(vec4)",
     "name": "Common",
     "description": "",
     "type": "common"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "XX3cRn",
    "date": "1734644701",
    "viewed": 160,
    "name": "Film Halation",
    "description": "film halation",
    "likes": 9,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "blur",
     "bloom",
     "film",
     "gaussian",
     "halation"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// ASC CDL color grading\n// https://en.wikipedia.org/wiki/ASC_CDL\nvec3 asc_cdl(vec3 col, vec3 slope, vec3 offset, vec3 power)\n{\n    return pow(max(col, 0.) * slope + offset, power);\n}\n\nvec3 view_transform(vec3 col)\n{\n    // avoid any negative values before using power functions\n    col = max(col, 0.);\n\n    // color grading\n    col = asc_cdl(\n        col,\n        1.1 * vec3(1, .95, .94),\n        vec3(0, 0, .007),\n        vec3(1.04, 1, 1)\n    );\n    \n    // flim\n    const float exposure = 0.;\n    col = flim_transform(col, exposure, false);\n\n    // OETF (Linear BT.709 I-D65 to sRGB 2.2)\n    col = pow(col, vec3(1. / 2.2));\n    col = clamp(col, 0., 1.);\n\n    return col;\n}\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    // bottom left pixel (0, 0) in the buffer stores the\n    // resolution.\n    if (ivec2(frag_coord) == ivec2(0))\n    {\n        frag_col = vec4(0, 0, 0, 1);\n        return;\n    }\n\n    // sample buffer\n    vec4 data = texelFetch(iChannel0, ivec2(frag_coord), 0);\n    vec3 col = data.xyz / max(data.w, 1.);\n\n    // view transform\n    col = view_transform(col);\n\n    // output\n    frag_col = vec4(col, 1);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "float bar_brightness(float u)\n{\n    return pow(remap01(u, -1.4, 1.), 6.) * 140. * step(u, 1.);\n}\n\n// render the bars (original scene without halation)\nvec3 render(vec2 coord)\n{\n    vec2 uv = screen_to_uv_fit(coord, iResolution.xy);\n    if (abs(uv.y - .2) < .1)\n    {\n        return vec3(bar_brightness(uv.x));\n    }\n    else if (abs(uv.y + .2) < .1)\n    {\n        return vec3(bar_brightness(-uv.x));\n    }\n    return vec3(0);\n}\n\n// render the original scene with halation.\n// effectively just blur \"the deep orange channel\" and mix\n// the original image with that.\nvec3 render_with_halation(vec2 coord)\n{\n    vec3 col = render(coord);\n    vec3 col_blurred = render(\n        coord + random_gauss() * .008 * min(iResolution.x, iResolution.y)\n    );\n    return mix(col, col_blurred, .1 * vec3(.9, .1, 0));\n}\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    // initialize PRNG\n    prng_init(vec3(frag_coord / iResolution.y, iTime + float(iFrame)));\n    \n    // bottom left pixel (0, 0) stores the resolution to\n    // detect when it changes.\n    if (ivec2(frag_coord) == ivec2(0))\n    {\n        frag_col = vec4(iResolution.x, iResolution.y, 0, 0);\n        return;\n    }\n    \n    // check if the resolution has changed\n    bool res_changed =\n        length_sq(\n            iResolution.xy - texelFetch(iChannel0, ivec2(0), 0).xy\n        ) > .99;\n    \n    // data from the previous frame. W channel is the total\n    // number of samples accumulated.\n    vec4 prev_data = texelFetch(iChannel0, ivec2(frag_coord), 0);\n    \n    // reset previous data on the first frame or if\n    // the resolution has changed.\n    if (iFrame < 1 || iTime < .02 || prev_data.w < .99 || res_changed)\n    {\n        prev_data = vec4(0);\n    }\n\n    // render with box jitter sampling\n    vec3 col = vec3(0);\n    const int N_SAMPLES = 16;\n    for (int i = 0; i < N_SAMPLES; i++)\n    {\n        col += render_with_halation(\n            frag_coord + vec2(random(), random()) - .5\n        );\n    }\n    col /= float(N_SAMPLES);\n    \n    // output\n    frag_col = vec4(prev_data.rgb + col, prev_data.w + 1.);\n}\n",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "/*___________ math & integer utils ____________*/\n\nconst float PI = 3.141592653589793238462643383;\nconst float TAU = 6.283185307179586476925286767;\nconst float PI_OVER_2 = 1.570796326794896619231321692;\nconst float INV_PI = .318309886183790671537767527;\nconst float INV_TAU = .159154943091895335768883763;\n\n#define FUNC_WRAP(T) \\\nT wrap(T v, float start, float end) \\\n{ \\\n    return start + mod(v - start, end - start); \\\n}\n\n#define FUNC_REMAP(T) \\\nT remap(T v, float inp_start, float inp_end, float out_start, float out_end) \\\n{ \\\n    return out_start \\\n        + ((out_end - out_start) / (inp_end - inp_start)) * (v - inp_start); \\\n}\n\n#define FUNC_REMAP_CLAMP(T) \\\nT remap_clamp( \\\n    T v, \\\n    float inp_start, \\\n    float inp_end, \\\n    float out_start, \\\n    float out_end \\\n) \\\n{ \\\n    T t = clamp((v - inp_start) / (inp_end - inp_start), 0., 1.); \\\n    return out_start + t * (out_end - out_start); \\\n}\n\n#define FUNC_REMAP01(T) \\\nT remap01(T v, float inp_start, float inp_end) \\\n{ \\\n    return clamp((v - inp_start) / (inp_end - inp_start), 0., 1.); \\\n}\n\n#define FUNC_LENGTH_SQ(T) \\\nfloat length_sq(T v) \\\n{ \\\n    return dot(v, v); \\\n}\n\n#define FUNC_DIST_SQ(T) \\\nfloat dist_sq(T a, T b) \\\n{ \\\n    a -= b; \\\n    return dot(a, a); \\\n}\n\nFUNC_WRAP(float)\nFUNC_WRAP(vec2)\nFUNC_WRAP(vec3)\nFUNC_WRAP(vec4)\n\nFUNC_REMAP(float)\nFUNC_REMAP(vec2)\nFUNC_REMAP(vec3)\nFUNC_REMAP(vec4)\n\nFUNC_REMAP_CLAMP(float)\nFUNC_REMAP_CLAMP(vec2)\nFUNC_REMAP_CLAMP(vec3)\nFUNC_REMAP_CLAMP(vec4)\n\nFUNC_REMAP01(float)\nFUNC_REMAP01(vec2)\nFUNC_REMAP01(vec3)\nFUNC_REMAP01(vec4)\n\nFUNC_LENGTH_SQ(vec2)\nFUNC_LENGTH_SQ(vec3)\nFUNC_LENGTH_SQ(vec4)\n\nFUNC_DIST_SQ(vec2)\nFUNC_DIST_SQ(vec3)\nFUNC_DIST_SQ(vec4)\n\nvec2 screen_to_uv01(vec2 coord, vec2 res)\n{\n    return coord / res;\n}\n\nvec2 screen_to_uv_horizontal(vec2 coord, vec2 res)\n{\n    return (2. * coord - res) / res.x;\n}\n\nvec2 screen_to_uv_vertical(vec2 coord, vec2 res)\n{\n    return (2. * coord - res) / res.y;\n}\n\nvec2 screen_to_uv_fit(vec2 coord, vec2 res)\n{\n    return (2. * coord - res) / min(res.x, res.y);\n}\n\nvec2 screen_to_uv_fill(vec2 coord, vec2 res)\n{\n    return (2. * coord - res) / max(res.x, res.y);\n}\n\n\n\n/*_______ pseudo-random number generator ______*/\n// source: https://www.shadertoy.com/view/WdSSRt\n// (heavily modified)\n\n/* usage example:\n    void mainImage(out vec4 frag_col, in vec2 frag_coord)\n    {\n        // initialize PRNG\n        prng_init(vec3(frag_coord / iResolution.y, iTime));\n    \n        // use the function\n        float a = random();\n        vec3 b = vec3(random(), random(), random());\n        \n        ...\n    }\n*/\n\nuint prng_state[2];\n\nuint prng_rot(uint x, int k)\n{\n    return (x << k) | (x >> (32 - k));\n}\n\n// random uint from 0 to 2^32-1\nuint randomui()\n{\n    uint s0 = prng_state[0];\n    uint s1 = prng_state[1];\n    uint result = prng_rot(s0 * 2654435771u, 5) * 5u;\n    s1 ^= s0;\n    prng_state[0] = prng_rot(s0, 26) ^ s1 ^ (s1 << 9);\n    prng_state[1] = prng_rot(s1, 13);\n    return result;\n}\n\n// random int from 0 to 2^31-1\nint randomi()\n{\n    return int(randomui() % 0x7FFFFFFFu);\n}\n\n// random float from 0 to 1\nfloat random()\n{\n    return float(randomui()) / float(0xffffffffu);\n}\n\n// generate two normally distributed random numbers using the\n// Box-Muller transform\n// https://www.baeldung.com/cs/uniform-to-normal-distribution\nvec2 random_gauss()\n{\n    float u1 = random();\n    float u2 = random() * TAU;\n    float temp = sqrt(-2. * log(u1));\n    return temp * vec2(cos(u2), sin(u2));\n    \n    // unoptimized version\n    //float u1 = random();\n    //float u2 = random();\n    //return vec2(cos(TAU * u2), sin(TAU * u2)) * sqrt(-2. * log(u1));\n}\n\nvec2 random_on_circle()\n{\n    vec2 v = vec2(1);\n    float lensqr;\n\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec2(2. * random() - 1., 2. * random() - 1.);\n        lensqr = dot(v, v);\n        if (lensqr == 0.)\n            i--;\n        else if (lensqr <= 1.)\n            break;\n    }\n    return v / sqrt(lensqr);\n}\n\nvec3 random_on_sphere()\n{\n    vec3 v = vec3(1);\n    float lensqr;\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec3(2. * random() - 1., 2. * random() - 1., 2. * random() - 1.);\n        lensqr = dot(v, v);\n        if (lensqr == 0.)\n            i--;\n        else if (lensqr <= 1.)\n            break;\n    }\n    return v / sqrt(lensqr);\n}\n\nvec2 random_in_circle()\n{\n    vec2 v = vec2(1);\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec2(2. * random() - 1., 2. * random() - 1.);\n        if (dot(v, v) <= 1.)\n            return v;\n    }\n    return v;\n}\n\nvec3 random_in_sphere()\n{\n    vec3 v = vec3(1);\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec3(2. * random() - 1., 2. * random() - 1., 2. * random() - 1.);\n        if (dot(v, v) <= 1.)\n            return v;\n    }\n    return v;\n}\n\nvec3 random_on_hemisphere(vec3 normal)\n{\n    vec3 v = random_on_sphere();\n    return v * sign(dot(v, normal));\n}\n\nvec3 random_in_hemisphere(vec3 normal)\n{\n    vec3 v = random_in_sphere();\n    return v * sign(dot(v, normal));\n}\n\n// initialize with uvec2\nvoid prng_init(uvec2 seed)\n{\n    seed += uvec2(1317, 944573125);\n    seed *= 464973573u;\n    prng_state[0] = seed.x;\n    prng_state[1] = seed.y;\n    randomi();\n}\n\n// initialize with uint\nvoid prng_init(uint seed)\n{\n    prng_init(uvec2(seed, 1));\n}\n\n// initialize with vec3\nvoid prng_init(vec3 seed)\n{\n    seed += 3.49276101561702;\n    seed.xy *= (seed.z + 10.258);\n    prng_state[0] = floatBitsToUint(seed.x);\n    prng_state[1] = floatBitsToUint(seed.y);\n    randomui();\n}\n\n// initialize with vec2\nvoid prng_init(vec2 seed)\n{\n    prng_init(vec3(seed, 1));\n}\n\n// initialize with float\nvoid prng_init(float seed)\n{\n    prng_init(vec3(seed, 1, 1));\n}\n\n\n\n/*-----------------------------------------------\n\nflim - Filmic Color Transform\n\nInput Color Space:   Linear BT.709 I-D65\nOutput Color Space:  Linear BT.709 I-D65 / sRGB 2.2 (depends on arguments)\n\nDescription:\n  Experimental port of flim for GLSL/Shadertoy\n  matching flim v1.1.0.\n\nAuthor:\n  Bean (beans_please on Shadertoy)\n\nOriginal Repo:\n  https://github.com/bean-mhm/flim\n\nOriginal Shader:\n  https://www.shadertoy.com/view/dd2yDz\n\n-----------------------------------------------*/\n\n// parameters\n\nconst float flim_pre_exposure = 4.3;\nconst vec3 flim_pre_formation_filter = vec3(1.);\nconst float flim_pre_formation_filter_strength = 0.;\n\nconst float flim_extended_gamut_red_scale = 1.05;\nconst float flim_extended_gamut_green_scale = 1.12;\nconst float flim_extended_gamut_blue_scale = 1.045;\nconst float flim_extended_gamut_red_rot = .5;\nconst float flim_extended_gamut_green_rot = 2.;\nconst float flim_extended_gamut_blue_rot = .1;\nconst float flim_extended_gamut_red_mul = 1.;\nconst float flim_extended_gamut_green_mul = 1.;\nconst float flim_extended_gamut_blue_mul = 1.;\n\nconst float flim_sigmoid_log2_min = -10.;\nconst float flim_sigmoid_log2_max = 22.;\nconst float flim_sigmoid_toe_x = .44;\nconst float flim_sigmoid_toe_y = .28;\nconst float flim_sigmoid_shoulder_x = .591;\nconst float flim_sigmoid_shoulder_y = .779;\n\nconst float flim_negative_film_exposure = 6.;\nconst float flim_negative_film_density = 5.;\n\nconst vec3 flim_print_backlight = vec3(1);\nconst float flim_print_film_exposure = 6.;\nconst float flim_print_film_density = 27.5;\n\nconst float flim_black_point = -1.; // -1 = auto\nconst vec3 flim_post_formation_filter = vec3(1);\nconst float flim_post_formation_filter_strength = 0.;\nconst float flim_midtone_saturation = 1.02;\n\n// color space conversions\n// the matrices below represent data in row-major, but GLSL matrices are in\n// column-major, so we need to multiply a vec3 by a matrix rather than\n// multiplying a matrix by a vec3.\n\nconst mat3 mat_bt2020_to_xyz = mat3(\n     0.6369580483,  0.1446169036,  0.1688809752,\n     0.2627002120,  0.6779980715,  0.0593017165,\n     0.0000000000,  0.0280726930,  1.0609850577\n);\n\nconst mat3 mat_xyz_to_bt2020 = mat3(\n     1.7166511880, -0.3556707838, -0.2533662814,\n    -0.6666843518,  1.6164812366,  0.0157685458,\n     0.0176398574, -0.0427706133,  0.9421031212\n);\n\nconst mat3 mat_bt709_to_xyz = mat3(\n     0.4123907993,  0.3575843394,  0.1804807884,\n     0.2126390059,  0.7151686788,  0.0721923154,\n     0.0193308187,  0.1191947798,  0.9505321522\n);\n\nconst mat3 mat_xyz_to_bt709 = mat3(\n     3.2409699419, -1.5373831776, -0.4986107603,\n    -0.9692436363,  1.8759675015,  0.0415550574,\n     0.0556300797, -0.2039769589,  1.0569715142\n);\n\nconst mat3 mat_dcip3_to_xyz = mat3(\n     0.4451698156,  0.2771344092,  0.1722826698,\n     0.2094916779,  0.7215952542,  0.0689130679,\n     0.0000000000,  0.0470605601,  0.9073553944\n);\n\nconst mat3 mat_xyz_to_dcip3 = mat3(\n     2.7253940305, -1.0180030062, -0.4401631952,\n    -0.7951680258,  1.6897320548,  0.0226471906,\n     0.0412418914, -0.0876390192,  1.1009293786\n);\n\nvec3 oetf_pow(vec3 col, float power)\n{\n    return pow(col, vec3(1. / power));\n}\n\nvec3 eotf_pow(vec3 col, float power)\n{\n    return pow(col, vec3(power));\n}\n\n// flim's utility functions\n\nfloat flim_wrap(float v, float start, float end)\n{\n    return start + mod(v - start, end - start);\n}\n\nfloat flim_remap(\n    float v,\n    float inp_start,\n    float inp_end,\n    float out_start,\n    float out_end\n)\n{\n    return out_start\n        + ((out_end - out_start) / (inp_end - inp_start)) * (v - inp_start);\n}\n\nfloat flim_remap_clamp(\n    float v,\n    float inp_start,\n    float inp_end,\n    float out_start,\n    float out_end\n)\n{\n    float t = clamp((v - inp_start) / (inp_end - inp_start), 0., 1.);\n    return out_start + t * (out_end - out_start);\n}\n\nfloat flim_remap01(\n    float v,\n    float inp_start,\n    float inp_end\n)\n{\n    return clamp((v - inp_start) / (inp_end - inp_start), 0., 1.);\n}\n\nvec3 flim_blender_rgb_to_hsv(vec3 rgb)\n{\n    float cmax, cmin, h, s, v, cdelta;\n    vec3 c;\n\n    cmax = max(rgb[0], max(rgb[1], rgb[2]));\n    cmin = min(rgb[0], min(rgb[1], rgb[2]));\n    cdelta = cmax - cmin;\n\n    v = cmax;\n    if (cmax != 0.)\n    {\n        s = cdelta / cmax;\n    }\n    else\n    {\n        s = 0.;\n        h = 0.;\n    }\n\n    if (s == 0.)\n    {\n        h = 0.;\n    }\n    else\n    {\n        c = (vec3(cmax) - rgb.xyz) / cdelta;\n\n        if (rgb.x == cmax)\n        {\n            h = c[2] - c[1];\n        }\n        else if (rgb.y == cmax)\n        {\n            h = 2. + c[0] - c[2];\n        }\n        else\n        {\n            h = 4. + c[1] - c[0];\n        }\n\n        h /= 6.;\n\n        if (h < 0.)\n        {\n            h += 1.;\n        }\n    }\n\n    return vec3(h, s, v);\n}\n\nvec3 flim_blender_hsv_to_rgb(vec3 hsv)\n{\n    float f, p, q, t, h, s, v;\n    vec3 rgb;\n\n    h = hsv[0];\n    s = hsv[1];\n    v = hsv[2];\n\n    if (s == 0.)\n    {\n        rgb = vec3(v, v, v);\n    }\n    else\n    {\n        if (h == 1.)\n        {\n            h = 0.;\n        }\n\n        h *= 6.;\n        int i = int(floor(h));\n        f = h - float(i);\n        rgb = vec3(f, f, f);\n        p = v * (1. - s);\n        q = v * (1. - (s * f));\n        t = v * (1. - (s * (1. - f)));\n\n        if (i == 0)\n        {\n            rgb = vec3(v, t, p);\n        }\n        else if (i == 1)\n        {\n            rgb = vec3(q, v, p);\n        }\n        else if (i == 2)\n        {\n            rgb = vec3(p, v, t);\n        }\n        else if (i == 3)\n        {\n            rgb = vec3(p, q, v);\n        }\n        else if (i == 4)\n        {\n            rgb = vec3(t, p, v);\n        }\n        else\n        {\n            rgb = vec3(v, p, q);\n        }\n    }\n\n    return rgb;\n}\n\nvec3 flim_blender_hue_sat(vec3 col, float hue, float sat, float value)\n{\n    vec3 hsv = flim_blender_rgb_to_hsv(col);\n\n    hsv[0] = fract(hsv[0] + hue + .5);\n    hsv[1] = clamp(hsv[1] * sat, 0., 1.);\n    hsv[2] = hsv[2] * value;\n\n    return flim_blender_hsv_to_rgb(hsv);\n}\n\nfloat flim_rgb_avg(vec3 col)\n{\n    return (col.x + col.y + col.z) / 3.;\n}\n\nfloat flim_rgb_sum(vec3 col)\n{\n    return col.x + col.y + col.z;\n}\n\nfloat flim_rgb_max(vec3 col)\n{\n    return max(max(col.x, col.y), col.z);\n}\n\nfloat flim_rgb_min(vec3 col)\n{\n    return min(min(col.x, col.y), col.z);\n}\n\nvec3 flim_rgb_uniform_offset(vec3 col, float black_point, float white_point)\n{\n    float mono = flim_rgb_avg(col);\n    float mono2 = flim_remap01(\n        mono, black_point / 1000.,\n        1. - (white_point / 1000.)\n    );\n    return col * (mono2 / mono);\n}\n\nvec3 flim_rgb_sweep(float hue)\n{\n    hue = flim_wrap(hue * 360., 0., 360.);\n\n    vec3 col = vec3(1, 0, 0);\n    col = mix(col, vec3(1, 1, 0), flim_remap01(hue, 0., 60.));\n    col = mix(col, vec3(0, 1, 0), flim_remap01(hue, 60., 120.));\n    col = mix(col, vec3(0, 1, 1), flim_remap01(hue, 120., 180.));\n    col = mix(col, vec3(0, 0, 1), flim_remap01(hue, 180., 240.));\n    col = mix(col, vec3(1, 0, 1), flim_remap01(hue, 240., 300.));\n    col = mix(col, vec3(1, 0, 0), flim_remap01(hue, 300., 360.));\n    \n    return col;\n}\n\nvec3 flim_rgb_exposure_sweep_test(vec2 uv0to1)\n{\n    float hue = 1. - uv0to1.y;\n    float exposure = flim_remap(uv0to1.x, 0., 1., -5., 10.);\n    return flim_rgb_sweep(hue) * pow(2., exposure);\n}\n\n// https://www.desmos.com/calculator/khkztixyeu\nfloat flim_super_sigmoid(\n    float v,\n    float toe_x,\n    float toe_y,\n    float shoulder_x,\n    float shoulder_y\n)\n{\n    // clip\n    v = clamp(v, 0., 1.);\n    toe_x = clamp(toe_x, 0., 1.);\n    toe_y = clamp(toe_y, 0., 1.);\n    shoulder_x = clamp(shoulder_x, 0., 1.);\n    shoulder_y = clamp(shoulder_y, 0., 1.);\n\n    // calculate straight line slope\n    float slope = (shoulder_y - toe_y) / (shoulder_x - toe_x);\n\n    // toe\n    if (v < toe_x)\n    {\n        float toe_pow = slope * toe_x / toe_y;\n        return toe_y * pow(v / toe_x, toe_pow);\n    }\n\n    // straight line\n    if (v < shoulder_x)\n    {\n        float intercept = toe_y - (slope * toe_x);\n        return slope * v + intercept;\n    }\n\n    // shoulder\n    float shoulder_pow =\n        -slope / (\n            ((shoulder_x - 1.) / pow(1. - shoulder_x, 2.))\n            * (1. - shoulder_y)\n        );\n    return\n        (1. - pow(1. - (v - shoulder_x) / (1. - shoulder_x), shoulder_pow))\n        * (1. - shoulder_y)\n        + shoulder_y;\n}\n\nfloat flim_dye_mix_factor(float mono, float max_density)\n{\n    // log2 and map range\n    float offset = pow(2., flim_sigmoid_log2_min);\n    float fac = flim_remap01(\n        log2(mono + offset),\n        flim_sigmoid_log2_min,\n        flim_sigmoid_log2_max\n    );\n\n    // calculate amount of exposure from 0 to 1\n    fac = flim_super_sigmoid(\n        fac,\n        flim_sigmoid_toe_x,\n        flim_sigmoid_toe_y,\n        flim_sigmoid_shoulder_x,\n        flim_sigmoid_shoulder_y\n    );\n\n    // calculate dye density\n    fac *= max_density;\n\n    // mix factor\n    fac = pow(2., -fac);\n\n    // clip and return\n    return clamp(fac, 0., 1.);\n}\n\nvec3 flim_rgb_color_layer(\n    vec3 col,\n    vec3 sensitivity_tone,\n    vec3 dye_tone,\n    float max_density\n)\n{\n    // normalize\n    vec3 sensitivity_tone_norm =\n        sensitivity_tone / flim_rgb_sum(sensitivity_tone);\n    vec3 dye_tone_norm = dye_tone / flim_rgb_max(dye_tone);\n\n    // dye mix factor\n    float mono = dot(col, sensitivity_tone_norm);\n    float mix_fac = flim_dye_mix_factor(mono, max_density);\n\n    // dye mixing\n    return mix(dye_tone_norm, vec3(1), mix_fac);\n}\n\nvec3 flim_rgb_develop(vec3 col, float exposure, float max_density)\n{\n    // exposure\n    col *= pow(2., exposure);\n\n    // blue-sensitive layer\n    vec3 result = flim_rgb_color_layer(\n        col,\n        vec3(0, 0, 1),\n        vec3(1, 1, 0),\n        max_density\n    );\n\n    // green-sensitive layer\n    result *= flim_rgb_color_layer(\n        col,\n        vec3(0, 1, 0),\n        vec3(1, 0, 1),\n        max_density\n    );\n\n    // red-sensitive layer\n    result *= flim_rgb_color_layer(\n        col,\n        vec3(1, 0, 0),\n        vec3(0, 1, 1),\n        max_density\n    );\n\n    return result;\n}\n\nvec3 flim_gamut_extension_mat_row(\n    float primary_hue,\n    float scale,\n    float rotate,\n    float mul\n)\n{\n    vec3 result = flim_blender_hsv_to_rgb(vec3(\n        flim_wrap(primary_hue + (rotate / 360.), 0., 1.),\n        1. / scale,\n        1.\n    ));\n    result /= flim_rgb_sum(result);\n    result *= mul;\n    return result;\n}\n\nmat3 flim_gamut_extension_mat(\n    float red_scale,\n    float green_scale,\n    float blue_scale,\n    float red_rot,\n    float green_rot,\n    float blue_rot,\n    float red_mul,\n    float green_mul,\n    float blue_mul\n)\n{\n    mat3 m;\n    m[0] = flim_gamut_extension_mat_row(\n        0.,\n        red_scale,\n        red_rot,\n        red_mul\n    );\n    m[1] = flim_gamut_extension_mat_row(\n        1. / 3.,\n        green_scale,\n        green_rot,\n        green_mul\n    );\n    m[2] = flim_gamut_extension_mat_row(\n        2. / 3.,\n        blue_scale,\n        blue_rot,\n        blue_mul\n    );\n    return m;\n}\n\nvec3 negative_and_print(vec3 col, vec3 backlight_ext)\n{\n    // develop negative\n    col = flim_rgb_develop(\n        col,\n        flim_negative_film_exposure,\n        flim_negative_film_density\n    );\n\n    // backlight\n    col *= backlight_ext;\n\n    // develop print\n    col = flim_rgb_develop(\n        col,\n        flim_print_film_exposure,\n        flim_print_film_density\n    );\n\n    return col;\n}\n\n// the flim transform\n\nvec3 flim_transform(vec3 col, float exposure, bool convert_to_srgb)\n{\n    // eliminate negative values\n    col = max(col, 0.);\n\n    // pre-Exposure\n    col *= pow(2., flim_pre_exposure + exposure);\n\n    // clip very large values for float precision issues\n    col = min(col, 5000.);\n\n    // gamut extension matrix (Linear BT.709)\n    mat3 extend_mat = flim_gamut_extension_mat(\n        flim_extended_gamut_red_scale,\n        flim_extended_gamut_green_scale,\n        flim_extended_gamut_blue_scale,\n        flim_extended_gamut_red_rot,\n        flim_extended_gamut_green_rot,\n        flim_extended_gamut_blue_rot,\n        flim_extended_gamut_red_mul,\n        flim_extended_gamut_green_mul,\n        flim_extended_gamut_blue_mul\n    );\n    mat3 extend_mat_inv = inverse(extend_mat);\n\n    // backlight in the extended gamut\n    vec3 backlight_ext = flim_print_backlight * extend_mat;\n\n    // upper limit in the print (highlight cap)\n    const float big = 10000000.;\n    vec3 white_cap = negative_and_print(vec3(big, big, big), backlight_ext);\n\n    // pre-formation filter\n    col = mix(\n        col,\n        col * flim_pre_formation_filter,\n        flim_pre_formation_filter_strength\n    );\n\n    // convert to the extended gamut\n    col *= extend_mat;\n\n    // negative & print\n    col = negative_and_print(col, backlight_ext);\n\n    // convert from the extended gamut\n    col *= extend_mat_inv;\n\n    // eliminate negative values\n    col = max(col, 0.);\n\n    // white cap\n    col /= white_cap;\n\n    // black cap (-1 = auto)\n    if (flim_black_point == -1.)\n    {\n        vec3 black_cap = negative_and_print(vec3(0.), backlight_ext);\n        black_cap /= white_cap;\n        col = flim_rgb_uniform_offset(\n            col,\n            flim_rgb_avg(black_cap) * 1000.,\n            0.\n        );\n    }\n    else\n    {\n        col = flim_rgb_uniform_offset(col, flim_black_point, 0.);\n    }\n\n    // post-formation filter\n    col = mix(\n        col,\n        col * flim_post_formation_filter,\n        flim_post_formation_filter_strength\n    );\n\n    // clip\n    col = clamp(col, 0., 1.);\n\n    // midtone saturation\n    float mono = flim_rgb_avg(col);\n    float mix_fac =\n        (mono < .5)\n        ? flim_remap01(mono, .05, .5)\n        : flim_remap01(mono, .95, .5);\n    col = mix(\n        col,\n        flim_blender_hue_sat(col, .5, flim_midtone_saturation, 1.),\n        mix_fac\n    );\n\n    // clip\n    col = clamp(col, 0., 1.);\n\n    // OETF\n    if (convert_to_srgb)\n    {\n        col = oetf_pow(col, 2.2);\n    }\n\n    return col;\n}\n\n/*____________________ end ____________________*/\n",
     "name": "Common",
     "description": "",
     "type": "common"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "M33cD7",
    "date": "1735165058",
    "viewed": 107,
    "name": "FXAA-ish",
    "description": "idk if this is FXAA or SMAA or whatever but screen space methods are still better than TAA\nhold mouse for before/after comparison",
    "likes": 2,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "antialiasing",
     "edge",
     "aa",
     "fxaa",
     "smaa",
     "mlaa"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "float lum(vec3 col)\n{\n    return dot(col, vec3(.3, .5, .2));\n}\n\nvec3 fetch(vec2 coord)\n{\n    return texture(iChannel0, coord / iResolution.xy).rgb;\n}\n\n// FXAA-like antialiasing\nvec3 fxaa_ish(vec2 coord)\n{\n    // calculate the gradient\n    vec2 grad = vec2(\n        lum(fetch(coord + vec2(1, 0))) - lum(fetch(coord + vec2(-1, 0))),\n        lum(fetch(coord + vec2(0, 1))) - lum(fetch(coord + vec2(0, -1)))\n    );\n    \n    // skip if the gradient is too small\n    if (dot(grad, grad) < .0003)\n    {\n        return fetch(coord);\n    }\n    \n    // tangent (rotate the gradient 90 deg)\n    vec2 tang = vec2(-grad.y, grad.x);\n\n    // keep following the tangent on both sides and average out the\n    // colors along the path\n    vec3 col = vec3(0);\n    for (int i = -6; i <= 6; i++)\n    {\n        col += fetch(coord + float(i) * tang);\n    }\n    col /= 13.;\n    return col;\n}\n\nvec3 view_transform(vec3 col)\n{\n    // avoid any negative values before using power functions\n    col = max(col, 0.);\n    \n    // OETF (Linear BT.709 I-D65 to sRGB 2.2)\n    col = pow(col, vec3(1. / 2.2));\n    col = clamp(col, 0., 1.);\n\n    return col;\n}\n\nvec3 render(vec2 coord)\n{\n    // before / after divider\n    if (iMouse.z > .5)\n    {\n        if (abs(coord.x - iMouse.x) < 1.1)\n        {\n            return vec3(.8, .05, .02);\n        }\n        if (coord.x < iMouse.x)\n        {\n            return fetch(coord);\n        }\n    }\n    \n    return fxaa_ish(coord);\n}\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    frag_col = vec4(view_transform(render(frag_coord)), 1);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "// this buffer renders some basic 2D shapes with no AA\n\nvec3 render(vec2 coord)\n{\n    vec2 uv = (2. * coord - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    vec3 col = vec3(.015, .02, .04);\n    if (abs(dot(uv, normalize(vec2(-.06, 1))) - .6) < .01)\n    {\n        col = vec3(.3, .5, .7);\n    }\n    if (abs(sin(uv.x * 6.2831853) - 32. * (uv.y - .1)) < .5)\n    {\n        col = vec3(.8, .6, .2);\n    }\n    \n    if (abs(dot(uv, uv) - .2) < .03)\n    {\n        col = vec3(.3, .6, .1);\n    }\n    if (max(abs(uv.x), abs(uv.y + .15)) < .15)\n    {\n        col = vec3(.8);\n    }\n    \n    return col;\n}\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    vec3 col = render(frag_coord);\n    frag_col = vec4(col, 1);\n}\n",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "lX3cD7",
    "date": "1735261091",
    "viewed": 127,
    "name": "Film Emulation",
    "description": "Full on film emulation. Detailed explanation in the Common tab + comments throughout the code.",
    "likes": 8,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "emulation",
     "film",
     "grain",
     "halation"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4sXGR8",
       "filepath": "/media/previz/buffer02.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "void mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    // read averaged value from the previous buffer\n    vec4 data = texelFetch(iChannel0, ivec2(frag_coord), 0);\n    vec3 col = data.rgb / max(1., data.w);\n    \n    // undo made-up gamut transformation\n    col *= inverse(gamut_extension_mat());\n\n    // OETF (Linear BT.709 I-D65 -> sRGB 2.2)\n    col = pow(col, vec3(1. / 2.2));\n\n    // output    \n    frag_col = vec4(col, 1);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "// how this shader works\n//\n// 1. buffer A renders a custom image in Linear BT.709 I-D65.\n//\n// 2. buffer B reads from buffer A and renders tiny cyan, magenta,\n//    and yellow grains (disks) where the density of grains\n//    depends on the local brightness of red, green, and blue,\n//    respectively. this essentially simulates a developed\n//    negative film.\n//    it should be noted that, when reading from buffer A, we\n//    multiply a 3x3 matrix by the color to effectively convert to\n//    a made-up wide gamut color space. this transformation is\n//    undone in the Image tab. for more information, watch my\n//    video on film emulation, linked below.\n//\n// 3. buffer C reads from buffer B and does the same grain\n//    simulation process, just with slightly different parameters\n//    and different random seeds.\n//\n// 4. finally, the Image tab reads from buffer C, undoes the\n//    made-up gamut transformation, and applies the sRGB OETF.\n//\n// in buffers A, B, and C, the W channel stores the number of\n// accumulated samples, so when reading from them, we should\n// divide XYZ by W to get the averaged RGB triplet.\n//\n// my video on film emulation and digital color:\n// https://www.youtube.com/watch?v=okPzA04TLYM\n//\n// flim, my filmic color transform:\n// https://github.com/bean-mhm/flim\n\n\n\n// grain (disk) radius range\nconst float MIN_GRAIN_RADIUS = .00004;\nconst float MAX_GRAIN_RADIUS = .0003;\n\nconst float LOG_MIN_GRAIN_RADIUS = log(MIN_GRAIN_RADIUS);\nconst float LOG_MAX_GRAIN_RADIUS = log(MAX_GRAIN_RADIUS);\n\n// * MUST be larger than MAX_GRAIN_RADIUS\nconst float TILE_SIZE = .001;\nconst float HALF_TILE_SIZE = .5 * TILE_SIZE;\n\n// parameters for the made-up gamut\nconst float EXTENDED_GAMUT_RED_SCALE = 1.05;\nconst float EXTENDED_GAMUT_GREEN_SCALE = 1.12;\nconst float EXTENDED_GAMUT_BLUE_SCALE = 1.045;\nconst float EXTENDED_GAMUT_RED_ROT = .5;\nconst float EXTENDED_GAMUT_GREEN_ROT = 2.;\nconst float EXTENDED_GAMUT_BLUE_ROT = .1;\nconst float EXTENDED_GAMUT_RED_MUL = 1.;\nconst float EXTENDED_GAMUT_GREEN_MUL = 1.;\nconst float EXTENDED_GAMUT_BLUE_MUL = 1.;\n\n\n\n/*___________ math & integer utils ____________*/\n\nconst float PI = 3.141592653589793238462643383;\nconst float TAU = 6.283185307179586476925286767;\nconst float PI_OVER_2 = 1.570796326794896619231321692;\nconst float INV_PI = .318309886183790671537767527;\nconst float INV_TAU = .159154943091895335768883763;\n\n#define FUNC_WRAP(T) \\\nT wrap(T v, float start, float end) \\\n{ \\\n    return start + mod(v - start, end - start); \\\n}\n\n#define FUNC_REMAP(T) \\\nT remap(T v, float inp_start, float inp_end, float out_start, float out_end) \\\n{ \\\n    return out_start \\\n        + ((out_end - out_start) / (inp_end - inp_start)) * (v - inp_start); \\\n}\n\n#define FUNC_REMAP_CLAMP(T) \\\nT remap_clamp( \\\n    T v, \\\n    float inp_start, \\\n    float inp_end, \\\n    float out_start, \\\n    float out_end \\\n) \\\n{ \\\n    T t = clamp((v - inp_start) / (inp_end - inp_start), 0., 1.); \\\n    return out_start + t * (out_end - out_start); \\\n}\n\n#define FUNC_REMAP01(T) \\\nT remap01(T v, float inp_start, float inp_end) \\\n{ \\\n    return clamp((v - inp_start) / (inp_end - inp_start), 0., 1.); \\\n}\n\n#define FUNC_LENGTH_SQ(T) \\\nfloat length_sq(T v) \\\n{ \\\n    return dot(v, v); \\\n}\n\n#define FUNC_DIST_SQ(T) \\\nfloat dist_sq(T a, T b) \\\n{ \\\n    a -= b; \\\n    return dot(a, a); \\\n}\n\nFUNC_WRAP(float)\nFUNC_WRAP(vec2)\nFUNC_WRAP(vec3)\nFUNC_WRAP(vec4)\n\nFUNC_REMAP(float)\nFUNC_REMAP(vec2)\nFUNC_REMAP(vec3)\nFUNC_REMAP(vec4)\n\nFUNC_REMAP_CLAMP(float)\nFUNC_REMAP_CLAMP(vec2)\nFUNC_REMAP_CLAMP(vec3)\nFUNC_REMAP_CLAMP(vec4)\n\nFUNC_REMAP01(float)\nFUNC_REMAP01(vec2)\nFUNC_REMAP01(vec3)\nFUNC_REMAP01(vec4)\n\nFUNC_LENGTH_SQ(vec2)\nFUNC_LENGTH_SQ(vec3)\nFUNC_LENGTH_SQ(vec4)\n\nFUNC_DIST_SQ(vec2)\nFUNC_DIST_SQ(vec3)\nFUNC_DIST_SQ(vec4)\n\nfloat chebyshev_dist(vec2 a, vec2 b)\n{\n    return max(abs(a.x - b.x), abs(a.y - b.y));\n}\n\nfloat chebyshev_dist(vec3 a, vec3 b)\n{\n    return max(\n        max(abs(a.x - b.x), abs(a.y - b.y)),\n        abs(a.z - b.z)\n    );\n}\n\nfloat chebyshev_dist(vec4 a, vec4 b)\n{\n    return max(\n        max(\n            max(abs(a.x - b.x), abs(a.y - b.y)),\n            abs(a.z - b.z)\n        ),\n        abs(a.w - b.w)\n    );\n}\n\n#define idiv_ceil(a, b) ((a + b - 1) / b)\n\nint iabs(int v)\n{\n    if (v < 0)\n    {\n        return -v;\n    }\n    return v;\n}\n\nint imin(int a, int b)\n{\n    if (a < b)\n    {\n        return a;\n    }\n    return b;\n}\n\nint imax(int a, int b)\n{\n    if (a > b)\n    {\n        return a;\n    }\n    return b;\n}\n\nint iclamp(int v, int start, int end)\n{\n    if (v < start)\n    {\n        v = start;\n    }\n    if (v > end)\n    {\n        v = end;\n    }\n    return v;\n}\n\nfloat min_component(vec2 v)\n{\n    return min(v.x, v.y);\n}\n\nfloat min_component(vec3 v)\n{\n    return min(min(v.x, v.y), v.z);\n}\n\nfloat min_component(vec4 v)\n{\n    return min(min(min(v.x, v.y), v.z), v.w);\n}\n\nfloat max_component(vec2 v)\n{\n    return max(v.x, v.y);\n}\n\nfloat max_component(vec3 v)\n{\n    return max(max(v.x, v.y), v.z);\n}\n\nfloat max_component(vec4 v)\n{\n    return max(max(max(v.x, v.y), v.z), v.w);\n}\n\nfloat sum_components(vec2 v)\n{\n    return dot(v, vec2(1));\n}\n\nfloat sum_components(vec3 v)\n{\n    return dot(v, vec3(1));\n}\n\nfloat sum_components(vec4 v)\n{\n    return dot(v, vec4(1));\n}\n\nint min_component(ivec2 v)\n{\n    return imin(v.x, v.y);\n}\n\nint min_component(ivec3 v)\n{\n    return imin(imin(v.x, v.y), v.z);\n}\n\nint min_component(ivec4 v)\n{\n    return imin(imin(imin(v.x, v.y), v.z), v.w);\n}\n\nint max_component(ivec2 v)\n{\n    return imax(v.x, v.y);\n}\n\nint max_component(ivec3 v)\n{\n    return imax(imax(v.x, v.y), v.z);\n}\n\nint max_component(ivec4 v)\n{\n    return imax(imax(imax(v.x, v.y), v.z), v.w);\n}\n\nint sum_components(ivec2 v)\n{\n    return v.x + v.y;\n}\n\nint sum_components(ivec3 v)\n{\n    return v.x + v.y + v.z;\n}\n\nint sum_components(ivec4 v)\n{\n    return v.x + v.y + v.z + v.w;\n}\n\nfloat bilinear(\n    float val_bl,\n    float val_tl,\n    float val_tr,\n    float val_br,\n    vec2 offs\n)\n{\n    return mix(\n        mix(val_bl, val_br, offs.x),\n        mix(val_tl, val_tr, offs.x),\n        offs.y\n    );\n}\n\n// credits to AHSEN (https://www.shadertoy.com/user/01000001)\n// https://www.desmos.com/calculator/5d6ph151vi interactive :D\nfloat cubic_interp(float a, float b, float c, float d, float t)\n{\n    float one = t - 1.;\n    float two = t - 2.;\n    float three = t - 3.;\n    return (\n        (-one * two * three * a)\n        + (t * one * two * d)\n        + (3. * t * two * three * b)\n        - (3. * t * one * three * c)\n    ) / 6.;\n}\n\nfloat dist_along_line(vec2 p, vec2 line_start, vec2 line_end)\n{\n    vec2 dir = line_end - line_start;\n    \n    // normalize\n    float len_sqr = dot(dir, dir);\n    if (len_sqr < .0001)\n        return 1e9;\n    dir /= sqrt(len_sqr);\n    \n    return dot(\n        dir,\n        p - line_start\n    );\n}\n\nfloat relative_dist_along_line(vec2 p, vec2 line_start, vec2 line_end)\n{\n    vec2 dir = line_end - line_start;\n    return dot(\n        dir,\n        p - line_start\n    );\n}\n\n// |a| * |b| * sin(theta)\nfloat cross2d(vec2 a, vec2 b)\n{\n    return a.x * b.y - a.y * b.x;\n}\n\n// references for barycentric coordinates\n// https://www.desmos.com/calculator/8g8xjejuox\n// https://www.shadertoy.com/view/mdjBWK\n\nvec3 cartesian_to_barycentric(\n    vec2 p,\n    vec2 v0,\n    vec2 v1,\n    vec2 v2,\n    bool clamp_,\n    out bool p_is_outside\n)\n{\n    vec3 b = vec3(\n        cross2d(v1 - p, v2 - p),\n        cross2d(v2 - p, v0 - p),\n        cross2d(v0 - p, v1 - p)\n    ) / cross2d(v1 - v0, v2 - v0);\n    p_is_outside = min(min(b.x, b.y), b.z) < 0.;\n    if (clamp_)\n    {\n        b = max(b, 0.);\n        b /= (b.x + b.y + b.z);\n    }\n    return b;\n}\n\nvec3 cartesian_to_barycentric(\n    vec3 p,\n    vec3 v0,\n    vec3 v1,\n    vec3 v2,\n    bool clamp_,\n    out bool p_is_outside\n)\n{\n    vec3 b = vec3(\n        length(cross(v1 - p, v2 - p)),\n        length(cross(v2 - p, v0 - p)),\n        length(cross(v0 - p, v1 - p))\n    ) / length(cross(v1 - v0, v2 - v0));\n    p_is_outside = min(min(b.x, b.y), b.z) < 0.;\n    if (clamp_)\n    {\n        b = max(b, 0.);\n        b /= (b.x + b.y + b.z);\n    }\n    return b;\n}\n\nfloat barycentric_interpolate(vec3 b, float v0, float v1, float v2)\n{\n    return dot(b, vec3(v0, v1, v2));\n}\n\nvec2 barycentric_interpolate(vec3 b, vec2 v0, vec2 v1, vec2 v2)\n{\n    return b.x * v0 + b.y * v1 + b.z * v2;\n}\n\nvec3 barycentric_interpolate(vec3 b, vec3 v0, vec3 v1, vec3 v2)\n{\n    return b.x * v0 + b.y * v1 + b.z * v2;\n}\n\nvec4 barycentric_interpolate(vec3 b, vec4 v0, vec4 v1, vec4 v2)\n{\n    return b.x * v0 + b.y * v1 + b.z * v2;\n}\n\nfloat barycentric_interpolate(vec2 b, float v0, float v1, float v2)\n{\n    return barycentric_interpolate(\n        vec3(b.x, b.y, 1. - b.x - b.y),\n        v0, v1, v2\n    );\n}\n\nvec2 barycentric_interpolate(vec2 b, vec2 v0, vec2 v1, vec2 v2)\n{\n    return barycentric_interpolate(\n        vec3(b.x, b.y, 1. - b.x - b.y),\n        v0, v1, v2\n    );\n}\n\nvec3 barycentric_interpolate(vec2 b, vec3 v0, vec3 v1, vec3 v2)\n{\n    return barycentric_interpolate(\n        vec3(b.x, b.y, 1. - b.x - b.y),\n        v0, v1, v2\n    );\n}\n\nvec4 barycentric_interpolate(vec2 b, vec4 v0, vec4 v1, vec4 v2)\n{\n    return barycentric_interpolate(\n        vec3(b.x, b.y, 1. - b.x - b.y),\n        v0, v1, v2\n    );\n}\n\n// angle from 0 to TAU\nfloat get_angle(vec2 p)\n{\n    float a = atan(p.y, p.x);\n    if (a < 0.)\n    {\n        return a + TAU;\n    }\n    return a;\n}\n\nmat2 rotate_2d(float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(\n        c, s,\n        -s, c\n    );\n}\n\nvec2 perpendicular(vec2 v)\n{\n    return vec2(-v.y, v.x);\n}\n\n// s.x=theta\n// s.y=phi\n// (there's no r)\nvec3 spherical_to_cartesian(vec2 s)\n{\n    float sin_theta = sin(s.x);\n    return vec3(\n        sin_theta * cos(s.y),\n        sin_theta * sin(s.y),\n        cos(s.x)\n    );\n}\n\n// s.x=r\n// s.y=theta\n// s.z=phi\nvec3 spherical_to_cartesian(vec3 s)\n{\n    float sin_theta = sin(s.y);\n    return s.x * vec3(\n        sin_theta * cos(s.z),\n        sin_theta * sin(s.z),\n        cos(s.y)\n    );\n}\n\nvec2 screen_to_uv01(vec2 coord, vec2 res)\n{\n    return coord / res;\n}\n\nvec2 screen_to_uv_horizontal(vec2 coord, vec2 res)\n{\n    return (2. * coord - res) / res.x;\n}\n\nvec2 screen_to_uv_vertical(vec2 coord, vec2 res)\n{\n    return (2. * coord - res) / res.y;\n}\n\nvec2 screen_to_uv_fit(vec2 coord, vec2 res)\n{\n    return (2. * coord - res) / min_component(res);\n}\n\nvec2 screen_to_uv_fill(vec2 coord, vec2 res)\n{\n    return (2. * coord - res) / max_component(res);\n}\n\n// * idx starts at 1\nfloat halton(int base, int idx)\n{\n    float result = 0.;\n    float digit_weight = 1.;\n    while (idx > 0)\n    {\n        digit_weight /= float(base);\n        result += float(idx % base) * digit_weight;\n        idx /= base;\n    }\n    return result;\n}\n\n// * idx starts at 1\nvec2 halton_2d(int idx)\n{\n    return vec2(halton(2, idx), halton(3, idx));\n}\n\n// * idx starts at 1\nvec3 halton_3d(int idx)\n{\n    return vec3(halton(2, idx), halton(3, idx), halton(5, idx));\n}\n\n// * idx starts at 1\nvec4 halton_4d(int idx)\n{\n    return vec4(\n        halton(2, idx),\n        halton(3, idx),\n        halton(5, idx),\n        halton(7, idx)\n    );\n}\n\n// for some reason we can't use intBitsToFloat() or floatBitsToInt() to store\n// integers below this value in a buffer.\nconst int BUFFER_MIN_INTEGER = 8388608;\n\n// * x must not be higher than 4,286,578,688 (see BUFFER_MIN_INTEGER above)\n// * for your sanity, don't use negative values\nfloat encode_int_for_buffer(int v)\n{\n    return intBitsToFloat(v + BUFFER_MIN_INTEGER);\n}\n\nint decode_int_from_buffer(float v)\n{\n    return floatBitsToInt(v) - BUFFER_MIN_INTEGER;\n}\n\n// pack two 16-bit integers in a single 32-bit integer\n// * both arguments should be in the 0-65535 range\n// * a must be less than 65279 (see the functions above)\nint pack_i16(int a, int b)\n{\n    return (a << 16) | b;\n}\n\n// unpack two 16-bit integers from a single 32-bit integer\nvoid unpack_i16(int v, out int a, out int b)\n{\n    a = (v >> 16) & 65535;\n    b = v & 65535;\n}\n\n// unpack the first 16-bit integer from a 32-bit integer\nint unpack_i16_a(int v)\n{\n    return (v >> 16) & 65535;\n}\n\n// unpack the second 16-bit integer from a 32-bit integer\nint unpack_i16_b(int v)\n{\n    return v & 65535;\n}\n\nbool icoord_in_bounds(ivec2 icoord, ivec2 ires)\n{\n    return\n        icoord.x >= 0 &&\n        icoord.y >= 0 &&\n        icoord.x < ires.x &&\n        icoord.y < ires.y;\n}\n\nbool icoord_in_bounds(ivec3 icoord, ivec3 ires)\n{\n    return\n        icoord.x >= 0 &&\n        icoord.y >= 0 &&\n        icoord.z >= 0 &&\n        icoord.x < ires.x &&\n        icoord.y < ires.y &&\n        icoord.z < ires.z;\n}\n\nint icoord_to_idx(ivec2 icoord, ivec2 ires)\n{\n    return icoord.x + (icoord.y * ires.x);\n}\n\nint icoord_to_idx(ivec3 icoord, ivec3 ires)\n{\n    return icoord.x + (icoord.y * ires.x) + (icoord.z * ires.x * ires.y);\n}\n\nivec2 idx_to_icoord(int idx, ivec2 ires)\n{\n    return ivec2(idx % ires.x, idx / ires.x);\n}\n\nivec3 idx_to_icoord(int idx, ivec3 ires)\n{\n    return ivec3(\n        idx % ires.x,\n        (idx % (ires.x * ires.y)) / ires.x,\n        idx / (ires.x * ires.y)\n    );\n}\n\n// https://www.desmos.com/calculator/kfe07basy9\n\nint compress_float_to_int_linear(float f, float min_f, float max_f, int max_i)\n{\n    return int(floor(\n        float(max_i) * remap01(f, min_f, max_f)\n    ));\n}\n\nfloat decompress_float_from_int_linear(\n    int i,\n    int max_i,\n    float min_f,\n    float max_f\n)\n{\n    return remap_clamp(\n        float(i) / float(max_i),\n        0., 1.,\n        min_f, max_f\n    );\n}\n\nint compress_float_to_int_log(\n    float f,\n    float log2_zero_offset,\n    float max_log2_f,\n    int max_i\n)\n{\n    f = max(0., f);\n    f += pow(2., log2_zero_offset);\n    return int(floor(\n        float(max_i) * remap01(log2(f), log2_zero_offset, max_log2_f)\n    ));\n}\n\nfloat decompress_float_from_int_log(\n    int i,\n    int max_i,\n    float log2_zero_offset,\n    float max_log2_f\n)\n{\n    return pow(2., remap_clamp(\n        float(i) / float(max_i),\n        0., 1.,\n        log2_zero_offset, max_log2_f\n    )) - pow(2., log2_zero_offset);\n}\n\n\n\n/*_______ pseudo-random number generator ______*/\n// source: https://www.shadertoy.com/view/WdSSRt\n// (heavily modified)\n\n/* usage example:\n    void mainImage(out vec4 frag_col, in vec2 frag_coord)\n    {\n        // initialize PRNG\n        prng_init(vec3(frag_coord / iResolution.y, iTime));\n    \n        // use the function\n        float a = random();\n        vec3 b = vec3(random(), random(), random());\n        \n        ...\n    }\n*/\n\nuint prng_state[2];\n\nuint prng_rot(uint x, int k)\n{\n    return (x << k) | (x >> (32 - k));\n}\n\n// random uint from 0 to 2^32-1\nuint randomui()\n{\n    uint s0 = prng_state[0];\n    uint s1 = prng_state[1];\n    uint result = prng_rot(s0 * 2654435771u, 5) * 5u;\n    s1 ^= s0;\n    prng_state[0] = prng_rot(s0, 26) ^ s1 ^ (s1 << 9);\n    prng_state[1] = prng_rot(s1, 13);\n    return result;\n}\n\n// random int from 0 to 2^31-1\nint randomi()\n{\n    return int(randomui() % 0x7FFFFFFFu);\n}\n\n// random float from 0 to 1\nfloat random()\n{\n    return float(randomui()) / float(0xffffffffu);\n}\n\n// generate two normally distributed random numbers using the\n// Box-Muller transform\n// https://www.baeldung.com/cs/uniform-to-normal-distribution\nvec2 random_gauss()\n{\n    float u1 = random();\n    float u2 = random() * TAU;\n    float temp = sqrt(-2. * log(u1));\n    return temp * vec2(cos(u2), sin(u2));\n    \n    // unoptimized version\n    //float u1 = random();\n    //float u2 = random();\n    //return vec2(cos(TAU * u2), sin(TAU * u2)) * sqrt(-2. * log(u1));\n}\n\nvec2 random_on_circle()\n{\n    vec2 v = vec2(1);\n    float lensqr;\n\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec2(2. * random() - 1., 2. * random() - 1.);\n        lensqr = dot(v, v);\n        if (lensqr == 0.)\n            i--;\n        else if (lensqr <= 1.)\n            break;\n    }\n    return v / sqrt(lensqr);\n}\n\nvec3 random_on_sphere()\n{\n    vec3 v = vec3(1);\n    float lensqr;\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec3(2. * random() - 1., 2. * random() - 1., 2. * random() - 1.);\n        lensqr = dot(v, v);\n        if (lensqr == 0.)\n            i--;\n        else if (lensqr <= 1.)\n            break;\n    }\n    return v / sqrt(lensqr);\n}\n\nvec2 random_in_circle()\n{\n    vec2 v = vec2(1);\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec2(2. * random() - 1., 2. * random() - 1.);\n        if (dot(v, v) <= 1.)\n            return v;\n    }\n    return v;\n}\n\nvec3 random_in_sphere()\n{\n    vec3 v = vec3(1);\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec3(2. * random() - 1., 2. * random() - 1., 2. * random() - 1.);\n        if (dot(v, v) <= 1.)\n            return v;\n    }\n    return v;\n}\n\nvec3 random_on_hemisphere(vec3 normal)\n{\n    vec3 v = random_on_sphere();\n    return v * sign(dot(v, normal));\n}\n\nvec3 random_in_hemisphere(vec3 normal)\n{\n    vec3 v = random_in_sphere();\n    return v * sign(dot(v, normal));\n}\n\n// generate random integer with poisson distribution\nint random_poisson(float mean_rate)\n{\n    float exp_negative_mean_rate = exp(-mean_rate);\n\n    int n = 0;\n    float product = 1.;\n    while (product > exp_negative_mean_rate)\n    {\n        product *= random();\n        n++;\n    }\n    return n;\n}\n\n// initialize with uvec2\nvoid prng_init(uvec2 seed)\n{\n    seed += uvec2(1317, 944573125);\n    seed *= 464973573u;\n    prng_state[0] = seed.x;\n    prng_state[1] = seed.y;\n    randomi();\n}\n\n// initialize with uint\nvoid prng_init(uint seed)\n{\n    prng_init(uvec2(seed, 1));\n}\n\n// initialize with vec3\nvoid prng_init(vec3 seed)\n{\n    seed += 3.49276101561702;\n    seed.xy *= (seed.z + 10.258);\n    prng_state[0] = floatBitsToUint(seed.x);\n    prng_state[1] = floatBitsToUint(seed.y);\n    randomui();\n}\n\n// initialize with vec2\nvoid prng_init(vec2 seed)\n{\n    prng_init(vec3(seed, 1));\n}\n\n// initialize with float\nvoid prng_init(float seed)\n{\n    prng_init(vec3(seed, 1, 1));\n}\n\n\n\n// gamut extension matrix\n\nvec3 blender_hsv_to_rgb(vec3 hsv)\n{\n    float f, p, q, t, h, s, v;\n    vec3 rgb;\n\n    h = hsv[0];\n    s = hsv[1];\n    v = hsv[2];\n\n    if (s == 0.)\n    {\n        rgb = vec3(v, v, v);\n    }\n    else\n    {\n        if (h == 1.)\n        {\n            h = 0.;\n        }\n\n        h *= 6.;\n        int i = int(floor(h));\n        f = h - float(i);\n        rgb = vec3(f, f, f);\n        p = v * (1. - s);\n        q = v * (1. - (s * f));\n        t = v * (1. - (s * (1. - f)));\n\n        if (i == 0)\n        {\n            rgb = vec3(v, t, p);\n        }\n        else if (i == 1)\n        {\n            rgb = vec3(q, v, p);\n        }\n        else if (i == 2)\n        {\n            rgb = vec3(p, v, t);\n        }\n        else if (i == 3)\n        {\n            rgb = vec3(p, q, v);\n        }\n        else if (i == 4)\n        {\n            rgb = vec3(t, p, v);\n        }\n        else\n        {\n            rgb = vec3(v, p, q);\n        }\n    }\n\n    return rgb;\n}\n\nvec3 gamut_extension_mat_row(\n    float primary_hue,\n    float scale,\n    float rotate,\n    float mul\n)\n{\n    vec3 result = blender_hsv_to_rgb(vec3(\n        wrap(primary_hue + (rotate / 360.), 0., 1.),\n        1. / scale,\n        1.\n    ));\n    result /= sum_components(result);\n    result *= mul;\n    return result;\n}\n\nmat3 gamut_extension_mat()\n{\n    mat3 m;\n    m[0] = gamut_extension_mat_row(\n        0.,\n        EXTENDED_GAMUT_RED_SCALE,\n        EXTENDED_GAMUT_RED_ROT,\n        EXTENDED_GAMUT_RED_MUL\n    );\n    m[1] = gamut_extension_mat_row(\n        1. / 3.,\n        EXTENDED_GAMUT_GREEN_SCALE,\n        EXTENDED_GAMUT_GREEN_ROT,\n        EXTENDED_GAMUT_GREEN_MUL\n    );\n    m[2] = gamut_extension_mat_row(\n        2. / 3.,\n        EXTENDED_GAMUT_BLUE_SCALE,\n        EXTENDED_GAMUT_BLUE_ROT,\n        EXTENDED_GAMUT_BLUE_MUL\n    );\n    return m;\n}\n",
     "name": "Common",
     "description": "",
     "type": "common"
    },
    {
     "inputs": [
      {
       "id": "4dfGRn",
       "filepath": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg",
       "type": "texture",
       "channel": 1,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "float bar_brightness(float u)\n{\n    return pow(remap01(u, -1.4, 1.), 6.) * 140. * step(u, 1.);\n}\n\n// render the bars (original scene without halation)\nvec3 render(vec2 coord)\n{\n    // render texture from iChannnel1\n    #if 0\n        vec3 col = pow(texture(iChannel1, coord / iResolution.xy).rgb, vec3(2.2));\n        \n        // HDR-ize\n        return 2.7 * pow(col, vec3(1.32));\n    #endif\n    \n    vec2 uv = screen_to_uv_fit(coord, iResolution.xy);\n    if (abs(uv.y - .2) < .1)\n    {\n        return vec3(bar_brightness(uv.x));\n    }\n    else if (abs(uv.y + .2) < .1)\n    {\n        return vec3(bar_brightness(-uv.x));\n    }\n    return vec3(0);\n}\n\n// render the original scene with halation.\n// effectively just blur \"the deep orange channel\" and mix\n// the original image with that.\nvec3 render_with_halation(vec2 coord)\n{\n    vec3 col = render(coord);\n    vec3 col_blurred = render(\n        coord + random_gauss() * .006 * min(iResolution.x, iResolution.y)\n    );\n    return mix(col, col_blurred, .1 * vec3(.93, .07, 0));\n}\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    // the first pixel (0, 0) stores resolution\n    if (ivec2(frag_coord) == ivec2(0))\n    {\n        frag_col = vec4(iResolution.xy, 0, 0);\n        return;\n    }\n    \n    // fetch previous frame's resolution and see if it's changed\n    vec2 prev_res = texelFetch(iChannel0, ivec2(0), 0).xy;\n    bool res_changed = dist_sq(iResolution.xy, prev_res) > .9;\n    \n    // fetch previous frame's values\n    // (XYZ = RGB, W = number of samples accumulated)\n    vec4 prev_data = texelFetch(iChannel0, ivec2(frag_coord), 0);\n    \n    // reset previous data if we're on the first frame or when the\n    // resolution changes.\n    if (iFrame < 1 || iTime < .02 || prev_data.w < .9 || res_changed)\n    {\n        prev_data = vec4(0);\n    }\n    \n    // stop accumulating after some point\n    if (prev_data.w > 65.)\n    {\n        frag_col = prev_data;\n        return;\n    }\n    \n    // initialize PRNG\n    prng_init(vec3(frag_coord, iTime + float(iFrame + 1)));\n\n    // render with box jitter sampling\n    vec3 col = vec3(0);\n    const int N_SAMPLES = 1;\n    for (int i = 0; i < N_SAMPLES; i++)\n    {\n        vec2 offs = vec2(random(), random()) - .5;\n        col += render_with_halation(frag_coord + offs);\n    }\n    col /= float(N_SAMPLES);\n    \n    // add to the previously accumulated samples\n    frag_col = vec4(prev_data.rgb + col, prev_data.w + 1.);\n}\n",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "XsXGR8",
       "channel": 0
      }
     ],
     "code": "// this is the range used to get the average rate of disks per tile\n// based on the log2 of the current color channel of the input.\nconst float MIN_LOG2_INPUT = -6.5;\nconst float MAX_LOG2_INPUT = 22.5;\n\n// 2 ^ MIN_LOG2_INPUT. we add this to the input color to avoid\n// clipping near zero.\nconst float EXP_MIN_LOG2_INPUT = pow(2., MIN_LOG2_INPUT + .00001);\n\n// maximum average rate of disks per tile\nconst float MAX_MEAN_RATE = 200.;\n\nvec3 render(vec2 coord)\n{\n    // UV coordinates centered around the origin\n    float min_res = min_component(iResolution.xy);\n    vec2 res = iResolution.xy;\n    vec2 uv = (2. * coord - res) / min_res;\n    \n    // tile 2D index\n    ivec2 itile = ivec2(floor(uv / TILE_SIZE));\n    \n    // gamut extension matrix (Linear BT.709)\n    mat3 extend_mat = gamut_extension_mat();\n    \n    // start with white (perfectly unexposed film)\n    vec3 col = vec3(1);\n    \n    // for each of the neighboring tiles and the current one\n    for (int ioffs_y = -1; ioffs_y <= 1; ioffs_y++)\n    {\n        for (int ioffs_x = -1; ioffs_x <= 1; ioffs_x++)\n        {\n            // current tile's 2D index\n            ivec2 curr_itile = itile + ivec2(ioffs_x, ioffs_y);\n            \n            // current tile's bounds\n            vec2 tile_bl = vec2(curr_itile) * TILE_SIZE;\n            vec2 tile_tl = tile_bl + TILE_SIZE;\n            vec2 tile_center = tile_bl + HALF_TILE_SIZE;\n            \n            // fetch input image color at tile center and convert it\n            // to the made-up gamut.\n            vec4 input_data = texture(\n                iChannel1,\n                (tile_center * min_res + res) / (2. * res)\n            );\n            vec3 input_col = input_data.rgb / max(1., input_data.w);\n            input_col *= extend_mat;\n            input_col += EXP_MIN_LOG2_INPUT;\n            \n            // for each color channel red, green, and blue, render a\n            // bunch of disks with the opposite color. the number of\n            // disks is calculated using a poisson random\n            // distribution.\n            for (int ch = 0; ch < 3; ch++)\n            {\n                // if we've already rendered a disk with the\n                // opposite color of the current channel, we\n                // don't need to do anything else.\n                if (col[ch] < .1)\n                {\n                    continue;\n                }\n            \n                // average rate of disks per tile which is based on\n                // log2(color channel intensity at tile center).\n                float mean_rate = MAX_MEAN_RATE * remap01(\n                    log2(input_col[ch]),\n                    MIN_LOG2_INPUT,\n                    MAX_LOG2_INPUT\n                );\n                \n                // initialize PRNG for the current tile and channel\n                // make sure this seed is different in buffer B\n                // and C.\n                prng_init(vec3(curr_itile + 0, ch + 0));\n                \n                // figure out the exact number of disks to render\n                // using a poisson distribution.\n                int n_disks = random_poisson(mean_rate);\n                \n                // render disks with the opposite color of the\n                // current color channel with multiplicative\n                // blending (just set the current channel to 0).\n                for (int i = 0; i < n_disks; i++)\n                {\n                    vec2 center = tile_bl + TILE_SIZE * vec2(random(), random());\n                    \n                    float log_radius = remap(\n                        random(),\n                        0., 1.,\n                        LOG_MIN_GRAIN_RADIUS, LOG_MAX_GRAIN_RADIUS\n                    );\n                    float radius = exp(log_radius);\n                    \n                    if (dist_sq(uv, center) < radius * radius)\n                    {\n                        col[ch] = 0.;\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    \n    // visualize tiles for testing\n    #if 0\n        col.rg = abs(sin(vec2(itile) * PI_OVER_2));\n        col.b *= .5;\n    #endif\n    \n    return col;\n}\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    // the first pixel (0, 0) stores resolution\n    if (ivec2(frag_coord) == ivec2(0))\n    {\n        frag_col = vec4(iResolution.xy, 0, 0);\n        return;\n    }\n    \n    // before doing anything, wait for buffer A to converge\n    vec4 prev_buf_data = texelFetch(iChannel1, ivec2(frag_coord), 0);\n    if (prev_buf_data.w < 65.)\n    {\n        frag_col = vec4(\n            prev_buf_data.rgb / max(1., prev_buf_data.w),\n            0\n        );\n        return;\n    }\n    \n    // fetch previous frame's resolution and see if it's changed\n    vec2 prev_res = texelFetch(iChannel0, ivec2(0), 0).xy;\n    bool res_changed = dist_sq(iResolution.xy, prev_res) > .9;\n\n    // fetch previous frame's values\n    // (XYZ = RGB, W = number of samples accumulated)\n    vec4 prev_data = texelFetch(iChannel0, ivec2(frag_coord), 0);\n    \n    // reset previous data if we're on the first frame or when the\n    // resolution changes.\n    if (iFrame < 1 || iTime < .02 || prev_data.w < .9 || res_changed)\n    {\n        prev_data = vec4(0);\n    }\n    \n    // stop accumulating after some point\n    if (prev_data.w > 100.)\n    {\n        frag_col = prev_data;\n        return;\n    }\n    \n    // initialize PRNG\n    prng_init(vec3(frag_coord, iTime + float(iFrame + 100)));\n    \n    // render with box jitter sampling\n    vec3 col = vec3(0);\n    const int N_SAMPLES = 1;\n    for (int i = 0; i < N_SAMPLES; i++)\n    {\n        vec2 offs = vec2(random(), random()) - .5;\n        col += render(frag_coord + offs);\n    }\n    col /= float(N_SAMPLES);\n    \n    // add to the previously accumulated samples\n    frag_col = vec4(prev_data.rgb + col, prev_data.w + 1.);\n}\n",
     "name": "Buffer B",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4sXGR8",
       "filepath": "/media/previz/buffer02.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4sXGR8",
       "channel": 0
      }
     ],
     "code": "// this is the range used to get the average rate of disks per tile\n// based on the log2 of the current color channel of the input.\nconst float MIN_LOG2_INPUT = -.5;\nconst float MAX_LOG2_INPUT = 20.;\n\n// 2 ^ MIN_LOG2_INPUT. we add this to the input color to avoid\n// clipping near zero.\nconst float EXP_MIN_LOG2_INPUT = pow(2., MIN_LOG2_INPUT);\n\n// maximum average rate of disks per tile\nconst float MAX_MEAN_RATE = 1400.;\n\nvec3 render(vec2 coord)\n{\n    // UV coordinates centered around the origin\n    float min_res = min_component(iResolution.xy);\n    vec2 res = iResolution.xy;\n    vec2 uv = (2. * coord - res) / min_res;\n    \n    // tile 2D index\n    ivec2 itile = ivec2(floor(uv / TILE_SIZE));\n    \n    // start with white (perfectly unexposed film)\n    vec3 col = vec3(1);\n    \n    // for each of the neighboring tiles and the current one\n    for (int ioffs_y = -1; ioffs_y <= 1; ioffs_y++)\n    {\n        for (int ioffs_x = -1; ioffs_x <= 1; ioffs_x++)\n        {\n            // current tile's 2D index\n            ivec2 curr_itile = itile + ivec2(ioffs_x, ioffs_y);\n            \n            // current tile's bounds\n            vec2 tile_bl = vec2(curr_itile) * TILE_SIZE;\n            vec2 tile_tl = tile_bl + TILE_SIZE;\n            vec2 tile_center = tile_bl + HALF_TILE_SIZE;\n            \n            // fetch input image color at tile center\n            vec4 input_data = texture(\n                iChannel1,\n                (tile_center * min_res + res) / (2. * res)\n            );\n            vec3 input_col = input_data.rgb / max(1., input_data.w);\n            input_col += EXP_MIN_LOG2_INPUT;\n            \n            // for each color channel red, green, and blue, render a\n            // bunch of disks with the opposite color. the number of\n            // disks is calculated using a poisson random\n            // distribution.\n            for (int ch = 0; ch < 3; ch++)\n            {\n                // if we've already rendered a disk with the\n                // opposite color of the current channel, we\n                // don't need to do anything else.\n                if (col[ch] < .1)\n                {\n                    continue;\n                }\n            \n                // average rate of disks per tile which is based on\n                // log2(color channel intensity at tile center).\n                float mean_rate = MAX_MEAN_RATE * remap01(\n                    log2(input_col[ch]),\n                    MIN_LOG2_INPUT,\n                    MAX_LOG2_INPUT\n                );\n                \n                // initialize PRNG for the current tile and channel\n                // make sure this seed is different in buffer B\n                // and C.\n                prng_init(vec3(curr_itile + 100, ch + 100));\n                \n                // figure out the exact number of disks to render\n                // using a poisson distribution.\n                int n_disks = random_poisson(mean_rate);\n                \n                // render disks with the opposite color of the\n                // current color channel with multiplicative\n                // blending (just set the current channel to 0).\n                for (int i = 0; i < n_disks; i++)\n                {\n                    vec2 center = tile_bl + TILE_SIZE * vec2(random(), random());\n                    \n                    float log_radius = remap(\n                        random(),\n                        0., 1.,\n                        LOG_MIN_GRAIN_RADIUS, LOG_MAX_GRAIN_RADIUS\n                    );\n                    float radius = exp(log_radius);\n                    \n                    if (dist_sq(uv, center) < radius * radius)\n                    {\n                        col[ch] = 0.;\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    \n    // visualize tiles for testing\n    #if 0\n        col.rg = abs(sin(vec2(itile) * PI_OVER_2));\n        col.b *= .5;\n    #endif\n    \n    return col;\n}\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    // the first pixel (0, 0) stores resolution\n    if (ivec2(frag_coord) == ivec2(0))\n    {\n        frag_col = vec4(iResolution.xy, 0, 0);\n        return;\n    }\n    \n    // before doing anything, wait for buffer B to converge\n    vec4 prev_buf_data = texelFetch(iChannel1, ivec2(frag_coord), 0);\n    if (prev_buf_data.w < 100.)\n    {\n        frag_col = vec4(\n            prev_buf_data.rgb / max(1., prev_buf_data.w),\n            0\n        );\n        return;\n    }\n    \n    // fetch previous frame's resolution and see if it's changed\n    vec2 prev_res = texelFetch(iChannel0, ivec2(0), 0).xy;\n    bool res_changed = dist_sq(iResolution.xy, prev_res) > .9;\n\n    // fetch previous frame's values\n    // (XYZ = RGB, W = number of samples accumulated)\n    vec4 prev_data = texelFetch(iChannel0, ivec2(frag_coord), 0);\n    \n    // reset previous data if we're on the first frame or when the\n    // resolution changes.\n    if (iFrame < 1 || iTime < .02 || prev_data.w < .9 || res_changed)\n    {\n        prev_data = vec4(0);\n    }\n    \n    // initialize PRNG\n    prng_init(vec3(frag_coord, iTime + float(iFrame + 200)));\n    \n    // render with box jitter sampling\n    vec3 col = vec3(0);\n    const int N_SAMPLES = 1;\n    for (int i = 0; i < N_SAMPLES; i++)\n    {\n        vec2 offs = vec2(random(), random()) - .5;\n        col += render(frag_coord + offs);\n    }\n    col /= float(N_SAMPLES);\n    \n    // add to the previously accumulated samples\n    frag_col = vec4(prev_data.rgb + col, prev_data.w + 1.);\n}\n",
     "name": "Buffer C",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "XXcyDB",
    "date": "1735546355",
    "viewed": 137,
    "name": "Fork Fractal Explorer (+flim)",
    "description": " More fractal fun! This time with a single pass depth of field effect. MOUSE DRAG to turn WASD & cursor keys to move. SHIFT for speed up. SPACE for another speed up!\n",
    "likes": 1,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "3d",
     "fractal",
     "dof",
     "fractalexplorerdof"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XlXXRj",
       "filepath": "https://soundcloud.com/art-zero/zzzzra-a-few-days-of-invinite",
       "type": "musicstream",
       "channel": 3,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 0
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fractal Explorer DOF. January 2016\n// by David Hoskins\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// https://www.shadertoy.com/view/4s3GW2\n\n\n//-------------------------------------------------------------------------------------------\n\nconst float GA =2.399; \nconst mat2 rot = mat2(cos(GA),sin(GA),-sin(GA),cos(GA));\n\nvec3 dof(vec2 uv,float rad, float zed)\n{\n\tvec3 acc=vec3(0);\n    vec2 pixel=vec2(iResolution.y/iResolution.x,1.)*0.003, angle=vec2(0,rad);;\n    vec3 central = texture(iChannel0, uv, -99.0).xyz;\n    rad=1.;\n\tfor (int j=0;j<80;j++)\n    {  \n        rad += 1./rad;\n\t    angle*=rot;\n        vec4 col=texture(iChannel0,uv+pixel*(rad-1.)*angle);\n        acc+= (col.w >= zed) ? col.xyz: central;\n\n    }\n\treturn acc/80.;\n}\n\n//-------------------------------------------------------------------------------------------\n\nvec3 PostEffects(vec3 rgb, vec2 xy)\n{\n    rgb *= smoothstep(0., 2., iTime);\n\n    // Vignette...\n\trgb *= smoothstep(1.2, .3, distance(xy, vec2(.5)));\n\n    // flim\n    rgb = flim_transform(rgb, 2., false);\n\n\t// OETF\n\trgb = pow(rgb, vec3(1. / 2.2));\n\n\t// Then...\n\t#define CONTRAST 1.4\n\t#define SATURATION 1.5\n\t#define BRIGHTNESS 1.\n\trgb = mix(vec3(.5), mix(vec3(dot(vec3(.2125, .7154, .0721), rgb*BRIGHTNESS)), rgb*BRIGHTNESS, SATURATION), CONTRAST);\n\n\treturn clamp(rgb, 0., 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float zed = texture(iChannel0, uv).w;\n\tfloat radius = abs(zed-1.)*.05;\n    radius*= radius;\n\tfragColor = vec4(PostEffects(dof(uv, radius, zed-2.), uv), 1);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "4dXGRr",
       "filepath": "/presets/tex00.jpg",
       "type": "keyboard",
       "channel": 3,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "nearest",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "// Adaption of Ben Quantock, WASD 2016 ( https://www.shadertoy.com/view/ldyGzW )\n// With speed limits and frame delta added by Dave Hoskins.\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define INVERT_Y 0\n\n#define ACCEL .01\n#define DECAY  .85 // how much velocity is preserved per frame (proportionally)\n#define MAX_SPEED  .02\n\n#if INVERT_Y\nconst float yMul = 1.0;\n#else\nconst float yMul = -1.0;\n#endif\nconst int KEY_W\t\t= 87;\nconst int KEY_A\t\t= 65;\nconst int KEY_S\t\t= 83;\nconst int KEY_D\t\t= 68;\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\n\nconst int KEY_SPACE\t= 32;\nconst int KEY_SHIFT\t= 16;\n\n//----------------------------------------------------------------------------------------\nfloat ReadKey( int key )\n{\n   \treturn step(.5,texture( iChannel3, vec2( (float(key)+.5)/256.0, .25)).x);\n}\n\n//----------------------------------------------------------------------------------------\n#define CSize vec3(1., 1.7, 1.)\n\nfloat Map( vec3 p )\n{\n\tp = p.xzy;\n\tfloat scale = 1.1;\n\tfor( int i=0; i < 8;i++ )\n\t{\n\t\tp = 2.0*clamp(p, -CSize, CSize) - p;\n\t\tfloat r2 = dot(p,p);\n        //float r2 = dot(p,p+sin(p.z*.3)); //Alternate fractal\n\t\tfloat k = max((2.)/(r2), .5);\n\t\tp     *= k;\n\t\tscale *= k;\n\t}\n\tfloat l = length(p.xy);\n\tfloat rxy = l - 1.0;\n\tfloat n = l * p.z;\n\trxy = max(rxy, (n) / 8.);\n\treturn (rxy) / abs(scale);\n}\n\n//----------------------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,0.0,1.0);\n\n    if ( int(fragCoord.y) == 0 )\n    {\n        if ( int(fragCoord.x) == 0 )\n        {\n            vec3 camPos = texture( iChannel0, vec2(.5,.5)/iResolution.xy, -100.0 ).xyz;\n            vec3 camVel = texture( iChannel0, vec2(3.5,.5)/iResolution.xy, -100.0 ).xyz;\n            float time  = (iTime-texture( iChannel0, vec2(4.5,.5)/iResolution.xy, -100.0 ).x)*30.0;\n             if (iFrame == 0)\n\t\t    {\n        \t\tfragColor = vec4(-10.0,-1.2,2.5, 1.);\n            }else\n            {\n                camVel *= time*(1.0+ReadKey(KEY_SHIFT)+ReadKey(KEY_SPACE));\n                vec3 oldCam = camPos;\n                camPos.x += camVel.x;if (Map(camPos) < 0.002) camPos.x = oldCam.x;\n                camPos.y += camVel.y;if (Map(camPos) < 0.002) camPos.y = oldCam.y;\n                camPos.z += camVel.z;if (Map(camPos) < 0.002) camPos.z = oldCam.z;\n            \tfragColor = vec4(camPos, 0);\n            }\n        }\n        else if ( int(fragCoord.x) <= 2 )\n        {\n            vec4 baseCamRot = texture( iChannel0, vec2(2.5,.5)/iResolution.xy, -100.0 );\n            vec4 camRot = texture( iChannel0, vec2(1.5,.5)/iResolution.xy, -100.0 );\n\n            vec2 mouseRot = (iMouse.yx/iResolution.yx-.5)*vec2(.5*yMul,1.);\n            \n            camRot.w = iMouse.z;\n            \n            bool press = (camRot.w > .0);\n            bool lastPress = (baseCamRot.w > .0);\n            bool click = press && !lastPress;\n            if ( click )\n            {\n                baseCamRot.xy -= mouseRot;\n            }\n            \n            if ( press )\n            {\n                camRot.xy = baseCamRot.xy + mouseRot;\n            }\n            else\n            {\n                //update the base pos\n                baseCamRot = camRot;\n            }\n\n            baseCamRot.w = camRot.w;\n            \n            // store\n            if ( int(fragCoord.x) == 1 )\n            {\n\t\t\t\tif (iFrame == 0)\n\t\t    \t{\n        \t\t\tfragColor = vec4(1., 0.1, 0,0);\n            \t}else\n            \tfragColor = camRot;\n            }\n            else\n            {\n            \tfragColor = baseCamRot;\n            }\n        }\n        else if ( int(fragCoord.x) == 3 )\n        {\n            vec4 camVel = texture( iChannel0, vec2(3.5,.5)/iResolution.xy, -100.0 );\n            vec4 camRot = texture( iChannel0, vec2(1.5,.5)/iResolution.xy, -100.0 )*6.28318530718;\n            \n            vec3 forward = vec3(0,0,ACCEL);\n            vec3 right \t = vec3(ACCEL,0,0);\n\n            forward.zy = forward.zy*cos(camRot.x) + sin(camRot.x)*vec2(1,-1)*forward.yz;\n            right.zy = right.zy*cos(camRot.x) + sin(camRot.x)*vec2(1,-1)*right.yz;\n                \n            forward.xz = forward.xz*cos(camRot.y) + sin(camRot.y)*vec2(1,-1)*forward.zx;\n\t\t    right.xz = right.xz*cos(camRot.y) + sin(camRot.y)*vec2(1,-1)*right.zx;\n            \n            camVel.xyz += (ReadKey(KEY_W)-ReadKey(KEY_S)+ReadKey(KEY_UP)-ReadKey(KEY_DOWN)) * forward;\n            camVel.xyz += (ReadKey(KEY_D)-ReadKey(KEY_A)+ReadKey(KEY_RIGHT)-ReadKey(KEY_LEFT)) * right;\n            \n\n            camVel *= DECAY; // exponential decay\n            float lim = length(camVel);\n            if (lim > MAX_SPEED)\n            {\n                camVel = normalize(camVel) * MAX_SPEED;\n            }\n        \n            \n            fragColor = camVel;\n        }\n\t\telse if ( int(fragCoord.x) == 4 )\n        {\n\t\t\tfragColor = vec4(iTime);\n\t    }\n    }\n}\n",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [
      {
       "id": "XdX3Rn",
       "filepath": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg",
       "type": "texture",
       "channel": 1,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4df3Rr",
       "filepath": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg",
       "type": "texture",
       "channel": 3,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "false",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "nearest",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "XsXGR8",
       "channel": 0
      }
     ],
     "code": "// Fractal Explorer DOF. January 2016\n// by David Hoskins\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// https://www.shadertoy.com/view/4s3GW2\n\n//--------------------------------------------------------------------------\n#define SUN_COLOUR vec3(1., .9, .85)\n#define FOG_COLOUR vec3(.13, 0.13, 0.14)\n#define MOD3 .1031\n#define TAU 6.28318530718\n#define STORE_DE\n\nvec2 fcoord;\n\nvec2 camStore = vec2(4.0,  0.0);\nvec2 rotationStore\t= vec2(1.,  0.);\nvec2 mouseStore = vec2(2.,  0.);\nvec3 sunLight  = vec3(  0.4, 0.4,  0.3 );\n\n// By TekF...\nvoid BarrelDistortion( inout vec3 ray, float degree )\n{\n\tray.z /= degree;\n\tray.z = ( ray.z*ray.z - dot(ray.xy,ray.xy) );\n\tray.z = degree*sqrt(ray.z);\n}\n\n//--------------------------------------------------------------------------\nvec3 loadValue3( in vec2 re )\n{\n    return texture( iChannel0, (0.5+re) / iChannelResolution[0].xy, -100.0 ).xyz;\n}\nvec2 loadValue2( in vec2 re )\n{\n    return texture( iChannel0, (0.5+re) / iChannelResolution[0].xy, -100.0 ).xy;\n}\n\n//----------------------------------------------------------------------------------------\n// From https://www.shadertoy.com/view/4djSRW\nfloat Hash(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * MOD3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nmat3 RotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\n//----------------------------------------------------------------------------------------\n#define CSize vec3(1., 1.7, 1.)\nvec3 Colour( vec3 p)\n{\n    p = p.xzy;\n\tfloat col\t= 0.0;\n    float r2\t= dot(p,p);\n\tfor( int i=0; i < 5;i++ )\n\t{\n\t\tvec3 p1= 2.0 * clamp(p, -CSize, CSize)-p;\n\t\tcol += abs(p.x-p1.z);\n\t\tp = p1;\n\t\tr2 = dot(p,p);\n        //float r2 = dot(p,p+sin(p.z*.3)); //Alternate fractal\n\t\tfloat k = max((2.)/(r2), .5);\n\t\tp *= k;\n\t}\n    return texture(iChannel3, vec2(p.x, p.y+p.z)*.2).xyz+vec3(.4, .2, 0.2);\n}\n\n//--------------------------------------------------------------------------\n\nfloat Map( vec3 p )\n{\n\tp = p.xzy;\n\tfloat scale = 1.1;\n\tfor( int i=0; i < 8;i++ )\n\t{\n\t\tp = 2.0*clamp(p, -CSize, CSize) - p;\n\t\tfloat r2 = dot(p,p);\n        //float r2 = dot(p,p+sin(p.z*.3)); //Alternate fractal\n\t\tfloat k = max((2.)/(r2), .5);\n\t\tp     *= k;\n\t\tscale *= k;\n\t}\n\tfloat l = length(p.xy);\n\tfloat rxy = l - 1.0;\n\tfloat n = l * p.z;\n\trxy = max(rxy, (n) / 8.);\n\treturn (rxy) / abs(scale);\n}\n\n//--------------------------------------------------------------------------\nfloat Shadow( in vec3 ro, in vec3 rd)\n{\n\tfloat res = 1.0;\n    float t = 0.05;\n\tfloat h;\n\t\n    for (int i = 0; i < 12; i++)\n\t{\n\t\th = Map( ro + rd*t );\n\t\tres = min(6.0*h / t, res);\n\t\tt += h+.02;\n\t}\n    return max(res, 0.0);\n}\n\n//--------------------------------------------------------------------------\nvec3 DoLighting(in vec3 mat, in vec3 pos, in vec3 normal, in vec3 eyeDir, in float d, in float sh)\n{\n    vec3 sunLight  = normalize( vec3(  0.4, 0.4,  0.3 ) );\n\tsh = Shadow(pos,  sunLight);\n    // Light surface with 'sun'...\n\tvec3 col = mat * SUN_COLOUR*(max(dot(sunLight,normal), 0.0)) *sh;\n    col += mat * vec3(.01, 0, .06)*(max(dot(-sunLight,normal), 0.0));\n    \n    normal = reflect(eyeDir, normal); // Specular...\n    col += pow(max(dot(sunLight, normal), 0.0), 12.0)  * SUN_COLOUR * .5 *sh;\n    // Abmient..\n    col += mat * .2 * max(normal.y, 0.2);\n    col = mix(FOG_COLOUR,col, clamp(exp(-d*.05)+.03,0.0, 1.0));\n    \n\treturn col;\n}\n\n//--------------------------------------------------------------------------\nvec3 GetNormal(vec3 p, float sphereR)\n{\n\tvec2 eps = vec2(sphereR, 0.0);\n\treturn normalize( vec3(\n           Map(p+eps.xyy) - Map(p-eps.xyy),\n           Map(p+eps.yxy) - Map(p-eps.yxy),\n           Map(p+eps.yyx) - Map(p-eps.yyx) ) );\n}\n\n//--------------------------------------------------------------------------\nfloat SphereRadius(in float t)\n{\n    t = t * .001*(500./iResolution.y);\n    return (t+.001);\n}\n\n//--------------------------------------------------------------------------\nfloat Scene(in vec3 rO, in vec3 rD)\n{\n\n\tfloat t = .05 * Hash(fcoord);\n\t\n\tvec3 p = vec3(0.0);\n\n\tfor( int j=0; j < 180; j++ )\n\t{\n\t\tif (t > 24.0) break;\n\t\tp = rO + t*rD;\n\t\tfloat sphereR = SphereRadius(t);\n\t\tfloat de = Map(p);\n\t\tif(abs(de) < sphereR) break;\n\t\tt +=  de*.8;\n\t}\n\n\treturn t;\n}\n\n//--------------------------------------------------------------------------\n\n\n//--------------------------------------------------------------------------\nvec3 TexCube( sampler2D sam, in vec3 p, in vec3 n )\n{\n\tvec3 x = texture( sam, p.yz ).xzy;\n\tvec3 y = texture( sam, p.zx ).xyz;\n\tvec3 z = texture( sam, p.xy ).yzx;\n\treturn (x*abs(n.x) + y*abs(n.y) + z*abs(n.z))/(abs(n.x)+abs(n.y)+abs(n.z));\n}\n\n//--------------------------------------------------------------------------\nvec3 Albedo(vec3 pos, vec3 nor)\n{\n    vec3 col = TexCube(iChannel1, pos*1.3, nor).zxy;\n    col *= Colour(pos);\n    return col;\n}\n\n//----------------------------------------------------------------------------------------\n\nvec2 rot2D(inout vec2 p, float a)\n{\n    return cos(a)*p - sin(a) * vec2(p.y, -p.x);\n}\n\n//--------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fcoord = fragCoord;\n\tfloat m = (iMouse.x/iResolution.x)*20.0;\n\tfloat gTime = ((iTime+26.)*.2+m);\n    vec2 xy = fragCoord.xy / iResolution.xy;\n\tvec2 uv = (-1. + 2.0 * xy) * vec2(iResolution.x/iResolution.y,1.0);\n\n  \n\t\n    //vec3 cameraPos= loadValue3(camStore).xyz;\n    //vec2 mou = loadValue2(rotationStore);\n    \n    vec3 cameraPos = texture( iChannel0, vec2(.5,.5)/iResolution.xy, -100.0 ).xyz;\n    vec2 camRot = texture( iChannel0, vec2(1.5,.5)/iResolution.xy, -100.0 ).xy;\n\n    camRot*= TAU;\n    \n    vec3 dir = normalize( vec3(uv, 1.2 ) );\n    BarrelDistortion(dir, .5);\n    dir =  normalize(dir);\n\n    float roll = .05 * sin(iTime*.3);\n    dir.xy = dir.xy*cos(roll) + sin(roll)*vec2(1,-1)*dir.yx;\n    dir.zy = dir.zy*cos(camRot.x) + sin(camRot.x)*vec2(1,-1)*dir.yz;\n    dir.xz = dir.xz*cos(camRot.y) + sin(camRot.y)*vec2(1,-1)*dir.zx;\n   \n\tvec3 col = vec3(1.0);\n\n    float dis = Scene(cameraPos, dir);\n\t\n    if (dis < 24.0)\n    {\n\t    vec3 pos = cameraPos + dir * dis;\n  \t\tfloat sphereR = SphereRadius(dis);\n        vec3 normal = GetNormal(pos, sphereR);\n\n    \tfloat sha = Shadow(pos, sunLight);\n    \n        vec3 alb = Albedo(pos, normal);\n        col = DoLighting(alb, pos, normal, dir, dis, sha);\n    }else\n    {\n   \t\tcol = FOG_COLOUR;\n        col += pow(max(dot(sunLight, dir), 0.0), 5.0)  * SUN_COLOUR;\n    }\n    \n\tfragColor=vec4(col,dis);\n}\n",
     "name": "Buffer B",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "/*-----------------------------------------------\n\nflim - Filmic Color Transform\n\nInput Color Space:   Linear BT.709 I-D65\nOutput Color Space:  Linear BT.709 I-D65 / sRGB 2.2 (depends on arguments)\n\nDescription:\n  Experimental port of flim for GLSL/Shadertoy\n  matching flim v1.1.0.\n\nAuthor:\n  Bean (beans_please on Shadertoy)\n\nOriginal Repo:\n  https://github.com/bean-mhm/flim\n\nOriginal Shader:\n  https://www.shadertoy.com/view/dd2yDz\n\n-----------------------------------------------*/\n\n// parameters\n\nconst float flim_pre_exposure = 4.3;\nconst vec3 flim_pre_formation_filter = vec3(1.);\nconst float flim_pre_formation_filter_strength = 0.;\n\nconst float flim_extended_gamut_red_scale = 1.05;\nconst float flim_extended_gamut_green_scale = 1.12;\nconst float flim_extended_gamut_blue_scale = 1.045;\nconst float flim_extended_gamut_red_rot = .5;\nconst float flim_extended_gamut_green_rot = 2.;\nconst float flim_extended_gamut_blue_rot = .1;\nconst float flim_extended_gamut_red_mul = 1.;\nconst float flim_extended_gamut_green_mul = 1.;\nconst float flim_extended_gamut_blue_mul = 1.;\n\nconst float flim_sigmoid_log2_min = -10.;\nconst float flim_sigmoid_log2_max = 22.;\nconst float flim_sigmoid_toe_x = .44;\nconst float flim_sigmoid_toe_y = .28;\nconst float flim_sigmoid_shoulder_x = .591;\nconst float flim_sigmoid_shoulder_y = .779;\n\nconst float flim_negative_film_exposure = 6.;\nconst float flim_negative_film_density = 5.;\n\nconst vec3 flim_print_backlight = vec3(1);\nconst float flim_print_film_exposure = 6.;\nconst float flim_print_film_density = 27.5;\n\nconst float flim_black_point = -1.; // -1 = auto\nconst vec3 flim_post_formation_filter = vec3(1);\nconst float flim_post_formation_filter_strength = 0.;\nconst float flim_midtone_saturation = 1.02;\n\n// color space conversions\n// the matrices below represent data in row-major, but GLSL matrices are in\n// column-major, so we need to multiply a vec3 by a matrix rather than\n// multiplying a matrix by a vec3.\n\nconst mat3 mat_bt2020_to_xyz = mat3(\n     0.6369580483,  0.1446169036,  0.1688809752,\n     0.2627002120,  0.6779980715,  0.0593017165,\n     0.0000000000,  0.0280726930,  1.0609850577\n);\n\nconst mat3 mat_xyz_to_bt2020 = mat3(\n     1.7166511880, -0.3556707838, -0.2533662814,\n    -0.6666843518,  1.6164812366,  0.0157685458,\n     0.0176398574, -0.0427706133,  0.9421031212\n);\n\nconst mat3 mat_bt709_to_xyz = mat3(\n     0.4123907993,  0.3575843394,  0.1804807884,\n     0.2126390059,  0.7151686788,  0.0721923154,\n     0.0193308187,  0.1191947798,  0.9505321522\n);\n\nconst mat3 mat_xyz_to_bt709 = mat3(\n     3.2409699419, -1.5373831776, -0.4986107603,\n    -0.9692436363,  1.8759675015,  0.0415550574,\n     0.0556300797, -0.2039769589,  1.0569715142\n);\n\nconst mat3 mat_dcip3_to_xyz = mat3(\n     0.4451698156,  0.2771344092,  0.1722826698,\n     0.2094916779,  0.7215952542,  0.0689130679,\n     0.0000000000,  0.0470605601,  0.9073553944\n);\n\nconst mat3 mat_xyz_to_dcip3 = mat3(\n     2.7253940305, -1.0180030062, -0.4401631952,\n    -0.7951680258,  1.6897320548,  0.0226471906,\n     0.0412418914, -0.0876390192,  1.1009293786\n);\n\nvec3 oetf_pow(vec3 col, float power)\n{\n    return pow(col, vec3(1. / power));\n}\n\nvec3 eotf_pow(vec3 col, float power)\n{\n    return pow(col, vec3(power));\n}\n\n// flim's utility functions\n\nfloat flim_wrap(float v, float start, float end)\n{\n    return start + mod(v - start, end - start);\n}\n\nfloat flim_remap(\n    float v,\n    float inp_start,\n    float inp_end,\n    float out_start,\n    float out_end\n)\n{\n    return out_start\n        + ((out_end - out_start) / (inp_end - inp_start)) * (v - inp_start);\n}\n\nfloat flim_remap_clamp(\n    float v,\n    float inp_start,\n    float inp_end,\n    float out_start,\n    float out_end\n)\n{\n    float t = clamp((v - inp_start) / (inp_end - inp_start), 0., 1.);\n    return out_start + t * (out_end - out_start);\n}\n\nfloat flim_remap01(\n    float v,\n    float inp_start,\n    float inp_end\n)\n{\n    return clamp((v - inp_start) / (inp_end - inp_start), 0., 1.);\n}\n\nvec3 flim_blender_rgb_to_hsv(vec3 rgb)\n{\n    float cmax, cmin, h, s, v, cdelta;\n    vec3 c;\n\n    cmax = max(rgb[0], max(rgb[1], rgb[2]));\n    cmin = min(rgb[0], min(rgb[1], rgb[2]));\n    cdelta = cmax - cmin;\n\n    v = cmax;\n    if (cmax != 0.)\n    {\n        s = cdelta / cmax;\n    }\n    else\n    {\n        s = 0.;\n        h = 0.;\n    }\n\n    if (s == 0.)\n    {\n        h = 0.;\n    }\n    else\n    {\n        c = (vec3(cmax) - rgb.xyz) / cdelta;\n\n        if (rgb.x == cmax)\n        {\n            h = c[2] - c[1];\n        }\n        else if (rgb.y == cmax)\n        {\n            h = 2. + c[0] - c[2];\n        }\n        else\n        {\n            h = 4. + c[1] - c[0];\n        }\n\n        h /= 6.;\n\n        if (h < 0.)\n        {\n            h += 1.;\n        }\n    }\n\n    return vec3(h, s, v);\n}\n\nvec3 flim_blender_hsv_to_rgb(vec3 hsv)\n{\n    float f, p, q, t, h, s, v;\n    vec3 rgb;\n\n    h = hsv[0];\n    s = hsv[1];\n    v = hsv[2];\n\n    if (s == 0.)\n    {\n        rgb = vec3(v, v, v);\n    }\n    else\n    {\n        if (h == 1.)\n        {\n            h = 0.;\n        }\n\n        h *= 6.;\n        int i = int(floor(h));\n        f = h - float(i);\n        rgb = vec3(f, f, f);\n        p = v * (1. - s);\n        q = v * (1. - (s * f));\n        t = v * (1. - (s * (1. - f)));\n\n        if (i == 0)\n        {\n            rgb = vec3(v, t, p);\n        }\n        else if (i == 1)\n        {\n            rgb = vec3(q, v, p);\n        }\n        else if (i == 2)\n        {\n            rgb = vec3(p, v, t);\n        }\n        else if (i == 3)\n        {\n            rgb = vec3(p, q, v);\n        }\n        else if (i == 4)\n        {\n            rgb = vec3(t, p, v);\n        }\n        else\n        {\n            rgb = vec3(v, p, q);\n        }\n    }\n\n    return rgb;\n}\n\nvec3 flim_blender_hue_sat(vec3 col, float hue, float sat, float value)\n{\n    vec3 hsv = flim_blender_rgb_to_hsv(col);\n\n    hsv[0] = fract(hsv[0] + hue + .5);\n    hsv[1] = clamp(hsv[1] * sat, 0., 1.);\n    hsv[2] = hsv[2] * value;\n\n    return flim_blender_hsv_to_rgb(hsv);\n}\n\nfloat flim_rgb_avg(vec3 col)\n{\n    return (col.x + col.y + col.z) / 3.;\n}\n\nfloat flim_rgb_sum(vec3 col)\n{\n    return col.x + col.y + col.z;\n}\n\nfloat flim_rgb_max(vec3 col)\n{\n    return max(max(col.x, col.y), col.z);\n}\n\nfloat flim_rgb_min(vec3 col)\n{\n    return min(min(col.x, col.y), col.z);\n}\n\nvec3 flim_rgb_uniform_offset(vec3 col, float black_point, float white_point)\n{\n    float mono = flim_rgb_avg(col);\n    float mono2 = flim_remap01(\n        mono, black_point / 1000.,\n        1. - (white_point / 1000.)\n    );\n    return col * (mono2 / mono);\n}\n\nvec3 flim_rgb_sweep(float hue)\n{\n    hue = flim_wrap(hue * 360., 0., 360.);\n\n    vec3 col = vec3(1, 0, 0);\n    col = mix(col, vec3(1, 1, 0), flim_remap01(hue, 0., 60.));\n    col = mix(col, vec3(0, 1, 0), flim_remap01(hue, 60., 120.));\n    col = mix(col, vec3(0, 1, 1), flim_remap01(hue, 120., 180.));\n    col = mix(col, vec3(0, 0, 1), flim_remap01(hue, 180., 240.));\n    col = mix(col, vec3(1, 0, 1), flim_remap01(hue, 240., 300.));\n    col = mix(col, vec3(1, 0, 0), flim_remap01(hue, 300., 360.));\n    \n    return col;\n}\n\nvec3 flim_rgb_exposure_sweep_test(vec2 uv0to1)\n{\n    float hue = 1. - uv0to1.y;\n    float exposure = flim_remap(uv0to1.x, 0., 1., -5., 10.);\n    return flim_rgb_sweep(hue) * pow(2., exposure);\n}\n\n// https://www.desmos.com/calculator/khkztixyeu\nfloat flim_super_sigmoid(\n    float v,\n    float toe_x,\n    float toe_y,\n    float shoulder_x,\n    float shoulder_y\n)\n{\n    // clip\n    v = clamp(v, 0., 1.);\n    toe_x = clamp(toe_x, 0., 1.);\n    toe_y = clamp(toe_y, 0., 1.);\n    shoulder_x = clamp(shoulder_x, 0., 1.);\n    shoulder_y = clamp(shoulder_y, 0., 1.);\n\n    // calculate straight line slope\n    float slope = (shoulder_y - toe_y) / (shoulder_x - toe_x);\n\n    // toe\n    if (v < toe_x)\n    {\n        float toe_pow = slope * toe_x / toe_y;\n        return toe_y * pow(v / toe_x, toe_pow);\n    }\n\n    // straight line\n    if (v < shoulder_x)\n    {\n        float intercept = toe_y - (slope * toe_x);\n        return slope * v + intercept;\n    }\n\n    // shoulder\n    float shoulder_pow =\n        -slope / (\n            ((shoulder_x - 1.) / pow(1. - shoulder_x, 2.))\n            * (1. - shoulder_y)\n        );\n    return\n        (1. - pow(1. - (v - shoulder_x) / (1. - shoulder_x), shoulder_pow))\n        * (1. - shoulder_y)\n        + shoulder_y;\n}\n\nfloat flim_dye_mix_factor(float mono, float max_density)\n{\n    // log2 and map range\n    float offset = pow(2., flim_sigmoid_log2_min);\n    float fac = flim_remap01(\n        log2(mono + offset),\n        flim_sigmoid_log2_min,\n        flim_sigmoid_log2_max\n    );\n\n    // calculate amount of exposure from 0 to 1\n    fac = flim_super_sigmoid(\n        fac,\n        flim_sigmoid_toe_x,\n        flim_sigmoid_toe_y,\n        flim_sigmoid_shoulder_x,\n        flim_sigmoid_shoulder_y\n    );\n\n    // calculate dye density\n    fac *= max_density;\n\n    // mix factor\n    fac = pow(2., -fac);\n\n    // clip and return\n    return clamp(fac, 0., 1.);\n}\n\nvec3 flim_rgb_color_layer(\n    vec3 col,\n    vec3 sensitivity_tone,\n    vec3 dye_tone,\n    float max_density\n)\n{\n    // normalize\n    vec3 sensitivity_tone_norm =\n        sensitivity_tone / flim_rgb_sum(sensitivity_tone);\n    vec3 dye_tone_norm = dye_tone / flim_rgb_max(dye_tone);\n\n    // dye mix factor\n    float mono = dot(col, sensitivity_tone_norm);\n    float mix_fac = flim_dye_mix_factor(mono, max_density);\n\n    // dye mixing\n    return mix(dye_tone_norm, vec3(1), mix_fac);\n}\n\nvec3 flim_rgb_develop(vec3 col, float exposure, float max_density)\n{\n    // exposure\n    col *= pow(2., exposure);\n\n    // blue-sensitive layer\n    vec3 result = flim_rgb_color_layer(\n        col,\n        vec3(0, 0, 1),\n        vec3(1, 1, 0),\n        max_density\n    );\n\n    // green-sensitive layer\n    result *= flim_rgb_color_layer(\n        col,\n        vec3(0, 1, 0),\n        vec3(1, 0, 1),\n        max_density\n    );\n\n    // red-sensitive layer\n    result *= flim_rgb_color_layer(\n        col,\n        vec3(1, 0, 0),\n        vec3(0, 1, 1),\n        max_density\n    );\n\n    return result;\n}\n\nvec3 flim_gamut_extension_mat_row(\n    float primary_hue,\n    float scale,\n    float rotate,\n    float mul\n)\n{\n    vec3 result = flim_blender_hsv_to_rgb(vec3(\n        flim_wrap(primary_hue + (rotate / 360.), 0., 1.),\n        1. / scale,\n        1.\n    ));\n    result /= flim_rgb_sum(result);\n    result *= mul;\n    return result;\n}\n\nmat3 flim_gamut_extension_mat(\n    float red_scale,\n    float green_scale,\n    float blue_scale,\n    float red_rot,\n    float green_rot,\n    float blue_rot,\n    float red_mul,\n    float green_mul,\n    float blue_mul\n)\n{\n    mat3 m;\n    m[0] = flim_gamut_extension_mat_row(\n        0.,\n        red_scale,\n        red_rot,\n        red_mul\n    );\n    m[1] = flim_gamut_extension_mat_row(\n        1. / 3.,\n        green_scale,\n        green_rot,\n        green_mul\n    );\n    m[2] = flim_gamut_extension_mat_row(\n        2. / 3.,\n        blue_scale,\n        blue_rot,\n        blue_mul\n    );\n    return m;\n}\n\nvec3 negative_and_print(vec3 col, vec3 backlight_ext)\n{\n    // develop negative\n    col = flim_rgb_develop(\n        col,\n        flim_negative_film_exposure,\n        flim_negative_film_density\n    );\n\n    // backlight\n    col *= backlight_ext;\n\n    // develop print\n    col = flim_rgb_develop(\n        col,\n        flim_print_film_exposure,\n        flim_print_film_density\n    );\n\n    return col;\n}\n\n// the flim transform\n\nvec3 flim_transform(vec3 col, float exposure, bool convert_to_srgb)\n{\n    // eliminate negative values\n    col = max(col, 0.);\n\n    // pre-Exposure\n    col *= pow(2., flim_pre_exposure + exposure);\n\n    // clip very large values for float precision issues\n    col = min(col, 5000.);\n\n    // gamut extension matrix (Linear BT.709)\n    mat3 extend_mat = flim_gamut_extension_mat(\n        flim_extended_gamut_red_scale,\n        flim_extended_gamut_green_scale,\n        flim_extended_gamut_blue_scale,\n        flim_extended_gamut_red_rot,\n        flim_extended_gamut_green_rot,\n        flim_extended_gamut_blue_rot,\n        flim_extended_gamut_red_mul,\n        flim_extended_gamut_green_mul,\n        flim_extended_gamut_blue_mul\n    );\n    mat3 extend_mat_inv = inverse(extend_mat);\n\n    // backlight in the extended gamut\n    vec3 backlight_ext = flim_print_backlight * extend_mat;\n\n    // upper limit in the print (highlight cap)\n    const float big = 10000000.;\n    vec3 white_cap = negative_and_print(vec3(big, big, big), backlight_ext);\n\n    // pre-formation filter\n    col = mix(\n        col,\n        col * flim_pre_formation_filter,\n        flim_pre_formation_filter_strength\n    );\n\n    // convert to the extended gamut\n    col *= extend_mat;\n\n    // negative & print\n    col = negative_and_print(col, backlight_ext);\n\n    // convert from the extended gamut\n    col *= extend_mat_inv;\n\n    // eliminate negative values\n    col = max(col, 0.);\n\n    // white cap\n    col /= white_cap;\n\n    // black cap (-1 = auto)\n    if (flim_black_point == -1.)\n    {\n        vec3 black_cap = negative_and_print(vec3(0.), backlight_ext);\n        black_cap /= white_cap;\n        col = flim_rgb_uniform_offset(\n            col,\n            flim_rgb_avg(black_cap) * 1000.,\n            0.\n        );\n    }\n    else\n    {\n        col = flim_rgb_uniform_offset(col, flim_black_point, 0.);\n    }\n\n    // post-formation filter\n    col = mix(\n        col,\n        col * flim_post_formation_filter,\n        flim_post_formation_filter_strength\n    );\n\n    // clip\n    col = clamp(col, 0., 1.);\n\n    // midtone saturation\n    float mono = flim_rgb_avg(col);\n    float mix_fac =\n        (mono < .5)\n        ? flim_remap01(mono, .05, .5)\n        : flim_remap01(mono, .95, .5);\n    col = mix(\n        col,\n        flim_blender_hue_sat(col, .5, flim_midtone_saturation, 1.),\n        mix_fac\n    );\n\n    // clip\n    col = clamp(col, 0., 1.);\n\n    // OETF\n    if (convert_to_srgb)\n    {\n        col = oetf_pow(col, 2.2);\n    }\n\n    return col;\n}\n\n/*____________________ end ____________________*/\n",
     "name": "Common",
     "description": "",
     "type": "common"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "lXGyDR",
    "date": "1736145027",
    "viewed": 96,
    "name": "Interleaved Gradient Noise ",
    "description": "Low discrepancy or something. I copied the formula form some article, I don't know how it's actually derived.",
    "likes": 3,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "noise",
     "lowdiscrepancy",
     "ign"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// interleaved gradient noise\nfloat ign(ivec2 icoord)\n{\n    float d = .06711056 * float(icoord.x) + .00583715 * float(icoord.y);\n    return mod(52.9829189 * mod(d, 1.), 1.);\n}\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    vec3 col = vec3(ign(ivec2(frag_coord)));\n    frag_col = vec4(pow(col, vec3(1. / 2.2)), 1);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "l3GcWh",
    "date": "1736170686",
    "viewed": 7,
    "name": "Analytical Motion Blur of a Disk",
    "description": "Full derivation with explanations: https://www.desmos.com/calculator/rrlboiohwo",
    "likes": 0,
    "published": "Unlisted",
    "usePreview": 0,
    "tags": [
     "blur",
     "motion",
     "analytical",
     "disk"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "const float DISK_RADIUS = .1;\nconst float DISK_RADIUS_SQ = DISK_RADIUS * DISK_RADIUS;\n\nconst float DISK_ROTATION_FREQ = 1.;\nconst float ONE_OVER_2PI_DISK_ROTATION_FREQ = 1. / (DISK_ROTATION_FREQ * 6.28318530717959);\n\nfloat rotating_disk_with_analytical_motion_blur(\n    vec2 uv,\n    float start_time,\n    float end_time\n)\n{\n    float len_sq = dot(uv, uv);\n    float idk = (len_sq - DISK_RADIUS_SQ + 1.) / (2. * sqrt(len_sq));\n    if (uv.x < 0.)\n    {\n        idk = -idk;\n    }\n    \n    if (abs(idk) > 1.)\n    {\n        return 0.;\n    }\n    \n    float v = 0.;\n    for (int k = 0; k <= 0; k++)\n    {\n        float interval_start = start_time;\n        float interval_end = end_time;\n        \n        if (uv.x < 0.)\n        {\n            interval_start = max(\n                interval_start,\n                ONE_OVER_2PI_DISK_ROTATION_FREQ * (acos(idk) + atan(uv.y / uv.x))\n                - (float(k) / DISK_ROTATION_FREQ)\n            );\n        }\n        else\n        {\n            interval_end = min(\n                interval_end,\n                ONE_OVER_2PI_DISK_ROTATION_FREQ * (acos(idk) + atan(uv.y / uv.x))\n                - (float(k) / DISK_ROTATION_FREQ)\n            );\n        }\n        \n        if (interval_start > interval_end)\n        {\n            continue;\n        }\n        \n        v = max(\n            v,\n            (interval_end - interval_start) / (end_time - start_time)\n        );\n    }\n    return v;\n}\n\nvec3 render(vec2 coord)\n{\n    vec2 uv = (2. * coord - iResolution.xy) / min(iResolution.x, iResolution.y);\n    uv *= 1.5;\n    \n    vec3 col = vec3(rotating_disk_with_analytical_motion_blur(\n        uv,\n        iTime - .1,\n        iTime\n    ));\n    \n    return col;\n}\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    vec3 col = render(frag_coord);\n    frag_col = vec4(pow(col, vec3(1. / 2.2)), 1);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "X3KcDh",
    "date": "1736180148",
    "viewed": 80,
    "name": "High Pass White Noise (Failed)",
    "description": "failed attempt to get blue noise from white noise\n\nsuccessful attempt: [url]https://www.shadertoy.com/view/lXycWt[/url]",
    "likes": 3,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "noise",
     "blue",
     "white"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGzn",
       "filepath": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png",
       "type": "texture",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "const float SQRT_2PI = 2.506628274631;\n\nfloat fetch(vec2 coord)\n{\n    return texture(iChannel0, coord / vec2(textureSize(iChannel0, 0))).x;\n}\n\nfloat sq(float x)\n{\n    return x * x;\n}\n\nfloat gaussian_distribution(float x, float standard_deviation)\n{\n    return exp(-.5 * sq(x / standard_deviation)) / (SQRT_2PI * standard_deviation);\n}\n\n// unnormalized, doesn't add up to 1, maximum value is 1.\nfloat gaussian_unnorm(float x, float standard_deviation)\n{\n    return exp(-.5 * sq(x / standard_deviation));\n}\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    float sum_values = 0.;\n    float sum_weights = 0.;\n    for (int offs_y = -5; offs_y <= 5; offs_y++)\n    {\n        for (int offs_x = -5; offs_x <= 5; offs_x++)\n        {\n            float v = fetch(frag_coord + vec2(offs_x, offs_y));\n            \n            float weight = gaussian_unnorm(\n                length(vec2(offs_x, offs_y)),\n                1.\n            );\n            \n            sum_values += v * weight;\n            sum_weights += weight;\n        }\n    }\n    float low_pass = sum_values / sum_weights;\n    float high_pass = 2. * (fetch(frag_coord) - low_pass);\n    \n    vec3 col = vec3(high_pass);\n    if (mod(iTime, 1.5) < .75)\n    {\n        col = vec3(fetch(frag_coord));\n    }\n    \n    frag_col = vec4(pow(col, vec3(1. / 2.2)), 1);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "MXGyDD",
    "date": "1736256150",
    "viewed": 133,
    "name": "Perlinary",
    "description": "procedural noise",
    "likes": 11,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "procedural",
     "voronoi",
     "noise",
     "texture",
     "random",
     "worley",
     "abstract",
     "cellular",
     "glitter"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// number of color palettes\nconst int N_PALETTES = 8;\n\n// number of colors in each palette\nconst int N_COLORS_IN_PALETTE = 5;\n\n// this array contains every color in every palette in order.\n// every N_COLORS_IN_PALETTE elements represent a palette.\nvec3 PALETTES[N_PALETTES * N_COLORS_IN_PALETTE] = vec3[](\n    vec3(.037, 0, .325),\n    vec3(.349, 0, .099),\n    vec3(1, 0, .087),\n    vec3(1, .087, 0),\n    vec3(1, .517, 0),\n    \n    vec3(.932, .014, .239),\n    vec3(.170, .001, .482),\n    vec3(.038, .001, .374),\n    vec3(.053, .119, .859),\n    vec3(.07, .592, .875),\n    \n    vec3(.02, .022, .051),\n    vec3(.272, .325, .431),\n    vec3(.851, .891, .908),\n    vec3(.867, .013, .041),\n    vec3(.701, 0, .018),\n    \n    vec3(0, .025, .064),\n    vec3(.68, .017, .017),\n    vec3(.932, .216, 0),\n    vec3(.974, .53, .064),\n    vec3(.828, .767, .482),\n\n    vec3(1, .251, .003),\n    vec3(.908, .639, .16),\n    vec3(1, .941, .875),\n    vec3(.344, .701, .652),\n    vec3(.037, .024, .101),\n    \n    vec3(0, 0, 0),\n    vec3(1, .049, .289),\n    vec3(.82, 0, .177),\n    vec3(.2, 0, .6),\n    vec3(1, .875, .19),\n    \n    vec3(.019, 0, .074),\n    vec3(.078, 0, .173),\n    vec3(.573, .013, 0),\n    vec3(.883, .066, 0),\n    vec3(1, .8, .1),\n    \n    vec3(1, .932, .646),\n    vec3(.263, .109, 1),\n    vec3(.145, .051, .548),\n    vec3(.05, .01, .339),\n    vec3(0)\n);\n\nfloat glitter(vec2 uv, int seed_offset)\n{\n    // tile size (we'll draw a bunch of disks inside every tile)\n    const float TILE_SIZE = .08;\n    \n    // number of disks in every tile\n    const int N_DISKS = 40;\n    \n    // radius of the disks\n    // should be a lot smaller than (TILE_SIZE / 2)\n    const float DISK_RADIUS = .003;\n    const float DISK_RADIUS_SQ = DISK_RADIUS * DISK_RADIUS;\n    \n    // 2D index of the current tile\n    ivec2 itile = ivec2(floor(uv / TILE_SIZE));\n    \n    // bottom left and top right coordinates of the tile\n    vec2 tile_bl = vec2(itile) * TILE_SIZE;\n    vec2 tile_tr = tile_bl + TILE_SIZE;\n    \n    // re-seed PRNG with the tile index\n    prng_init(uvec2(itile + 115249 * seed_offset));\n    \n    // draw a bunch of disks inside the current tile\n    float v = 0.;\n    for (int i = 0; i < N_DISKS; i++)\n    {\n        vec2 center = vec2(\n            remap(\n                random(),\n                0.,\n                1.,\n                tile_bl.x + DISK_RADIUS,\n                tile_tr.x - DISK_RADIUS\n            ),\n            remap(\n                random(),\n                0.,\n                1.,\n                tile_bl.y + DISK_RADIUS,\n                tile_tr.y - DISK_RADIUS\n            )\n        );\n        \n        float brightness = pow(random(), 7.);\n        \n        if (dist_sq(uv, center) < DISK_RADIUS_SQ)\n        {\n            v = max(v, brightness);\n        }\n    }\n    return v;\n}\n\nvec3 render(vec2 coord)\n{\n    // 2D world-space UV coordinates\n    vec2 orig_uv = screen_to_uv(coord, iResolution.xy);\n    vec2 uv = orig_uv;\n\n    // translate UV\n    uv += vec2(.01 * iTime, -.02 * iTime);\n\n    // distort UV to create wobbly effect\n    uv += .11 * vec2(\n        perlin(1.4 * uv + 20. + .12 * iTime),\n        perlin(1.4 * uv - 20. + .06 * iTime)\n    );\n    \n    // sample noise\n    float v = smoothstep(-.45, .38, perlin_fractal(1.6 * uv, 2, -.15, 2.));\n    v = clamp(v, 0., 1.);\n    \n    // modulate v\n    v = fract(v - .03 * iTime);\n    \n    // choose palette index\n    int palette_idx = int(iTime / 4.) % N_PALETTES;\n    int first_color_idx = palette_idx * N_COLORS_IN_PALETTE;\n    \n    // put v into a colormap (gradient)\n    vec3 col = PALETTES[first_color_idx];\n    for (int i = 0; i < N_COLORS_IN_PALETTE - 1; i++)\n    {\n        col = mix(\n            col,\n            PALETTES[first_color_idx + i + 1],\n            step(\n                (float(i) + .5) / float(N_COLORS_IN_PALETTE - 1),\n                v\n            )\n        );\n    }\n    \n    // add grain\n    float col_lum = dot(col, vec3(.3, .5, .2));\n    col = mix(\n        col,\n        vec3(1),\n        glitter(orig_uv, int(iTime / .3)) * remap(col_lum, 0., 1., .08, .04)\n    );\n    \n    return col;\n}\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    // render with grid multisampling\n    vec3 col = vec3(0);\n    for (int y = -1; y <= 1; y++)\n    {\n        for (int x = -1; x <= 1; x++)\n        {\n            col += render(frag_coord + .35 * vec2(x, y));\n        }\n    }\n    col /= 9.;\n    \n    // output\n    col = pow(col, vec3(1. / 2.2));\n    frag_col = vec4(col, 1);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "/*_________________ Math Utils ________________*/\n\n#define PI 3.1415926535897932384626433832\n#define TAU 6.283185307179586476925286766\n#define PI_OVER_2 1.57079632679489661923132169163\n\n#define FUNC_LERP(T) \\\nT lerp(T a, T b, float t) \\\n{ \\\n    return a + t*(b-a); \\\n}\n\n#define FUNC_WRAP(T) \\\nT wrap(T inp, float start, float end) \\\n{ \\\n    return start + mod(inp - start, end - start); \\\n}\n\n#define FUNC_REMAP(T) \\\nT remap(T inp, float inp_start, float inp_end, float out_start, float out_end) \\\n{ \\\n    return out_start + ((out_end - out_start) / (inp_end - inp_start)) * (inp - inp_start); \\\n}\n\n#define FUNC_REMAP_CLAMP(T) \\\nT remap_clamp(T inp, float inp_start, float inp_end, float out_start, float out_end) \\\n{ \\\n    T t = clamp((inp - inp_start) / (inp_end - inp_start), 0.0, 1.0); \\\n    return out_start + t * (out_end - out_start); \\\n}\n\n#define FUNC_REMAP01(T) \\\nT remap01(T inp, float inp_start, float inp_end) \\\n{ \\\n    return clamp((inp - inp_start) / (inp_end - inp_start), 0.0, 1.0); \\\n}\n\nFUNC_LERP(float)\nFUNC_LERP(vec2)\nFUNC_LERP(vec3)\nFUNC_LERP(vec4)\n\nFUNC_WRAP(float)\nFUNC_WRAP(vec2)\nFUNC_WRAP(vec3)\nFUNC_WRAP(vec4)\n\nFUNC_REMAP(float)\nFUNC_REMAP(vec2)\nFUNC_REMAP(vec3)\nFUNC_REMAP(vec4)\n\nFUNC_REMAP_CLAMP(float)\nFUNC_REMAP_CLAMP(vec2)\nFUNC_REMAP_CLAMP(vec3)\nFUNC_REMAP_CLAMP(vec4)\n\nFUNC_REMAP01(float)\nFUNC_REMAP01(vec2)\nFUNC_REMAP01(vec3)\nFUNC_REMAP01(vec4)\n\nmat2 rotate_2d(float angle)\n{\n    return mat2(cos(angle), sin(angle), cos(angle + PI_OVER_2), sin(angle + PI_OVER_2));\n}\n\n/*____________________ End ____________________*/\n\n\n\n/*_______ Pseudo-Random Number Generator ______*/\n// Source: https://www.shadertoy.com/view/WdSSRt\n\n/* Usage Example:\n    void mainImage(out vec4 frag_col, in vec2 frag_coord)\n    {\n        // Initialize PRNG\n        prng_init(vec3(frag_coord / iResolution.y, iTime));\n    \n        // Using the function\n        float a = random();\n        vec3 b = vec3(random(), random(), random());\n        \n        ...\n    }\n*/\n\nuint prng_state[2];\n\nuint prng_rot(uint x, int k)\n{\n    return (x << k) | (x >> (32 - k));\n}\n\n// Random uint from 0 to 2^32-1\nuint randomui()\n{\n    uint s0 = prng_state[0];\n    uint s1 = prng_state[1];\n    uint result = prng_rot(s0 * 0x9e3779bbu, 5) * 5u;\n    s1 ^= s0;\n    prng_state[0] = prng_rot(s0, 26) ^ s1 ^ (s1 << 9);\n    prng_state[1] = prng_rot(s1, 13);\n    return result;\n}\n\n// Random int from 0 to 2^31-1\nint randomi()\n{\n    return int(randomui() % 0x7FFFFFFFu);\n}\n\n// Random float from 0 to 1\nfloat random()\n{\n    return float(randomui()) / float(0xffffffffu);\n}\n\n// Generate two normally distributed random numbers using the\n// Box-Muller Transform.\n// https://www.baeldung.com/cs/uniform-to-normal-distribution\nvec2 random_gauss()\n{\n    float u1 = random();\n    float u2 = random() * TAU;\n    float temp = sqrt(-2. * log(u1));\n    return temp * vec2(cos(u2), sin(u2));\n    \n    // Unoptimized version\n    //float u1 = random();\n    //float u2 = random();\n    //return vec2(cos(TAU * u2), sin(TAU * u2)) * sqrt(-2. * log(u1));\n}\n\nvec2 random_unit_vec2()\n{\n    vec2 v = vec2(1);\n    float lensqr;\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec2(2. * random() - 1., 2. * random() - 1.);\n        lensqr = dot(v, v);\n        if (lensqr == 0.)\n            i--;\n        else if (lensqr <= 1.)\n            break;\n    }\n    return v / sqrt(lensqr);\n}\n\nvec3 random_unit_vec3()\n{\n    vec3 v = vec3(1);\n    float lensqr;\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec3(2. * random() - 1., 2. * random() - 1., 2. * random() - 1.);\n        lensqr = dot(v, v);\n        if (lensqr == 0.)\n            i--;\n        else if (lensqr <= 1.)\n            break;\n    }\n    return v / sqrt(lensqr);\n}\n\nvec2 random_in_circle()\n{\n    vec2 v = vec2(1);\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec2(2. * random() - 1., 2. * random() - 1.);\n        if (dot(v, v) <= 1.)\n            return v;\n    }\n    return v;\n}\n\nvec3 random_in_sphere()\n{\n    vec3 v = vec3(1);\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec3(2. * random() - 1., 2. * random() - 1., 2. * random() - 1.);\n        if (dot(v, v) <= 1.)\n            return v;\n    }\n    return v;\n}\n\n// Initialize with uvec2\nvoid prng_init(uvec2 seed)\n{\n    seed += uvec2(1317, 944573125);\n    seed *= 464973573u;\n    prng_state[0] = seed.x;\n    prng_state[1] = seed.y;\n    randomi();\n}\n\n// Initialize with uint\nvoid prng_init(uint seed)\n{\n    prng_init(uvec2(seed, 1));\n}\n\n// Initialize with vec3\nvoid prng_init(vec3 seed)\n{\n    seed += 3.49276101561702;\n    seed.xy *= (seed.z + 10.258);\n    prng_state[0] = floatBitsToUint(seed.x);\n    prng_state[1] = floatBitsToUint(seed.y);\n    randomui();\n}\n\n// Initialize with vec2\nvoid prng_init(vec2 seed)\n{\n    prng_init(vec3(seed, 1));\n}\n\n// Initialize with float\nvoid prng_init(float seed)\n{\n    prng_init(vec3(seed, 1, 1));\n}\n\n/*____________________ End ____________________*/\n\n\n\n// https://www.shadertoy.com/view/Ml3Gz8\nfloat smoothmin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n    return mix(a, b, h) - k*h*(1.0-h);\n}\n\nvec2 perpendicular(vec2 dir)\n{\n    return vec2(-dir.y, dir.x);\n}\n\nfloat dist_sq(vec2 a, vec2 b)\n{\n    vec2 temp = a - b;\n    return dot(temp, temp);\n}\n\nfloat dist_along_line(vec2 p, vec2 line_start, vec2 line_end)\n{\n    vec2 dir = line_end - line_start;\n    \n    // normalize\n    float len_sqr = dot(dir, dir);\n    if (len_sqr < .0001)\n        return 1e9;\n    dir /= sqrt(len_sqr);\n    \n    return dot(\n        dir,\n        p - line_start\n    );\n}\n\nfloat relative_dist_along_line(vec2 p, vec2 line_start, vec2 line_end)\n{\n    vec2 dir = line_end - line_start;\n    return dot(\n        dir,\n        p - line_start\n    );\n}\n\nvec2 screen_to_uv(vec2 coord, vec2 res)\n{\n    return 2. * (coord - .5 * res) / min(res.x, res.y);\n}\n\nfloat bilinear(\n    float val_bl,\n    float val_tl,\n    float val_tr,\n    float val_br,\n    vec2 offs\n)\n{\n    return mix(\n        mix(val_bl, val_br, offs.x),\n        mix(val_tl, val_tr, offs.x),\n        offs.y\n    );\n}\n\nfloat perlin(vec2 coord)\n{\n    // Cell indices\n    ivec2 icell = ivec2(floor(coord));\n    \n    // Cell corners\n    vec2 cell_bl = vec2(icell);\n    vec2 cell_tl = cell_bl + vec2(0, 1);\n    vec2 cell_tr = cell_bl + vec2(1, 1);\n    vec2 cell_br = cell_bl + vec2(1, 0);\n    \n    // Cell offset in [0, 1) range (vector pointing from the bottom\n    // left corner to coord)\n    vec2 cell_offs = coord - cell_bl;\n    \n    // Generate a random unit vector at each cell corner and take\n    // the distance that coord has traveled along that line\n    \n    prng_init(uvec2(icell));\n    vec2 grad_bl = random_unit_vec2();\n    \n    prng_init(uvec2(icell) + uvec2(0, 1));\n    vec2 grad_tl = random_unit_vec2();\n    \n    prng_init(uvec2(icell) + uvec2(1, 1));\n    vec2 grad_tr = random_unit_vec2();\n    \n    prng_init(uvec2(icell) + uvec2(1, 0));\n    vec2 grad_br = random_unit_vec2();\n    \n    float dist_bl = relative_dist_along_line(coord, cell_bl, cell_bl + grad_bl);\n    float dist_tl = relative_dist_along_line(coord, cell_tl, cell_tl + grad_tl);\n    float dist_tr = relative_dist_along_line(coord, cell_tr, cell_tr + grad_tr);\n    float dist_br = relative_dist_along_line(coord, cell_br, cell_br + grad_br);\n    \n    // Smoothstep the cell offset vector\n    cell_offs = smoothstep(0., 1., cell_offs);\n    \n    // Bilinear interpolation between the four distances\n    float val = bilinear(\n        dist_bl,\n        dist_tl,\n        dist_tr,\n        dist_br,\n        cell_offs\n    );\n    \n    return val;\n}\n\n// Random offset for a sample point inside a cell\nvec2 cell_corner_offs(ivec2 icell)\n{\n    prng_init(uvec2(icell));\n    return 1. *  (vec2(random(), random()) - .5);\n}\n\nfloat perlin_fractal(\n    vec2 coord,\n    int depth,\n    float roughness,\n    float lacunarity\n)\n{\n    float v = 0.;\n    float sum_fac = 0.;\n    \n    for (int i = 0; i < depth; i++)\n    {\n        // Factor (impact of the current layer)\n        float fac = 0.;\n        roughness = clamp(roughness, -1., 1.);\n        if (roughness < 0.)\n        {\n            // Roughness [-1, 0) will go from fully smooth to normal\n            fac = pow(\n                lacunarity / max(roughness + 1., .0001),\n                float(-i)\n            );\n        }\n        else\n        {\n            // Roughness [0, 1] will go from normal to fully rough\n            fac = pow(\n                mix(lacunarity, 1., roughness),\n                float(-i)\n            );\n        }\n        sum_fac += fac;\n        \n        // Scale of the current layer\n        float scale = pow(lacunarity, float(i));\n        \n        // Add sample\n        v += fac * perlin(coord * scale);\n        \n        // Move and rotate the next layer\n        coord += 100.;\n        coord *= rotate_2d(1.09956);\n    }\n    \n    return v / sum_fac;\n}\n",
     "name": "Common",
     "description": "",
     "type": "common"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "4XVcWc",
    "date": "0",
    "viewed": 0,
    "name": "evenly distributed dots",
    "description": "probably called startification",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "noise",
     "random",
     "blue",
     "dots",
     "spaced",
     "evenly"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "const float TILE_SIZE = .1;\nconst float DISK_RADIUS = .01;\nconst float DISK_RADIUS_SQ = DISK_RADIUS * DISK_RADIUS;\n\nvec3 render(vec2 coord)\n{\n    vec2 uv = screen_to_uv_fit(coord, iResolution.xy);\n    \n    // 2D index of the tile we're in (we = current pixel)\n    ivec2 itile_center = ivec2(floor(uv / TILE_SIZE));\n    \n    // iterate over the neighboring tiles (including the current one)\n    for (int y = -1; y <= 1; y++)\n    {\n        for (int x = -1; x <= 1; x++)\n        {\n            // 2D index of the current tiles\n            ivec2 itile = itile_center + ivec2(x, y);\n            \n            // reseed PRNG with the current tile index\n            prng_init(uvec2(itile));\n            \n            // current tile's bottom left and top right coords\n            vec2 itile_bl = vec2(itile) * TILE_SIZE;\n            vec2 itile_tr = itile_bl + TILE_SIZE;\n            \n            // draw disk randomly positioned inside the tile\n            vec2 disk_center = vec2(\n                remap(random(), 0., 1., itile_bl.x, itile_tr.x),\n                remap(random(), 0., 1., itile_bl.y, itile_tr.y)\n            );\n            disk_center += .5 * TILE_SIZE * vec2(\n                cos(TAU * 1. * iTime + float(itile.x)),\n                sin(TAU * 1. * iTime + float(itile.x))\n            );\n            \n            if (dist_sq(uv, disk_center) < DISK_RADIUS_SQ)\n            {\n                return vec3(0);\n            }\n        }\n    }\n    \n    return vec3(1, 1, 0);\n}\n\nvec3 view_transform(vec3 col)\n{\n    // avoid any negative values before using power functions\n    col = max(col, 0.);\n\n    // OETF (Linear BT.709 I-D65 to sRGB 2.2)\n    col = pow(col, vec3(1. / 2.2));\n    col = clamp(col, 0., 1.);\n\n    return col;\n}\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    // render\n    vec3 col = render(frag_coord);\n\n    // view transform\n    col = view_transform(col);\n\n    // output\n    frag_col = vec4(col, 1);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "#define SHADERTOY 1\n\nprecision highp float;\nprecision highp int;\n\n\n\n/*___________ math & integer utils ____________*/\n\nconst float PI = 3.141592653589793238462643383;\nconst float TAU = 6.283185307179586476925286767;\nconst float PI_OVER_2 = 1.570796326794896619231321692;\nconst float INV_PI = .318309886183790671537767527;\nconst float INV_TAU = .159154943091895335768883763;\n\n#define FUNC_WRAP(T) \\\nT wrap(T v, float start, float end) \\\n{ \\\n    return start + mod(v - start, end - start); \\\n}\n\n#define FUNC_REMAP(T) \\\nT remap(T v, float inp_start, float inp_end, float out_start, float out_end) \\\n{ \\\n    return out_start \\\n        + ((out_end - out_start) / (inp_end - inp_start)) * (v - inp_start); \\\n}\n\n#define FUNC_REMAP_CLAMP(T) \\\nT remap_clamp( \\\n    T v, \\\n    float inp_start, \\\n    float inp_end, \\\n    float out_start, \\\n    float out_end \\\n) \\\n{ \\\n    T t = clamp((v - inp_start) / (inp_end - inp_start), 0., 1.); \\\n    return out_start + t * (out_end - out_start); \\\n}\n\n#define FUNC_REMAP01(T) \\\nT remap01(T v, float inp_start, float inp_end) \\\n{ \\\n    return clamp((v - inp_start) / (inp_end - inp_start), 0., 1.); \\\n}\n\n#define FUNC_LENGTH_SQ(T) \\\nfloat length_sq(T v) \\\n{ \\\n    return dot(v, v); \\\n}\n\n#define FUNC_DIST_SQ(T) \\\nfloat dist_sq(T a, T b) \\\n{ \\\n    a -= b; \\\n    return dot(a, a); \\\n}\n\nFUNC_WRAP(float)\nFUNC_WRAP(vec2)\nFUNC_WRAP(vec3)\nFUNC_WRAP(vec4)\n\nFUNC_REMAP(float)\nFUNC_REMAP(vec2)\nFUNC_REMAP(vec3)\nFUNC_REMAP(vec4)\n\nFUNC_REMAP_CLAMP(float)\nFUNC_REMAP_CLAMP(vec2)\nFUNC_REMAP_CLAMP(vec3)\nFUNC_REMAP_CLAMP(vec4)\n\nFUNC_REMAP01(float)\nFUNC_REMAP01(vec2)\nFUNC_REMAP01(vec3)\nFUNC_REMAP01(vec4)\n\nFUNC_LENGTH_SQ(vec2)\nFUNC_LENGTH_SQ(vec3)\nFUNC_LENGTH_SQ(vec4)\n\nFUNC_DIST_SQ(vec2)\nFUNC_DIST_SQ(vec3)\nFUNC_DIST_SQ(vec4)\n\nfloat chebyshev_dist(vec2 a, vec2 b)\n{\n    return max(abs(a.x - b.x), abs(a.y - b.y));\n}\n\nfloat chebyshev_dist(vec3 a, vec3 b)\n{\n    return max(\n        max(abs(a.x - b.x), abs(a.y - b.y)),\n        abs(a.z - b.z)\n    );\n}\n\nfloat chebyshev_dist(vec4 a, vec4 b)\n{\n    return max(\n        max(\n            max(abs(a.x - b.x), abs(a.y - b.y)),\n            abs(a.z - b.z)\n        ),\n        abs(a.w - b.w)\n    );\n}\n\n#define idiv_ceil(a, b) ((a + b - 1) / b)\n\nint iabs(int v)\n{\n    if (v < 0)\n    {\n        return -v;\n    }\n    return v;\n}\n\nint imin(int a, int b)\n{\n    if (a < b)\n    {\n        return a;\n    }\n    return b;\n}\n\nint imax(int a, int b)\n{\n    if (a > b)\n    {\n        return a;\n    }\n    return b;\n}\n\nint iclamp(int v, int start, int end)\n{\n    if (v < start)\n    {\n        v = start;\n    }\n    if (v > end)\n    {\n        v = end;\n    }\n    return v;\n}\n\nfloat min_component(vec2 v)\n{\n    return min(v.x, v.y);\n}\n\nfloat min_component(vec3 v)\n{\n    return min(min(v.x, v.y), v.z);\n}\n\nfloat min_component(vec4 v)\n{\n    return min(min(min(v.x, v.y), v.z), v.w);\n}\n\nfloat max_component(vec2 v)\n{\n    return max(v.x, v.y);\n}\n\nfloat max_component(vec3 v)\n{\n    return max(max(v.x, v.y), v.z);\n}\n\nfloat max_component(vec4 v)\n{\n    return max(max(max(v.x, v.y), v.z), v.w);\n}\n\nint min_component(ivec2 v)\n{\n    return imin(v.x, v.y);\n}\n\nint min_component(ivec3 v)\n{\n    return imin(imin(v.x, v.y), v.z);\n}\n\nint min_component(ivec4 v)\n{\n    return imin(imin(imin(v.x, v.y), v.z), v.w);\n}\n\nint max_component(ivec2 v)\n{\n    return imax(v.x, v.y);\n}\n\nint max_component(ivec3 v)\n{\n    return imax(imax(v.x, v.y), v.z);\n}\n\nint max_component(ivec4 v)\n{\n    return imax(imax(imax(v.x, v.y), v.z), v.w);\n}\n\nfloat bilinear(\n    float val_bl,\n    float val_tl,\n    float val_tr,\n    float val_br,\n    vec2 offs\n)\n{\n    return mix(\n        mix(val_bl, val_br, offs.x),\n        mix(val_tl, val_tr, offs.x),\n        offs.y\n    );\n}\n\n// credits to AHSEN (https://www.shadertoy.com/user/01000001)\n// https://www.desmos.com/calculator/5d6ph151vi interactive :D\nfloat cubic_interp(float a, float b, float c, float d, float t)\n{\n    float one = t - 1.;\n    float two = t - 2.;\n    float three = t - 3.;\n    return (\n        (-one * two * three * a)\n        + (t * one * two * d)\n        + (3. * t * two * three * b)\n        - (3. * t * one * three * c)\n    ) / 6.;\n}\n\nfloat dist_along_line(vec2 p, vec2 line_start, vec2 line_end)\n{\n    vec2 dir = line_end - line_start;\n    \n    // normalize\n    float len_sqr = dot(dir, dir);\n    if (len_sqr < .0001)\n        return 1e9;\n    dir /= sqrt(len_sqr);\n    \n    return dot(\n        dir,\n        p - line_start\n    );\n}\n\nfloat relative_dist_along_line(vec2 p, vec2 line_start, vec2 line_end)\n{\n    vec2 dir = line_end - line_start;\n    return dot(\n        dir,\n        p - line_start\n    );\n}\n\n// |a| * |b| * sin(theta)\nfloat cross2d(vec2 a, vec2 b)\n{\n    return a.x * b.y - a.y * b.x;\n}\n\n// references for barycentric coordinates\n// https://www.desmos.com/calculator/8g8xjejuox\n// https://www.shadertoy.com/view/mdjBWK\n\nvec3 cartesian_to_barycentric(\n    vec2 p,\n    vec2 v0,\n    vec2 v1,\n    vec2 v2,\n    bool clamp_,\n    out bool p_is_outside\n)\n{\n    vec3 b = vec3(\n        cross2d(v1 - p, v2 - p),\n        cross2d(v2 - p, v0 - p),\n        cross2d(v0 - p, v1 - p)\n    ) / cross2d(v1 - v0, v2 - v0);\n    p_is_outside = min(min(b.x, b.y), b.z) < 0.;\n    if (clamp_)\n    {\n        b = max(b, 0.);\n        b /= (b.x + b.y + b.z);\n    }\n    return b;\n}\n\nvec3 cartesian_to_barycentric(\n    vec3 p,\n    vec3 v0,\n    vec3 v1,\n    vec3 v2,\n    bool clamp_,\n    out bool p_is_outside\n)\n{\n    vec3 b = vec3(\n        length(cross(v1 - p, v2 - p)),\n        length(cross(v2 - p, v0 - p)),\n        length(cross(v0 - p, v1 - p))\n    ) / length(cross(v1 - v0, v2 - v0));\n    p_is_outside = min(min(b.x, b.y), b.z) < 0.;\n    if (clamp_)\n    {\n        b = max(b, 0.);\n        b /= (b.x + b.y + b.z);\n    }\n    return b;\n}\n\nfloat barycentric_interpolate(vec3 b, float v0, float v1, float v2)\n{\n    return dot(b, vec3(v0, v1, v2));\n}\n\nvec2 barycentric_interpolate(vec3 b, vec2 v0, vec2 v1, vec2 v2)\n{\n    return b.x * v0 + b.y * v1 + b.z * v2;\n}\n\nvec3 barycentric_interpolate(vec3 b, vec3 v0, vec3 v1, vec3 v2)\n{\n    return b.x * v0 + b.y * v1 + b.z * v2;\n}\n\nvec4 barycentric_interpolate(vec3 b, vec4 v0, vec4 v1, vec4 v2)\n{\n    return b.x * v0 + b.y * v1 + b.z * v2;\n}\n\nfloat barycentric_interpolate(vec2 b, float v0, float v1, float v2)\n{\n    return barycentric_interpolate(\n        vec3(b.x, b.y, 1. - b.x - b.y),\n        v0, v1, v2\n    );\n}\n\nvec2 barycentric_interpolate(vec2 b, vec2 v0, vec2 v1, vec2 v2)\n{\n    return barycentric_interpolate(\n        vec3(b.x, b.y, 1. - b.x - b.y),\n        v0, v1, v2\n    );\n}\n\nvec3 barycentric_interpolate(vec2 b, vec3 v0, vec3 v1, vec3 v2)\n{\n    return barycentric_interpolate(\n        vec3(b.x, b.y, 1. - b.x - b.y),\n        v0, v1, v2\n    );\n}\n\nvec4 barycentric_interpolate(vec2 b, vec4 v0, vec4 v1, vec4 v2)\n{\n    return barycentric_interpolate(\n        vec3(b.x, b.y, 1. - b.x - b.y),\n        v0, v1, v2\n    );\n}\n\n// angle from 0 to TAU\nfloat get_angle(vec2 p)\n{\n    float a = atan(p.y, p.x);\n    if (a < 0.)\n    {\n        return a + TAU;\n    }\n    return a;\n}\n\nmat2 rotate_2d(float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(\n        c, s,\n        -s, c\n    );\n}\n\nvec2 perpendicular(vec2 v)\n{\n    return vec2(-v.y, v.x);\n}\n\n// s.x=theta\n// s.y=phi\n// (there's no r)\nvec3 spherical_to_cartesian(vec2 s)\n{\n    float sin_theta = sin(s.x);\n    return vec3(\n        sin_theta * cos(s.y),\n        sin_theta * sin(s.y),\n        cos(s.x)\n    );\n}\n\n// s.x=r\n// s.y=theta\n// s.z=phi\nvec3 spherical_to_cartesian(vec3 s)\n{\n    float sin_theta = sin(s.y);\n    return s.x * vec3(\n        sin_theta * cos(s.z),\n        sin_theta * sin(s.z),\n        cos(s.y)\n    );\n}\n\nvec2 screen_to_uv01(vec2 coord, vec2 res)\n{\n    return coord / res;\n}\n\nvec2 screen_to_uv_horizontal(vec2 coord, vec2 res)\n{\n    return (2. * coord - res) / res.x;\n}\n\nvec2 screen_to_uv_vertical(vec2 coord, vec2 res)\n{\n    return (2. * coord - res) / res.y;\n}\n\nvec2 screen_to_uv_fit(vec2 coord, vec2 res)\n{\n    return (2. * coord - res) / min_component(res);\n}\n\nvec2 screen_to_uv_fill(vec2 coord, vec2 res)\n{\n    return (2. * coord - res) / max_component(res);\n}\n\n// * idx starts at 1\nfloat halton(int base, int idx)\n{\n    float result = 0.;\n    float digit_weight = 1.;\n    while (idx > 0)\n    {\n        digit_weight /= float(base);\n        result += float(idx % base) * digit_weight;\n        idx /= base;\n    }\n    return result;\n}\n\n// * idx starts at 1\nvec2 halton_2d(int idx)\n{\n    return vec2(halton(2, idx), halton(3, idx));\n}\n\n// * idx starts at 1\nvec3 halton_3d(int idx)\n{\n    return vec3(halton(2, idx), halton(3, idx), halton(5, idx));\n}\n\n// * idx starts at 1\nvec4 halton_4d(int idx)\n{\n    return vec4(\n        halton(2, idx),\n        halton(3, idx),\n        halton(5, idx),\n        halton(7, idx)\n    );\n}\n\n// for some reason we can't use intBitsToFloat() or floatBitsToInt() to store\n// integers below this value in a buffer.\nconst int BUFFER_MIN_INTEGER = 8388608;\n\n// * x must not be higher than 4,286,578,688 (see BUFFER_MIN_INTEGER above)\n// * for your sanity, don't use negative values\nfloat encode_int_for_buffer(int v)\n{\n    return intBitsToFloat(v + BUFFER_MIN_INTEGER);\n}\n\nint decode_int_from_buffer(float v)\n{\n    return floatBitsToInt(v) - BUFFER_MIN_INTEGER;\n}\n\n// pack two 16-bit integers in a single 32-bit integer\n// * both arguments should be in the 0-65535 range\n// * a must be less than 65279 (see the functions above)\nint pack_i16(int a, int b)\n{\n    return (a << 16) | b;\n}\n\n// unpack two 16-bit integers from a single 32-bit integer\nvoid unpack_i16(int v, out int a, out int b)\n{\n    a = (v >> 16) & 65535;\n    b = v & 65535;\n}\n\n// unpack the first 16-bit integer from a 32-bit integer\nint unpack_i16_a(int v)\n{\n    return (v >> 16) & 65535;\n}\n\n// unpack the second 16-bit integer from a 32-bit integer\nint unpack_i16_b(int v)\n{\n    return v & 65535;\n}\n\nbool icoord_in_bounds(ivec2 icoord, ivec2 ires)\n{\n    return\n        icoord.x >= 0 &&\n        icoord.y >= 0 &&\n        icoord.x < ires.x &&\n        icoord.y < ires.y;\n}\n\nbool icoord_in_bounds(ivec3 icoord, ivec3 ires)\n{\n    return\n        icoord.x >= 0 &&\n        icoord.y >= 0 &&\n        icoord.z >= 0 &&\n        icoord.x < ires.x &&\n        icoord.y < ires.y &&\n        icoord.z < ires.z;\n}\n\nint icoord_to_idx(ivec2 icoord, ivec2 ires)\n{\n    return icoord.x + (icoord.y * ires.x);\n}\n\nint icoord_to_idx(ivec3 icoord, ivec3 ires)\n{\n    return icoord.x + (icoord.y * ires.x) + (icoord.z * ires.x * ires.y);\n}\n\nivec2 idx_to_icoord(int idx, ivec2 ires)\n{\n    return ivec2(idx % ires.x, idx / ires.x);\n}\n\nivec3 idx_to_icoord(int idx, ivec3 ires)\n{\n    return ivec3(\n        idx % ires.x,\n        (idx % (ires.x * ires.y)) / ires.x,\n        idx / (ires.x * ires.y)\n    );\n}\n\n// https://www.desmos.com/calculator/kfe07basy9\n\nint compress_float_to_int_linear(float f, float min_f, float max_f, int max_i)\n{\n    return int(floor(\n        float(max_i) * remap01(f, min_f, max_f)\n    ));\n}\n\nfloat decompress_float_from_int_linear(\n    int i,\n    int max_i,\n    float min_f,\n    float max_f\n)\n{\n    return remap_clamp(\n        float(i) / float(max_i),\n        0., 1.,\n        min_f, max_f\n    );\n}\n\nint compress_float_to_int_log(\n    float f,\n    float log2_zero_offset,\n    float max_log2_f,\n    int max_i\n)\n{\n    f = max(0., f);\n    f += pow(2., log2_zero_offset);\n    return int(floor(\n        float(max_i) * remap01(log2(f), log2_zero_offset, max_log2_f)\n    ));\n}\n\nfloat decompress_float_from_int_log(\n    int i,\n    int max_i,\n    float log2_zero_offset,\n    float max_log2_f\n)\n{\n    return pow(2., remap_clamp(\n        float(i) / float(max_i),\n        0., 1.,\n        log2_zero_offset, max_log2_f\n    )) - pow(2., log2_zero_offset);\n}\n\n\n\n/*_______ pseudo-random number generator ______*/\n// source: https://www.shadertoy.com/view/WdSSRt\n// (heavily modified)\n\n/* usage example:\n    void mainImage(out vec4 frag_col, in vec2 frag_coord)\n    {\n        // initialize PRNG\n        prng_init(vec3(frag_coord / iResolution.y, iTime));\n    \n        // use the function\n        float a = random();\n        vec3 b = vec3(random(), random(), random());\n        \n        ...\n    }\n*/\n\nuint prng_state[2];\n\nuint prng_rot(uint x, int k)\n{\n    return (x << k) | (x >> (32 - k));\n}\n\n// random uint from 0 to 2^32-1\nuint randomui()\n{\n    uint s0 = prng_state[0];\n    uint s1 = prng_state[1];\n    uint result = prng_rot(s0 * 2654435771u, 5) * 5u;\n    s1 ^= s0;\n    prng_state[0] = prng_rot(s0, 26) ^ s1 ^ (s1 << 9);\n    prng_state[1] = prng_rot(s1, 13);\n    return result;\n}\n\n// random int from 0 to 2^31-1\nint randomi()\n{\n    return int(randomui() % 0x7FFFFFFFu);\n}\n\n// random float from 0 to 1\nfloat random()\n{\n    return float(randomui()) / float(0xffffffffu);\n}\n\n// generate two normally distributed random numbers using the\n// Box-Muller transform\n// https://www.baeldung.com/cs/uniform-to-normal-distribution\nvec2 random_gauss()\n{\n    float u1 = random();\n    float u2 = random() * TAU;\n    float temp = sqrt(-2. * log(u1));\n    return temp * vec2(cos(u2), sin(u2));\n    \n    // unoptimized version\n    //float u1 = random();\n    //float u2 = random();\n    //return vec2(cos(TAU * u2), sin(TAU * u2)) * sqrt(-2. * log(u1));\n}\n\nvec2 random_on_circle()\n{\n    vec2 v = vec2(1);\n    float lensqr;\n\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec2(2. * random() - 1., 2. * random() - 1.);\n        lensqr = dot(v, v);\n        if (lensqr == 0.)\n            i--;\n        else if (lensqr <= 1.)\n            break;\n    }\n    return v / sqrt(lensqr);\n}\n\nvec3 random_on_sphere()\n{\n    vec3 v = vec3(1);\n    float lensqr;\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec3(2. * random() - 1., 2. * random() - 1., 2. * random() - 1.);\n        lensqr = dot(v, v);\n        if (lensqr == 0.)\n            i--;\n        else if (lensqr <= 1.)\n            break;\n    }\n    return v / sqrt(lensqr);\n}\n\nvec2 random_in_circle()\n{\n    vec2 v = vec2(1);\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec2(2. * random() - 1., 2. * random() - 1.);\n        if (dot(v, v) <= 1.)\n            return v;\n    }\n    return v;\n}\n\nvec3 random_in_sphere()\n{\n    vec3 v = vec3(1);\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec3(2. * random() - 1., 2. * random() - 1., 2. * random() - 1.);\n        if (dot(v, v) <= 1.)\n            return v;\n    }\n    return v;\n}\n\nvec3 random_on_hemisphere(vec3 normal)\n{\n    vec3 v = random_on_sphere();\n    return v * sign(dot(v, normal));\n}\n\nvec3 random_in_hemisphere(vec3 normal)\n{\n    vec3 v = random_in_sphere();\n    return v * sign(dot(v, normal));\n}\n\n// initialize with uvec2\nvoid prng_init(uvec2 seed)\n{\n    seed += uvec2(1317, 944573125);\n    seed *= 464973573u;\n    prng_state[0] = seed.x;\n    prng_state[1] = seed.y;\n    randomi();\n}\n\n// initialize with uint\nvoid prng_init(uint seed)\n{\n    prng_init(uvec2(seed, 1));\n}\n\n// initialize with vec3\nvoid prng_init(vec3 seed)\n{\n    seed += 3.49276101561702;\n    seed.xy *= (seed.z + 10.258);\n    prng_state[0] = floatBitsToUint(seed.x);\n    prng_state[1] = floatBitsToUint(seed.y);\n    randomui();\n}\n\n// initialize with vec2\nvoid prng_init(vec2 seed)\n{\n    prng_init(vec3(seed, 1));\n}\n\n// initialize with float\nvoid prng_init(float seed)\n{\n    prng_init(vec3(seed, 1, 1));\n}\n",
     "name": "Common",
     "description": "",
     "type": "common"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "lXycWt",
    "date": "1736801004",
    "viewed": 96,
    "name": "Getting Blue Noise from White",
    "description": "high passing white noise to get blue noise. one important detail is that you should map the original input from [0, 1] to [-1, +1] by performing [code](x * 2. - 1.)[/code] and undo it at the very end by doing [code](x * .5 + .5)[/code]",
    "likes": 6,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "noise",
     "blue",
     "white",
     "prng",
     "low",
     "rng",
     "discrepency"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// high pass again again\n// make sure to map the final output from [-1, +1] back to [0, 1]\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    float sum_values = 0.;\n    float sum_weights = 0.;\n    for (int offs_y = -5; offs_y <= 5; offs_y++)\n    {\n        for (int offs_x = -5; offs_x <= 5; offs_x++)\n        {\n            float v = FETCH(frag_coord + vec2(offs_x, offs_y));\n            \n            float weight = gaussian_unnorm(\n                length(vec2(offs_x, offs_y)),\n                1.\n            );\n            \n            sum_values += v * weight;\n            sum_weights += weight;\n        }\n    }\n    float low_pass = sum_values / sum_weights;\n    float high_pass = FETCH(frag_coord) - low_pass;\n    \n    // map from [-1, +1] back to [0, 1]\n    vec3 col = vec3(high_pass * .5 + .5);\n    \n    frag_col = vec4(pow(col, vec3(1. / 2.2)), 1);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "const float SQRT_2PI = 2.506628274631;\n\nfloat sq(float x)\n{\n    return x * x;\n}\n\nfloat gaussian_distribution(float x, float standard_deviation)\n{\n    return exp(-.5 * sq(x / standard_deviation)) / (SQRT_2PI * standard_deviation);\n}\n\n// unnormalized gaussian, doesn't add up to 1, maximum value is 1.\nfloat gaussian_unnorm(float x, float standard_deviation)\n{\n    return exp(-.5 * sq(x / standard_deviation));\n}\n\n// fetch the input value from iChannel0\n#define FETCH(COORD) \\\n(texture(iChannel0, (COORD) / vec2(textureSize(iChannel0, 0))).x)\n\n// fetch the input and map it from [0, 1] to [-1, +1].\n// this is only done in Buffer A. the final value is mapped back to\n// [0, 1] in the Image tab by doing (x * .5 + .5).\n#define FETCH_MAPPED(COORD) \\\n(FETCH(COORD) * 2. - 1.)\n",
     "name": "Common",
     "description": "",
     "type": "common"
    },
    {
     "inputs": [
      {
       "id": "4dXGzn",
       "filepath": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png",
       "type": "texture",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "// high pass iChannel0 (texture)\n// make sure to first map the input from [0, 1] to [-1, +1]\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    float sum_values = 0.;\n    float sum_weights = 0.;\n    for (int offs_y = -5; offs_y <= 5; offs_y++)\n    {\n        for (int offs_x = -5; offs_x <= 5; offs_x++)\n        {\n            // this will map the input from [0, 1] to [-1, +1]\n            float v = FETCH_MAPPED(frag_coord + vec2(offs_x, offs_y));\n            \n            float weight = gaussian_unnorm(\n                length(vec2(offs_x, offs_y)),\n                1.\n            );\n            \n            sum_values += v * weight;\n            sum_weights += weight;\n        }\n    }\n    float low_pass = sum_values / sum_weights;\n    float high_pass = FETCH_MAPPED(frag_coord) - low_pass;\n    \n    vec3 col = vec3(high_pass);\n    \n    frag_col = vec4(col, 1);\n}\n\n",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "XsXGR8",
       "channel": 0
      }
     ],
     "code": "// high pass again\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    float sum_values = 0.;\n    float sum_weights = 0.;\n    for (int offs_y = -5; offs_y <= 5; offs_y++)\n    {\n        for (int offs_x = -5; offs_x <= 5; offs_x++)\n        {\n            float v = FETCH(frag_coord + vec2(offs_x, offs_y));\n            \n            float weight = gaussian_unnorm(\n                length(vec2(offs_x, offs_y)),\n                1.\n            );\n            \n            sum_values += v * weight;\n            sum_weights += weight;\n        }\n    }\n    float low_pass = sum_values / sum_weights;\n    float high_pass = FETCH(frag_coord) - low_pass;\n    \n    vec3 col = vec3(high_pass);\n    \n    frag_col = vec4(col, 1);\n}\n\n",
     "name": "Buffer B",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "MX3Bzr",
    "date": "0",
    "viewed": 0,
    "name": "Blue Noise Experiment 2",
    "description": "exp",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "noise",
     "blue"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "XsBSR3",
       "filepath": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png",
       "type": "texture",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "vec3 render(vec2 coord)\n{\n    //return texture(iChannel0, coord / vec2(textureSize(iChannel0, 0))).xxx;\n    prng_init(1403u);\n\n    float sum = 0.;\n    float sum_weights = 0.;\n    const int N_WAVES = 2000;\n    for (int i = 0; i < N_WAVES; i++)\n    {\n        // random direction for the wave\n        float angle = random() * TAU;\n        vec2 dir = vec2(cos(angle), sin(angle));\n        \n        // random frequency from .25 to 1 \"Hz\" in pixel space\n        float log2_freq = remap(random(), 0., 1., -1.1, 0.);\n        float freq = exp(log2_freq);\n        \n        // lower frequencies have less weight (amplitude)\n        float weight = 1.;\n        \n        sum += weight * cos(TAU * freq * dot(coord, dir));\n        sum_weights += weight;\n    }\n    float v = sqrt(float(N_WAVES)) * sum / sum_weights;\n    \n    return vec3(v * .5 + .5);\n}\n\nvec3 view_transform(vec3 col)\n{\n    // avoid any negative values before using power functions\n    col = max(col, 0.);\n\n    // OETF (Linear BT.709 I-D65 to sRGB 2.2)\n    col = pow(col, vec3(1. / 2.2));\n    col = clamp(col, 0., 1.);\n\n    return col;\n}\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    // render\n    vec3 col = vec3(0);\n    const int N_SAMPLES = 8;\n    for (int i = 0; i < N_SAMPLES; i++)\n    {\n        prng_init(uint(i));\n        col += render(frag_coord + vec2(random(), random()) - .5);\n    }\n    col /= float(N_SAMPLES);\n\n    // view transform\n    col = view_transform(col);\n\n    // output\n    frag_col = vec4(col, 1);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "#define SHADERTOY 1\n\nprecision highp float;\nprecision highp int;\n\n\n\n/*___________ math & integer utils ____________*/\n\nconst float PI = 3.141592653589793238462643383;\nconst float TAU = 6.283185307179586476925286767;\nconst float PI_OVER_2 = 1.570796326794896619231321692;\nconst float INV_PI = .318309886183790671537767527;\nconst float INV_TAU = .159154943091895335768883763;\n\n#define FUNC_WRAP(T) \\\nT wrap(T v, float start, float end) \\\n{ \\\n    return start + mod(v - start, end - start); \\\n}\n\n#define FUNC_REMAP(T) \\\nT remap(T v, float inp_start, float inp_end, float out_start, float out_end) \\\n{ \\\n    return out_start \\\n        + ((out_end - out_start) / (inp_end - inp_start)) * (v - inp_start); \\\n}\n\n#define FUNC_REMAP_CLAMP(T) \\\nT remap_clamp( \\\n    T v, \\\n    float inp_start, \\\n    float inp_end, \\\n    float out_start, \\\n    float out_end \\\n) \\\n{ \\\n    T t = clamp((v - inp_start) / (inp_end - inp_start), 0., 1.); \\\n    return out_start + t * (out_end - out_start); \\\n}\n\n#define FUNC_REMAP01(T) \\\nT remap01(T v, float inp_start, float inp_end) \\\n{ \\\n    return clamp((v - inp_start) / (inp_end - inp_start), 0., 1.); \\\n}\n\n#define FUNC_LENGTH_SQ(T) \\\nfloat length_sq(T v) \\\n{ \\\n    return dot(v, v); \\\n}\n\n#define FUNC_DIST_SQ(T) \\\nfloat dist_sq(T a, T b) \\\n{ \\\n    a -= b; \\\n    return dot(a, a); \\\n}\n\nFUNC_WRAP(float)\nFUNC_WRAP(vec2)\nFUNC_WRAP(vec3)\nFUNC_WRAP(vec4)\n\nFUNC_REMAP(float)\nFUNC_REMAP(vec2)\nFUNC_REMAP(vec3)\nFUNC_REMAP(vec4)\n\nFUNC_REMAP_CLAMP(float)\nFUNC_REMAP_CLAMP(vec2)\nFUNC_REMAP_CLAMP(vec3)\nFUNC_REMAP_CLAMP(vec4)\n\nFUNC_REMAP01(float)\nFUNC_REMAP01(vec2)\nFUNC_REMAP01(vec3)\nFUNC_REMAP01(vec4)\n\nFUNC_LENGTH_SQ(vec2)\nFUNC_LENGTH_SQ(vec3)\nFUNC_LENGTH_SQ(vec4)\n\nFUNC_DIST_SQ(vec2)\nFUNC_DIST_SQ(vec3)\nFUNC_DIST_SQ(vec4)\n\nfloat chebyshev_dist(vec2 a, vec2 b)\n{\n    return max(abs(a.x - b.x), abs(a.y - b.y));\n}\n\nfloat chebyshev_dist(vec3 a, vec3 b)\n{\n    return max(\n        max(abs(a.x - b.x), abs(a.y - b.y)),\n        abs(a.z - b.z)\n    );\n}\n\nfloat chebyshev_dist(vec4 a, vec4 b)\n{\n    return max(\n        max(\n            max(abs(a.x - b.x), abs(a.y - b.y)),\n            abs(a.z - b.z)\n        ),\n        abs(a.w - b.w)\n    );\n}\n\n#define idiv_ceil(a, b) ((a + b - 1) / b)\n\nint iabs(int v)\n{\n    if (v < 0)\n    {\n        return -v;\n    }\n    return v;\n}\n\nint imin(int a, int b)\n{\n    if (a < b)\n    {\n        return a;\n    }\n    return b;\n}\n\nint imax(int a, int b)\n{\n    if (a > b)\n    {\n        return a;\n    }\n    return b;\n}\n\nint iclamp(int v, int start, int end)\n{\n    if (v < start)\n    {\n        v = start;\n    }\n    if (v > end)\n    {\n        v = end;\n    }\n    return v;\n}\n\nfloat min_component(vec2 v)\n{\n    return min(v.x, v.y);\n}\n\nfloat min_component(vec3 v)\n{\n    return min(min(v.x, v.y), v.z);\n}\n\nfloat min_component(vec4 v)\n{\n    return min(min(min(v.x, v.y), v.z), v.w);\n}\n\nfloat max_component(vec2 v)\n{\n    return max(v.x, v.y);\n}\n\nfloat max_component(vec3 v)\n{\n    return max(max(v.x, v.y), v.z);\n}\n\nfloat max_component(vec4 v)\n{\n    return max(max(max(v.x, v.y), v.z), v.w);\n}\n\nint min_component(ivec2 v)\n{\n    return imin(v.x, v.y);\n}\n\nint min_component(ivec3 v)\n{\n    return imin(imin(v.x, v.y), v.z);\n}\n\nint min_component(ivec4 v)\n{\n    return imin(imin(imin(v.x, v.y), v.z), v.w);\n}\n\nint max_component(ivec2 v)\n{\n    return imax(v.x, v.y);\n}\n\nint max_component(ivec3 v)\n{\n    return imax(imax(v.x, v.y), v.z);\n}\n\nint max_component(ivec4 v)\n{\n    return imax(imax(imax(v.x, v.y), v.z), v.w);\n}\n\nfloat bilinear(\n    float val_bl,\n    float val_tl,\n    float val_tr,\n    float val_br,\n    vec2 offs\n)\n{\n    return mix(\n        mix(val_bl, val_br, offs.x),\n        mix(val_tl, val_tr, offs.x),\n        offs.y\n    );\n}\n\n// credits to AHSEN (https://www.shadertoy.com/user/01000001)\n// https://www.desmos.com/calculator/5d6ph151vi interactive :D\nfloat cubic_interp(float a, float b, float c, float d, float t)\n{\n    float one = t - 1.;\n    float two = t - 2.;\n    float three = t - 3.;\n    return (\n        (-one * two * three * a)\n        + (t * one * two * d)\n        + (3. * t * two * three * b)\n        - (3. * t * one * three * c)\n    ) / 6.;\n}\n\nfloat dist_along_line(vec2 p, vec2 line_start, vec2 line_end)\n{\n    vec2 dir = line_end - line_start;\n    \n    // normalize\n    float len_sqr = dot(dir, dir);\n    if (len_sqr < .0001)\n        return 1e9;\n    dir /= sqrt(len_sqr);\n    \n    return dot(\n        dir,\n        p - line_start\n    );\n}\n\nfloat relative_dist_along_line(vec2 p, vec2 line_start, vec2 line_end)\n{\n    vec2 dir = line_end - line_start;\n    return dot(\n        dir,\n        p - line_start\n    );\n}\n\n// |a| * |b| * sin(theta)\nfloat cross2d(vec2 a, vec2 b)\n{\n    return a.x * b.y - a.y * b.x;\n}\n\n// references for barycentric coordinates\n// https://www.desmos.com/calculator/8g8xjejuox\n// https://www.shadertoy.com/view/mdjBWK\n\nvec3 cartesian_to_barycentric(\n    vec2 p,\n    vec2 v0,\n    vec2 v1,\n    vec2 v2,\n    bool clamp_,\n    out bool p_is_outside\n)\n{\n    vec3 b = vec3(\n        cross2d(v1 - p, v2 - p),\n        cross2d(v2 - p, v0 - p),\n        cross2d(v0 - p, v1 - p)\n    ) / cross2d(v1 - v0, v2 - v0);\n    p_is_outside = min(min(b.x, b.y), b.z) < 0.;\n    if (clamp_)\n    {\n        b = max(b, 0.);\n        b /= (b.x + b.y + b.z);\n    }\n    return b;\n}\n\nvec3 cartesian_to_barycentric(\n    vec3 p,\n    vec3 v0,\n    vec3 v1,\n    vec3 v2,\n    bool clamp_,\n    out bool p_is_outside\n)\n{\n    vec3 b = vec3(\n        length(cross(v1 - p, v2 - p)),\n        length(cross(v2 - p, v0 - p)),\n        length(cross(v0 - p, v1 - p))\n    ) / length(cross(v1 - v0, v2 - v0));\n    p_is_outside = min(min(b.x, b.y), b.z) < 0.;\n    if (clamp_)\n    {\n        b = max(b, 0.);\n        b /= (b.x + b.y + b.z);\n    }\n    return b;\n}\n\nfloat barycentric_interpolate(vec3 b, float v0, float v1, float v2)\n{\n    return dot(b, vec3(v0, v1, v2));\n}\n\nvec2 barycentric_interpolate(vec3 b, vec2 v0, vec2 v1, vec2 v2)\n{\n    return b.x * v0 + b.y * v1 + b.z * v2;\n}\n\nvec3 barycentric_interpolate(vec3 b, vec3 v0, vec3 v1, vec3 v2)\n{\n    return b.x * v0 + b.y * v1 + b.z * v2;\n}\n\nvec4 barycentric_interpolate(vec3 b, vec4 v0, vec4 v1, vec4 v2)\n{\n    return b.x * v0 + b.y * v1 + b.z * v2;\n}\n\nfloat barycentric_interpolate(vec2 b, float v0, float v1, float v2)\n{\n    return barycentric_interpolate(\n        vec3(b.x, b.y, 1. - b.x - b.y),\n        v0, v1, v2\n    );\n}\n\nvec2 barycentric_interpolate(vec2 b, vec2 v0, vec2 v1, vec2 v2)\n{\n    return barycentric_interpolate(\n        vec3(b.x, b.y, 1. - b.x - b.y),\n        v0, v1, v2\n    );\n}\n\nvec3 barycentric_interpolate(vec2 b, vec3 v0, vec3 v1, vec3 v2)\n{\n    return barycentric_interpolate(\n        vec3(b.x, b.y, 1. - b.x - b.y),\n        v0, v1, v2\n    );\n}\n\nvec4 barycentric_interpolate(vec2 b, vec4 v0, vec4 v1, vec4 v2)\n{\n    return barycentric_interpolate(\n        vec3(b.x, b.y, 1. - b.x - b.y),\n        v0, v1, v2\n    );\n}\n\n// angle from 0 to TAU\nfloat get_angle(vec2 p)\n{\n    float a = atan(p.y, p.x);\n    if (a < 0.)\n    {\n        return a + TAU;\n    }\n    return a;\n}\n\nmat2 rotate_2d(float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(\n        c, s,\n        -s, c\n    );\n}\n\nvec2 perpendicular(vec2 v)\n{\n    return vec2(-v.y, v.x);\n}\n\n// s.x=theta\n// s.y=phi\n// (there's no r)\nvec3 spherical_to_cartesian(vec2 s)\n{\n    float sin_theta = sin(s.x);\n    return vec3(\n        sin_theta * cos(s.y),\n        sin_theta * sin(s.y),\n        cos(s.x)\n    );\n}\n\n// s.x=r\n// s.y=theta\n// s.z=phi\nvec3 spherical_to_cartesian(vec3 s)\n{\n    float sin_theta = sin(s.y);\n    return s.x * vec3(\n        sin_theta * cos(s.z),\n        sin_theta * sin(s.z),\n        cos(s.y)\n    );\n}\n\nvec2 screen_to_uv01(vec2 coord, vec2 res)\n{\n    return coord / res;\n}\n\nvec2 screen_to_uv_horizontal(vec2 coord, vec2 res)\n{\n    return (2. * coord - res) / res.x;\n}\n\nvec2 screen_to_uv_vertical(vec2 coord, vec2 res)\n{\n    return (2. * coord - res) / res.y;\n}\n\nvec2 screen_to_uv_fit(vec2 coord, vec2 res)\n{\n    return (2. * coord - res) / min_component(res);\n}\n\nvec2 screen_to_uv_fill(vec2 coord, vec2 res)\n{\n    return (2. * coord - res) / max_component(res);\n}\n\n// * idx starts at 1\nfloat halton(int base, int idx)\n{\n    float result = 0.;\n    float digit_weight = 1.;\n    while (idx > 0)\n    {\n        digit_weight /= float(base);\n        result += float(idx % base) * digit_weight;\n        idx /= base;\n    }\n    return result;\n}\n\n// * idx starts at 1\nvec2 halton_2d(int idx)\n{\n    return vec2(halton(2, idx), halton(3, idx));\n}\n\n// * idx starts at 1\nvec3 halton_3d(int idx)\n{\n    return vec3(halton(2, idx), halton(3, idx), halton(5, idx));\n}\n\n// * idx starts at 1\nvec4 halton_4d(int idx)\n{\n    return vec4(\n        halton(2, idx),\n        halton(3, idx),\n        halton(5, idx),\n        halton(7, idx)\n    );\n}\n\n// for some reason we can't use intBitsToFloat() or floatBitsToInt() to store\n// integers below this value in a buffer.\nconst int BUFFER_MIN_INTEGER = 8388608;\n\n// * x must not be higher than 4,286,578,688 (see BUFFER_MIN_INTEGER above)\n// * for your sanity, don't use negative values\nfloat encode_int_for_buffer(int v)\n{\n    return intBitsToFloat(v + BUFFER_MIN_INTEGER);\n}\n\nint decode_int_from_buffer(float v)\n{\n    return floatBitsToInt(v) - BUFFER_MIN_INTEGER;\n}\n\n// pack two 16-bit integers in a single 32-bit integer\n// * both arguments should be in the 0-65535 range\n// * a must be less than 65279 (see the functions above)\nint pack_i16(int a, int b)\n{\n    return (a << 16) | b;\n}\n\n// unpack two 16-bit integers from a single 32-bit integer\nvoid unpack_i16(int v, out int a, out int b)\n{\n    a = (v >> 16) & 65535;\n    b = v & 65535;\n}\n\n// unpack the first 16-bit integer from a 32-bit integer\nint unpack_i16_a(int v)\n{\n    return (v >> 16) & 65535;\n}\n\n// unpack the second 16-bit integer from a 32-bit integer\nint unpack_i16_b(int v)\n{\n    return v & 65535;\n}\n\nbool icoord_in_bounds(ivec2 icoord, ivec2 ires)\n{\n    return\n        icoord.x >= 0 &&\n        icoord.y >= 0 &&\n        icoord.x < ires.x &&\n        icoord.y < ires.y;\n}\n\nbool icoord_in_bounds(ivec3 icoord, ivec3 ires)\n{\n    return\n        icoord.x >= 0 &&\n        icoord.y >= 0 &&\n        icoord.z >= 0 &&\n        icoord.x < ires.x &&\n        icoord.y < ires.y &&\n        icoord.z < ires.z;\n}\n\nint icoord_to_idx(ivec2 icoord, ivec2 ires)\n{\n    return icoord.x + (icoord.y * ires.x);\n}\n\nint icoord_to_idx(ivec3 icoord, ivec3 ires)\n{\n    return icoord.x + (icoord.y * ires.x) + (icoord.z * ires.x * ires.y);\n}\n\nivec2 idx_to_icoord(int idx, ivec2 ires)\n{\n    return ivec2(idx % ires.x, idx / ires.x);\n}\n\nivec3 idx_to_icoord(int idx, ivec3 ires)\n{\n    return ivec3(\n        idx % ires.x,\n        (idx % (ires.x * ires.y)) / ires.x,\n        idx / (ires.x * ires.y)\n    );\n}\n\n// https://www.desmos.com/calculator/kfe07basy9\n\nint compress_float_to_int_linear(float f, float min_f, float max_f, int max_i)\n{\n    return int(floor(\n        float(max_i) * remap01(f, min_f, max_f)\n    ));\n}\n\nfloat decompress_float_from_int_linear(\n    int i,\n    int max_i,\n    float min_f,\n    float max_f\n)\n{\n    return remap_clamp(\n        float(i) / float(max_i),\n        0., 1.,\n        min_f, max_f\n    );\n}\n\nint compress_float_to_int_log(\n    float f,\n    float log2_zero_offset,\n    float max_log2_f,\n    int max_i\n)\n{\n    f = max(0., f);\n    f += pow(2., log2_zero_offset);\n    return int(floor(\n        float(max_i) * remap01(log2(f), log2_zero_offset, max_log2_f)\n    ));\n}\n\nfloat decompress_float_from_int_log(\n    int i,\n    int max_i,\n    float log2_zero_offset,\n    float max_log2_f\n)\n{\n    return pow(2., remap_clamp(\n        float(i) / float(max_i),\n        0., 1.,\n        log2_zero_offset, max_log2_f\n    )) - pow(2., log2_zero_offset);\n}\n\n\n\n/*_______ pseudo-random number generator ______*/\n// source: https://www.shadertoy.com/view/WdSSRt\n// (heavily modified)\n\n/* usage example:\n    void mainImage(out vec4 frag_col, in vec2 frag_coord)\n    {\n        // initialize PRNG\n        prng_init(vec3(frag_coord / iResolution.y, iTime));\n    \n        // use the function\n        float a = random();\n        vec3 b = vec3(random(), random(), random());\n        \n        ...\n    }\n*/\n\nuint prng_state[2];\n\nuint prng_rot(uint x, int k)\n{\n    return (x << k) | (x >> (32 - k));\n}\n\n// random uint from 0 to 2^32-1\nuint randomui()\n{\n    uint s0 = prng_state[0];\n    uint s1 = prng_state[1];\n    uint result = prng_rot(s0 * 2654435771u, 5) * 5u;\n    s1 ^= s0;\n    prng_state[0] = prng_rot(s0, 26) ^ s1 ^ (s1 << 9);\n    prng_state[1] = prng_rot(s1, 13);\n    return result;\n}\n\n// random int from 0 to 2^31-1\nint randomi()\n{\n    return int(randomui() % 0x7FFFFFFFu);\n}\n\n// random float from 0 to 1\nfloat random()\n{\n    return float(randomui()) / float(0xffffffffu);\n}\n\n// generate two normally distributed random numbers using the\n// Box-Muller transform\n// https://www.baeldung.com/cs/uniform-to-normal-distribution\nvec2 random_gauss()\n{\n    float u1 = random();\n    float u2 = random() * TAU;\n    float temp = sqrt(-2. * log(u1));\n    return temp * vec2(cos(u2), sin(u2));\n    \n    // unoptimized version\n    //float u1 = random();\n    //float u2 = random();\n    //return vec2(cos(TAU * u2), sin(TAU * u2)) * sqrt(-2. * log(u1));\n}\n\nvec2 random_on_circle()\n{\n    vec2 v = vec2(1);\n    float lensqr;\n\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec2(2. * random() - 1., 2. * random() - 1.);\n        lensqr = dot(v, v);\n        if (lensqr == 0.)\n            i--;\n        else if (lensqr <= 1.)\n            break;\n    }\n    return v / sqrt(lensqr);\n}\n\nvec3 random_on_sphere()\n{\n    vec3 v = vec3(1);\n    float lensqr;\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec3(2. * random() - 1., 2. * random() - 1., 2. * random() - 1.);\n        lensqr = dot(v, v);\n        if (lensqr == 0.)\n            i--;\n        else if (lensqr <= 1.)\n            break;\n    }\n    return v / sqrt(lensqr);\n}\n\nvec2 random_in_circle()\n{\n    vec2 v = vec2(1);\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec2(2. * random() - 1., 2. * random() - 1.);\n        if (dot(v, v) <= 1.)\n            return v;\n    }\n    return v;\n}\n\nvec3 random_in_sphere()\n{\n    vec3 v = vec3(1);\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec3(2. * random() - 1., 2. * random() - 1., 2. * random() - 1.);\n        if (dot(v, v) <= 1.)\n            return v;\n    }\n    return v;\n}\n\nvec3 random_on_hemisphere(vec3 normal)\n{\n    vec3 v = random_on_sphere();\n    return v * sign(dot(v, normal));\n}\n\nvec3 random_in_hemisphere(vec3 normal)\n{\n    vec3 v = random_in_sphere();\n    return v * sign(dot(v, normal));\n}\n\n// initialize with uvec2\nvoid prng_init(uvec2 seed)\n{\n    seed += uvec2(1317, 944573125);\n    seed *= 464973573u;\n    prng_state[0] = seed.x;\n    prng_state[1] = seed.y;\n    randomi();\n}\n\n// initialize with uint\nvoid prng_init(uint seed)\n{\n    prng_init(uvec2(seed, 1));\n}\n\n// initialize with vec3\nvoid prng_init(vec3 seed)\n{\n    seed += 3.49276101561702;\n    seed.xy *= (seed.z + 10.258);\n    prng_state[0] = floatBitsToUint(seed.x);\n    prng_state[1] = floatBitsToUint(seed.y);\n    randomui();\n}\n\n// initialize with vec2\nvoid prng_init(vec2 seed)\n{\n    prng_init(vec3(seed, 1));\n}\n\n// initialize with float\nvoid prng_init(float seed)\n{\n    prng_init(vec3(seed, 1, 1));\n}\n\n\n\n/*__________________ keyboard _________________*/\n\n// put this code in every buffer that uses the keyboard input:\n/*\n#if SHADERTOY\n// iChannelX must be set to Keyboard in Shadertoy\n#define SHADERTOY_KEYBOARD_CH iChannelX\n#else\n#iKeyboard\n#endif\n\ndefine_keyboard_utils\n*/\n\n#if SHADERTOY\n\n#define define_keyboard_utils \\\n \\\n/* https://github.com/stevensona/shader-toy/blob/c4833b972649d78a2ee090af60b79a3907e8e091/src/extensions/keyboard/keyboard_shader_extension.ts#L11 */ \\\nconst int \\\n    Key_Backspace = 8, Key_Tab = 9, Key_Enter = 13, Key_Shift = 16, \\\n    Key_Ctrl = 17, Key_Alt = 18, Key_Pause = 19, Key_Caps = 20, \\\n    Key_Escape = 27, Key_PageUp = 33, Key_PageDown = 34, Key_End = 35, \\\n    Key_Home = 36, Key_LeftArrow = 37, Key_UpArrow = 38, Key_RightArrow = 39, \\\n    Key_DownArrow = 40, Key_Insert = 45, Key_Delete = 46, Key_0 = 48, \\\n    Key_1 = 49, Key_2 = 50, Key_3 = 51, Key_4 = 52, Key_5 = 53, Key_6 = 54, \\\n    Key_7 = 55, Key_8 = 56, Key_9 = 57, Key_A = 65, Key_B = 66, Key_C = 67, \\\n    Key_D = 68, Key_E = 69, Key_F = 70, Key_G = 71, Key_H = 72, \\\n    Key_I = 73, Key_J = 74, Key_K = 75, Key_L = 76, Key_M = 77, Key_N = 78, \\\n    Key_O = 79, Key_P = 80, Key_Q = 81, Key_R = 82, Key_S = 83, Key_T = 84, \\\n    Key_U = 85, Key_V = 86, Key_W = 87, Key_X = 88, Key_Y = 89, Key_Z = 90, \\\n    Key_LeftWindow = 91, Key_RightWindows = 92, Key_Select = 93, \\\n    Key_Numpad0 = 96, Key_Numpad1 = 97, Key_Numpad2 = 98, Key_Numpad3 = 99, \\\n    Key_Numpad4 = 100, Key_Numpad5 = 101, Key_Numpad6 = 102, \\\n    Key_Numpad7 = 103, Key_Numpad8 = 104, Key_Numpad9 = 105, \\\n    Key_NumpadMultiply = 106, Key_NumpadAdd = 107, Key_NumpadSubtract = 109, \\\n    Key_NumpadPeriod = 110, Key_NumpadDivide = 111, Key_F1 = 112, \\\n    Key_F2 = 113, Key_F3 = 114, Key_F4 = 115, Key_F5 = 116, Key_F6 = 117, \\\n    Key_F7 = 118, Key_F8 = 119, Key_F9 = 120, Key_F10 = 121, Key_F11 = 122, \\\n    Key_F12 = 123, Key_NumLock = 144, Key_ScrollLock = 145, \\\n    Key_SemiColon = 186, Key_Equal = 187, Key_Comma = 188, Key_Dash = 189, \\\n    Key_Period = 190, Key_ForwardSlash = 191, Key_GraveAccent = 192, \\\n    Key_OpenBracket = 219, Key_BackSlash = 220, Key_CloseBraket = 221, \\\n    Key_SingleQuote = 222; \\\nconst int Key_Space = 32; \\\n \\\nbool is_key_pressed(int key) \\\n{ \\\n    return texelFetch(SHADERTOY_KEYBOARD_CH, ivec2(key, 1), 0).x > .5; \\\n} \\\n \\\nbool is_key_down(int key) \\\n{ \\\n    return texelFetch(SHADERTOY_KEYBOARD_CH, ivec2(key, 0), 0).x > .5; \\\n} \\\n \\\nbool is_key_toggled(int key) \\\n{ \\\n    return texelFetch(SHADERTOY_KEYBOARD_CH, ivec2(key, 2), 0).x > .5; \\\n}\n\n#else\n\n#define define_keyboard_utils \\\n \\\nconst int Key_Space = 32; \\\n \\\nbool is_key_pressed(int key) \\\n{ \\\n    return isKeyPressed(key); \\\n} \\\n \\\nbool is_key_down(int key) \\\n{ \\\n    return isKeyDown(key); \\\n} \\\n \\\nbool is_key_toggled(int key) \\\n{ \\\n    return isKeyToggled(key); \\\n}\n\n#endif\n\n\n\n/*-----------------------------------------------\n\nflim - Filmic Color Transform\n\nInput Color Space:   Linear BT.709 I-D65\nOutput Color Space:  Linear BT.709 I-D65 / sRGB 2.2 (depends on arguments)\n\nDescription:\n  Experimental port of flim for GLSL/Shadertoy\n  matching flim v1.1.0.\n\nAuthor:\n  Bean (beans_please on Shadertoy)\n\nOriginal Repo:\n  https://github.com/bean-mhm/flim\n\nOriginal Shader:\n  https://www.shadertoy.com/view/dd2yDz\n\n-----------------------------------------------*/\n\n// parameters\n\nconst float flim_pre_exposure = 4.3;\nconst vec3 flim_pre_formation_filter = vec3(1.);\nconst float flim_pre_formation_filter_strength = 0.;\n\nconst float flim_extended_gamut_red_scale = 1.05;\nconst float flim_extended_gamut_green_scale = 1.12;\nconst float flim_extended_gamut_blue_scale = 1.045;\nconst float flim_extended_gamut_red_rot = .5;\nconst float flim_extended_gamut_green_rot = 2.;\nconst float flim_extended_gamut_blue_rot = .1;\nconst float flim_extended_gamut_red_mul = 1.;\nconst float flim_extended_gamut_green_mul = 1.;\nconst float flim_extended_gamut_blue_mul = 1.;\n\nconst float flim_sigmoid_log2_min = -10.;\nconst float flim_sigmoid_log2_max = 22.;\nconst float flim_sigmoid_toe_x = .44;\nconst float flim_sigmoid_toe_y = .28;\nconst float flim_sigmoid_shoulder_x = .591;\nconst float flim_sigmoid_shoulder_y = .779;\n\nconst float flim_negative_film_exposure = 6.;\nconst float flim_negative_film_density = 5.;\n\nconst vec3 flim_print_backlight = vec3(1);\nconst float flim_print_film_exposure = 6.;\nconst float flim_print_film_density = 27.5;\n\nconst float flim_black_point = -1.; // -1 = auto\nconst vec3 flim_post_formation_filter = vec3(1);\nconst float flim_post_formation_filter_strength = 0.;\nconst float flim_midtone_saturation = 1.02;\n\n// color space conversions\n// the matrices below represent data in row-major, but GLSL matrices are in\n// column-major, so we need to multiply a vec3 by a matrix rather than\n// multiplying a matrix by a vec3.\n\nconst mat3 mat_bt2020_to_xyz = mat3(\n     0.6369580483,  0.1446169036,  0.1688809752,\n     0.2627002120,  0.6779980715,  0.0593017165,\n     0.0000000000,  0.0280726930,  1.0609850577\n);\n\nconst mat3 mat_xyz_to_bt2020 = mat3(\n     1.7166511880, -0.3556707838, -0.2533662814,\n    -0.6666843518,  1.6164812366,  0.0157685458,\n     0.0176398574, -0.0427706133,  0.9421031212\n);\n\nconst mat3 mat_bt709_to_xyz = mat3(\n     0.4123907993,  0.3575843394,  0.1804807884,\n     0.2126390059,  0.7151686788,  0.0721923154,\n     0.0193308187,  0.1191947798,  0.9505321522\n);\n\nconst mat3 mat_xyz_to_bt709 = mat3(\n     3.2409699419, -1.5373831776, -0.4986107603,\n    -0.9692436363,  1.8759675015,  0.0415550574,\n     0.0556300797, -0.2039769589,  1.0569715142\n);\n\nconst mat3 mat_dcip3_to_xyz = mat3(\n     0.4451698156,  0.2771344092,  0.1722826698,\n     0.2094916779,  0.7215952542,  0.0689130679,\n     0.0000000000,  0.0470605601,  0.9073553944\n);\n\nconst mat3 mat_xyz_to_dcip3 = mat3(\n     2.7253940305, -1.0180030062, -0.4401631952,\n    -0.7951680258,  1.6897320548,  0.0226471906,\n     0.0412418914, -0.0876390192,  1.1009293786\n);\n\nvec3 oetf_pow(vec3 col, float power)\n{\n    return pow(col, vec3(1. / power));\n}\n\nvec3 eotf_pow(vec3 col, float power)\n{\n    return pow(col, vec3(power));\n}\n\n// flim's utility functions\n\nfloat flim_wrap(float v, float start, float end)\n{\n    return start + mod(v - start, end - start);\n}\n\nfloat flim_remap(\n    float v,\n    float inp_start,\n    float inp_end,\n    float out_start,\n    float out_end\n)\n{\n    return out_start\n        + ((out_end - out_start) / (inp_end - inp_start)) * (v - inp_start);\n}\n\nfloat flim_remap_clamp(\n    float v,\n    float inp_start,\n    float inp_end,\n    float out_start,\n    float out_end\n)\n{\n    float t = clamp((v - inp_start) / (inp_end - inp_start), 0., 1.);\n    return out_start + t * (out_end - out_start);\n}\n\nfloat flim_remap01(\n    float v,\n    float inp_start,\n    float inp_end\n)\n{\n    return clamp((v - inp_start) / (inp_end - inp_start), 0., 1.);\n}\n\nvec3 flim_blender_rgb_to_hsv(vec3 rgb)\n{\n    float cmax, cmin, h, s, v, cdelta;\n    vec3 c;\n\n    cmax = max(rgb[0], max(rgb[1], rgb[2]));\n    cmin = min(rgb[0], min(rgb[1], rgb[2]));\n    cdelta = cmax - cmin;\n\n    v = cmax;\n    if (cmax != 0.)\n    {\n        s = cdelta / cmax;\n    }\n    else\n    {\n        s = 0.;\n        h = 0.;\n    }\n\n    if (s == 0.)\n    {\n        h = 0.;\n    }\n    else\n    {\n        c = (vec3(cmax) - rgb.xyz) / cdelta;\n\n        if (rgb.x == cmax)\n        {\n            h = c[2] - c[1];\n        }\n        else if (rgb.y == cmax)\n        {\n            h = 2. + c[0] - c[2];\n        }\n        else\n        {\n            h = 4. + c[1] - c[0];\n        }\n\n        h /= 6.;\n\n        if (h < 0.)\n        {\n            h += 1.;\n        }\n    }\n\n    return vec3(h, s, v);\n}\n\nvec3 flim_blender_hsv_to_rgb(vec3 hsv)\n{\n    float f, p, q, t, h, s, v;\n    vec3 rgb;\n\n    h = hsv[0];\n    s = hsv[1];\n    v = hsv[2];\n\n    if (s == 0.)\n    {\n        rgb = vec3(v, v, v);\n    }\n    else\n    {\n        if (h == 1.)\n        {\n            h = 0.;\n        }\n\n        h *= 6.;\n        int i = int(floor(h));\n        f = h - float(i);\n        rgb = vec3(f, f, f);\n        p = v * (1. - s);\n        q = v * (1. - (s * f));\n        t = v * (1. - (s * (1. - f)));\n\n        if (i == 0)\n        {\n            rgb = vec3(v, t, p);\n        }\n        else if (i == 1)\n        {\n            rgb = vec3(q, v, p);\n        }\n        else if (i == 2)\n        {\n            rgb = vec3(p, v, t);\n        }\n        else if (i == 3)\n        {\n            rgb = vec3(p, q, v);\n        }\n        else if (i == 4)\n        {\n            rgb = vec3(t, p, v);\n        }\n        else\n        {\n            rgb = vec3(v, p, q);\n        }\n    }\n\n    return rgb;\n}\n\nvec3 flim_blender_hue_sat(vec3 col, float hue, float sat, float value)\n{\n    vec3 hsv = flim_blender_rgb_to_hsv(col);\n\n    hsv[0] = fract(hsv[0] + hue + .5);\n    hsv[1] = clamp(hsv[1] * sat, 0., 1.);\n    hsv[2] = hsv[2] * value;\n\n    return flim_blender_hsv_to_rgb(hsv);\n}\n\nfloat flim_rgb_avg(vec3 col)\n{\n    return (col.x + col.y + col.z) / 3.;\n}\n\nfloat flim_rgb_sum(vec3 col)\n{\n    return col.x + col.y + col.z;\n}\n\nfloat flim_rgb_max(vec3 col)\n{\n    return max(max(col.x, col.y), col.z);\n}\n\nfloat flim_rgb_min(vec3 col)\n{\n    return min(min(col.x, col.y), col.z);\n}\n\nvec3 flim_rgb_uniform_offset(vec3 col, float black_point, float white_point)\n{\n    float mono = flim_rgb_avg(col);\n    float mono2 = flim_remap01(\n        mono, black_point / 1000.,\n        1. - (white_point / 1000.)\n    );\n    return col * (mono2 / mono);\n}\n\nvec3 flim_rgb_sweep(float hue)\n{\n    hue = flim_wrap(hue * 360., 0., 360.);\n\n    vec3 col = vec3(1, 0, 0);\n    col = mix(col, vec3(1, 1, 0), flim_remap01(hue, 0., 60.));\n    col = mix(col, vec3(0, 1, 0), flim_remap01(hue, 60., 120.));\n    col = mix(col, vec3(0, 1, 1), flim_remap01(hue, 120., 180.));\n    col = mix(col, vec3(0, 0, 1), flim_remap01(hue, 180., 240.));\n    col = mix(col, vec3(1, 0, 1), flim_remap01(hue, 240., 300.));\n    col = mix(col, vec3(1, 0, 0), flim_remap01(hue, 300., 360.));\n    \n    return col;\n}\n\nvec3 flim_rgb_exposure_sweep_test(vec2 uv0to1)\n{\n    float hue = 1. - uv0to1.y;\n    float exposure = flim_remap(uv0to1.x, 0., 1., -5., 10.);\n    return flim_rgb_sweep(hue) * pow(2., exposure);\n}\n\n// https://www.desmos.com/calculator/khkztixyeu\nfloat flim_super_sigmoid(\n    float v,\n    float toe_x,\n    float toe_y,\n    float shoulder_x,\n    float shoulder_y\n)\n{\n    // clip\n    v = clamp(v, 0., 1.);\n    toe_x = clamp(toe_x, 0., 1.);\n    toe_y = clamp(toe_y, 0., 1.);\n    shoulder_x = clamp(shoulder_x, 0., 1.);\n    shoulder_y = clamp(shoulder_y, 0., 1.);\n\n    // calculate straight line slope\n    float slope = (shoulder_y - toe_y) / (shoulder_x - toe_x);\n\n    // toe\n    if (v < toe_x)\n    {\n        float toe_pow = slope * toe_x / toe_y;\n        return toe_y * pow(v / toe_x, toe_pow);\n    }\n\n    // straight line\n    if (v < shoulder_x)\n    {\n        float intercept = toe_y - (slope * toe_x);\n        return slope * v + intercept;\n    }\n\n    // shoulder\n    float shoulder_pow =\n        -slope / (\n            ((shoulder_x - 1.) / pow(1. - shoulder_x, 2.))\n            * (1. - shoulder_y)\n        );\n    return\n        (1. - pow(1. - (v - shoulder_x) / (1. - shoulder_x), shoulder_pow))\n        * (1. - shoulder_y)\n        + shoulder_y;\n}\n\nfloat flim_dye_mix_factor(float mono, float max_density)\n{\n    // log2 and map range\n    float offset = pow(2., flim_sigmoid_log2_min);\n    float fac = flim_remap01(\n        log2(mono + offset),\n        flim_sigmoid_log2_min,\n        flim_sigmoid_log2_max\n    );\n\n    // calculate amount of exposure from 0 to 1\n    fac = flim_super_sigmoid(\n        fac,\n        flim_sigmoid_toe_x,\n        flim_sigmoid_toe_y,\n        flim_sigmoid_shoulder_x,\n        flim_sigmoid_shoulder_y\n    );\n\n    // calculate dye density\n    fac *= max_density;\n\n    // mix factor\n    fac = pow(2., -fac);\n\n    // clip and return\n    return clamp(fac, 0., 1.);\n}\n\nvec3 flim_rgb_color_layer(\n    vec3 col,\n    vec3 sensitivity_tone,\n    vec3 dye_tone,\n    float max_density\n)\n{\n    // normalize\n    vec3 sensitivity_tone_norm =\n        sensitivity_tone / flim_rgb_sum(sensitivity_tone);\n    vec3 dye_tone_norm = dye_tone / flim_rgb_max(dye_tone);\n\n    // dye mix factor\n    float mono = dot(col, sensitivity_tone_norm);\n    float mix_fac = flim_dye_mix_factor(mono, max_density);\n\n    // dye mixing\n    return mix(dye_tone_norm, vec3(1), mix_fac);\n}\n\nvec3 flim_rgb_develop(vec3 col, float exposure, float max_density)\n{\n    // exposure\n    col *= pow(2., exposure);\n\n    // blue-sensitive layer\n    vec3 result = flim_rgb_color_layer(\n        col,\n        vec3(0, 0, 1),\n        vec3(1, 1, 0),\n        max_density\n    );\n\n    // green-sensitive layer\n    result *= flim_rgb_color_layer(\n        col,\n        vec3(0, 1, 0),\n        vec3(1, 0, 1),\n        max_density\n    );\n\n    // red-sensitive layer\n    result *= flim_rgb_color_layer(\n        col,\n        vec3(1, 0, 0),\n        vec3(0, 1, 1),\n        max_density\n    );\n\n    return result;\n}\n\nvec3 flim_gamut_extension_mat_row(\n    float primary_hue,\n    float scale,\n    float rotate,\n    float mul\n)\n{\n    vec3 result = flim_blender_hsv_to_rgb(vec3(\n        flim_wrap(primary_hue + (rotate / 360.), 0., 1.),\n        1. / scale,\n        1.\n    ));\n    result /= flim_rgb_sum(result);\n    result *= mul;\n    return result;\n}\n\nmat3 flim_gamut_extension_mat(\n    float red_scale,\n    float green_scale,\n    float blue_scale,\n    float red_rot,\n    float green_rot,\n    float blue_rot,\n    float red_mul,\n    float green_mul,\n    float blue_mul\n)\n{\n    mat3 m;\n    m[0] = flim_gamut_extension_mat_row(\n        0.,\n        red_scale,\n        red_rot,\n        red_mul\n    );\n    m[1] = flim_gamut_extension_mat_row(\n        1. / 3.,\n        green_scale,\n        green_rot,\n        green_mul\n    );\n    m[2] = flim_gamut_extension_mat_row(\n        2. / 3.,\n        blue_scale,\n        blue_rot,\n        blue_mul\n    );\n    return m;\n}\n\nvec3 negative_and_print(vec3 col, vec3 backlight_ext)\n{\n    // develop negative\n    col = flim_rgb_develop(\n        col,\n        flim_negative_film_exposure,\n        flim_negative_film_density\n    );\n\n    // backlight\n    col *= backlight_ext;\n\n    // develop print\n    col = flim_rgb_develop(\n        col,\n        flim_print_film_exposure,\n        flim_print_film_density\n    );\n\n    return col;\n}\n\n// the flim transform\n\nvec3 flim_transform(vec3 col, float exposure, bool convert_to_srgb)\n{\n    // eliminate negative values\n    col = max(col, 0.);\n\n    // pre-Exposure\n    col *= pow(2., flim_pre_exposure + exposure);\n\n    // clip very large values for float precision issues\n    col = min(col, 5000.);\n\n    // gamut extension matrix (Linear BT.709)\n    mat3 extend_mat = flim_gamut_extension_mat(\n        flim_extended_gamut_red_scale,\n        flim_extended_gamut_green_scale,\n        flim_extended_gamut_blue_scale,\n        flim_extended_gamut_red_rot,\n        flim_extended_gamut_green_rot,\n        flim_extended_gamut_blue_rot,\n        flim_extended_gamut_red_mul,\n        flim_extended_gamut_green_mul,\n        flim_extended_gamut_blue_mul\n    );\n    mat3 extend_mat_inv = inverse(extend_mat);\n\n    // backlight in the extended gamut\n    vec3 backlight_ext = flim_print_backlight * extend_mat;\n\n    // upper limit in the print (highlight cap)\n    const float big = 10000000.;\n    vec3 white_cap = negative_and_print(vec3(big, big, big), backlight_ext);\n\n    // pre-formation filter\n    col = mix(\n        col,\n        col * flim_pre_formation_filter,\n        flim_pre_formation_filter_strength\n    );\n\n    // convert to the extended gamut\n    col *= extend_mat;\n\n    // negative & print\n    col = negative_and_print(col, backlight_ext);\n\n    // convert from the extended gamut\n    col *= extend_mat_inv;\n\n    // eliminate negative values\n    col = max(col, 0.);\n\n    // white cap\n    col /= white_cap;\n\n    // black cap (-1 = auto)\n    if (flim_black_point == -1.)\n    {\n        vec3 black_cap = negative_and_print(vec3(0.), backlight_ext);\n        black_cap /= white_cap;\n        col = flim_rgb_uniform_offset(\n            col,\n            flim_rgb_avg(black_cap) * 1000.,\n            0.\n        );\n    }\n    else\n    {\n        col = flim_rgb_uniform_offset(col, flim_black_point, 0.);\n    }\n\n    // post-formation filter\n    col = mix(\n        col,\n        col * flim_post_formation_filter,\n        flim_post_formation_filter_strength\n    );\n\n    // clip\n    col = clamp(col, 0., 1.);\n\n    // midtone saturation\n    float mono = flim_rgb_avg(col);\n    float mix_fac =\n        (mono < .5)\n        ? flim_remap01(mono, .05, .5)\n        : flim_remap01(mono, .95, .5);\n    col = mix(\n        col,\n        flim_blender_hue_sat(col, .5, flim_midtone_saturation, 1.),\n        mix_fac\n    );\n\n    // clip\n    col = clamp(col, 0., 1.);\n\n    // OETF\n    if (convert_to_srgb)\n    {\n        col = oetf_pow(col, 2.2);\n    }\n\n    return col;\n}\n\n/*____________________ end ____________________*/\n",
     "name": "Common",
     "description": "",
     "type": "common"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "MX3BR8",
    "date": "1736931744",
    "viewed": 139,
    "name": "Single Function Semi Blue Noise",
    "description": "Convolution with a white noise.\n\nHold mouse to see Shadertoy's default blue noise texture.",
    "likes": 9,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "noise",
     "blue",
     "hash",
     "prng",
     "low",
     "rng",
     "discrepency"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "XsBSR3",
       "filepath": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png",
       "type": "texture",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// generate blue noise by doing a convolution with a white noise\nfloat blue_noise(ivec2 icoord, int frame)\n{\n    // the kernel is generated using a Python script\n    // https://gist.github.com/bean-mhm/ef42ec1c838efc9470ba44787044b008\n    const float KERNEL[7 * 7] = float[](\n        0.0008446,  0.002607,   0.004386,   0.0048513,  0.004386,   0.002607,   0.0008446,\n        0.002607,   0.0049418, -0.0033291, -0.0137976, -0.0033291,  0.0049418,  0.002607, \n        0.004386,  -0.0033291, -0.0688435, -0.1310897, -0.0688435, -0.0033291,  0.004386, \n        0.0048513, -0.0137976, -0.1310898,  0.761284,  -0.1310898, -0.0137976,  0.0048513,\n        0.004386,  -0.0033291, -0.0688435, -0.1310897, -0.0688435, -0.0033291,  0.004386, \n        0.002607,   0.0049418, -0.0033291, -0.0137976, -0.0033291,  0.0049418,  0.002607, \n        0.0008446,  0.002607,   0.004386,   0.0048513,  0.004386,   0.002607,   0.0008446\n    );\n\n    float high_pass = 0.;\n    for (int offs_y = -3; offs_y <= 3; offs_y++)\n    {\n        for (int offs_x = -3; offs_x <= 3; offs_x++)\n        {\n            float v = hashf(ivec3(\n                icoord + ivec2(offs_x, offs_y),\n                frame\n            ));\n            \n            float weight = KERNEL[(offs_x + 3) + (offs_y + 3) * 7];\n            high_pass += v * weight;\n        }\n    }\n    return high_pass + .5;\n}\n\n// WARNING: this one is currently broken. if you know how to fix, please comment.\n// generate spatio-temporal blue noise by doing a convolution with a white noise.\n// this uses a 3D convolution where the third axis is the frame number.\nfloat blue_noise_spatiotemporal(ivec2 icoord, int frame)\n{\n    // the kernel is generated using a Python script\n    // https://gist.github.com/bean-mhm/ef42ec1c838efc9470ba44787044b008\n    const float KERNEL[7 * 7 * 5] = float[](\n        0.0000896,  0.0002944,  0.000562,   0.0006796,  0.000562,   0.0002944,  0.0000896,\n        0.0002944,  0.0008032,  0.0009556,  0.0007131,  0.0009556,  0.0008032,  0.0002944,\n        0.000562,   0.0009556, -0.0013139, -0.0039915, -0.0013139,  0.0009556,  0.000562,\n        0.0006796,  0.0007132, -0.0039915, -0.008925,  -0.0039915,  0.0007131,  0.0006796,\n        0.000562,   0.0009556, -0.0013139, -0.0039915, -0.0013139,  0.0009556,  0.000562,\n        0.0002944,  0.0008032,  0.0009556,  0.0007131,  0.0009556,  0.0008032,  0.0002944,\n        0.0000896,  0.0002944,  0.000562,   0.0006796,  0.000562,   0.0002944,  0.0000896,\n        \n        0.0001847,  0.000562,   0.0009157,  0.0009869,  0.0009157,  0.000562,   0.0001847,\n        0.000562,   0.0009556, -0.0013139, -0.0039915, -0.0013139,  0.0009556,  0.000562,\n        0.0009157, -0.0013139, -0.0177341, -0.0331018, -0.0177341, -0.0013139,  0.0009157,\n        0.0009868, -0.0039915, -0.0331018, -0.059537,  -0.0331018, -0.0039915,  0.0009868,\n        0.0009157, -0.0013139, -0.0177341, -0.0331018, -0.0177341, -0.0013139,  0.0009157,\n        0.000562,   0.0009556, -0.0013139, -0.0039915, -0.0013139,  0.0009556,  0.000562,\n        0.0001847,  0.000562,   0.0009157,  0.0009869,  0.0009157,  0.000562,   0.0001847,\n        \n        0.0002337,  0.0006796,  0.0009869,  0.0009556,  0.0009869,  0.0006796,  0.0002337,\n        0.0006796,  0.0007132, -0.0039915, -0.008925,  -0.0039915,  0.0007131,  0.0006796,\n        0.0009868, -0.0039915, -0.0331018, -0.059537,  -0.0331018, -0.0039915,  0.0009869,\n        0.0009556, -0.008925,  -0.0595371,  0.895468,  -0.059537,  -0.008925,   0.0009556,\n        0.0009869, -0.0039915, -0.0331018, -0.059537,  -0.0331018, -0.0039915,  0.0009868,\n        0.0006796,  0.0007131, -0.0039915, -0.008925,  -0.0039915,  0.0007131,  0.0006796,\n        0.0002337,  0.0006796,  0.0009869,  0.0009556,  0.0009869,  0.0006796,  0.0002337,\n        \n        0.0001847,  0.000562,   0.0009157,  0.0009869,  0.0009157,  0.000562,   0.0001847,\n        0.000562,   0.0009556, -0.0013139, -0.0039915, -0.0013139,  0.0009556,  0.000562,\n        0.0009157, -0.0013139, -0.0177341, -0.0331018, -0.0177341, -0.0013139,  0.0009157,\n        0.0009869, -0.0039915, -0.0331018, -0.059537,  -0.0331018, -0.0039915,  0.0009868,\n        0.0009157, -0.0013139, -0.0177341, -0.0331018, -0.0177341, -0.0013139,  0.0009157,\n        0.000562,   0.0009556, -0.0013139, -0.0039915, -0.0013139,  0.0009556,  0.000562,\n        0.0001847,  0.000562,   0.0009157,  0.0009869,  0.0009157,  0.000562,   0.0001847,\n        \n        0.0000896,  0.0002944,  0.000562,   0.0006796,  0.000562,   0.0002944,  0.0000896,\n        0.0002944,  0.0008032,  0.0009556,  0.0007131,  0.0009556,  0.0008032,  0.0002944,\n        0.000562,   0.0009556, -0.0013139, -0.0039915, -0.0013139,  0.0009556,  0.000562,\n        0.0006796,  0.0007131, -0.0039915, -0.008925,  -0.0039915,  0.0007132,  0.0006796,\n        0.000562,   0.0009556, -0.0013139, -0.0039915, -0.0013139,  0.0009556,  0.000562,\n        0.0002944,  0.0008032,  0.0009556,  0.0007131,  0.0009556,  0.0008032,  0.0002944,\n        0.0000896,  0.0002944,  0.000562,   0.0006796,  0.000562,   0.0002944,  0.0000896\n    );\n\n    float high_pass = 0.;\n    for (int offs_frame = -2; offs_frame <= 2; offs_frame++)\n    {\n        for (int offs_y = -3; offs_y <= 3; offs_y++)\n        {\n            for (int offs_x = -3; offs_x <= 3; offs_x++)\n            {\n                float v = hashf(ivec3(\n                    icoord + ivec2(offs_x, offs_y),\n                    frame + offs_frame\n                ));\n                \n                float weight = KERNEL[(offs_x + 3) + (offs_y + 3) * 7 + (offs_frame + 2) * 7 * 7];\n                high_pass += v * weight;\n            }\n        }\n    }\n    return high_pass + .5;\n}\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    vec3 col = vec3(blue_noise(ivec2(frag_coord), iFrame));\n    \n    if (iMouse.z > .5)\n        col = texture(iChannel0, (frag_coord + 1000. * float(iFrame % 20)) / vec2(textureSize(iChannel0, 0))).xxx;\n    \n    frag_col = vec4(pow(col, vec3(1. / 2.2)), 1);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "// hash function collection\n// sources: https://nullprogram.com/blog/2018/07/31/\n//          https://www.shadertoy.com/view/WttXWX\n// -------------------------------------------------\n\nuint triple32(uint x)\n{\n    x ^= x >> 17;\n    x *= 0xed5ad4bbU;\n    x ^= x >> 11;\n    x *= 0xac4c1b51U;\n    x ^= x >> 15;\n    x *= 0x31848babU;\n    x ^= x >> 14;\n    return x;\n}\n\n// uint -> uint\n\nuint hash(uint v)\n{\n    return triple32(v);\n}\n\nuint hash(uvec2 v)\n{\n    return triple32(v.x + triple32(v.y));\n}\n\nuint hash(uvec3 v)\n{\n    return triple32(v.x + triple32(v.y + triple32(v.z)));\n}\n\nuint hash(uvec4 v)\n{\n    return triple32(v.x + triple32(v.y + triple32(v.z + triple32(v.w))));\n}\n\n// int -> uint\n\nuint hash(int v)\n{\n    return triple32(uint(v));\n}\n\nuint hash(ivec2 v)\n{\n    return triple32(uint(v.x) + triple32(uint(v.y)));\n}\n\nuint hash(ivec3 v)\n{\n    return triple32(uint(v.x) + triple32(uint(v.y) + triple32(uint(v.z))));\n}\n\nuint hash(ivec4 v)\n{\n    return triple32(uint(v.x) + triple32(uint(v.y) + triple32(uint(v.z) + triple32(uint(v.w)))));\n}\n\n// float -> uint\n\nuint hash(float v)\n{\n    return triple32(floatBitsToUint(v));\n}\n\nuint hash(vec2 v)\n{\n    return triple32(floatBitsToUint(v.x) + triple32(floatBitsToUint(v.y)));\n}\n\nuint hash(vec3 v)\n{\n    return triple32(floatBitsToUint(v.x) + triple32(floatBitsToUint(v.y) + triple32(floatBitsToUint(v.z))));\n}\n\nuint hash(vec4 v)\n{\n    return triple32(floatBitsToUint(v.x) + triple32(floatBitsToUint(v.y) + triple32(floatBitsToUint(v.z) + triple32(floatBitsToUint(v.w)))));\n}\n\n// any -> int\n#define hashi(v) int(hash(v));\n\n// any -> float\n#define hashf(v) (float(hash(v)) / 4294967295.);\n\n// end of hash functions\n// -------------------------------------------------\n",
     "name": "Common",
     "description": "",
     "type": "common"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "l3dBRf",
    "date": "0",
    "viewed": 0,
    "name": "Fork Single Fun beans_plea 455",
    "description": "Convolution with a white noise.\n\nHold mouse to see Shadertoy's default blue noise texture.",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "noise",
     "blue",
     "hash",
     "prng",
     "low",
     "rng",
     "discrepency"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "XsBSR3",
       "filepath": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png",
       "type": "texture",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// generate blue noise by doing a convolution with a white noise\nfloat blue_noise(ivec2 icoord, int frame)\n{\n    // the kernel is generated using a Python script\n    // https://gist.github.com/bean-mhm/b69446a292ca2313fcb3430374bfd8a7\n    const float KERNEL[11 * 11] = float[](\n         0.0000276,  0.0000249, -0.0000694, -0.00029,   -0.0005259, -0.0006225, -0.0005259, -0.00029,   -0.0000694,  0.0000249,  0.0000276,\n         0.0000249, -0.0001356, -0.0006225, -0.0011152, -0.0010479, -0.0008268, -0.0010479, -0.0011152, -0.0006225, -0.0001356,  0.0000249,\n        -0.0000694, -0.0006225, -0.0011472,  0.0010808,  0.0062139,  0.008819,   0.0062139,  0.0010808, -0.0011472, -0.0006225, -0.0000694,\n        -0.00029,   -0.0011152,  0.0010808,  0.0116721,  0.0136128,  0.0047107,  0.0136128,  0.0116721,  0.0010808, -0.0011152, -0.00029,  \n        -0.0005259, -0.0010479,  0.0062139,  0.0136128, -0.0657256, -0.1587959, -0.0657256,  0.0136128,  0.0062139, -0.0010479, -0.0005259,\n        -0.0006225, -0.0008268,  0.008819,   0.0047107, -0.1587959,  0.6685213, -0.1587959,  0.0047107,  0.008819,  -0.0008268, -0.0006225,\n        -0.0005259, -0.0010479,  0.0062139,  0.0136128, -0.0657256, -0.1587959, -0.0657256,  0.0136128,  0.0062139, -0.0010479, -0.0005259,\n        -0.00029,   -0.0011152,  0.0010808,  0.0116721,  0.0136128,  0.0047107,  0.0136128,  0.0116721,  0.0010808, -0.0011152, -0.00029,  \n        -0.0000694, -0.0006225, -0.0011472,  0.0010808,  0.0062139,  0.008819,   0.0062139,  0.0010808, -0.0011472, -0.0006225, -0.0000694,\n         0.0000249, -0.0001356, -0.0006225, -0.0011152, -0.0010479, -0.0008268, -0.0010479, -0.0011152, -0.0006225, -0.0001356,  0.0000249,\n         0.0000276,  0.0000249, -0.0000694, -0.00029,   -0.0005259, -0.0006225, -0.0005259, -0.00029,   -0.0000694,  0.0000249,  0.0000276\n    );\n\n    float high_pass = 0.;\n    for (int offs_y = -5; offs_y <= 5; offs_y++)\n    {\n        for (int offs_x = -5; offs_x <= 5; offs_x++)\n        {\n            float v = hashf(ivec3(\n                icoord + ivec2(offs_x, offs_y),\n                frame\n            ));\n            \n            float weight = KERNEL[(offs_x + 5) + (offs_y + 5) * 11];\n            high_pass += v * weight;\n        }\n    }\n    return high_pass + .5;\n    return pow(normal_cdf(high_pass * 1.), 1.);\n}\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    vec3 col = vec3(blue_noise(ivec2(frag_coord), iFrame));\n    \n    if (iMouse.z > .5)\n        col = texture(iChannel0, (frag_coord + 1000. * float(iFrame % 20)) / vec2(textureSize(iChannel0, 0))).xxx;\n    \n    frag_col = vec4(pow(col, vec3(1. / 1.)), 1);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "// hash function collection\n// sources: https://nullprogram.com/blog/2018/07/31/\n//          https://www.shadertoy.com/view/WttXWX\n// -------------------------------------------------\n\nuint triple32(uint x)\n{\n    x ^= x >> 17;\n    x *= 0xed5ad4bbU;\n    x ^= x >> 11;\n    x *= 0xac4c1b51U;\n    x ^= x >> 15;\n    x *= 0x31848babU;\n    x ^= x >> 14;\n    return x;\n}\n\n// uint -> uint\n\nuint hash(uint v)\n{\n    return triple32(v);\n}\n\nuint hash(uvec2 v)\n{\n    return triple32(v.x + triple32(v.y));\n}\n\nuint hash(uvec3 v)\n{\n    return triple32(v.x + triple32(v.y + triple32(v.z)));\n}\n\nuint hash(uvec4 v)\n{\n    return triple32(v.x + triple32(v.y + triple32(v.z + triple32(v.w))));\n}\n\n// int -> uint\n\nuint hash(int v)\n{\n    return triple32(uint(v));\n}\n\nuint hash(ivec2 v)\n{\n    return triple32(uint(v.x) + triple32(uint(v.y)));\n}\n\nuint hash(ivec3 v)\n{\n    return triple32(uint(v.x) + triple32(uint(v.y) + triple32(uint(v.z))));\n}\n\nuint hash(ivec4 v)\n{\n    return triple32(uint(v.x) + triple32(uint(v.y) + triple32(uint(v.z) + triple32(uint(v.w)))));\n}\n\n// float -> uint\n\nuint hash(float v)\n{\n    return triple32(floatBitsToUint(v));\n}\n\nuint hash(vec2 v)\n{\n    return triple32(floatBitsToUint(v.x) + triple32(floatBitsToUint(v.y)));\n}\n\nuint hash(vec3 v)\n{\n    return triple32(floatBitsToUint(v.x) + triple32(floatBitsToUint(v.y) + triple32(floatBitsToUint(v.z))));\n}\n\nuint hash(vec4 v)\n{\n    return triple32(floatBitsToUint(v.x) + triple32(floatBitsToUint(v.y) + triple32(floatBitsToUint(v.z) + triple32(floatBitsToUint(v.w)))));\n}\n\n// any -> int\n#define hashi(v) int(hash(v));\n\n// any -> float\n#define hashf(v) (float(hash(v)) / 4294967295.);\n\n// end of hash functions\n// -------------------------------------------------\n\n\n\nconst float INV_SQRT_2 = 0.7071067811865475244;\n\n// error function (erf) approx. with max error: 1.5 * 10^-7\n// https://en.wikipedia.org/wiki/Error_function\nfloat erf(float v)\n{\n    const float p = 0.3275911;\n    const float a1 = 0.254829592;\n    const float a2 = -0.284496736;\n    const float a3 = 1.421413741;\n    const float a4 = -1.453152027;\n    const float a5 = 1.061405429;\n    \n    float x = abs(v);\n    \n    float t = 1. / (1. + p * x);\n    float t2 = t * t;\n    float t3 = t2 * t;\n    float t4 = t3 * t;\n    float t5 = t4 * t;\n    \n    float positive_only = 1. - exp(-x * x) * ((a1 * t) + (a2 * t2) + (a3 * t3) + (a4 * t4) + (a5 * t5));\n    return sign(v) * positive_only;\n}\n\n// CDF of a normal (gaussian) distribution with mean=0 and std=1\n// https://en.wikipedia.org/wiki/Normal_distribution\nfloat normal_cdf(float v)\n{\n    return erf(v * INV_SQRT_2) * .5 + .5;\n}\n",
     "name": "Common",
     "description": "",
     "type": "common"
    }
   ]
  }
 ]
}